{"version":3,"sources":["../../src/grid-aggregation-layer.ts"],"names":["AggregationLayer","GPUGridAggregator","Buffer","log","BinSorter","pointToDensityGridDataCPU","GridAggregationLayer","initializeAggregationLayer","dimensions","gl","context","setState","layerData","gpuGridAggregator","id","cpuGridAggregator","updateState","opts","updateAggregationState","aggregationDataDirty","aggregationWeightsDirty","gpuAggregation","state","getNumInstances","aggregationDirty","_updateAggregation","_updateWeightBins","_uploadAggregationResults","finalizeState","count","weights","aggregationBuffer","delete","updateShaders","shaders","assert","allocateResources","numRow","numCol","dataBytes","name","weight","byteLength","accessor","size","type","divisor","updateResults","aggregationData","maxMinData","maxData","minData","gridOffset","posOffset","translation","scaling","boundingBox","projectPoints","props","viewport","attributes","getAttributes","vertexCount","result","run","cellSize","xOffset","yOffset","moduleSettings","getModuleSettings","getValue","sortedBins","data","aggregatedBins","minValue","maxValue","totalCount","ELEMENTCOUNT","aggregationSize","Float32Array","fill","bin","lonIdx","latIdx","i","value","counts","cellIndex"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport AggregationLayer, {AggregationLayerProps} from './aggregation-layer';\nimport GPUGridAggregator from './utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {Buffer} from '@luma.gl/core';\nimport {LayerContext, log, UpdateParameters} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport BinSorter from './utils/bin-sorter';\nimport {pointToDensityGridDataCPU} from './cpu-grid-layer/grid-aggregator';\n\nexport type GridAggregationLayerProps<DataT> = AggregationLayerProps<DataT>;\n\nexport default abstract class GridAggregationLayer<\n  DataT,\n  ExtraPropsT extends {} = {}\n> extends AggregationLayer<DataT, ExtraPropsT> {\n  static layerName = 'GridAggregationLayer';\n\n  state!: AggregationLayer<DataT>['state'] & {\n    aggregationDataDirty?: any;\n    aggregationWeightsDirty?: any;\n    gpuAggregation?: any;\n    getValue?: () => any;\n    sortedBins?: BinSorter;\n  };\n\n  initializeAggregationLayer({dimensions}) {\n    const {gl} = this.context;\n    super.initializeAggregationLayer(dimensions);\n    this.setState({\n      // CPU aggregation results\n      layerData: {},\n      gpuGridAggregator: new GPUGridAggregator(gl, {id: `${this.id}-gpu-aggregator`}),\n      cpuGridAggregator: pointToDensityGridDataCPU\n    });\n  }\n\n  updateState(opts: UpdateParameters<this>) {\n    // get current attributes\n    super.updateState(opts);\n\n    this.updateAggregationState(opts);\n\n    const {aggregationDataDirty, aggregationWeightsDirty, gpuAggregation} = this.state;\n    if (this.getNumInstances() <= 0) {\n      return;\n    }\n    let aggregationDirty = false;\n    // CPU aggregation is two steps\n    // 1. Create bins (based on cellSize and position) 2. Aggregate weights for each bin\n    // For GPU aggregation both above steps are combined into one step\n\n    // step-1\n    if (aggregationDataDirty || (gpuAggregation && aggregationWeightsDirty)) {\n      this._updateAggregation(opts);\n      aggregationDirty = true;\n    }\n    // step-2 (Applicalbe for CPU aggregation only)\n    if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {\n      this._updateWeightBins();\n      this._uploadAggregationResults();\n      aggregationDirty = true;\n    }\n\n    this.setState({aggregationDirty});\n  }\n\n  finalizeState(context: LayerContext) {\n    const {count} = this.state.weights;\n    if (count && count.aggregationBuffer) {\n      count.aggregationBuffer.delete();\n    }\n    this.state.gpuGridAggregator?.delete();\n    super.finalizeState(context);\n  }\n\n  updateShaders(shaders: any): void {\n    if (this.state.gpuAggregation) {\n      this.state.gpuGridAggregator.updateShaders(shaders);\n    }\n  }\n\n  // Methods that can be overriden by subclasses for customizations\n\n  updateAggregationState(opts) {\n    // Sublayers should implement this method.\n    log.assert(false);\n  }\n\n  allocateResources(numRow, numCol) {\n    if (this.state.numRow !== numRow || this.state.numCol !== numCol) {\n      const dataBytes = numCol * numRow * 4 * 4;\n      const gl = this.context.gl;\n      const {weights} = this.state;\n      for (const name in weights) {\n        const weight = weights[name];\n        if (weight.aggregationBuffer) {\n          weight.aggregationBuffer.delete();\n        }\n        weight.aggregationBuffer = new Buffer(gl, {\n          byteLength: dataBytes,\n          accessor: {\n            size: 4,\n            type: GL.FLOAT,\n            divisor: 1\n          }\n        });\n      }\n    }\n  }\n\n  updateResults({aggregationData, maxMinData, maxData, minData}) {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = aggregationData;\n      count.maxMinData = maxMinData;\n      count.maxData = maxData;\n      count.minData = minData;\n    }\n  }\n\n  // Private\n\n  _updateAggregation(opts) {\n    const {\n      cpuGridAggregator,\n      gpuGridAggregator,\n      gridOffset,\n      posOffset,\n      translation = [0, 0],\n      scaling = [0, 0, 0],\n      boundingBox,\n      projectPoints,\n      gpuAggregation,\n      numCol,\n      numRow\n    } = this.state;\n    const {props} = opts;\n    const {viewport} = this.context;\n    const attributes = this.getAttributes();\n    const vertexCount = this.getNumInstances();\n\n    if (!gpuAggregation) {\n      const result = cpuGridAggregator(props, {\n        gridOffset,\n        projectPoints,\n        attributes,\n        viewport,\n        posOffset,\n        boundingBox\n      });\n      this.setState({\n        layerData: result\n      });\n    } else {\n      const {weights} = this.state;\n      gpuGridAggregator.run({\n        weights,\n        cellSize: [gridOffset.xOffset, gridOffset.yOffset],\n        numCol,\n        numRow,\n        translation,\n        scaling,\n        vertexCount,\n        projectPoints,\n        attributes,\n        moduleSettings: this.getModuleSettings()\n      });\n    }\n  }\n\n  _updateWeightBins() {\n    const {getValue} = this.state;\n\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {getValue});\n    this.setState({sortedBins});\n  }\n\n  _uploadAggregationResults(): void {\n    const {numCol, numRow} = this.state;\n    const {data} = this.state.layerData;\n    const {aggregatedBins, minValue, maxValue, totalCount} = this.state.sortedBins!;\n\n    const ELEMENTCOUNT = 4;\n    const aggregationSize = numCol * numRow * ELEMENTCOUNT;\n    const aggregationData = new Float32Array(aggregationSize).fill(0);\n    for (const bin of aggregatedBins) {\n      const {lonIdx, latIdx} = data[bin.i];\n      const {value, counts} = bin;\n      const cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;\n      aggregationData[cellIndex] = value;\n      aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;\n    }\n    const maxMinData = new Float32Array([maxValue, 0, 0, minValue]);\n    const maxData = new Float32Array([maxValue, 0, 0, totalCount]);\n    const minData = new Float32Array([minValue, 0, 0, totalCount]);\n    this.updateResults({aggregationData, maxMinData, maxData, minData});\n  }\n}\n"],"file":"grid-aggregation-layer.js"}