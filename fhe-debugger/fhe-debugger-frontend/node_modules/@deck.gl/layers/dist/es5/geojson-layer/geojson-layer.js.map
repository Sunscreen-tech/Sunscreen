{"version":3,"sources":["../../../src/geojson-layer/geojson-layer.ts"],"names":["FEATURE_TYPES","defaultProps","POINT_LAYER","circle","icon","text","LINE_LAYER","POLYGON_LAYER","stroked","filled","extruded","wireframe","_full3d","iconAtlas","type","value","iconMapping","getIcon","f","properties","getText","pointType","getRadius","deprecatedFor","GeoJsonLayer","state","layerProps","features","props","changeFlags","dataChanged","data","binary","setState","_updateStateBinary","_updateStateJSON","encodePickingColor","wrapFeature","getSubLayerRow","bind","newFeatures","featuresDiff","Array","isArray","oldFeatures","key","slice","dataRange","partialFeatures","push","getIndex","__source","index","replace","params","info","sourceLayer","featureType","find","ft","id","startsWith","points","globalFeatureIds","pointLayerIdPrefix","sourceIsPoints","getSubLayers","layer","updateAutoHighlight","PolygonFillLayer","shouldRenderSubLayer","polygons","getSubLayerClass","forwardedProps","useLineColor","getLineColor","updateTriggers","lineColors","getSubLayerProps","polygonStrokeLayerId","lineStringsLayerId","PolygonStrokeLayer","polygonsOutline","LineStringsLayer","lines","highlightedObjectIndex","Number","isFinite","findIndex","d","types","Set","split","pointLayers","PointLayerMapping","PointsLayer","pointsLayerProps","attributes","instancePickingColors","rest","polygonFillLayer","_renderPolygonLayer","lineLayers","_renderLineLayers","_renderPointLayers","accessor","object","feature","CompositeLayer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Accessor,\n  Color,\n  CompositeLayer,\n  CompositeLayerProps,\n  Layer,\n  PickingInfo,\n  Unit,\n  Material,\n  UpdateParameters,\n  _ConstructorOf,\n  DefaultProps\n} from '@deck.gl/core';\n\nimport type {BinaryFeatures} from '@loaders.gl/schema';\nimport type {Feature, GeoJSON} from 'geojson';\n\nimport {replaceInRange} from '../utils';\nimport {BinaryFeatureTypes, binaryToFeatureForAccesor} from './geojson-binary';\nimport {\n  POINT_LAYER,\n  LINE_LAYER,\n  POLYGON_LAYER,\n  getDefaultProps,\n  forwardProps\n} from './sub-layer-map';\n\nimport {getGeojsonFeatures, SeparatedGeometries, separateGeojsonFeatures} from './geojson';\nimport {createLayerPropsFromFeatures, createLayerPropsFromBinary} from './geojson-layer-props';\n\n/** All properties supported by GeoJsonLayer */\nexport type GeoJsonLayerProps = _GeoJsonLayerProps & CompositeLayerProps;\n\n/** Properties added by GeoJsonLayer */\nexport type _GeoJsonLayerProps = {\n  data: string | GeoJSON | BinaryFeatures | Promise<GeoJSON | BinaryFeatures>;\n  /**\n   * How to render Point and MultiPoint features in the data.\n   *\n   * Supported types are:\n   *  * `'circle'`\n   *  * `'icon'`\n   *  * `'text'`\n   *\n   * @default 'circle'\n   */\n  pointType?: string;\n} & _GeoJsonLayerFillProps &\n  _GeoJsonLayerStrokeProps &\n  _GeoJsonLayer3DProps &\n  _GeoJsonLayerPointCircleProps &\n  _GeojsonLayerIconPointProps &\n  _GeojsonLayerTextPointProps;\n\n/** GeoJsonLayer fill options. */\ntype _GeoJsonLayerFillProps = {\n  /**\n   * Whether to draw a filled polygon (solid fill).\n   *\n   * Note that only the area between the outer polygon and any holes will be filled.\n   *\n   * @default true\n   */\n  filled?: boolean;\n\n  /**\n   * Fill collor value or accessor.\n   *\n   * @default [0, 0, 0, 255]\n   */\n  getFillColor?: Accessor<Feature, Color>;\n};\n\n/** GeoJsonLayer stroke options. */\ntype _GeoJsonLayerStrokeProps = {\n  /**\n   * Whether to draw an outline around the polygon (solid fill).\n   *\n   * Note that both the outer polygon as well the outlines of any holes will be drawn.\n   *\n   * @default true\n   */\n  stroked?: boolean;\n\n  /**\n   * Line color value or accessor.\n   *\n   * @default [0, 0, 0, 255]\n   */\n  getLineColor?: Accessor<Feature, Color>;\n\n  /**\n   * Line width value or accessor.\n   *\n   * @default [0, 0, 0, 255]\n   */\n  getLineWidth?: Accessor<Feature, number>;\n\n  /**\n   * The units of the line width, one of `meters`, `common`, and `pixels`.\n   *\n   * @default 'meters'\n   * @see Unit.\n   */\n  lineWidthUnits?: Unit;\n\n  /**\n   * A multiplier that is applied to all line widths\n   *\n   * @default 1\n   */\n  lineWidthScale?: number;\n\n  /**\n   * The minimum line width in pixels.\n   *\n   * @default 0\n   */\n  lineWidthMinPixels?: number;\n\n  /**\n   * The maximum line width in pixels\n   *\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  lineWidthMaxPixels?: number;\n\n  /**\n   * Type of joint. If `true`, draw round joints. Otherwise draw miter joints.\n   *\n   * @default false\n   */\n  lineJointRounded?: boolean;\n\n  /**\n   * The maximum extent of a joint in ratio to the stroke width.\n   *\n   * Only works if `lineJointRounded` is false.\n   *\n   * @default 4\n   */\n  lineMiterLimit?: number;\n\n  /**\n   * Type of line caps.\n   *\n   * If `true`, draw round caps. Otherwise draw square caps.\n   *\n   * @default false\n   */\n  lineCapRounded?: boolean;\n\n  /**\n   * If `true`, extrude the line in screen space (width always faces the camera).\n   * If `false`, the width always faces up.\n   *\n   * @default false\n   */\n  lineBillboard?: boolean;\n};\n\n/** GeoJsonLayer 3D options. */\ntype _GeoJsonLayer3DProps = {\n  /**\n   * Extrude Polygon and MultiPolygon features along the z-axis if set to true\n   *\n   * Based on the elevations provided by the `getElevation` accessor.\n   *\n   * @default false\n   */\n  extruded?: boolean;\n\n  /**\n   * Whether to generate a line wireframe of the hexagon.\n   *\n   * @default false\n   */\n  wireframe?: boolean;\n\n  /**\n   * (Experimental) This prop is only effective with `XYZ` data.\n   * When true, polygon tesselation will be performed on the plane with the largest area, instead of the xy plane.\n   * @default false\n   */\n  _full3d?: boolean;\n\n  /**\n   * Elevation valur or accessor.\n   *\n   * Only used if `extruded: true`.\n   *\n   * @default 1000\n   */\n  getElevation?: Accessor<Feature, number>;\n\n  /**\n   * Elevation multiplier.\n   *\n   * The final elevation is calculated by `elevationScale * getElevation(d)`.\n   * `elevationScale` is a handy property to scale all elevation without updating the data.\n   *\n   * @default 1\n   */\n  elevationScale?: boolean;\n\n  /**\n   * Material settings for lighting effect. Applies to extruded polgons.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n};\n\n/** GeoJsonLayer Properties forwarded to `ScatterPlotLayer` if `pointType` is `'circle'` */\nexport type _GeoJsonLayerPointCircleProps = {\n  getPointRadius?: Accessor<Feature, number>;\n  pointRadiusUnits?: Unit;\n  pointRadiusScale?: number;\n  pointRadiusMinPixels?: number;\n  pointRadiusMaxPixels?: number;\n  pointAntialiasing?: boolean;\n  pointBillboard?: boolean;\n\n  /** @deprecated use getPointRadius */\n  getRadius?: Accessor<Feature, number>;\n};\n\n/** GeoJsonLayer properties forwarded to `IconLayer` if `pointType` is `'icon'` */\ntype _GeojsonLayerIconPointProps = {\n  iconAtlas?: any;\n  iconMapping?: any;\n  getIcon?: Accessor<Feature, any>;\n  getIconSize?: Accessor<Feature, number>;\n  getIconColor?: Accessor<Feature, Color>;\n  getIconAngle?: Accessor<Feature, number>;\n  getIconPixelOffset?: Accessor<Feature, number[]>;\n  iconSizeUnits?: Unit;\n  iconSizeScale?: number;\n  iconSizeMinPixels?: number;\n  iconSizeMaxPixels?: number;\n  iconBillboard?: boolean;\n  iconAlphaCutoff?: number;\n};\n\n/** GeoJsonLayer properties forwarded to `TextLayer` if `pointType` is `'text'` */\ntype _GeojsonLayerTextPointProps = {\n  getText?: Accessor<Feature, any>;\n  getTextColor?: Accessor<Feature, Color>;\n  getTextAngle?: Accessor<Feature, number>;\n  getTextSize?: Accessor<Feature, number>;\n  getTextAnchor?: Accessor<Feature, string>;\n  getTextAlignmentBaseline?: Accessor<Feature, string>;\n  getTextPixelOffset?: Accessor<Feature, number[]>;\n  getTextBackgroundColor?: Accessor<Feature, Color>;\n  getTextBorderColor?: Accessor<Feature, Color>;\n  getTextBorderWidth?: Accessor<Feature, number>;\n  textSizeUnits?: Unit;\n  textSizeScale?: number;\n  textSizeMinPixels?: number;\n  textSizeMaxPixels?: number;\n  textCharacterSet?: any;\n  textFontFamily?: string;\n  textFontWeight?: number;\n  textLineHeight?: number;\n  textMaxWidth?: number;\n  textWordBreak?: string; // TODO\n  textBackground?: boolean;\n  textBackgroundPadding?: number[];\n  textOutlineColor?: Color;\n  textOutlineWidth?: number;\n  textBillboard?: boolean;\n  textFontSettings?: any;\n};\n\nconst FEATURE_TYPES = ['points', 'linestrings', 'polygons'];\n\nconst defaultProps: DefaultProps<GeoJsonLayerProps> = {\n  ...getDefaultProps(POINT_LAYER.circle),\n  ...getDefaultProps(POINT_LAYER.icon),\n  ...getDefaultProps(POINT_LAYER.text),\n  ...getDefaultProps(LINE_LAYER),\n  ...getDefaultProps(POLYGON_LAYER),\n\n  // Overwrite sub layer defaults\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  _full3d: false,\n  iconAtlas: {type: 'object', value: null},\n  iconMapping: {type: 'object', value: {}},\n  getIcon: {type: 'accessor', value: f => f.properties.icon},\n  getText: {type: 'accessor', value: f => f.properties.text},\n\n  // Self props\n  pointType: 'circle',\n\n  // TODO: deprecated, remove in v9\n  getRadius: {deprecatedFor: 'getPointRadius'}\n};\n\ntype GeoJsonPickingInfo = PickingInfo & {\n  featureType?: string | null;\n  info?: any;\n};\n\n/** Render GeoJSON formatted data as polygons, lines and points (circles, icons and/or texts). */\nexport default class GeoJsonLayer<ExtraProps extends {} = {}> extends CompositeLayer<\n  Required<GeoJsonLayerProps> & ExtraProps\n> {\n  static layerName = 'GeoJsonLayer';\n  static defaultProps = defaultProps;\n\n  initializeState(): void {\n    this.state = {\n      layerProps: {},\n      features: {}\n    };\n  }\n\n  updateState({props, changeFlags}: UpdateParameters<this>): void {\n    if (!changeFlags.dataChanged) {\n      return;\n    }\n    const {data} = this.props;\n    const binary =\n      data && 'points' in (data as {}) && 'polygons' in (data as {}) && 'lines' in (data as {});\n\n    this.setState({binary});\n\n    if (binary) {\n      this._updateStateBinary({props, changeFlags});\n    } else {\n      this._updateStateJSON({props, changeFlags});\n    }\n  }\n\n  private _updateStateBinary({props, changeFlags}): void {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);\n    this.setState({layerProps});\n  }\n\n  private _updateStateJSON({props, changeFlags}): void {\n    const features: Feature[] = getGeojsonFeatures(props.data) as any;\n    const wrapFeature = this.getSubLayerRow.bind(this);\n    let newFeatures: SeparatedGeometries = {} as SeparatedGeometries;\n    const featuresDiff = {};\n\n    if (Array.isArray(changeFlags.dataChanged)) {\n      const oldFeatures = this.state.features;\n      for (const key in oldFeatures) {\n        newFeatures[key] = oldFeatures[key].slice();\n        featuresDiff[key] = [];\n      }\n\n      for (const dataRange of changeFlags.dataChanged) {\n        const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);\n        for (const key in oldFeatures) {\n          featuresDiff[key].push(\n            replaceInRange({\n              data: newFeatures[key],\n              getIndex: f => f.__source.index,\n              dataRange,\n              replace: partialFeatures[key]\n            })\n          );\n        }\n      }\n    } else {\n      newFeatures = separateGeojsonFeatures(features, wrapFeature);\n    }\n\n    const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);\n\n    this.setState({\n      features: newFeatures,\n      featuresDiff,\n      layerProps\n    });\n  }\n\n  getPickingInfo(params): GeoJsonPickingInfo {\n    const info = super.getPickingInfo(params) as GeoJsonPickingInfo;\n    const {index, sourceLayer} = info;\n    info.featureType = FEATURE_TYPES.find(ft => sourceLayer!.id.startsWith(`${this.id}-${ft}-`));\n    if (index >= 0 && sourceLayer!.id.startsWith(`${this.id}-points-text`) && this.state.binary) {\n      info.index = (this.props.data as BinaryFeatures).points!.globalFeatureIds.value[index];\n    }\n    return info;\n  }\n\n  _updateAutoHighlight(info: GeoJsonPickingInfo): void {\n    // All sub layers except the points layer use source feature index to encode the picking color\n    // The points layer uses indices from the points data array.\n    const pointLayerIdPrefix = `${this.id}-points-`;\n    const sourceIsPoints = info.featureType === 'points';\n    for (const layer of this.getSubLayers()) {\n      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {\n        layer.updateAutoHighlight(info);\n      }\n    }\n  }\n\n  private _renderPolygonLayer(): Layer | null {\n    const {extruded, wireframe} = this.props;\n    const {layerProps} = this.state;\n    const id = 'polygons-fill';\n\n    const PolygonFillLayer =\n      this.shouldRenderSubLayer(id, layerProps.polygons.data) &&\n      this.getSubLayerClass(id, POLYGON_LAYER.type);\n\n    if (PolygonFillLayer) {\n      const forwardedProps = forwardProps(this, POLYGON_LAYER.props);\n      // Avoid building the lineColors attribute if wireframe is off\n      const useLineColor = extruded && wireframe;\n      if (!useLineColor) {\n        delete forwardedProps.getLineColor;\n      }\n      // using a legacy API to invalid lineColor attributes\n      forwardedProps.updateTriggers.lineColors = useLineColor;\n\n      return new PolygonFillLayer(\n        forwardedProps,\n        this.getSubLayerProps({\n          id,\n          updateTriggers: forwardedProps.updateTriggers\n        }),\n        layerProps.polygons\n      );\n    }\n    return null;\n  }\n\n  private _renderLineLayers(): (Layer | false)[] | null {\n    const {extruded, stroked} = this.props;\n    const {layerProps} = this.state;\n    const polygonStrokeLayerId = 'polygons-stroke';\n    const lineStringsLayerId = 'linestrings';\n\n    const PolygonStrokeLayer =\n      !extruded &&\n      stroked &&\n      this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline.data) &&\n      this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);\n    const LineStringsLayer =\n      this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines.data) &&\n      this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);\n\n    if (PolygonStrokeLayer || LineStringsLayer) {\n      const forwardedProps = forwardProps(this, LINE_LAYER.props);\n\n      return [\n        PolygonStrokeLayer &&\n          new PolygonStrokeLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id: polygonStrokeLayerId,\n              updateTriggers: forwardedProps.updateTriggers\n            }),\n            layerProps.polygonsOutline\n          ),\n\n        LineStringsLayer &&\n          new LineStringsLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id: lineStringsLayerId,\n              updateTriggers: forwardedProps.updateTriggers\n            }),\n            layerProps.lines\n          )\n      ];\n    }\n    return null;\n  }\n\n  private _renderPointLayers(): Layer[] | null {\n    const {pointType} = this.props;\n    const {layerProps, binary} = this.state;\n    let {highlightedObjectIndex} = this.props;\n\n    if (!binary && Number.isFinite(highlightedObjectIndex)) {\n      highlightedObjectIndex = layerProps.points.data.findIndex(\n        d => d.__source.index === highlightedObjectIndex\n      );\n    }\n\n    // Avoid duplicate sub layer ids\n    const types = new Set(pointType.split('+'));\n    const pointLayers: Layer[] = [];\n    for (const type of types) {\n      const id = `points-${type}`;\n      const PointLayerMapping = POINT_LAYER[type];\n      const PointsLayer: _ConstructorOf<Layer> =\n        PointLayerMapping &&\n        this.shouldRenderSubLayer(id, layerProps.points.data) &&\n        this.getSubLayerClass(id, PointLayerMapping.type);\n      if (PointsLayer) {\n        const forwardedProps = forwardProps(this, PointLayerMapping.props);\n        let pointsLayerProps = layerProps.points;\n\n        if (type === 'text' && binary) {\n          // Picking colors are per-point but for text per-character are required\n          // getPickingInfo() maps back to the correct index\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const {instancePickingColors, ...rest} = pointsLayerProps.data.attributes;\n          pointsLayerProps = {\n            ...pointsLayerProps,\n            data: {...pointsLayerProps.data, attributes: rest}\n          };\n        }\n\n        pointLayers.push(\n          new PointsLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id,\n              updateTriggers: forwardedProps.updateTriggers,\n              highlightedObjectIndex\n            }),\n            pointsLayerProps\n          )\n        );\n      }\n    }\n    return pointLayers;\n  }\n\n  renderLayers() {\n    const {extruded} = this.props;\n\n    const polygonFillLayer = this._renderPolygonLayer();\n    const lineLayers = this._renderLineLayers();\n    const pointLayers = this._renderPointLayers();\n\n    return [\n      // If not extruded: flat fill layer is drawn below outlines\n      !extruded && polygonFillLayer,\n      lineLayers,\n      pointLayers,\n      // If extruded: draw fill layer last for correct blending behavior\n      extruded && polygonFillLayer\n    ];\n  }\n\n  protected getSubLayerAccessor<In, Out>(accessor: Accessor<In, Out>): Accessor<In, Out> {\n    const {binary} = this.state;\n    if (!binary || typeof accessor !== 'function') {\n      return super.getSubLayerAccessor(accessor);\n    }\n\n    return (object, info) => {\n      const {data, index} = info;\n      const feature = binaryToFeatureForAccesor(data as unknown as BinaryFeatureTypes, index);\n      // @ts-ignore (TS2349) accessor is always function\n      return accessor(feature, info);\n    };\n  }\n}\n"],"file":"geojson-layer.js"}