{"version":3,"sources":["../../../../src/text-layer/multi-icon-layer/multi-icon-layer.ts"],"names":["DEFAULT_BUFFER","EMPTY_ARRAY","defaultProps","getIconOffsets","type","value","x","offsets","alphaCutoff","smoothing","outlineWidth","outlineColor","MultiIconLayer","fs","attributeManager","getAttributeManager","addInstanced","instanceOffsets","size","accessor","instancePickingColors","object","index","target","encodePickingColor","params","props","oldProps","map","Number","isFinite","setState","sdf","log","warn","id","state","outlineBuffer","Math","max","uniforms","sdfBuffer","gamma","Boolean","iconManager","iconsTexture","getTexture","model","draw","icons","Array","from","flatMap","icon","IconLayer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {log} from '@deck.gl/core';\nimport IconLayer from '../../icon-layer/icon-layer';\n\nimport fs from './multi-icon-layer-fragment.glsl';\n\nimport type {IconLayerProps} from '../../icon-layer/icon-layer';\nimport type {Accessor, Color, UpdateParameters, DefaultProps} from '@deck.gl/core';\n\n// TODO expose as layer properties\nconst DEFAULT_BUFFER = 192.0 / 256;\nconst EMPTY_ARRAY = [];\n\ntype _MultiIconLayerProps<DataT> = {\n  getIconOffsets?: Accessor<DataT, number[]>;\n  sdf?: boolean;\n  smoothing?: number;\n  outlineWidth?: number;\n  outlineColor?: Color;\n};\n\nexport type MultiIconLayerProps<DataT = any> = _MultiIconLayerProps<DataT> & IconLayerProps<DataT>;\n\nconst defaultProps: DefaultProps<MultiIconLayerProps> = {\n  getIconOffsets: {type: 'accessor', value: x => x.offsets},\n  alphaCutoff: 0.001,\n  smoothing: 0.1,\n  outlineWidth: 0,\n  outlineColor: {type: 'color', value: [0, 0, 0, 255]}\n};\n\nexport default class MultiIconLayer<DataT, ExtraPropsT extends {} = {}> extends IconLayer<\n  DataT,\n  ExtraPropsT & Required<_MultiIconLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'MultiIconLayer';\n\n  state!: IconLayer['state'] & {\n    outlineColor: Color;\n  };\n\n  getShaders() {\n    return {...super.getShaders(), fs};\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    const attributeManager = this.getAttributeManager();\n    attributeManager!.addInstanced({\n      instanceOffsets: {\n        size: 2,\n        accessor: 'getIconOffsets'\n      },\n      instancePickingColors: {\n        type: GL.UNSIGNED_BYTE,\n        size: 3,\n        accessor: (object, {index, target: value}) => this.encodePickingColor(index, value)\n      }\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n    const {props, oldProps} = params;\n    let {outlineColor} = props;\n\n    if (outlineColor !== oldProps.outlineColor) {\n      outlineColor = outlineColor.map(x => x / 255) as Color;\n      outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;\n\n      this.setState({\n        outlineColor\n      });\n    }\n    if (!props.sdf && props.outlineWidth) {\n      log.warn(`${this.id}: fontSettings.sdf is required to render outline`)();\n    }\n  }\n\n  draw(params) {\n    const {sdf, smoothing, outlineWidth} = this.props;\n    const {outlineColor} = this.state;\n    const outlineBuffer = outlineWidth\n      ? Math.max(smoothing, DEFAULT_BUFFER * (1 - outlineWidth))\n      : -1;\n\n    params.uniforms = {\n      ...params.uniforms,\n      // Refer the following doc about gamma and buffer\n      // https://blog.mapbox.com/drawing-text-with-signed-distance-fields-in-mapbox-gl-b0933af6f817\n      sdfBuffer: DEFAULT_BUFFER,\n      outlineBuffer,\n      gamma: smoothing,\n      sdf: Boolean(sdf),\n      outlineColor\n    };\n\n    super.draw(params);\n\n    // draw text without outline on top to ensure a thick outline won't occlude other characters\n    if (sdf && outlineWidth) {\n      const {iconManager} = this.state;\n      const iconsTexture = iconManager.getTexture();\n\n      if (iconsTexture) {\n        this.state.model.draw({uniforms: {outlineBuffer: DEFAULT_BUFFER}});\n      }\n    }\n  }\n\n  protected getInstanceOffset(icons: string): number[] {\n    return icons ? Array.from(icons).flatMap(icon => super.getInstanceOffset(icon)) : EMPTY_ARRAY;\n  }\n\n  getInstanceColorMode(icons: string): number {\n    return 1; // mask\n  }\n\n  getInstanceIconFrame(icons: string): number[] {\n    return icons\n      ? Array.from(icons).flatMap(icon => super.getInstanceIconFrame(icon))\n      : EMPTY_ARRAY;\n  }\n}\n"],"file":"multi-icon-layer.js"}