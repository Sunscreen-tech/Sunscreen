"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseGLTF = exports.isGLTF = void 0;
const textures_1 = require("@loaders.gl/textures");
const images_1 = require("@loaders.gl/images");
const loader_utils_1 = require("@loaders.gl/loader-utils");
const assert_1 = require("../utils/assert");
const resolve_url_1 = require("../gltf-utils/resolve-url");
const get_typed_array_1 = require("../gltf-utils/get-typed-array");
const gltf_extensions_1 = require("../api/gltf-extensions");
const normalize_gltf_v1_1 = require("../api/normalize-gltf-v1");
const post_process_gltf_1 = require("../api/post-process-gltf");
const parse_glb_1 = __importStar(require("./parse-glb"));
// export type GLTFOptions = {
//   gltf?: GLTFParseOptions;
// };
function isGLTF(arrayBuffer, options) {
    const byteOffset = 0;
    return (0, parse_glb_1.isGLB)(arrayBuffer, byteOffset, options);
}
exports.isGLTF = isGLTF;
async function parseGLTF(gltf, arrayBufferOrString, byteOffset = 0, options, context) {
    parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);
    (0, normalize_gltf_v1_1.normalizeGLTFV1)(gltf, { normalize: options?.gltf?.normalize });
    (0, gltf_extensions_1.preprocessExtensions)(gltf, options, context);
    const promises = [];
    // Load linked buffers asynchronously and decodes base64 buffers in parallel
    if (options?.gltf?.loadBuffers && gltf.json.buffers) {
        await loadBuffers(gltf, options, context);
    }
    if (options?.gltf?.loadImages) {
        const promise = loadImages(gltf, options, context);
        promises.push(promise);
    }
    const promise = (0, gltf_extensions_1.decodeExtensions)(gltf, options, context);
    promises.push(promise);
    // Parallelize image loading and buffer loading/extension decoding
    await Promise.all(promises);
    // Post processing resolves indices to objects, buffers
    return options?.gltf?.postProcess ? (0, post_process_gltf_1.postProcessGLTF)(gltf, options) : gltf;
}
exports.parseGLTF = parseGLTF;
// `data` - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)
function parseGLTFContainerSync(gltf, data, byteOffset, options) {
    // Initialize gltf container
    if (options.uri) {
        gltf.baseUri = options.uri;
    }
    // If data is binary and starting with magic bytes, assume binary JSON text, convert to string
    if (data instanceof ArrayBuffer && !(0, parse_glb_1.isGLB)(data, byteOffset, options)) {
        const textDecoder = new TextDecoder();
        data = textDecoder.decode(data);
    }
    if (typeof data === 'string') {
        // If string, try to parse as JSON
        gltf.json = (0, loader_utils_1.parseJSON)(data);
    }
    else if (data instanceof ArrayBuffer) {
        // If still ArrayBuffer, parse as GLB container
        const glb = {};
        byteOffset = (0, parse_glb_1.default)(glb, data, byteOffset, options.glb);
        (0, assert_1.assert)(glb.type === 'glTF', `Invalid GLB magic string ${glb.type}`);
        gltf._glb = glb;
        gltf.json = glb.json;
    }
    else {
        (0, assert_1.assert)(false, 'GLTF: must be ArrayBuffer or string');
    }
    // Populate buffers
    // Create an external buffers array to hold binary data
    const buffers = gltf.json.buffers || [];
    gltf.buffers = new Array(buffers.length).fill(null);
    // Populates JSON and some bin chunk info
    if (gltf._glb && gltf._glb.header.hasBinChunk) {
        const { binChunks } = gltf._glb;
        gltf.buffers[0] = {
            arrayBuffer: binChunks[0].arrayBuffer,
            byteOffset: binChunks[0].byteOffset,
            byteLength: binChunks[0].byteLength
        };
        // TODO - this modifies JSON and is a post processing thing
        // gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;
        // gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;
    }
    // Populate images
    const images = gltf.json.images || [];
    gltf.images = new Array(images.length).fill({});
}
/** Asynchronously fetch and parse buffers, store in buffers array outside of json
 * TODO - traverse gltf and determine which buffers are actually needed
 */
async function loadBuffers(gltf, options, context) {
    // TODO
    const buffers = gltf.json.buffers || [];
    for (let i = 0; i < buffers.length; ++i) {
        const buffer = buffers[i];
        if (buffer.uri) {
            const { fetch } = context;
            (0, assert_1.assert)(fetch);
            const uri = (0, resolve_url_1.resolveUrl)(buffer.uri, options);
            const response = await context?.fetch?.(uri);
            const arrayBuffer = await response?.arrayBuffer?.();
            gltf.buffers[i] = {
                arrayBuffer,
                byteOffset: 0,
                byteLength: arrayBuffer.byteLength
            };
            delete buffer.uri;
        }
        else if (gltf.buffers[i] === null) {
            gltf.buffers[i] = {
                arrayBuffer: new ArrayBuffer(buffer.byteLength),
                byteOffset: 0,
                byteLength: buffer.byteLength
            };
        }
    }
}
/**
 * Loads all images
 * TODO - traverse gltf and determine which images are actually needed
 * @param gltf
 * @param options
 * @param context
 * @returns
 */
async function loadImages(gltf, options, context) {
    const imageIndices = getReferencesImageIndices(gltf);
    const images = gltf.json.images || [];
    const promises = [];
    for (const imageIndex of imageIndices) {
        promises.push(loadImage(gltf, images[imageIndex], imageIndex, options, context));
    }
    return await Promise.all(promises);
}
/** Make sure we only load images that are actually referenced by textures */
function getReferencesImageIndices(gltf) {
    const imageIndices = new Set();
    const textures = gltf.json.textures || [];
    for (const texture of textures) {
        if (texture.source !== undefined) {
            imageIndices.add(texture.source);
        }
    }
    return Array.from(imageIndices).sort();
}
/** Asynchronously fetches and parses one image, store in images array outside of json */
async function loadImage(gltf, image, index, options, context) {
    const { fetch, parse } = context;
    let arrayBuffer;
    if (image.uri && !image.hasOwnProperty('bufferView')) {
        const uri = (0, resolve_url_1.resolveUrl)(image.uri, options);
        const response = await fetch(uri);
        arrayBuffer = await response.arrayBuffer();
        image.bufferView = {
            data: arrayBuffer
        };
    }
    if (Number.isFinite(image.bufferView)) {
        const array = (0, get_typed_array_1.getTypedArrayForBufferView)(gltf.json, gltf.buffers, image.bufferView);
        arrayBuffer = (0, loader_utils_1.sliceArrayBuffer)(array.buffer, array.byteOffset, array.byteLength);
    }
    (0, assert_1.assert)(arrayBuffer, 'glTF image has no data');
    // Call `parse`
    let parsedImage = await parse(arrayBuffer, [images_1.ImageLoader, textures_1.BasisLoader], { mimeType: image.mimeType, basis: options.basis || { format: (0, textures_1.selectSupportedBasisFormat)() } }, context);
    if (parsedImage && parsedImage[0]) {
        parsedImage = {
            compressed: true,
            mipmaps: false,
            width: parsedImage[0].width,
            height: parsedImage[0].height,
            data: parsedImage[0]
        };
    }
    // TODO making sure ImageLoader is overridable by using array of loaders
    // const parsedImage = await parse(arrayBuffer, [ImageLoader]);
    // Store the loaded image
    gltf.images = gltf.images || [];
    gltf.images[index] = parsedImage;
}
