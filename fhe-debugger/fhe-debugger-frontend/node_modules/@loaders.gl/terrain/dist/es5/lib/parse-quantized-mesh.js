"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = loadQuantizedMesh;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _schema = require("@loaders.gl/schema");
var _decodeQuantizedMesh = _interopRequireWildcard(require("./decode-quantized-mesh"));
var _skirt = require("./helpers/skirt");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function getMeshAttributes(vertexData, header, bounds) {
  var minHeight = header.minHeight,
    maxHeight = header.maxHeight;
  var _ref = bounds || [0, 0, 1, 1],
    _ref2 = (0, _slicedToArray2.default)(_ref, 4),
    minX = _ref2[0],
    minY = _ref2[1],
    maxX = _ref2[2],
    maxY = _ref2[3];
  var xScale = maxX - minX;
  var yScale = maxY - minY;
  var zScale = maxHeight - minHeight;
  var nCoords = vertexData.length / 3;
  var positions = new Float32Array(nCoords * 3);
  var texCoords = new Float32Array(nCoords * 2);
  for (var i = 0; i < nCoords; i++) {
    var x = vertexData[i] / 32767;
    var y = vertexData[i + nCoords] / 32767;
    var z = vertexData[i + nCoords * 2] / 32767;
    positions[3 * i + 0] = x * xScale + minX;
    positions[3 * i + 1] = y * yScale + minY;
    positions[3 * i + 2] = z * zScale + minHeight;
    texCoords[2 * i + 0] = x;
    texCoords[2 * i + 1] = y;
  }
  return {
    POSITION: {
      value: positions,
      size: 3
    },
    TEXCOORD_0: {
      value: texCoords,
      size: 2
    }
  };
}
function getTileMesh(arrayBuffer, options) {
  if (!arrayBuffer) {
    return null;
  }
  var bounds = options.bounds;
  var _decode = (0, _decodeQuantizedMesh.default)(arrayBuffer, _decodeQuantizedMesh.DECODING_STEPS.triangleIndices),
    header = _decode.header,
    vertexData = _decode.vertexData,
    originalTriangleIndices = _decode.triangleIndices,
    westIndices = _decode.westIndices,
    northIndices = _decode.northIndices,
    eastIndices = _decode.eastIndices,
    southIndices = _decode.southIndices;
  var triangleIndices = originalTriangleIndices;
  var attributes = getMeshAttributes(vertexData, header, bounds);
  var boundingBox = (0, _schema.getMeshBoundingBox)(attributes);
  if (options.skirtHeight) {
    var _addSkirt = (0, _skirt.addSkirt)(attributes, triangleIndices, options.skirtHeight, {
        westIndices: westIndices,
        northIndices: northIndices,
        eastIndices: eastIndices,
        southIndices: southIndices
      }),
      newAttributes = _addSkirt.attributes,
      newTriangles = _addSkirt.triangles;
    attributes = newAttributes;
    triangleIndices = newTriangles;
  }
  return {
    loaderData: {
      header: {}
    },
    header: {
      vertexCount: triangleIndices.length,
      boundingBox: boundingBox
    },
    mode: 4,
    indices: {
      value: triangleIndices,
      size: 1
    },
    attributes: attributes
  };
}
function loadQuantizedMesh(arrayBuffer, options) {
  return getTileMesh(arrayBuffer, options['quantized-mesh']);
}
//# sourceMappingURL=parse-quantized-mesh.js.map