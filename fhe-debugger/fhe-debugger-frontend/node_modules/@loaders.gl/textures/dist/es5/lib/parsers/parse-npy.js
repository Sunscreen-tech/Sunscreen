"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseNPY = parseNPY;
function systemIsLittleEndian() {
  var a = new Uint32Array([0x12345678]);
  var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
  return !(b[0] === 0x12);
}
var LITTLE_ENDIAN_OS = systemIsLittleEndian();
var DTYPES = {
  u1: Uint8Array,
  i1: Int8Array,
  u2: Uint16Array,
  i2: Int16Array,
  u4: Uint32Array,
  i4: Int32Array,
  f4: Float32Array,
  f8: Float64Array
};
function parseNPY(arrayBuffer, options) {
  var _header$shape;
  if (!arrayBuffer) {
    return null;
  }
  var view = new DataView(arrayBuffer);
  var _parseHeader = parseHeader(view),
    header = _parseHeader.header,
    headerEndOffset = _parseHeader.headerEndOffset;
  var numpyType = header.descr;
  var ArrayType = DTYPES[numpyType.slice(1, 3)];
  if (!ArrayType) {
    throw new Error("Unimplemented type ".concat(numpyType));
  }
  var nArrayElements = (_header$shape = header.shape) === null || _header$shape === void 0 ? void 0 : _header$shape.reduce(function (a, b) {
    return a * b;
  });
  var arrayByteLength = nArrayElements * ArrayType.BYTES_PER_ELEMENT;
  if (arrayBuffer.byteLength < headerEndOffset + arrayByteLength) {
    throw new Error('Buffer overflow');
  }
  var data = new ArrayType(arrayBuffer.slice(headerEndOffset, headerEndOffset + arrayByteLength));
  if (numpyType[0] === '>' && LITTLE_ENDIAN_OS || numpyType[0] === '<' && !LITTLE_ENDIAN_OS) {
    throw new Error('Incorrect endianness');
  }
  return {
    data: data,
    header: header
  };
}
function parseHeader(view) {
  var majorVersion = view.getUint8(6);
  var offset = 8;
  var headerLength;
  if (majorVersion >= 2) {
    headerLength = view.getUint32(offset, true);
    offset += 4;
  } else {
    headerLength = view.getUint16(offset, true);
    offset += 2;
  }
  var encoding = majorVersion <= 2 ? 'latin1' : 'utf-8';
  var decoder = new TextDecoder(encoding);
  var headerArray = new Uint8Array(view.buffer, offset, headerLength);
  var headerText = decoder.decode(headerArray);
  offset += headerLength;
  var header = JSON.parse(headerText.replace(/'/g, '"').replace('False', 'false').replace('(', '[').replace(/,*\),*/g, ']'));
  return {
    header: header,
    headerEndOffset: offset
  };
}
//# sourceMappingURL=parse-npy.js.map