"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLibraryUrl = exports.loadLibrary = void 0;
/* global importScripts */
const globals_1 = require("../env-utils/globals");
const node = __importStar(require("../node/require-utils.node"));
const assert_1 = require("../env-utils/assert");
const version_1 = require("../env-utils/version");
/**
 * TODO - unpkg.com doesn't seem to have a `latest` specifier for alpha releases...
 * 'beta' on beta branch, 'latest' on prod branch
 */
const LATEST = 'latest';
const VERSION = typeof version_1.VERSION !== 'undefined' ? version_1.VERSION : LATEST;
const loadLibraryPromises = {}; // promises
/**
 * Dynamically loads a library ("module")
 *
 * - wasm library: Array buffer is returned
 * - js library: Parse JS is returned
 *
 * Method depends on environment
 * - browser - script element is created and installed on document
 * - worker - eval is called on global context
 * - node - file is required
 *
 * @param libraryUrl
 * @param moduleName
 * @param options
 */
async function loadLibrary(libraryUrl, moduleName = null, options = {}) {
    if (moduleName) {
        libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);
    }
    // Ensure libraries are only loaded once
    loadLibraryPromises[libraryUrl] =
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
    return await loadLibraryPromises[libraryUrl];
}
exports.loadLibrary = loadLibrary;
// TODO - sort out how to resolve paths for main/worker and dev/prod
function getLibraryUrl(library, moduleName, options) {
    // Check if already a URL
    if (library.startsWith('http')) {
        return library;
    }
    // Allow application to import and supply libraries through `options.modules`
    const modules = options.modules || {};
    if (modules[library]) {
        return modules[library];
    }
    // Load from local files, not from CDN scripts in Node.js
    // TODO - needs to locate the modules directory when installed!
    if (!globals_1.isBrowser) {
        return `modules/${moduleName}/dist/libs/${library}`;
    }
    // In browser, load from external scripts
    if (options.CDN) {
        (0, assert_1.assert)(options.CDN.startsWith('http'));
        return `${options.CDN}/${moduleName}@${VERSION}/dist/libs/${library}`;
    }
    // TODO - loading inside workers requires paths relative to worker script location...
    if (globals_1.isWorker) {
        return `../src/libs/${library}`;
    }
    return `modules/${moduleName}/src/libs/${library}`;
}
exports.getLibraryUrl = getLibraryUrl;
async function loadLibraryFromFile(libraryUrl) {
    if (libraryUrl.endsWith('wasm')) {
        const response = await fetch(libraryUrl);
        return await response.arrayBuffer();
    }
    if (!globals_1.isBrowser) {
        try {
            return node && node.requireFromFile && (await node.requireFromFile(libraryUrl));
        }
        catch {
            return null;
        }
    }
    if (globals_1.isWorker) {
        return importScripts(libraryUrl);
    }
    // TODO - fix - should be more secure than string parsing since observes CORS
    // if (isBrowser) {
    //   return await loadScriptFromFile(libraryUrl);
    // }
    const response = await fetch(libraryUrl);
    const scriptSource = await response.text();
    return loadLibraryFromString(scriptSource, libraryUrl);
}
/*
async function loadScriptFromFile(libraryUrl) {
  const script = document.createElement('script');
  script.src = libraryUrl;
  return await new Promise((resolve, reject) => {
    script.onload = data => {
      resolve(data);
    };
    script.onerror = reject;
  });
}
*/
// TODO - Needs security audit...
//  - Raw eval call
//  - Potentially bypasses CORS
// Upside is that this separates fetching and parsing
// we could create a`LibraryLoader` or`ModuleLoader`
function loadLibraryFromString(scriptSource, id) {
    if (!globals_1.isBrowser) {
        return node.requireFromString && node.requireFromString(scriptSource, id);
    }
    if (globals_1.isWorker) {
        // Use lvalue trick to make eval run in global scope
        eval.call(globals_1.global, scriptSource); // eslint-disable-line no-eval
        // https://stackoverflow.com/questions/9107240/1-evalthis-vs-evalthis-in-javascript
        // http://perfectionkills.com/global-eval-what-are-the-options/
        return null;
    }
    const script = document.createElement('script');
    script.id = id;
    // most browsers like a separate text node but some throw an error. The second method covers those.
    try {
        script.appendChild(document.createTextNode(scriptSource));
    }
    catch (e) {
        script.text = scriptSource;
    }
    document.body.appendChild(script);
    return null;
}
// TODO - technique for module injection into worker, from THREE.DracoLoader...
/*
function combineWorkerWithLibrary(worker, jsContent) {
  var fn = wWorker.toString();
  var body = [
    '// injected',
    jsContent,
    '',
    '// worker',
    fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))
  ].join('\n');
  this.workerSourceURL = URL.createObjectURL(new Blob([body]));
}
*/
