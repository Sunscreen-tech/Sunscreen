(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // src/sax-ts/sax.ts
  var DEFAULT_SAX_EVENTS, DEFAULT_SAX_PARSER_OPTIONS, EVENTS, BUFFERS, nameStart, nameBody, entityStart, entityBody, ENTITIES, SAX, SAXParser;
  var init_sax = __esm({
    "src/sax-ts/sax.ts"() {
      DEFAULT_SAX_EVENTS = {
        ontext: () => {
        },
        onprocessinginstruction: () => {
        },
        onsgmldeclaration: () => {
        },
        ondoctype: () => {
        },
        oncomment: () => {
        },
        onopentagstart: () => {
        },
        onattribute: () => {
        },
        onopentag: () => {
        },
        onclosetag: () => {
        },
        onopencdata: () => {
        },
        oncdata: () => {
        },
        onclosecdata: () => {
        },
        onerror: () => {
        },
        onend: () => {
        },
        onready: () => {
        },
        onscript: () => {
        },
        onopennamespace: () => {
        },
        onclosenamespace: () => {
        }
      };
      DEFAULT_SAX_PARSER_OPTIONS = {
        ...DEFAULT_SAX_EVENTS,
        strict: false,
        MAX_BUFFER_LENGTH: 64 * 1024,
        lowercase: false,
        lowercasetags: false,
        noscript: false,
        strictEntities: false,
        xmlns: void 0,
        position: void 0,
        trim: void 0,
        normalize: void 0
      };
      EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      BUFFERS = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      };
      Object.keys(ENTITIES).forEach((key) => {
        const e = ENTITIES[key];
        ENTITIES[key] = typeof e === "number" ? String.fromCharCode(e) : e;
      });
      SAX = class {
        constructor() {
          this.EVENTS = EVENTS;
          this.ENTITIES = {
            ...ENTITIES
          };
          this.XML_ENTITIES = {
            amp: "&",
            gt: ">",
            lt: "<",
            quot: '"',
            apos: "'"
          };
          this.S = 0;
          this.trackPosition = false;
          this.column = 0;
          this.line = 0;
          this.c = "";
          this.q = "";
          this.closed = false;
          this.tags = [];
          this.looseCase = "";
          this.closedRoot = false;
          this.sawRoot = false;
          this.strict = false;
          this.noscript = false;
          this.attribList = [];
          this.position = 0;
          this.STATE = {
            BEGIN: this.S++,
            BEGIN_WHITESPACE: this.S++,
            TEXT: this.S++,
            TEXT_ENTITY: this.S++,
            OPEN_WAKA: this.S++,
            SGML_DECL: this.S++,
            SGML_DECL_QUOTED: this.S++,
            DOCTYPE: this.S++,
            DOCTYPE_QUOTED: this.S++,
            DOCTYPE_DTD: this.S++,
            DOCTYPE_DTD_QUOTED: this.S++,
            COMMENT_STARTING: this.S++,
            COMMENT: this.S++,
            COMMENT_ENDING: this.S++,
            COMMENT_ENDED: this.S++,
            CDATA: this.S++,
            CDATA_ENDING: this.S++,
            CDATA_ENDING_2: this.S++,
            PROC_INST: this.S++,
            PROC_INST_BODY: this.S++,
            PROC_INST_ENDING: this.S++,
            OPEN_TAG: this.S++,
            OPEN_TAG_SLASH: this.S++,
            ATTRIB: this.S++,
            ATTRIB_NAME: this.S++,
            ATTRIB_NAME_SAW_WHITE: this.S++,
            ATTRIB_VALUE: this.S++,
            ATTRIB_VALUE_QUOTED: this.S++,
            ATTRIB_VALUE_CLOSED: this.S++,
            ATTRIB_VALUE_UNQUOTED: this.S++,
            ATTRIB_VALUE_ENTITY_Q: this.S++,
            ATTRIB_VALUE_ENTITY_U: this.S++,
            CLOSE_TAG: this.S++,
            CLOSE_TAG_SAW_WHITE: this.S++,
            SCRIPT: this.S++,
            SCRIPT_ENDING: this.S++
          };
          this.BUFFERS = BUFFERS;
          this.CDATA = "[CDATA[";
          this.DOCTYPE = "DOCTYPE";
          this.XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
          this.XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
          this.rootNS = {
            xml: this.XML_NAMESPACE,
            xmlns: this.XMLNS_NAMESPACE
          };
          this.textNode = "";
          this.entity = "";
          this.cdata = "";
          this.script = "";
          this.startTagPosition = 0;
          this.S = 0;
          for (const s in this.STATE) {
            if (this.STATE.hasOwnProperty(s)) {
              this.STATE[this.STATE[s]] = s;
            }
          }
          this.S = this.STATE;
        }
        static charAt(chunk, i) {
          let result = "";
          if (i < chunk.length) {
            result = chunk.charAt(i);
          }
          return result;
        }
        static isWhitespace(c) {
          return c === " " || c === "\n" || c === "\r" || c === "	";
        }
        static isQuote(c) {
          return c === '"' || c === "'";
        }
        static isAttribEnd(c) {
          return c === ">" || SAX.isWhitespace(c);
        }
        static isMatch(regex, c) {
          return regex.test(c);
        }
        static notMatch(regex, c) {
          return !SAX.isMatch(regex, c);
        }
        static qname(name, attribute) {
          const i = name.indexOf(":");
          const qualName = i < 0 ? ["", name] : name.split(":");
          let prefix = qualName[0];
          let local = qualName[1];
          if (attribute && name === "xmlns") {
            prefix = "xmlns";
            local = "";
          }
          return { prefix, local };
        }
        write(chunk) {
          if (this.error) {
            throw this.error;
          }
          if (this.closed) {
            return this.errorFunction("Cannot write after close. Assign an onready handler.");
          }
          if (chunk === null) {
            return this.end();
          }
          if (typeof chunk === "object") {
            chunk = chunk.toString();
          }
          let i = 0;
          let c;
          while (true) {
            c = SAX.charAt(chunk, i++);
            this.c = c;
            if (!c) {
              break;
            }
            if (this.trackPosition) {
              this.position++;
              if (c === "\n") {
                this.line++;
                this.column = 0;
              } else {
                this.column++;
              }
            }
            switch (this.state) {
              case this.S.BEGIN:
                this.state = this.S.BEGIN_WHITESPACE;
                if (c === "\uFEFF") {
                  continue;
                }
                this.beginWhiteSpace(c);
                continue;
              case this.S.BEGIN_WHITESPACE:
                this.beginWhiteSpace(c);
                continue;
              case this.S.TEXT:
                if (this.sawRoot && !this.closedRoot) {
                  const starti = i - 1;
                  while (c && c !== "<" && c !== "&") {
                    c = SAX.charAt(chunk, i++);
                    if (c && this.trackPosition) {
                      this.position++;
                      if (c === "\n") {
                        this.line++;
                        this.column = 0;
                      } else {
                        this.column++;
                      }
                    }
                  }
                  this.textNode += chunk.substring(starti, i - 1);
                }
                if (c === "<" && !(this.sawRoot && this.closedRoot && !this.strict)) {
                  this.state = this.S.OPEN_WAKA;
                  this.startTagPosition = this.position;
                } else {
                  if (!SAX.isWhitespace(c) && (!this.sawRoot || this.closedRoot)) {
                    this.strictFail("Text data outside of root node.");
                  }
                  if (c === "&") {
                    this.state = this.S.TEXT_ENTITY;
                  } else {
                    this.textNode += c;
                  }
                }
                continue;
              case this.S.SCRIPT:
                if (c === "<") {
                  this.state = this.S.SCRIPT_ENDING;
                } else {
                  this.script += c;
                }
                continue;
              case this.S.SCRIPT_ENDING:
                if (c === "/") {
                  this.state = this.S.CLOSE_TAG;
                } else {
                  this.script += `<${c}`;
                  this.state = this.S.SCRIPT;
                }
                continue;
              case this.S.OPEN_WAKA:
                if (c === "!") {
                  this.state = this.S.SGML_DECL;
                  this.sgmlDecl = "";
                } else if (SAX.isWhitespace(c)) {
                } else if (SAX.isMatch(nameStart, c)) {
                  this.state = this.S.OPEN_TAG;
                  this.tagName = c;
                } else if (c === "/") {
                  this.state = this.S.CLOSE_TAG;
                  this.tagName = "";
                } else if (c === "?") {
                  this.state = this.S.PROC_INST;
                  this.procInstName = this.procInstBody = "";
                } else {
                  this.strictFail("Unencoded <");
                  if (this.startTagPosition + 1 < this.position) {
                    const pad = this.position - this.startTagPosition;
                    c = new Array(pad).join(" ") + c;
                  }
                  this.textNode += `<${c}`;
                  this.state = this.S.TEXT;
                }
                continue;
              case this.S.SGML_DECL:
                if ((this.sgmlDecl + c).toUpperCase() === this.CDATA) {
                  this.emitNode("onopencdata");
                  this.state = this.S.CDATA;
                  this.sgmlDecl = "";
                  this.cdata = "";
                } else if (this.sgmlDecl + c === "--") {
                  this.state = this.S.COMMENT;
                  this.comment = "";
                  this.sgmlDecl = "";
                } else if ((this.sgmlDecl + c).toUpperCase() === this.DOCTYPE) {
                  this.state = this.S.DOCTYPE;
                  if (this.doctype || this.sawRoot) {
                    this.strictFail("Inappropriately located doctype declaration");
                  }
                  this.doctype = "";
                  this.sgmlDecl = "";
                } else if (c === ">") {
                  this.emitNode("onsgmldeclaration", this.sgmlDecl);
                  this.sgmlDecl = "";
                  this.state = this.S.TEXT;
                } else if (SAX.isQuote(c)) {
                  this.state = this.S.SGML_DECL_QUOTED;
                  this.sgmlDecl += c;
                } else {
                  this.sgmlDecl += c;
                }
                continue;
              case this.S.SGML_DECL_QUOTED:
                if (c === this.q) {
                  this.state = this.S.SGML_DECL;
                  this.q = "";
                }
                this.sgmlDecl += c;
                continue;
              case this.S.DOCTYPE:
                if (c === ">") {
                  this.state = this.S.TEXT;
                  this.emitNode("ondoctype", this.doctype);
                  this.doctype = true;
                } else {
                  this.doctype += c;
                  if (c === "[") {
                    this.state = this.S.DOCTYPE_DTD;
                  } else if (SAX.isQuote(c)) {
                    this.state = this.S.DOCTYPE_QUOTED;
                    this.q = c;
                  }
                }
                continue;
              case this.S.DOCTYPE_QUOTED:
                this.doctype += c;
                if (c === this.q) {
                  this.q = "";
                  this.state = this.S.DOCTYPE;
                }
                continue;
              case this.S.DOCTYPE_DTD:
                this.doctype += c;
                if (c === "]") {
                  this.state = this.S.DOCTYPE;
                } else if (SAX.isQuote(c)) {
                  this.state = this.S.DOCTYPE_DTD_QUOTED;
                  this.q = c;
                }
                continue;
              case this.S.DOCTYPE_DTD_QUOTED:
                this.doctype += c;
                if (c === this.q) {
                  this.state = this.S.DOCTYPE_DTD;
                  this.q = "";
                }
                continue;
              case this.S.COMMENT:
                if (c === "-") {
                  this.state = this.S.COMMENT_ENDING;
                } else {
                  this.comment += c;
                }
                continue;
              case this.S.COMMENT_ENDING:
                if (c === "-") {
                  this.state = this.S.COMMENT_ENDED;
                  this.comment = this.textApplyOptions(this.comment);
                  if (this.comment) {
                    this.emitNode("oncomment", this.comment);
                  }
                  this.comment = "";
                } else {
                  this.comment += `-${c}`;
                  this.state = this.S.COMMENT;
                }
                continue;
              case this.S.COMMENT_ENDED:
                if (c !== ">") {
                  this.strictFail("Malformed comment");
                  this.comment += `--${c}`;
                  this.state = this.S.COMMENT;
                } else {
                  this.state = this.S.TEXT;
                }
                continue;
              case this.S.CDATA:
                if (c === "]") {
                  this.state = this.S.CDATA_ENDING;
                } else {
                  this.cdata += c;
                }
                continue;
              case this.S.CDATA_ENDING:
                if (c === "]") {
                  this.state = this.S.CDATA_ENDING_2;
                } else {
                  this.cdata += `]${c}`;
                  this.state = this.S.CDATA;
                }
                continue;
              case this.S.CDATA_ENDING_2:
                if (c === ">") {
                  if (this.cdata) {
                    this.emitNode("oncdata", this.cdata);
                  }
                  this.emitNode("onclosecdata");
                  this.cdata = "";
                  this.state = this.S.TEXT;
                } else if (c === "]") {
                  this.cdata += "]";
                } else {
                  this.cdata += `]]${c}`;
                  this.state = this.S.CDATA;
                }
                continue;
              case this.S.PROC_INST:
                if (c === "?") {
                  this.state = this.S.PROC_INST_ENDING;
                } else if (SAX.isWhitespace(c)) {
                  this.state = this.S.PROC_INST_BODY;
                } else {
                  this.procInstName += c;
                }
                continue;
              case this.S.PROC_INST_BODY:
                if (!this.procInstBody && SAX.isWhitespace(c)) {
                  continue;
                } else if (c === "?") {
                  this.state = this.S.PROC_INST_ENDING;
                } else {
                  this.procInstBody += c;
                }
                continue;
              case this.S.PROC_INST_ENDING:
                if (c === ">") {
                  this.emitNode("onprocessinginstruction", {
                    name: this.procInstName,
                    body: this.procInstBody
                  });
                  this.procInstName = this.procInstBody = "";
                  this.state = this.S.TEXT;
                } else {
                  this.procInstBody += `?${c}`;
                  this.state = this.S.PROC_INST_BODY;
                }
                continue;
              case this.S.OPEN_TAG:
                if (SAX.isMatch(nameBody, c)) {
                  this.tagName += c;
                } else {
                  this.newTag();
                  if (c === ">") {
                    this.openTag();
                  } else if (c === "/") {
                    this.state = this.S.OPEN_TAG_SLASH;
                  } else {
                    if (!SAX.isWhitespace(c)) {
                      this.strictFail("Invalid character in tag name");
                    }
                    this.state = this.S.ATTRIB;
                  }
                }
                continue;
              case this.S.OPEN_TAG_SLASH:
                if (c === ">") {
                  this.openTag(true);
                  this.closeTag();
                } else {
                  this.strictFail("Forward-slash in opening tag not followed by >");
                  this.state = this.S.ATTRIB;
                }
                continue;
              case this.S.ATTRIB:
                if (SAX.isWhitespace(c)) {
                  continue;
                } else if (c === ">") {
                  this.openTag();
                } else if (c === "/") {
                  this.state = this.S.OPEN_TAG_SLASH;
                } else if (SAX.isMatch(nameStart, c)) {
                  this.attribName = c;
                  this.attribValue = "";
                  this.state = this.S.ATTRIB_NAME;
                } else {
                  this.strictFail("Invalid attribute name");
                }
                continue;
              case this.S.ATTRIB_NAME:
                if (c === "=") {
                  this.state = this.S.ATTRIB_VALUE;
                } else if (c === ">") {
                  this.strictFail("Attribute without value");
                  this.attribValue = this.attribName;
                  this.attrib();
                  this.openTag();
                } else if (SAX.isWhitespace(c)) {
                  this.state = this.S.ATTRIB_NAME_SAW_WHITE;
                } else if (SAX.isMatch(nameBody, c)) {
                  this.attribName += c;
                } else {
                  this.strictFail("Invalid attribute name");
                }
                continue;
              case this.S.ATTRIB_NAME_SAW_WHITE:
                if (c === "=") {
                  this.state = this.S.ATTRIB_VALUE;
                } else if (SAX.isWhitespace(c)) {
                  continue;
                } else {
                  this.strictFail("Attribute without value");
                  this.tag.attributes[this.attribName] = "";
                  this.attribValue = "";
                  this.emitNode("onattribute", {
                    name: this.attribName,
                    value: ""
                  });
                  this.attribName = "";
                  if (c === ">") {
                    this.openTag();
                  } else if (SAX.isMatch(nameStart, c)) {
                    this.attribName = c;
                    this.state = this.S.ATTRIB_NAME;
                  } else {
                    this.strictFail("Invalid attribute name");
                    this.state = this.S.ATTRIB;
                  }
                }
                continue;
              case this.S.ATTRIB_VALUE:
                if (SAX.isWhitespace(c)) {
                  continue;
                } else if (SAX.isQuote(c)) {
                  this.q = c;
                  this.state = this.S.ATTRIB_VALUE_QUOTED;
                } else {
                  this.strictFail("Unquoted attribute value");
                  this.state = this.S.ATTRIB_VALUE_UNQUOTED;
                  this.attribValue = c;
                }
                continue;
              case this.S.ATTRIB_VALUE_QUOTED:
                if (c !== this.q) {
                  if (c === "&") {
                    this.state = this.S.ATTRIB_VALUE_ENTITY_Q;
                  } else {
                    this.attribValue += c;
                  }
                  continue;
                }
                this.attrib();
                this.q = "";
                this.state = this.S.ATTRIB_VALUE_CLOSED;
                continue;
              case this.S.ATTRIB_VALUE_CLOSED:
                if (SAX.isWhitespace(c)) {
                  this.state = this.S.ATTRIB;
                } else if (c === ">") {
                  this.openTag();
                } else if (c === "/") {
                  this.state = this.S.OPEN_TAG_SLASH;
                } else if (SAX.isMatch(nameStart, c)) {
                  this.strictFail("No whitespace between attributes");
                  this.attribName = c;
                  this.attribValue = "";
                  this.state = this.S.ATTRIB_NAME;
                } else {
                  this.strictFail("Invalid attribute name");
                }
                continue;
              case this.S.ATTRIB_VALUE_UNQUOTED:
                if (!SAX.isAttribEnd(c)) {
                  if (c === "&") {
                    this.state = this.S.ATTRIB_VALUE_ENTITY_U;
                  } else {
                    this.attribValue += c;
                  }
                  continue;
                }
                this.attrib();
                if (c === ">") {
                  this.openTag();
                } else {
                  this.state = this.S.ATTRIB;
                }
                continue;
              case this.S.CLOSE_TAG:
                if (!this.tagName) {
                  if (SAX.isWhitespace(c)) {
                    continue;
                  } else if (SAX.notMatch(nameStart, c)) {
                    if (this.script) {
                      this.script += `</${c}`;
                      this.state = this.S.SCRIPT;
                    } else {
                      this.strictFail("Invalid tagname in closing tag.");
                    }
                  } else {
                    this.tagName = c;
                  }
                } else if (c === ">") {
                  this.closeTag();
                } else if (SAX.isMatch(nameBody, c)) {
                  this.tagName += c;
                } else if (this.script) {
                  this.script += `</${this.tagName}`;
                  this.tagName = "";
                  this.state = this.S.SCRIPT;
                } else {
                  if (!SAX.isWhitespace(c)) {
                    this.strictFail("Invalid tagname in closing tag");
                  }
                  this.state = this.S.CLOSE_TAG_SAW_WHITE;
                }
                continue;
              case this.S.CLOSE_TAG_SAW_WHITE:
                if (SAX.isWhitespace(c)) {
                  continue;
                }
                if (c === ">") {
                  this.closeTag();
                } else {
                  this.strictFail("Invalid characters in closing tag");
                }
                continue;
              case this.S.TEXT_ENTITY:
              case this.S.ATTRIB_VALUE_ENTITY_Q:
              case this.S.ATTRIB_VALUE_ENTITY_U:
                let returnState;
                let buffer;
                switch (this.state) {
                  case this.S.TEXT_ENTITY:
                    returnState = this.S.TEXT;
                    buffer = "textNode";
                    break;
                  case this.S.ATTRIB_VALUE_ENTITY_Q:
                    returnState = this.S.ATTRIB_VALUE_QUOTED;
                    buffer = "attribValue";
                    break;
                  case this.S.ATTRIB_VALUE_ENTITY_U:
                    returnState = this.S.ATTRIB_VALUE_UNQUOTED;
                    buffer = "attribValue";
                    break;
                  default:
                    throw new Error(`Unknown state: ${this.state}`);
                }
                if (c === ";") {
                  this[buffer] += this.parseEntity();
                  this.entity = "";
                  this.state = returnState;
                } else if (SAX.isMatch(this.entity.length ? entityBody : entityStart, c)) {
                  this.entity += c;
                } else {
                  this.strictFail("Invalid character in entity name");
                  this[buffer] += `&${this.entity}${c}`;
                  this.entity = "";
                  this.state = returnState;
                }
                continue;
              default:
                throw new Error(`Unknown state: ${this.state}`);
            }
          }
          if (this.position >= this.bufferCheckPosition) {
            this.checkBufferLength();
          }
          return this;
        }
        emit(event, data) {
          if (this.events.hasOwnProperty(event)) {
            const eventName = event.replace(/^on/, "");
            this.events[event](data, eventName, this);
          }
        }
        clearBuffers() {
          for (let i = 0, l = this.BUFFERS.length; i < l; i++) {
            this[this[i]] = "";
          }
        }
        flushBuffers() {
          this.closeText();
          if (this.cdata !== "") {
            this.emitNode("oncdata", this.cdata);
            this.cdata = "";
          }
          if (this.script !== "") {
            this.emitNode("onscript", this.script);
            this.script = "";
          }
        }
        end() {
          if (this.sawRoot && !this.closedRoot)
            this.strictFail("Unclosed root tag");
          if (this.state !== this.S.BEGIN && this.state !== this.S.BEGIN_WHITESPACE && this.state !== this.S.TEXT) {
            this.errorFunction("Unexpected end");
          }
          this.closeText();
          this.c = "";
          this.closed = true;
          this.emit("onend");
          return new SAXParser(this.opt);
        }
        errorFunction(er) {
          this.closeText();
          if (this.trackPosition) {
            er += `
Line: ${this.line}
Column: ${this.column}
Char: ${this.c}`;
          }
          const error = new Error(er);
          this.error = error;
          this.emit("onerror", error);
          return this;
        }
        attrib() {
          if (!this.strict) {
            this.attribName = this.attribName[this.looseCase]();
          }
          if (this.attribList.indexOf(this.attribName) !== -1 || this.tag.attributes.hasOwnProperty(this.attribName)) {
            this.attribName = this.attribValue = "";
            return;
          }
          if (this.opt.xmlns) {
            const qn = SAX.qname(this.attribName, true);
            const prefix = qn.prefix;
            const local = qn.local;
            if (prefix === "xmlns") {
              if (local === "xml" && this.attribValue !== this.XML_NAMESPACE) {
                this.strictFail(`xml: prefix must be bound to ${this.XML_NAMESPACE}
Actual: ${this.attribValue}`);
              } else if (local === "xmlns" && this.attribValue !== this.XMLNS_NAMESPACE) {
                this.strictFail(`xmlns: prefix must be bound to ${this.XMLNS_NAMESPACE}
Actual: ${this.attribValue}`);
              } else {
                const tag = this.tag;
                const parent = this.tags[this.tags.length - 1] || this;
                if (tag.ns === parent.ns) {
                  tag.ns = Object.create(parent.ns);
                }
                tag.ns[local] = this.attribValue;
              }
            }
            this.attribList.push([this.attribName, this.attribValue]);
          } else {
            this.tag.attributes[this.attribName] = this.attribValue;
            this.emitNode("onattribute", {
              name: this.attribName,
              value: this.attribValue
            });
          }
          this.attribName = this.attribValue = "";
        }
        newTag() {
          if (!this.strict)
            this.tagName = this.tagName[this.looseCase]();
          const parent = this.tags[this.tags.length - 1] || this;
          const tag = this.tag = { name: this.tagName, attributes: {} };
          if (this.opt.xmlns) {
            tag.ns = parent.ns;
          }
          this.attribList.length = 0;
          this.emitNode("onopentagstart", tag);
        }
        parseEntity() {
          let entity = this.entity;
          const entityLC = entity.toLowerCase();
          let num = NaN;
          let numStr = "";
          if (this.ENTITIES[entity]) {
            return this.ENTITIES[entity];
          }
          if (this.ENTITIES[entityLC]) {
            return this.ENTITIES[entityLC];
          }
          entity = entityLC;
          if (entity.charAt(0) === "#") {
            if (entity.charAt(1) === "x") {
              entity = entity.slice(2);
              num = parseInt(entity, 16);
              numStr = num.toString(16);
            } else {
              entity = entity.slice(1);
              num = parseInt(entity, 10);
              numStr = num.toString(10);
            }
          }
          entity = entity.replace(/^0+/, "");
          if (isNaN(num) || numStr.toLowerCase() !== entity) {
            this.strictFail("Invalid character entity");
            return `&${this.entity};`;
          }
          return String.fromCodePoint(num);
        }
        beginWhiteSpace(c) {
          if (c === "<") {
            this.state = this.S.OPEN_WAKA;
            this.startTagPosition = this.position;
          } else if (!SAX.isWhitespace(c)) {
            this.strictFail("Non-whitespace before first tag.");
            this.textNode = c;
            this.state = this.S.TEXT;
          } else {
          }
        }
        strictFail(message) {
          if (typeof this !== "object" || !(this instanceof SAXParser)) {
            throw new Error("bad call to strictFail");
          }
          if (this.strict) {
            this.errorFunction(message);
          }
        }
        textApplyOptions(text) {
          if (this.opt.trim)
            text = text.trim();
          if (this.opt.normalize)
            text = text.replace(/\s+/g, " ");
          return text;
        }
        emitNode(nodeType, data) {
          if (this.textNode)
            this.closeText();
          this.emit(nodeType, data);
        }
        closeText() {
          this.textNode = this.textApplyOptions(this.textNode);
          if (this.textNode !== void 0 && this.textNode !== "" && this.textNode !== "undefined") {
            this.emit("ontext", this.textNode);
          }
          this.textNode = "";
        }
        checkBufferLength() {
          const maxAllowed = Math.max(this.opt.MAX_BUFFER_LENGTH, 10);
          let maxActual = 0;
          for (let i = 0, l = this.BUFFERS.length; i < l; i++) {
            const len = this[this.BUFFERS[i]]?.length || 0;
            if (len > maxAllowed) {
              switch (this.BUFFERS[i]) {
                case "textNode":
                  this.closeText();
                  break;
                case "cdata":
                  this.emitNode("oncdata", this.cdata);
                  this.cdata = "";
                  break;
                case "script":
                  this.emitNode("onscript", this.script);
                  this.script = "";
                  break;
                default:
                  this.errorFunction(`Max buffer length exceeded: ${this.BUFFERS[i]}`);
              }
            }
            maxActual = Math.max(maxActual, len);
          }
          const m = this.opt.MAX_BUFFER_LENGTH - maxActual;
          this.bufferCheckPosition = m + this.position;
        }
        openTag(selfClosing) {
          if (this.opt.xmlns) {
            const tag = this.tag;
            const qn = SAX.qname(this.tagName);
            tag.prefix = qn.prefix;
            tag.local = qn.local;
            tag.uri = tag.ns[qn.prefix] || "";
            if (tag.prefix && !tag.uri) {
              this.strictFail(`Unbound namespace prefix: ${JSON.stringify(this.tagName)}`);
              tag.uri = qn.prefix;
            }
            const parent = this.tags[this.tags.length - 1] || this;
            if (tag.ns && parent.ns !== tag.ns) {
              const that = this;
              Object.keys(tag.ns).forEach((p) => {
                that.emitNode("onopennamespace", {
                  prefix: p,
                  uri: tag.ns[p]
                });
              });
            }
            for (let i = 0, l = this.attribList.length; i < l; i++) {
              const nv = this.attribList[i];
              const name = nv[0];
              const value = nv[1];
              const qualName = SAX.qname(name, true);
              const prefix = qualName.prefix;
              const local = qualName.local;
              const uri = prefix === "" ? "" : tag.ns[prefix] || "";
              const a = {
                name,
                value,
                prefix,
                local,
                uri
              };
              if (prefix && prefix !== "xmlns" && !uri) {
                this.strictFail(`Unbound namespace prefix: ${JSON.stringify(prefix)}`);
                a.uri = prefix;
              }
              this.tag.attributes[name] = a;
              this.emitNode("onattribute", a);
            }
            this.attribList.length = 0;
          }
          this.tag.isSelfClosing = Boolean(selfClosing);
          this.sawRoot = true;
          this.tags.push(this.tag);
          this.emitNode("onopentag", this.tag);
          if (!selfClosing) {
            if (!this.noscript && this.tagName.toLowerCase() === "script") {
              this.state = this.S.SCRIPT;
            } else {
              this.state = this.S.TEXT;
            }
            this.tag = null;
            this.tagName = "";
          }
          this.attribName = this.attribValue = "";
          this.attribList.length = 0;
        }
        closeTag() {
          if (!this.tagName) {
            this.strictFail("Weird empty close tag.");
            this.textNode += "</>";
            this.state = this.S.TEXT;
            return;
          }
          if (this.script) {
            if (this.tagName !== "script") {
              this.script += `</${this.tagName}>`;
              this.tagName = "";
              this.state = this.S.SCRIPT;
              return;
            }
            this.emitNode("onscript", this.script);
            this.script = "";
          }
          let t = this.tags.length;
          let tagName = this.tagName;
          if (!this.strict) {
            tagName = tagName[this.looseCase]();
          }
          while (t--) {
            const close = this.tags[t];
            if (close.name !== tagName) {
              this.strictFail("Unexpected close tag");
            } else {
              break;
            }
          }
          if (t < 0) {
            this.strictFail(`Unmatched closing tag: ${this.tagName}`);
            this.textNode += `</${this.tagName}>`;
            this.state = this.S.TEXT;
            return;
          }
          this.tagName = tagName;
          let s = this.tags.length;
          while (s-- > t) {
            const tag = this.tag = this.tags.pop();
            this.tagName = this.tag.name;
            this.emitNode("onclosetag", this.tagName);
            const x = {};
            for (const i in tag.ns) {
              if (tag.ns.hasOwnProperty(i)) {
                x[i] = tag.ns[i];
              }
            }
            const parent = this.tags[this.tags.length - 1] || this;
            if (this.opt.xmlns && tag.ns !== parent.ns) {
              const that = this;
              Object.keys(tag.ns).forEach((p) => {
                const n = tag.ns[p];
                that.emitNode("onclosenamespace", { prefix: p, uri: n });
              });
            }
          }
          if (t === 0)
            this.closedRoot = true;
          this.tagName = this.attribValue = this.attribName = "";
          this.attribList.length = 0;
          this.state = this.S.TEXT;
        }
      };
      SAXParser = class extends SAX {
        constructor(opt) {
          super();
          this.opt = DEFAULT_SAX_PARSER_OPTIONS;
          this.events = DEFAULT_SAX_EVENTS;
          this.clearBuffers();
          this.opt = opt = { ...this.opt, ...opt };
          this.events = { ...this.events, ...opt };
          this.q = this.c = "";
          this.opt.lowercase = this.opt.lowercase || this.opt.lowercasetags;
          this.bufferCheckPosition = this.opt.MAX_BUFFER_LENGTH;
          this.looseCase = this.opt.lowercase ? "toLowerCase" : "toUpperCase";
          this.tags = [];
          this.closed = this.closedRoot = this.sawRoot = false;
          this.tag = this.error = null;
          this.strict = Boolean(this.opt.strict);
          this.noscript = Boolean(this.opt.strict || this.opt.noscript);
          this.state = this.S.BEGIN;
          this.strictEntities = this.opt.strictEntities;
          this.ENTITIES = this.strictEntities ? Object.create(this.XML_ENTITIES) : Object.create(this.ENTITIES);
          this.attribList = [];
          if (this.opt.xmlns) {
            this.ns = Object.create(this.rootNS);
          }
          this.trackPosition = this.opt.position !== false;
          if (this.trackPosition) {
            this.position = this.line = this.column = 0;
          }
          this.emit("onready");
        }
        resume() {
          this.error = null;
          return this;
        }
        close() {
          return this.write(null);
        }
        flush() {
          this.flushBuffers();
        }
      };
      SAXParser.ENTITIES = ENTITIES;
    }
  });

  // ../../node_modules/fast-xml-parser/src/util.js
  var require_util = __commonJS({
    "../../node_modules/fast-xml-parser/src/util.js"(exports) {
      "use strict";
      var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
      var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
      var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
      var regexName = new RegExp("^" + nameRegexp + "$");
      var getAllMatches = function(string, regex) {
        const matches = [];
        let match = regex.exec(string);
        while (match) {
          const allmatches = [];
          allmatches.startIndex = regex.lastIndex - match[0].length;
          const len = match.length;
          for (let index = 0; index < len; index++) {
            allmatches.push(match[index]);
          }
          matches.push(allmatches);
          match = regex.exec(string);
        }
        return matches;
      };
      var isName = function(string) {
        const match = regexName.exec(string);
        return !(match === null || typeof match === "undefined");
      };
      exports.isExist = function(v) {
        return typeof v !== "undefined";
      };
      exports.isEmptyObject = function(obj) {
        return Object.keys(obj).length === 0;
      };
      exports.merge = function(target, a, arrayMode) {
        if (a) {
          const keys = Object.keys(a);
          const len = keys.length;
          for (let i = 0; i < len; i++) {
            if (arrayMode === "strict") {
              target[keys[i]] = [a[keys[i]]];
            } else {
              target[keys[i]] = a[keys[i]];
            }
          }
        }
      };
      exports.getValue = function(v) {
        if (exports.isExist(v)) {
          return v;
        } else {
          return "";
        }
      };
      exports.isName = isName;
      exports.getAllMatches = getAllMatches;
      exports.nameRegexp = nameRegexp;
    }
  });

  // ../../node_modules/fast-xml-parser/src/validator.js
  var require_validator = __commonJS({
    "../../node_modules/fast-xml-parser/src/validator.js"(exports) {
      "use strict";
      var util = require_util();
      var defaultOptions = {
        allowBooleanAttributes: false,
        unpairedTags: []
      };
      exports.validate = function(xmlData, options) {
        options = Object.assign({}, defaultOptions, options);
        const tags = [];
        let tagFound = false;
        let reachedRoot = false;
        if (xmlData[0] === "\uFEFF") {
          xmlData = xmlData.substr(1);
        }
        for (let i = 0; i < xmlData.length; i++) {
          if (xmlData[i] === "<" && xmlData[i + 1] === "?") {
            i += 2;
            i = readPI(xmlData, i);
            if (i.err)
              return i;
          } else if (xmlData[i] === "<") {
            let tagStartPos = i;
            i++;
            if (xmlData[i] === "!") {
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else {
              let closingTag = false;
              if (xmlData[i] === "/") {
                closingTag = true;
                i++;
              }
              let tagName = "";
              for (; i < xmlData.length && xmlData[i] !== ">" && xmlData[i] !== " " && xmlData[i] !== "	" && xmlData[i] !== "\n" && xmlData[i] !== "\r"; i++) {
                tagName += xmlData[i];
              }
              tagName = tagName.trim();
              if (tagName[tagName.length - 1] === "/") {
                tagName = tagName.substring(0, tagName.length - 1);
                i--;
              }
              if (!validateTagName(tagName)) {
                let msg;
                if (tagName.trim().length === 0) {
                  msg = "Invalid space after '<'.";
                } else {
                  msg = "Tag '" + tagName + "' is an invalid name.";
                }
                return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i));
              }
              const result = readAttributeStr(xmlData, i);
              if (result === false) {
                return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
              }
              let attrStr = result.value;
              i = result.index;
              if (attrStr[attrStr.length - 1] === "/") {
                const attrStrStart = i - attrStr.length;
                attrStr = attrStr.substring(0, attrStr.length - 1);
                const isValid = validateAttributeString(attrStr, options);
                if (isValid === true) {
                  tagFound = true;
                } else {
                  return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
                }
              } else if (closingTag) {
                if (!result.tagClosed) {
                  return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
                } else if (attrStr.trim().length > 0) {
                  return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
                } else {
                  const otg = tags.pop();
                  if (tagName !== otg.tagName) {
                    let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                    return getErrorObject("InvalidTag", "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.", getLineNumberForPosition(xmlData, tagStartPos));
                  }
                  if (tags.length == 0) {
                    reachedRoot = true;
                  }
                }
              } else {
                const isValid = validateAttributeString(attrStr, options);
                if (isValid !== true) {
                  return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
                }
                if (reachedRoot === true) {
                  return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i));
                } else if (options.unpairedTags.indexOf(tagName) !== -1) {
                } else {
                  tags.push({ tagName, tagStartPos });
                }
                tagFound = true;
              }
              for (i++; i < xmlData.length; i++) {
                if (xmlData[i] === "<") {
                  if (xmlData[i + 1] === "!") {
                    i++;
                    i = readCommentAndCDATA(xmlData, i);
                    continue;
                  } else if (xmlData[i + 1] === "?") {
                    i = readPI(xmlData, ++i);
                    if (i.err)
                      return i;
                  } else {
                    break;
                  }
                } else if (xmlData[i] === "&") {
                  const afterAmp = validateAmpersand(xmlData, i);
                  if (afterAmp == -1)
                    return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
                  i = afterAmp;
                } else {
                  if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
                    return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i));
                  }
                }
              }
              if (xmlData[i] === "<") {
                i--;
              }
            }
          } else {
            if (isWhiteSpace(xmlData[i])) {
              continue;
            }
            return getErrorObject("InvalidChar", "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
          }
        }
        if (!tagFound) {
          return getErrorObject("InvalidXml", "Start tag expected.", 1);
        } else if (tags.length == 1) {
          return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
        } else if (tags.length > 0) {
          return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
        }
        return true;
      };
      function isWhiteSpace(char) {
        return char === " " || char === "	" || char === "\n" || char === "\r";
      }
      function readPI(xmlData, i) {
        const start = i;
        for (; i < xmlData.length; i++) {
          if (xmlData[i] == "?" || xmlData[i] == " ") {
            const tagname = xmlData.substr(start, i - start);
            if (i > 5 && tagname === "xml") {
              return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i));
            } else if (xmlData[i] == "?" && xmlData[i + 1] == ">") {
              i++;
              break;
            } else {
              continue;
            }
          }
        }
        return i;
      }
      function readCommentAndCDATA(xmlData, i) {
        if (xmlData.length > i + 5 && xmlData[i + 1] === "-" && xmlData[i + 2] === "-") {
          for (i += 3; i < xmlData.length; i++) {
            if (xmlData[i] === "-" && xmlData[i + 1] === "-" && xmlData[i + 2] === ">") {
              i += 2;
              break;
            }
          }
        } else if (xmlData.length > i + 8 && xmlData[i + 1] === "D" && xmlData[i + 2] === "O" && xmlData[i + 3] === "C" && xmlData[i + 4] === "T" && xmlData[i + 5] === "Y" && xmlData[i + 6] === "P" && xmlData[i + 7] === "E") {
          let angleBracketsCount = 1;
          for (i += 8; i < xmlData.length; i++) {
            if (xmlData[i] === "<") {
              angleBracketsCount++;
            } else if (xmlData[i] === ">") {
              angleBracketsCount--;
              if (angleBracketsCount === 0) {
                break;
              }
            }
          }
        } else if (xmlData.length > i + 9 && xmlData[i + 1] === "[" && xmlData[i + 2] === "C" && xmlData[i + 3] === "D" && xmlData[i + 4] === "A" && xmlData[i + 5] === "T" && xmlData[i + 6] === "A" && xmlData[i + 7] === "[") {
          for (i += 8; i < xmlData.length; i++) {
            if (xmlData[i] === "]" && xmlData[i + 1] === "]" && xmlData[i + 2] === ">") {
              i += 2;
              break;
            }
          }
        }
        return i;
      }
      var doubleQuote = '"';
      var singleQuote = "'";
      function readAttributeStr(xmlData, i) {
        let attrStr = "";
        let startChar = "";
        let tagClosed = false;
        for (; i < xmlData.length; i++) {
          if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
            if (startChar === "") {
              startChar = xmlData[i];
            } else if (startChar !== xmlData[i]) {
            } else {
              startChar = "";
            }
          } else if (xmlData[i] === ">") {
            if (startChar === "") {
              tagClosed = true;
              break;
            }
          }
          attrStr += xmlData[i];
        }
        if (startChar !== "") {
          return false;
        }
        return {
          value: attrStr,
          index: i,
          tagClosed
        };
      }
      var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
      function validateAttributeString(attrStr, options) {
        const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
        const attrNames = {};
        for (let i = 0; i < matches.length; i++) {
          if (matches[i][1].length === 0) {
            return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' has no space in starting.", getPositionFromMatch(matches[i]));
          } else if (matches[i][3] !== void 0 && matches[i][4] === void 0) {
            return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' is without value.", getPositionFromMatch(matches[i]));
          } else if (matches[i][3] === void 0 && !options.allowBooleanAttributes) {
            return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i][2] + "' is not allowed.", getPositionFromMatch(matches[i]));
          }
          const attrName = matches[i][2];
          if (!validateAttrName(attrName)) {
            return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i]));
          }
          if (!attrNames.hasOwnProperty(attrName)) {
            attrNames[attrName] = 1;
          } else {
            return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i]));
          }
        }
        return true;
      }
      function validateNumberAmpersand(xmlData, i) {
        let re = /\d/;
        if (xmlData[i] === "x") {
          i++;
          re = /[\da-fA-F]/;
        }
        for (; i < xmlData.length; i++) {
          if (xmlData[i] === ";")
            return i;
          if (!xmlData[i].match(re))
            break;
        }
        return -1;
      }
      function validateAmpersand(xmlData, i) {
        i++;
        if (xmlData[i] === ";")
          return -1;
        if (xmlData[i] === "#") {
          i++;
          return validateNumberAmpersand(xmlData, i);
        }
        let count = 0;
        for (; i < xmlData.length; i++, count++) {
          if (xmlData[i].match(/\w/) && count < 20)
            continue;
          if (xmlData[i] === ";")
            break;
          return -1;
        }
        return i;
      }
      function getErrorObject(code, message, lineNumber) {
        return {
          err: {
            code,
            msg: message,
            line: lineNumber.line || lineNumber,
            col: lineNumber.col
          }
        };
      }
      function validateAttrName(attrName) {
        return util.isName(attrName);
      }
      function validateTagName(tagname) {
        return util.isName(tagname);
      }
      function getLineNumberForPosition(xmlData, index) {
        const lines = xmlData.substring(0, index).split(/\r?\n/);
        return {
          line: lines.length,
          col: lines[lines.length - 1].length + 1
        };
      }
      function getPositionFromMatch(match) {
        return match.startIndex + match[1].length;
      }
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
  var require_OptionsBuilder = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
      var defaultOptions = {
        preserveOrder: false,
        attributeNamePrefix: "@_",
        attributesGroupName: false,
        textNodeName: "#text",
        ignoreAttributes: true,
        removeNSPrefix: false,
        allowBooleanAttributes: false,
        parseTagValue: true,
        parseAttributeValue: false,
        trimValues: true,
        cdataPropName: false,
        numberParseOptions: {
          hex: true,
          leadingZeros: true,
          eNotation: true
        },
        tagValueProcessor: function(tagName, val2) {
          return val2;
        },
        attributeValueProcessor: function(attrName, val2) {
          return val2;
        },
        stopNodes: [],
        alwaysCreateTextNode: false,
        isArray: () => false,
        commentPropName: false,
        unpairedTags: [],
        processEntities: true,
        htmlEntities: false,
        ignoreDeclaration: false,
        ignorePiTags: false,
        transformTagName: false,
        transformAttributeName: false,
        updateTag: function(tagName, jPath, attrs) {
          return tagName;
        }
      };
      var buildOptions = function(options) {
        return Object.assign({}, defaultOptions, options);
      };
      exports.buildOptions = buildOptions;
      exports.defaultOptions = defaultOptions;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
  var require_xmlNode = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module) {
      "use strict";
      var XmlNode = class {
        constructor(tagname) {
          this.tagname = tagname;
          this.child = [];
          this[":@"] = {};
        }
        add(key, val2) {
          if (key === "__proto__")
            key = "#__proto__";
          this.child.push({ [key]: val2 });
        }
        addChild(node) {
          if (node.tagname === "__proto__")
            node.tagname = "#__proto__";
          if (node[":@"] && Object.keys(node[":@"]).length > 0) {
            this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
          } else {
            this.child.push({ [node.tagname]: node.child });
          }
        }
      };
      module.exports = XmlNode;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
  var require_DocTypeReader = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module) {
      var util = require_util();
      function readDocType(xmlData, i) {
        const entities = {};
        if (xmlData[i + 3] === "O" && xmlData[i + 4] === "C" && xmlData[i + 5] === "T" && xmlData[i + 6] === "Y" && xmlData[i + 7] === "P" && xmlData[i + 8] === "E") {
          i = i + 9;
          let angleBracketsCount = 1;
          let hasBody = false, comment = false;
          let exp = "";
          for (; i < xmlData.length; i++) {
            if (xmlData[i] === "<" && !comment) {
              if (hasBody && isEntity(xmlData, i)) {
                i += 7;
                [entityName, val, i] = readEntityExp(xmlData, i + 1);
                if (val.indexOf("&") === -1)
                  entities[validateEntityName(entityName)] = {
                    regx: RegExp(`&${entityName};`, "g"),
                    val
                  };
              } else if (hasBody && isElement(xmlData, i))
                i += 8;
              else if (hasBody && isAttlist(xmlData, i))
                i += 8;
              else if (hasBody && isNotation(xmlData, i))
                i += 9;
              else if (isComment)
                comment = true;
              else
                throw new Error("Invalid DOCTYPE");
              angleBracketsCount++;
              exp = "";
            } else if (xmlData[i] === ">") {
              if (comment) {
                if (xmlData[i - 1] === "-" && xmlData[i - 2] === "-") {
                  comment = false;
                  angleBracketsCount--;
                }
              } else {
                angleBracketsCount--;
              }
              if (angleBracketsCount === 0) {
                break;
              }
            } else if (xmlData[i] === "[") {
              hasBody = true;
            } else {
              exp += xmlData[i];
            }
          }
          if (angleBracketsCount !== 0) {
            throw new Error(`Unclosed DOCTYPE`);
          }
        } else {
          throw new Error(`Invalid Tag instead of DOCTYPE`);
        }
        return { entities, i };
      }
      function readEntityExp(xmlData, i) {
        let entityName2 = "";
        for (; i < xmlData.length && (xmlData[i] !== "'" && xmlData[i] !== '"'); i++) {
          entityName2 += xmlData[i];
        }
        entityName2 = entityName2.trim();
        if (entityName2.indexOf(" ") !== -1)
          throw new Error("External entites are not supported");
        const startChar = xmlData[i++];
        let val2 = "";
        for (; i < xmlData.length && xmlData[i] !== startChar; i++) {
          val2 += xmlData[i];
        }
        return [entityName2, val2, i];
      }
      function isComment(xmlData, i) {
        if (xmlData[i + 1] === "!" && xmlData[i + 2] === "-" && xmlData[i + 3] === "-")
          return true;
        return false;
      }
      function isEntity(xmlData, i) {
        if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "N" && xmlData[i + 4] === "T" && xmlData[i + 5] === "I" && xmlData[i + 6] === "T" && xmlData[i + 7] === "Y")
          return true;
        return false;
      }
      function isElement(xmlData, i) {
        if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "L" && xmlData[i + 4] === "E" && xmlData[i + 5] === "M" && xmlData[i + 6] === "E" && xmlData[i + 7] === "N" && xmlData[i + 8] === "T")
          return true;
        return false;
      }
      function isAttlist(xmlData, i) {
        if (xmlData[i + 1] === "!" && xmlData[i + 2] === "A" && xmlData[i + 3] === "T" && xmlData[i + 4] === "T" && xmlData[i + 5] === "L" && xmlData[i + 6] === "I" && xmlData[i + 7] === "S" && xmlData[i + 8] === "T")
          return true;
        return false;
      }
      function isNotation(xmlData, i) {
        if (xmlData[i + 1] === "!" && xmlData[i + 2] === "N" && xmlData[i + 3] === "O" && xmlData[i + 4] === "T" && xmlData[i + 5] === "A" && xmlData[i + 6] === "T" && xmlData[i + 7] === "I" && xmlData[i + 8] === "O" && xmlData[i + 9] === "N")
          return true;
        return false;
      }
      function validateEntityName(name) {
        if (util.isName(name))
          return name;
        else
          throw new Error(`Invalid entity name ${name}`);
      }
      module.exports = readDocType;
    }
  });

  // ../../node_modules/strnum/strnum.js
  var require_strnum = __commonJS({
    "../../node_modules/strnum/strnum.js"(exports, module) {
      var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
      var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
      if (!Number.parseInt && window.parseInt) {
        Number.parseInt = window.parseInt;
      }
      if (!Number.parseFloat && window.parseFloat) {
        Number.parseFloat = window.parseFloat;
      }
      var consider = {
        hex: true,
        leadingZeros: true,
        decimalPoint: ".",
        eNotation: true
      };
      function toNumber(str, options = {}) {
        options = Object.assign({}, consider, options);
        if (!str || typeof str !== "string")
          return str;
        let trimmedStr = str.trim();
        if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
          return str;
        else if (options.hex && hexRegex.test(trimmedStr)) {
          return Number.parseInt(trimmedStr, 16);
        } else {
          const match = numRegex.exec(trimmedStr);
          if (match) {
            const sign = match[1];
            const leadingZeros = match[2];
            let numTrimmedByZeros = trimZeros(match[3]);
            const eNotation = match[4] || match[6];
            if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".")
              return str;
            else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".")
              return str;
            else {
              const num = Number(trimmedStr);
              const numStr = "" + num;
              if (numStr.search(/[eE]/) !== -1) {
                if (options.eNotation)
                  return num;
                else
                  return str;
              } else if (eNotation) {
                if (options.eNotation)
                  return num;
                else
                  return str;
              } else if (trimmedStr.indexOf(".") !== -1) {
                if (numStr === "0" && numTrimmedByZeros === "")
                  return num;
                else if (numStr === numTrimmedByZeros)
                  return num;
                else if (sign && numStr === "-" + numTrimmedByZeros)
                  return num;
                else
                  return str;
              }
              if (leadingZeros) {
                if (numTrimmedByZeros === numStr)
                  return num;
                else if (sign + numTrimmedByZeros === numStr)
                  return num;
                else
                  return str;
              }
              if (trimmedStr === numStr)
                return num;
              else if (trimmedStr === sign + numStr)
                return num;
              return str;
            }
          } else {
            return str;
          }
        }
      }
      function trimZeros(numStr) {
        if (numStr && numStr.indexOf(".") !== -1) {
          numStr = numStr.replace(/0+$/, "");
          if (numStr === ".")
            numStr = "0";
          else if (numStr[0] === ".")
            numStr = "0" + numStr;
          else if (numStr[numStr.length - 1] === ".")
            numStr = numStr.substr(0, numStr.length - 1);
          return numStr;
        }
        return numStr;
      }
      module.exports = toNumber;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
  var require_OrderedObjParser = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module) {
      "use strict";
      var util = require_util();
      var xmlNode = require_xmlNode();
      var readDocType = require_DocTypeReader();
      var toNumber = require_strnum();
      var regx = "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, util.nameRegexp);
      var OrderedObjParser = class {
        constructor(options) {
          this.options = options;
          this.currentNode = null;
          this.tagsNodeStack = [];
          this.docTypeEntities = {};
          this.lastEntities = {
            "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
            "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
            "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
            "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
          };
          this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
          this.htmlEntities = {
            "space": { regex: /&(nbsp|#160);/g, val: " " },
            "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
            "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
            "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
            "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
            "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
            "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
            "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" }
          };
          this.addExternalEntities = addExternalEntities;
          this.parseXml = parseXml;
          this.parseTextData = parseTextData;
          this.resolveNameSpace = resolveNameSpace;
          this.buildAttributesMap = buildAttributesMap;
          this.isItStopNode = isItStopNode;
          this.replaceEntitiesValue = replaceEntitiesValue;
          this.readStopNodeData = readStopNodeData;
          this.saveTextToParentTag = saveTextToParentTag;
          this.addChild = addChild;
        }
      };
      function addExternalEntities(externalEntities) {
        const entKeys = Object.keys(externalEntities);
        for (let i = 0; i < entKeys.length; i++) {
          const ent = entKeys[i];
          this.lastEntities[ent] = {
            regex: new RegExp("&" + ent + ";", "g"),
            val: externalEntities[ent]
          };
        }
      }
      function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
        if (val2 !== void 0) {
          if (this.options.trimValues && !dontTrim) {
            val2 = val2.trim();
          }
          if (val2.length > 0) {
            if (!escapeEntities)
              val2 = this.replaceEntitiesValue(val2);
            const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
            if (newval === null || newval === void 0) {
              return val2;
            } else if (typeof newval !== typeof val2 || newval !== val2) {
              return newval;
            } else if (this.options.trimValues) {
              return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              const trimmedVal = val2.trim();
              if (trimmedVal === val2) {
                return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
              } else {
                return val2;
              }
            }
          }
        }
      }
      function resolveNameSpace(tagname) {
        if (this.options.removeNSPrefix) {
          const tags = tagname.split(":");
          const prefix = tagname.charAt(0) === "/" ? "/" : "";
          if (tags[0] === "xmlns") {
            return "";
          }
          if (tags.length === 2) {
            tagname = prefix + tags[1];
          }
        }
        return tagname;
      }
      var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
      function buildAttributesMap(attrStr, jPath, tagName) {
        if (!this.options.ignoreAttributes && typeof attrStr === "string") {
          const matches = util.getAllMatches(attrStr, attrsRegx);
          const len = matches.length;
          const attrs = {};
          for (let i = 0; i < len; i++) {
            const attrName = this.resolveNameSpace(matches[i][1]);
            let oldVal = matches[i][4];
            let aName = this.options.attributeNamePrefix + attrName;
            if (attrName.length) {
              if (this.options.transformAttributeName) {
                aName = this.options.transformAttributeName(aName);
              }
              if (aName === "__proto__")
                aName = "#__proto__";
              if (oldVal !== void 0) {
                if (this.options.trimValues) {
                  oldVal = oldVal.trim();
                }
                oldVal = this.replaceEntitiesValue(oldVal);
                const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
                if (newVal === null || newVal === void 0) {
                  attrs[aName] = oldVal;
                } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                  attrs[aName] = newVal;
                } else {
                  attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);
                }
              } else if (this.options.allowBooleanAttributes) {
                attrs[aName] = true;
              }
            }
          }
          if (!Object.keys(attrs).length) {
            return;
          }
          if (this.options.attributesGroupName) {
            const attrCollection = {};
            attrCollection[this.options.attributesGroupName] = attrs;
            return attrCollection;
          }
          return attrs;
        }
      }
      var parseXml = function(xmlData) {
        xmlData = xmlData.replace(/\r\n?/g, "\n");
        const xmlObj = new xmlNode("!xml");
        let currentNode = xmlObj;
        let textData = "";
        let jPath = "";
        for (let i = 0; i < xmlData.length; i++) {
          const ch = xmlData[i];
          if (ch === "<") {
            if (xmlData[i + 1] === "/") {
              const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
              let tagName = xmlData.substring(i + 2, closeIndex).trim();
              if (this.options.removeNSPrefix) {
                const colonIndex = tagName.indexOf(":");
                if (colonIndex !== -1) {
                  tagName = tagName.substr(colonIndex + 1);
                }
              }
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              if (currentNode) {
                textData = this.saveTextToParentTag(textData, currentNode, jPath);
              }
              const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
              if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
                throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
              }
              let propIndex = 0;
              if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
                propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
                this.tagsNodeStack.pop();
              } else {
                propIndex = jPath.lastIndexOf(".");
              }
              jPath = jPath.substring(0, propIndex);
              currentNode = this.tagsNodeStack.pop();
              textData = "";
              i = closeIndex;
            } else if (xmlData[i + 1] === "?") {
              let tagData = readTagExp(xmlData, i, false, "?>");
              if (!tagData)
                throw new Error("Pi Tag is not closed.");
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
              } else {
                const childNode = new xmlNode(tagData.tagName);
                childNode.add(this.options.textNodeName, "");
                if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
                }
                this.addChild(currentNode, childNode, jPath);
              }
              i = tagData.closeIndex + 1;
            } else if (xmlData.substr(i + 1, 3) === "!--") {
              const endIndex = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
              if (this.options.commentPropName) {
                const comment = xmlData.substring(i + 4, endIndex - 2);
                textData = this.saveTextToParentTag(textData, currentNode, jPath);
                currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
              }
              i = endIndex;
            } else if (xmlData.substr(i + 1, 2) === "!D") {
              const result = readDocType(xmlData, i);
              this.docTypeEntities = result.entities;
              i = result.i;
            } else if (xmlData.substr(i + 1, 2) === "![") {
              const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
              const tagExp = xmlData.substring(i + 9, closeIndex);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              if (this.options.cdataPropName) {
                currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
              } else {
                let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
                if (val2 == void 0)
                  val2 = "";
                currentNode.add(this.options.textNodeName, val2);
              }
              i = closeIndex + 2;
            } else {
              let result = readTagExp(xmlData, i, this.options.removeNSPrefix);
              let tagName = result.tagName;
              let tagExp = result.tagExp;
              let attrExpPresent = result.attrExpPresent;
              let closeIndex = result.closeIndex;
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              if (currentNode && textData) {
                if (currentNode.tagname !== "!xml") {
                  textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
                }
              }
              const lastTag = currentNode;
              if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
                currentNode = this.tagsNodeStack.pop();
                jPath = jPath.substring(0, jPath.lastIndexOf("."));
              }
              if (tagName !== xmlObj.tagname) {
                jPath += jPath ? "." + tagName : tagName;
              }
              if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
                let tagContent = "";
                if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                  i = result.closeIndex;
                } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                  i = result.closeIndex;
                } else {
                  const result2 = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
                  if (!result2)
                    throw new Error(`Unexpected end of ${tagName}`);
                  i = result2.i;
                  tagContent = result2.tagContent;
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                if (tagContent) {
                  tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
                }
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
                childNode.add(this.options.textNodeName, tagContent);
                this.addChild(currentNode, childNode, jPath);
              } else {
                if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                  if (tagName[tagName.length - 1] === "/") {
                    tagName = tagName.substr(0, tagName.length - 1);
                    tagExp = tagName;
                  } else {
                    tagExp = tagExp.substr(0, tagExp.length - 1);
                  }
                  if (this.options.transformTagName) {
                    tagName = this.options.transformTagName(tagName);
                  }
                  const childNode = new xmlNode(tagName);
                  if (tagName !== tagExp && attrExpPresent) {
                    childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                  }
                  this.addChild(currentNode, childNode, jPath);
                  jPath = jPath.substr(0, jPath.lastIndexOf("."));
                } else {
                  const childNode = new xmlNode(tagName);
                  this.tagsNodeStack.push(currentNode);
                  if (tagName !== tagExp && attrExpPresent) {
                    childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                  }
                  this.addChild(currentNode, childNode, jPath);
                  currentNode = childNode;
                }
                textData = "";
                i = closeIndex;
              }
            }
          } else {
            textData += xmlData[i];
          }
        }
        return xmlObj.child;
      };
      function addChild(currentNode, childNode, jPath) {
        const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
        if (result === false) {
        } else if (typeof result === "string") {
          childNode.tagname = result;
          currentNode.addChild(childNode);
        } else {
          currentNode.addChild(childNode);
        }
      }
      var replaceEntitiesValue = function(val2) {
        if (this.options.processEntities) {
          for (let entityName2 in this.docTypeEntities) {
            const entity = this.docTypeEntities[entityName2];
            val2 = val2.replace(entity.regx, entity.val);
          }
          for (let entityName2 in this.lastEntities) {
            const entity = this.lastEntities[entityName2];
            val2 = val2.replace(entity.regex, entity.val);
          }
          if (this.options.htmlEntities) {
            for (let entityName2 in this.htmlEntities) {
              const entity = this.htmlEntities[entityName2];
              val2 = val2.replace(entity.regex, entity.val);
            }
          }
          val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
        }
        return val2;
      };
      function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
        if (textData) {
          if (isLeafNode === void 0)
            isLeafNode = Object.keys(currentNode.child).length === 0;
          textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false, isLeafNode);
          if (textData !== void 0 && textData !== "")
            currentNode.add(this.options.textNodeName, textData);
          textData = "";
        }
        return textData;
      }
      function isItStopNode(stopNodes, jPath, currentTagName) {
        const allNodesExp = "*." + currentTagName;
        for (const stopNodePath in stopNodes) {
          const stopNodeExp = stopNodes[stopNodePath];
          if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
            return true;
        }
        return false;
      }
      function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
        let attrBoundary;
        let tagExp = "";
        for (let index = i; index < xmlData.length; index++) {
          let ch = xmlData[index];
          if (attrBoundary) {
            if (ch === attrBoundary)
              attrBoundary = "";
          } else if (ch === '"' || ch === "'") {
            attrBoundary = ch;
          } else if (ch === closingChar[0]) {
            if (closingChar[1]) {
              if (xmlData[index + 1] === closingChar[1]) {
                return {
                  data: tagExp,
                  index
                };
              }
            } else {
              return {
                data: tagExp,
                index
              };
            }
          } else if (ch === "	") {
            ch = " ";
          }
          tagExp += ch;
        }
      }
      function findClosingIndex(xmlData, str, i, errMsg) {
        const closingIndex = xmlData.indexOf(str, i);
        if (closingIndex === -1) {
          throw new Error(errMsg);
        } else {
          return closingIndex + str.length - 1;
        }
      }
      function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
        const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
        if (!result)
          return;
        let tagExp = result.data;
        const closeIndex = result.index;
        const separatorIndex = tagExp.search(/\s/);
        let tagName = tagExp;
        let attrExpPresent = true;
        if (separatorIndex !== -1) {
          tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, "");
          tagExp = tagExp.substr(separatorIndex + 1);
        }
        if (removeNSPrefix) {
          const colonIndex = tagName.indexOf(":");
          if (colonIndex !== -1) {
            tagName = tagName.substr(colonIndex + 1);
            attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
          }
        }
        return {
          tagName,
          tagExp,
          closeIndex,
          attrExpPresent
        };
      }
      function readStopNodeData(xmlData, tagName, i) {
        const startIndex = i;
        let openTagCount = 1;
        for (; i < xmlData.length; i++) {
          if (xmlData[i] === "<") {
            if (xmlData[i + 1] === "/") {
              const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
              let closeTagName = xmlData.substring(i + 2, closeIndex).trim();
              if (closeTagName === tagName) {
                openTagCount--;
                if (openTagCount === 0) {
                  return {
                    tagContent: xmlData.substring(startIndex, i),
                    i: closeIndex
                  };
                }
              }
              i = closeIndex;
            } else if (xmlData[i + 1] === "?") {
              const closeIndex = findClosingIndex(xmlData, "?>", i + 1, "StopNode is not closed.");
              i = closeIndex;
            } else if (xmlData.substr(i + 1, 3) === "!--") {
              const closeIndex = findClosingIndex(xmlData, "-->", i + 3, "StopNode is not closed.");
              i = closeIndex;
            } else if (xmlData.substr(i + 1, 2) === "![") {
              const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
              i = closeIndex;
            } else {
              const tagData = readTagExp(xmlData, i, ">");
              if (tagData) {
                const openTagName = tagData && tagData.tagName;
                if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                  openTagCount++;
                }
                i = tagData.closeIndex;
              }
            }
          }
        }
      }
      function parseValue(val2, shouldParse, options) {
        if (shouldParse && typeof val2 === "string") {
          const newval = val2.trim();
          if (newval === "true")
            return true;
          else if (newval === "false")
            return false;
          else
            return toNumber(val2, options);
        } else {
          if (util.isExist(val2)) {
            return val2;
          } else {
            return "";
          }
        }
      }
      module.exports = OrderedObjParser;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/node2json.js
  var require_node2json = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
      "use strict";
      function prettify(node, options) {
        return compress(node, options);
      }
      function compress(arr, options, jPath) {
        let text;
        const compressedObj = {};
        for (let i = 0; i < arr.length; i++) {
          const tagObj = arr[i];
          const property = propName(tagObj);
          let newJpath = "";
          if (jPath === void 0)
            newJpath = property;
          else
            newJpath = jPath + "." + property;
          if (property === options.textNodeName) {
            if (text === void 0)
              text = tagObj[property];
            else
              text += "" + tagObj[property];
          } else if (property === void 0) {
            continue;
          } else if (tagObj[property]) {
            let val2 = compress(tagObj[property], options, newJpath);
            const isLeaf = isLeafTag(val2, options);
            if (tagObj[":@"]) {
              assignAttributes(val2, tagObj[":@"], newJpath, options);
            } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
              val2 = val2[options.textNodeName];
            } else if (Object.keys(val2).length === 0) {
              if (options.alwaysCreateTextNode)
                val2[options.textNodeName] = "";
              else
                val2 = "";
            }
            if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
              if (!Array.isArray(compressedObj[property])) {
                compressedObj[property] = [compressedObj[property]];
              }
              compressedObj[property].push(val2);
            } else {
              if (options.isArray(property, newJpath, isLeaf)) {
                compressedObj[property] = [val2];
              } else {
                compressedObj[property] = val2;
              }
            }
          }
        }
        if (typeof text === "string") {
          if (text.length > 0)
            compressedObj[options.textNodeName] = text;
        } else if (text !== void 0)
          compressedObj[options.textNodeName] = text;
        return compressedObj;
      }
      function propName(obj) {
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          if (key !== ":@")
            return key;
        }
      }
      function assignAttributes(obj, attrMap, jpath, options) {
        if (attrMap) {
          const keys = Object.keys(attrMap);
          const len = keys.length;
          for (let i = 0; i < len; i++) {
            const atrrName = keys[i];
            if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
              obj[atrrName] = [attrMap[atrrName]];
            } else {
              obj[atrrName] = attrMap[atrrName];
            }
          }
        }
      }
      function isLeafTag(obj, options) {
        const { textNodeName } = options;
        const propCount = Object.keys(obj).length;
        if (propCount === 0) {
          return true;
        }
        if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
          return true;
        }
        return false;
      }
      exports.prettify = prettify;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
  var require_XMLParser = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module) {
      var { buildOptions } = require_OptionsBuilder();
      var OrderedObjParser = require_OrderedObjParser();
      var { prettify } = require_node2json();
      var validator = require_validator();
      var XMLParser = class {
        constructor(options) {
          this.externalEntities = {};
          this.options = buildOptions(options);
        }
        parse(xmlData, validationOption) {
          if (typeof xmlData === "string") {
          } else if (xmlData.toString) {
            xmlData = xmlData.toString();
          } else {
            throw new Error("XML data is accepted in String or Bytes[] form.");
          }
          if (validationOption) {
            if (validationOption === true)
              validationOption = {};
            const result = validator.validate(xmlData, validationOption);
            if (result !== true) {
              throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
            }
          }
          const orderedObjParser = new OrderedObjParser(this.options);
          orderedObjParser.addExternalEntities(this.externalEntities);
          const orderedResult = orderedObjParser.parseXml(xmlData);
          if (this.options.preserveOrder || orderedResult === void 0)
            return orderedResult;
          else
            return prettify(orderedResult, this.options);
        }
        addEntity(key, value) {
          if (value.indexOf("&") !== -1) {
            throw new Error("Entity value can't have '&'");
          } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
          } else if (value === "&") {
            throw new Error("An entity with value '&' is not permitted");
          } else {
            this.externalEntities[key] = value;
          }
        }
      };
      module.exports = XMLParser;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
  var require_orderedJs2Xml = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module) {
      var EOL = "\n";
      function toXml(jArray, options) {
        let indentation = "";
        if (options.format && options.indentBy.length > 0) {
          indentation = EOL;
        }
        return arrToStr(jArray, options, "", indentation);
      }
      function arrToStr(arr, options, jPath, indentation) {
        let xmlStr = "";
        let isPreviousElementTag = false;
        for (let i = 0; i < arr.length; i++) {
          const tagObj = arr[i];
          const tagName = propName(tagObj);
          let newJPath = "";
          if (jPath.length === 0)
            newJPath = tagName;
          else
            newJPath = `${jPath}.${tagName}`;
          if (tagName === options.textNodeName) {
            let tagText = tagObj[tagName];
            if (!isStopNode(newJPath, options)) {
              tagText = options.tagValueProcessor(tagName, tagText);
              tagText = replaceEntitiesValue(tagText, options);
            }
            if (isPreviousElementTag) {
              xmlStr += indentation;
            }
            xmlStr += tagText;
            isPreviousElementTag = false;
            continue;
          } else if (tagName === options.cdataPropName) {
            if (isPreviousElementTag) {
              xmlStr += indentation;
            }
            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
            isPreviousElementTag = false;
            continue;
          } else if (tagName === options.commentPropName) {
            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
            isPreviousElementTag = true;
            continue;
          } else if (tagName[0] === "?") {
            const attStr2 = attr_to_str(tagObj[":@"], options);
            const tempInd = tagName === "?xml" ? "" : indentation;
            let piTextNodeName = tagObj[tagName][0][options.textNodeName];
            piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
            isPreviousElementTag = true;
            continue;
          }
          let newIdentation = indentation;
          if (newIdentation !== "") {
            newIdentation += options.indentBy;
          }
          const attStr = attr_to_str(tagObj[":@"], options);
          const tagStart = indentation + `<${tagName}${attStr}`;
          const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
          if (options.unpairedTags.indexOf(tagName) !== -1) {
            if (options.suppressUnpairedNode)
              xmlStr += tagStart + ">";
            else
              xmlStr += tagStart + "/>";
          } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
            xmlStr += tagStart + "/>";
          } else if (tagValue && tagValue.endsWith(">")) {
            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
          } else {
            xmlStr += tagStart + ">";
            if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
              xmlStr += indentation + options.indentBy + tagValue + indentation;
            } else {
              xmlStr += tagValue;
            }
            xmlStr += `</${tagName}>`;
          }
          isPreviousElementTag = true;
        }
        return xmlStr;
      }
      function propName(obj) {
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          if (key !== ":@")
            return key;
        }
      }
      function attr_to_str(attrMap, options) {
        let attrStr = "";
        if (attrMap && !options.ignoreAttributes) {
          for (let attr in attrMap) {
            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
            attrVal = replaceEntitiesValue(attrVal, options);
            if (attrVal === true && options.suppressBooleanAttributes) {
              attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
            } else {
              attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
            }
          }
        }
        return attrStr;
      }
      function isStopNode(jPath, options) {
        jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
        let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
        for (let index in options.stopNodes) {
          if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
            return true;
        }
        return false;
      }
      function replaceEntitiesValue(textValue, options) {
        if (textValue && textValue.length > 0 && options.processEntities) {
          for (let i = 0; i < options.entities.length; i++) {
            const entity = options.entities[i];
            textValue = textValue.replace(entity.regex, entity.val);
          }
        }
        return textValue;
      }
      module.exports = toXml;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
  var require_json2xml = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module) {
      "use strict";
      var buildFromOrderedJs = require_orderedJs2Xml();
      var defaultOptions = {
        attributeNamePrefix: "@_",
        attributesGroupName: false,
        textNodeName: "#text",
        ignoreAttributes: true,
        cdataPropName: false,
        format: false,
        indentBy: "  ",
        suppressEmptyNode: false,
        suppressUnpairedNode: true,
        suppressBooleanAttributes: true,
        tagValueProcessor: function(key, a) {
          return a;
        },
        attributeValueProcessor: function(attrName, a) {
          return a;
        },
        preserveOrder: false,
        commentPropName: false,
        unpairedTags: [],
        entities: [
          { regex: new RegExp("&", "g"), val: "&amp;" },
          { regex: new RegExp(">", "g"), val: "&gt;" },
          { regex: new RegExp("<", "g"), val: "&lt;" },
          { regex: new RegExp("'", "g"), val: "&apos;" },
          { regex: new RegExp('"', "g"), val: "&quot;" }
        ],
        processEntities: true,
        stopNodes: [],
        oneListGroup: false
      };
      function Builder(options) {
        this.options = Object.assign({}, defaultOptions, options);
        if (this.options.ignoreAttributes || this.options.attributesGroupName) {
          this.isAttribute = function() {
            return false;
          };
        } else {
          this.attrPrefixLen = this.options.attributeNamePrefix.length;
          this.isAttribute = isAttribute;
        }
        this.processTextOrObjNode = processTextOrObjNode;
        if (this.options.format) {
          this.indentate = indentate;
          this.tagEndChar = ">\n";
          this.newLine = "\n";
        } else {
          this.indentate = function() {
            return "";
          };
          this.tagEndChar = ">";
          this.newLine = "";
        }
      }
      Builder.prototype.build = function(jObj) {
        if (this.options.preserveOrder) {
          return buildFromOrderedJs(jObj, this.options);
        } else {
          if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
            jObj = {
              [this.options.arrayNodeName]: jObj
            };
          }
          return this.j2x(jObj, 0).val;
        }
      };
      Builder.prototype.j2x = function(jObj, level) {
        let attrStr = "";
        let val2 = "";
        for (let key in jObj) {
          if (typeof jObj[key] === "undefined") {
          } else if (jObj[key] === null) {
            if (key[0] === "?")
              val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
            else
              val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          } else if (jObj[key] instanceof Date) {
            val2 += this.buildTextValNode(jObj[key], key, "", level);
          } else if (typeof jObj[key] !== "object") {
            const attr = this.isAttribute(key);
            if (attr) {
              attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
            } else {
              if (key === this.options.textNodeName) {
                let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
                val2 += this.replaceEntitiesValue(newval);
              } else {
                val2 += this.buildTextValNode(jObj[key], key, "", level);
              }
            }
          } else if (Array.isArray(jObj[key])) {
            const arrLen = jObj[key].length;
            let listTagVal = "";
            for (let j = 0; j < arrLen; j++) {
              const item = jObj[key][j];
              if (typeof item === "undefined") {
              } else if (item === null) {
                if (key[0] === "?")
                  val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
                else
                  val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
              } else if (typeof item === "object") {
                if (this.options.oneListGroup) {
                  listTagVal += this.j2x(item, level + 1).val;
                } else {
                  listTagVal += this.processTextOrObjNode(item, key, level);
                }
              } else {
                listTagVal += this.buildTextValNode(item, key, "", level);
              }
            }
            if (this.options.oneListGroup) {
              listTagVal = this.buildObjectNode(listTagVal, key, "", level);
            }
            val2 += listTagVal;
          } else {
            if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
              const Ks = Object.keys(jObj[key]);
              const L = Ks.length;
              for (let j = 0; j < L; j++) {
                attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);
              }
            } else {
              val2 += this.processTextOrObjNode(jObj[key], key, level);
            }
          }
        }
        return { attrStr, val: val2 };
      };
      Builder.prototype.buildAttrPairStr = function(attrName, val2) {
        val2 = this.options.attributeValueProcessor(attrName, "" + val2);
        val2 = this.replaceEntitiesValue(val2);
        if (this.options.suppressBooleanAttributes && val2 === "true") {
          return " " + attrName;
        } else
          return " " + attrName + '="' + val2 + '"';
      };
      function processTextOrObjNode(object, key, level) {
        const result = this.j2x(object, level + 1);
        if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
          return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
        } else {
          return this.buildObjectNode(result.val, key, result.attrStr, level);
        }
      }
      Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {
        if (val2 === "") {
          if (key[0] === "?")
            return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
          else {
            return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
          }
        } else {
          let tagEndExp = "</" + key + this.tagEndChar;
          let piClosingChar = "";
          if (key[0] === "?") {
            piClosingChar = "?";
            tagEndExp = "";
          }
          if (attrStr && val2.indexOf("<") === -1) {
            return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
          } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
            return this.indentate(level) + `<!--${val2}-->` + this.newLine;
          } else {
            return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
          }
        }
      };
      Builder.prototype.closeTag = function(key) {
        let closeTag = "";
        if (this.options.unpairedTags.indexOf(key) !== -1) {
          if (!this.options.suppressUnpairedNode)
            closeTag = "/";
        } else if (this.options.suppressEmptyNode) {
          closeTag = "/";
        } else {
          closeTag = `></${key}`;
        }
        return closeTag;
      };
      Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {
        if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
          return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
          return this.indentate(level) + `<!--${val2}-->` + this.newLine;
        } else if (key[0] === "?") {
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        } else {
          let textValue = this.options.tagValueProcessor(key, val2);
          textValue = this.replaceEntitiesValue(textValue);
          if (textValue === "") {
            return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
          } else {
            return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
          }
        }
      };
      Builder.prototype.replaceEntitiesValue = function(textValue) {
        if (textValue && textValue.length > 0 && this.options.processEntities) {
          for (let i = 0; i < this.options.entities.length; i++) {
            const entity = this.options.entities[i];
            textValue = textValue.replace(entity.regex, entity.val);
          }
        }
        return textValue;
      };
      function indentate(level) {
        return this.options.indentBy.repeat(level);
      }
      function isAttribute(name) {
        if (name.startsWith(this.options.attributeNamePrefix)) {
          return name.substr(this.attrPrefixLen);
        } else {
          return false;
        }
      }
      module.exports = Builder;
    }
  });

  // ../../node_modules/fast-xml-parser/src/fxp.js
  var require_fxp = __commonJS({
    "../../node_modules/fast-xml-parser/src/fxp.js"(exports, module) {
      "use strict";
      var validator = require_validator();
      var XMLParser = require_XMLParser();
      var XMLBuilder = require_json2xml();
      module.exports = {
        XMLParser,
        XMLValidator: validator,
        XMLBuilder
      };
    }
  });

  // src/lib/parsers/parse-xml.ts
  function fastParseXML(text, options) {
    const parser = new import_fast_xml_parser.XMLParser({
      ignoreAttributes: false,
      attributeNamePrefix: "",
      ...options
    });
    const parsedXML = parser.parse(text);
    return parsedXML;
  }
  var import_fast_xml_parser;
  var init_parse_xml = __esm({
    "src/lib/parsers/parse-xml.ts"() {
      import_fast_xml_parser = __toModule(require_fxp());
    }
  });

  // src/lib/xml-utils/uncapitalize.ts
  function uncapitalize(str) {
    return typeof str === "string" ? str.charAt(0).toLowerCase() + str.slice(1) : str;
  }
  function uncapitalizeKeys(object) {
    if (Array.isArray(object)) {
      return object.map((element) => uncapitalizeKeys(element));
    }
    if (object && typeof object === "object") {
      const newObject = {};
      for (const [key, value] of Object.entries(object)) {
        newObject[uncapitalize(key)] = uncapitalizeKeys(value);
      }
      return newObject;
    }
    return object;
  }
  var init_uncapitalize = __esm({
    "src/lib/xml-utils/uncapitalize.ts"() {
    }
  });

  // src/xml-loader.ts
  function testXMLFile(text) {
    return text.startsWith("<?xml");
  }
  function parseTextSync(text, options) {
    const xmlOptions = { ...XMLLoader.options.xml, ...options?.xml };
    switch (xmlOptions.parser) {
      case "fast-xml-parser":
        const fastXMLOptions = {
          allowBooleanAttributes: true,
          ignoreDeclaration: true,
          removeNSPrefix: xmlOptions.removeNSPrefix,
          textNodeName: xmlOptions.textNodeName,
          isArray: (name, jpath, isLeafNode, isAttribute) => {
            const array = Boolean(xmlOptions?.arrayPaths?.some((path) => jpath === path));
            return array;
          },
          ...options?._fastXML
        };
        const xml = fastParseXML(text, fastXMLOptions);
        return xmlOptions.uncapitalizeKeys ? uncapitalizeKeys(xml) : xml;
      default:
        throw new Error(options?.xml?.parser);
    }
  }
  var VERSION, XMLLoader;
  var init_xml_loader = __esm({
    "src/xml-loader.ts"() {
      init_parse_xml();
      init_uncapitalize();
      VERSION = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
      XMLLoader = {
        name: "XML",
        id: "xml",
        module: "xml",
        version: VERSION,
        worker: false,
        extensions: ["xml"],
        mimeTypes: ["application/xml", "text/xml"],
        testText: testXMLFile,
        options: {
          xml: {
            parser: "fast-xml-parser",
            uncapitalizeKeys: false,
            removeNSPrefix: false,
            textNodeName: "value",
            arrayPaths: []
          }
        },
        parse: async (arrayBuffer, options) => parseTextSync(new TextDecoder().decode(arrayBuffer), options),
        parseTextSync: (text, options) => parseTextSync(text, options)
      };
    }
  });

  // ../loader-utils/src/lib/option-utils/merge-loader-options.ts
  function mergeLoaderOptions(baseOptions, newOptions) {
    const options = { ...baseOptions };
    for (const [key, newValue] of Object.entries(newOptions)) {
      if (newValue && typeof newValue === "object") {
        options[key] = options[key] || {};
        Object.assign(options[key], newOptions[key]);
      } else {
        options[key] = newOptions[key];
      }
    }
    return options;
  }
  var init_merge_loader_options = __esm({
    "../loader-utils/src/lib/option-utils/merge-loader-options.ts"() {
    }
  });

  // ../loader-utils/src/index.ts
  var init_src = __esm({
    "../loader-utils/src/index.ts"() {
      init_merge_loader_options();
    }
  });

  // src/html-loader.ts
  function testHTMLFile(text) {
    return text.startsWith("<html");
  }
  function parseTextSync2(text, options) {
    options = mergeLoaderOptions(options, {
      xml: {
        parser: "fast-xml-parser"
      },
      _fastXML: {
        htmlEntities: true
      }
    });
    return XMLLoader.parseTextSync(text, options);
  }
  var HTMLLoader;
  var init_html_loader = __esm({
    "src/html-loader.ts"() {
      init_src();
      init_xml_loader();
      HTMLLoader = {
        ...XMLLoader,
        name: "HTML",
        id: "html",
        extensions: ["html", "htm"],
        mimeTypes: ["text/html"],
        testText: testHTMLFile,
        parse: async (arrayBuffer, options) => parseTextSync2(new TextDecoder().decode(arrayBuffer), options),
        parseTextSync: (text, options) => parseTextSync2(text, options)
      };
    }
  });

  // src/lib/xml-utils/xml-utils.ts
  function convertXMLValueToArray(xmlValue) {
    if (Array.isArray(xmlValue)) {
      return xmlValue;
    }
    if (xmlValue && typeof xmlValue === "object" && xmlValue["0"]) {
    }
    if (xmlValue) {
      return [xmlValue];
    }
    return [];
  }
  function convertXMLFieldToArrayInPlace(xml, key) {
    xml[key] = convertXMLValueToArray(xml[key]);
  }
  var init_xml_utils = __esm({
    "src/lib/xml-utils/xml-utils.ts"() {
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    HTMLLoader: () => HTMLLoader,
    SAXParser: () => SAXParser,
    XMLLoader: () => XMLLoader,
    _uncapitalize: () => uncapitalize,
    _uncapitalizeKeys: () => uncapitalizeKeys,
    convertXMLFieldToArrayInPlace: () => convertXMLFieldToArrayInPlace,
    convertXMLValueToArray: () => convertXMLValueToArray
  });
  var init_src2 = __esm({
    "src/index.ts"() {
      init_xml_loader();
      init_html_loader();
      init_sax();
      init_xml_utils();
      init_uncapitalize();
    }
  });

  // src/bundle.ts
  var require_bundle = __commonJS({
    "src/bundle.ts"(exports, module) {
      var moduleExports = (init_src2(), src_exports);
      globalThis.loaders = globalThis.loaders || {};
      module.exports = Object.assign(globalThis.loaders, moduleExports);
    }
  });
  require_bundle();
})();
