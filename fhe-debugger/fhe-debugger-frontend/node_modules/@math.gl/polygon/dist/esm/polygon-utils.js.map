{"version":3,"sources":["../../src/polygon-utils.ts"],"names":["equals","WINDING","CLOCKWISE","COUNTER_CLOCKWISE","modifyPolygonWindingDirection","points","direction","options","windingDirection","getPolygonWindingDirection","reversePolygon","Math","sign","getPolygonSignedArea","start","end","length","dim","size","area","i","j","forEachSegmentInPolygon","visitor","isClosed","numPoints","endPointIndex","isClosedEx","numSwaps","floor","b1","b2","tmp","modifyPolygonWindingDirectionPoints","currentDirection","getPolygonWindingDirectionPoints","reverse","getPolygonSignedAreaPoints","forEachSegmentInPolygonPoints"],"mappings":"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","sourcesContent":["/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */\n\nimport {equals} from '@math.gl/core';\nimport type {NumericArray} from '@math.gl/core';\n\nexport const WINDING = {\n  CLOCKWISE: 1,\n  COUNTER_CLOCKWISE: -1\n} as const;\n\n/** Polygon representation where each point is represented as a separate array of positions. */\ntype PointsArray = NumericArray[];\n\n/** Segment visitor callback type for polygons defined with flat arrays, */\ntype SegmentVisitorFlat = (\n  p1x: number,\n  p1y: number,\n  p2x: number,\n  p2y: number,\n  i1: number,\n  i2: number\n) => void;\n\n/** Segment visitor callback type for polygons defined with array of points. */\nexport type SegmentVisitorPoints = (\n  p1: NumericArray,\n  p2: NumericArray,\n  i1: number,\n  i2: number\n) => void;\n\n/** Parameters of a polygon. */\ntype PolygonParams = {\n  start?: number; // Start index of the polygon in the array of positions. Defaults to 0.\n  end?: number; // End index of the polygon in the array of positions. Defaults to number of positions.\n  size?: number; // Size of a point, 2 (XZ) or 3 (XYZ). Defaults to 2. Affects only polygons stored in flat arrays.\n  isClosed?: boolean; // Indicates that the first point of the polygon is equal to the last point, and additional checks should be ommited.\n};\n\n/**\n * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n * Note: points are modified in-place.\n * @param points An array that represents points of the polygon.\n * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n * @param options Parameters of the polygon.\n * @return Returns true if the winding direction was changed.\n */\nexport function modifyPolygonWindingDirection(\n  points: NumericArray,\n  direction: number,\n  options: PolygonParams = {}\n): boolean {\n  const windingDirection = getPolygonWindingDirection(points, options);\n  if (windingDirection !== direction) {\n    reversePolygon(points, options);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns winding direction of the polygon.\n * @param points An array that represents points of the polygon.\n * @param options Parameters of the polygon.\n * @returns Winding direction of the polygon.\n */\nexport function getPolygonWindingDirection(\n  points: NumericArray,\n  options: PolygonParams = {}\n): number {\n  return Math.sign(getPolygonSignedArea(points, options));\n}\n\n/**\n * Returns signed area of the polygon.\n * @param points An array that represents points of the polygon.\n * @param options Parameters of the polygon.\n * @returns Signed area of the polygon.\n * https://en.wikipedia.org/wiki/Shoelace_formula\n */\nexport function getPolygonSignedArea(points: NumericArray, options: PolygonParams = {}): number {\n  const {start = 0, end = points.length} = options;\n  const dim = options.size || 2;\n  let area = 0;\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    area += (points[i] - points[j]) * (points[i + 1] + points[j + 1]);\n    j = i;\n  }\n  return area / 2;\n}\n\n/**\n * Calls the visitor callback for each segment in the polygon.\n * @param points An array that represents points of the polygon\n * @param visitor A callback to call for each segment.\n * @param options Parameters of the polygon.\n */\nexport function forEachSegmentInPolygon(\n  points: NumericArray,\n  visitor: SegmentVisitorFlat,\n  options: PolygonParams = {}\n): void {\n  const {start = 0, end = points.length, size = 2, isClosed} = options;\n\n  const numPoints = (end - start) / size;\n  for (let i = 0; i < numPoints - 1; ++i) {\n    visitor(\n      points[start + i * size],\n      points[start + i * size + 1],\n      points[start + (i + 1) * size],\n      points[start + (i + 1) * size + 1],\n      i,\n      i + 1\n    );\n  }\n\n  const endPointIndex = start + (numPoints - 1) * size;\n  const isClosedEx =\n    isClosed ||\n    (equals(points[start], points[endPointIndex]) &&\n      equals(points[start + 1], points[endPointIndex + 1]));\n\n  if (!isClosedEx) {\n    visitor(\n      points[endPointIndex],\n      points[endPointIndex + 1],\n      points[start],\n      points[start + 1],\n      numPoints - 1,\n      0\n    );\n  }\n}\n\nfunction reversePolygon(\n  points: NumericArray,\n  options: {start?: number; end?: number; size?: number}\n): void {\n  const {start = 0, end = points.length, size = 2} = options;\n\n  const numPoints = (end - start) / size;\n  const numSwaps = Math.floor(numPoints / 2);\n  for (let i = 0; i < numSwaps; ++i) {\n    const b1 = start + i * size;\n    const b2 = start + (numPoints - 1 - i) * size;\n    for (let j = 0; j < size; ++j) {\n      const tmp = points[b1 + j];\n      points[b1 + j] = points[b2 + j];\n      points[b2 + j] = tmp;\n    }\n  }\n}\n\n/**\n * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n * Note: points are modified in-place.\n * @param points Array of points that represent the polygon.\n * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n * @param options Parameters of the polygon.\n * @return Returns true if the winding direction was changed.\n */\nexport function modifyPolygonWindingDirectionPoints(\n  points: PointsArray,\n  direction: number,\n  options: PolygonParams = {}\n): boolean {\n  const currentDirection = getPolygonWindingDirectionPoints(points, options);\n  if (currentDirection !== direction) {\n    points.reverse();\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns winding direction of the polygon.\n * @param points Array of points that represent the polygon.\n * @param options Parameters of the polygon.\n * @returns Winding direction of the polygon.\n */\nexport function getPolygonWindingDirectionPoints(\n  points: PointsArray,\n  options: PolygonParams = {}\n): number {\n  return Math.sign(getPolygonSignedAreaPoints(points, options));\n}\n\n/**\n * Returns signed area of the polygon.\n * @param points Array of points that represent the polygon.\n * @param options Parameters of the polygon.\n * @returns Signed area of the polygon.\n */\nexport function getPolygonSignedAreaPoints(\n  points: PointsArray,\n  options: PolygonParams = {}\n): number {\n  // https://en.wikipedia.org/wiki/Shoelace_formula\n  const {start = 0, end = points.length} = options;\n  let area = 0;\n  for (let i = start, j = end - 1; i < end; ++i) {\n    area += (points[i][0] - points[j][0]) * (points[i][1] + points[j][1]);\n    j = i;\n  }\n  return area / 2;\n}\n\n/**\n * Calls visitor callback for each segment in the polygon.\n * @param points Array of points that represent the polygon.\n * @param visitor A callback to call for each segment.\n * @param options Parameters of the polygon.\n */\nexport function forEachSegmentInPolygonPoints(\n  points: PointsArray,\n  visitor: SegmentVisitorPoints,\n  options: PolygonParams = {}\n): void {\n  const {start = 0, end = points.length, isClosed} = options;\n  for (let i = start; i < end - 1; ++i) {\n    visitor(points[i], points[i + 1], i, i + 1);\n  }\n\n  const isClosedEx = isClosed || equals(points[end - 1], points[0]);\n  if (!isClosedEx) {\n    visitor(points[end - 1], points[0], end - 1, 0);\n  }\n}\n"],"file":"polygon-utils.js"}