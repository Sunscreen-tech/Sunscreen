import { GetCrossingsTotal } from './ordering';
export class ConstrainedOrdering {
    constructor(geomGraph, basicIntGraph, layering, nodeIdToIndex, database, settings) {
        this.verticalEdges = new Array();
        this.numberOfLayers = -1;
        this.layersAreDoubled = false;
        throw new Error('not implemented');
        // this.settings = this.settings;
        // this.horizontalConstraints = this.settings.HorizontalConstraints;
        // this.horizontalConstraints.PrepareForOrdering(nodeIdToIndex, layering);
        // this.geometryGraph = geomGraph;
        // this.database = this.database;
        // this.intGraph = basicIntGraph;
        // this.initialLayering = layering;
        // // this has to be changed only to insert layers that are needed
        // if (this.NeedToInsertLayers(layering)) {
        //  for (let i= 0; (i < layering.length); i++) {
        //    layering[i] = (layering[i] * 2);
        //  }
        //  this.LayersAreDoubled = true;
        //  this.numberOfLayers = -1;
        // }
        // this.PrepareProperLayeredGraphAndFillLayerInfos();
        // this.adjSwapper = new AdjacentSwapsWithConstraints(this.LayerArrays, this.HasCrossWeights(), this.ProperLayeredGraph, this.layerInfos);
    }
    get NumberOfLayers() {
        throw new Error('not implemented');
        if (this.numberOfLayers > 0) {
            return this.numberOfLayers;
        }
        return 0;
    }
    NodeSeparation() {
        return this.settings.NodeSeparation;
    }
    get LayersAreDoubled() {
        return this.layersAreDoubled;
    }
    set LayersAreDoubled(value) {
        this.layersAreDoubled = value;
    }
    NeedToInsertLayers(layering) {
        return (ConstrainedOrdering.ExistsShortLabeledEdge(layering, Array.from(this.intGraph.edges)) ||
            ConstrainedOrdering.ExistsShortMultiEdge(layering, this.database.Multiedges));
    }
    static ExistsShortMultiEdge(layering, multiedges) {
        return Array.from(multiedges.keyValues()).some(([k, v]) => v.length > 2 && layering[k.x] === 1 + layering[k.y]);
    }
    // Calculate() {
    //  this.AllocateXPositions();
    //  let originalGraph = (<GeomGraph>(this.intGraph.Nodes[0].GeometryParent));
    //  LayeredLayoutEngine.CalculateAnchorSizes(this.database, TODOOUTthis.database.anchors, this.ProperLayeredGraph, originalGraph, this.intGraph, this.settings);
    //  LayeredLayoutEngine.CalcInitialYAnchorLocations(this.LayerArrays, 500, this.geometryGraph, this.database, this.intGraph, this.settings, this.LayersAreDoubled);
    //  this.Order();
    // }
    CreateMeasure() {
        return GetCrossingsTotal(this.ProperLayeredGraph, this.LayerArrays);
    }
    HasCrossWeights() {
        for (const le of this.ProperLayeredGraph.Edges) {
            if (le.CrossingWeight !== 1)
                return true;
        }
        return false;
    }
    static ExistsShortLabeledEdge(layering, edges) {
        return edges.some((edge) => layering[edge.source] === layering[edge.target] + 1 && edge.edge.label != null);
    }
    AllocateXPositions() {
        this.xPositions = new Array(this.NumberOfLayers);
        for (let i = 0; i < this.NumberOfLayers; i++) {
            this.xPositions[i] = new Array(this.LayerArrays.Layers[i].length);
        }
    }
    Order() {
        throw new Error('not implemented');
        // this.CreateInitialOrderInLayers();
        // this.TryPushingOutStrangersFromHorizontalBlocks();
        // let n= 5;
        // let measure = Number.MAX_SAFE_INTEGER;
        // while (n-- > 0 && this.noGainSteps <= ConstrainedOrdering.MaxNumberOfNoGainSteps) {
        //  this.SetXPositions();
        //  let newMeasure = this.CreateMeasure();
        //  if (newMeasure < measure) {
        //    this.noGainSteps = 0;
        //    const t = { layerArraysCopy: this.yetBestLayers }
        //    Ordering.CloneLayers(this.LayerArrays.Layers, t);
        //    this.yetBestLayers = t.layerArraysCopy
        //    measure = newMeasure;
        //  }
        //  else {
        //    this.noGainSteps++;
        //    this.RestoreState();
        //  }
        // }
    }
    SetXPositions() {
        throw new Error('not implemented');
    }
    // InitSolverWithoutOrder(): ISolverShell {
    //  let solver: ISolverShell = ConstrainedOrdering.CreateSolver();
    //  this.InitSolverVars(solver);
    //  this.PutLeftRightConstraintsIntoSolver(solver);
    //  this.PutVerticalConstraintsIntoSolver(solver);
    //  this.AddGoalsToKeepProperEdgesShort(solver);
    //  this.AddGoalsToKeepFlatEdgesShort(solver);
    //  return solver;
    // }
    // SortLayers(solver: ISolverShell) {
    //  for (let i= 0; (i < this.LayerArrays.Layers.length); i++) {
    //    this.SortLayerBasedOnSolution(this.LayerArrays.Layers[i], solver);
    //  }
    // }
    // AddGoalsToKeepFlatEdgesShort(solver: ISolverShell) {
    //  for (let layerInfo of this.layerInfos) {
    //    ConstrainedOrdering.AddGoalToKeepFlatEdgesShortOnBlockLevel(layerInfo, solver);
    //  }
    // }
    // InitSolverVars(solver: ISolverShell) {
    //  for (let i= 0; (i < this.LayerArrays.y.length); i++) {
    //    solver.AddVariableWithIdealPosition(i, 0);
    //  }
    // }
    // AddGoalsToKeepProperEdgesShort(solver: ISolverShell) {
    //  for (let edge of this.ProperLayeredGraph.edges) {
    //    solver.AddGoalTwoVariablesAreClose(edge.Source, edge.Target, PositionOverBaricenterWeight);
    //  }
    // }
    // PutVerticalConstraintsIntoSolver(solver: ISolverShell) {
    //  for (let pair of this.horizontalConstraints.VerticalInts) {
    //    solver.AddGoalTwoVariablesAreClose(pair.Item1, pair.Item2, ConstrainedVarWeight);
    //  }
    // }
    // PutLeftRightConstraintsIntoSolver(solver: ISolverShell) {
    //  for (let pair of this.horizontalConstraints.LeftRighInts) {
    //    solver.AddLeftRightSeparationConstraint(pair.Item1, pair.Item2, this.SimpleGapBetweenTwoNodes(pair.Item1, pair.Item2));
    //  }
    // }
    // PutLayerNodeSeparationsIntoSolver(solver: ISolverShell) {
    //  for (let layer of this.LayerArrays.Layers) {
    //    for (let i= 0; (i
    //      < (layer.length - 1)); i++) {
    //      let l: number = layer[i];
    //      let r: number = layer[(i + 1)];
    //      solver.AddLeftRightSeparationConstraint(l, r, this.SimpleGapBetweenTwoNodes(l, r));
    //    }
    //  }
    // }
    // ImproveWithAdjacentSwaps() {
    //  this.adjSwapper.DoSwaps();
    // }
    // TryPushingOutStrangersFromHorizontalBlocks() {
    // }
    // CreateInitialOrderInLayers() {
    //  // the idea is to topologically ordering all nodes horizontally, by using vertical components, then fill the layers according to this order
    //  let nodesToVerticalComponentsRoots: Map<number, number> = this.CreateVerticalComponents();
    //  let liftedLeftRightRelations: Array<IntPair> = this.LiftLeftRightRelationsToComponentRoots(nodesToVerticalComponentsRoots).ToArray();
    //  let orderOfVerticalComponentRoots: number[] = TopologicalSort.GetOrderOnEdges(liftedLeftRightRelations);
    //  this.FillLayersWithVerticalComponentsOrder(orderOfVerticalComponentRoots, nodesToVerticalComponentsRoots);
    //  this.LayerArrays.UpdateXFromLayers();
    // }
    // FillLayersWithVerticalComponentsOrder(order: number[], nodesToVerticalComponentsRoots: Map<number, number>) {
    //  let componentRootsToComponents: Map<number, Array<number>> = ConstrainedOrdering.CreateComponentRootsToComponentsMap(nodesToVerticalComponentsRoots);
    //  let alreadyInLayers = new Array(this.LayerArrays.y.length);
    //  let runninglayerCounts = new Array(this.LayerArrays.Layers.length);
    //  for (let vertCompRoot of order) {
    //    this.PutVerticalComponentIntoLayers(this.EnumerateVertComponent(componentRootsToComponents, vertCompRoot), runninglayerCounts, alreadyInLayers);
    //  }
    //  for (let i= 0; (i < this.ProperLayeredGraph.NodeCount); i++) {
    //    if ((alreadyInLayers[i] === false)) {
    //      this.AddVertToLayers(i, runninglayerCounts, alreadyInLayers);
    //    }
    //  }
    // }
    // EnumerateVertComponent(componentRootsToComponents: Map<number, Array<number>>, vertCompRoot: number): Array<number> {
    //  let compList: Array<number>;
    //  if (componentRootsToComponents.TryGetValue(vertCompRoot, TODOOUTcompList)) {
    //    for (let i of compList) {
    //      yield;
    //    }
    //    return i;
    //  }
    //  else {
    //    yield;
    //  }
    //  return vertCompRoot;
    // }
    // PutVerticalComponentIntoLayers(vertComponent: Array<number>, runningLayerCounts: number[], alreadyInLayers: boolean[]) {
    //  for (let i of vertComponent) {
    //    this.AddVertToLayers(i, runningLayerCounts, alreadyInLayers);
    //  }
    // }
    // AddVertToLayers(i: number, runningLayerCounts: number[], alreadyInLayers: boolean[]) {
    //  if (alreadyInLayers[i]) {
    //    return;
    //  }
    //  let layerIndex: number = this.LayerArrays.y[i];
    //  let xIndex: number = runningLayerCounts[layerIndex];
    //  let layer = this.LayerArrays.Layers[layerIndex];
    //  layer[xIndex++] = i;
    //  alreadyInLayers[i] = true;
    //  let block: Array<number>;
    //  if (this.horizontalConstraints.BlockRootToBlock.TryGetValue(i, TODOOUTblock)) {
    //    for (let v of block) {
    //      if (alreadyInLayers[v]) {
    //        continue
    //      }
    //      layer[xIndex++] = v;
    //      alreadyInLayers[v] = true;
    //    }
    //  }
    //  runningLayerCounts[layerIndex] = xIndex;
    // }
    // static CreateComponentRootsToComponentsMap(nodesToVerticalComponentsRoots: Map<number, number>): Map<number, Array<number>> {
    //  let d = new Map<number, Array<number>>();
    //  for (let kv of nodesToVerticalComponentsRoots) {
    //    let i: number = kv.Key;
    //    let root = kv.Value;
    //    let component: Array<number>;
    //    if (!d.TryGetValue(root, TODOOUTcomponent)) {
    //      component = new Array<number>();
    //      d[root] = new Array<number>();
    //    }
    //    component.Add(i);
    //  }
    //  return d;
    // }
    // LiftLeftRightRelationsToComponentRoots(nodesToVerticalComponentsRoots: Map<number, number>): Array<IntPair> {
    //  for (let pair of this.horizontalConstraints.LeftRighInts) {
    //    yield;
    //  }
    //  return new IntPair(ConstrainedOrdering.GetFromDictionaryOrIdentical(nodesToVerticalComponentsRoots, pair.Item1), ConstrainedOrdering.GetFromDictionaryOrIdentical(nodesToVerticalComponentsRoots, pair.Item2));
    //  for (let pair of this.horizontalConstraints.LeftRightIntNeibs) {
    //    yield;
    //  }
    //  return new IntPair(ConstrainedOrdering.GetFromDictionaryOrIdentical(nodesToVerticalComponentsRoots, pair.Item1), ConstrainedOrdering.GetFromDictionaryOrIdentical(nodesToVerticalComponentsRoots, pair.Item2));
    // }
    // static GetFromDictionaryOrIdentical(d: Map<number, number>, key: number): number {
    //  let i: number;
    //  if (d.TryGetValue(key, TODOOUTi)) {
    //    return i;
    //  }
    //  return key;
    // }
    // // These blocks are connected components in the vertical constraints. They don't necesserely span consequent layers.
    //
    // CreateVerticalComponents(): Map<number, number> {
    //  let vertGraph = new BasicGraphOnEdges<PolyIntEdge>(from, pair, in, this.horizontalConstraints.VerticalInts, select, new PolyIntEdge(pair.Item1, pair.Item2));
    //  let verticalComponents = ConnectedComponentCalculator.GetComponents(vertGraph);
    //  let nodesToComponentRoots = new Map<number, number>();
    //  for (let component of verticalComponents) {
    //    let ca = component.ToArray();
    //    if ((ca.length === 1)) {
    //      continue
    //    }
    //    let componentRoot: number = -1;
    //    for (let j of component) {
    //      if ((componentRoot === -1)) {
    //        componentRoot = j;
    //      }
    //      nodesToComponentRoots[j] = componentRoot;
    //    }
    //  }
    //  return nodesToComponentRoots;
    // }
    // RestoreState() {
    //  this.LayerArrays.UpdateLayers(this.yetBestLayers);
    // }
    // Show() {
    //  SugiyamaLayoutSettings.ShowDatabase(this.database);
    // }
    // static PrintPositions(positions: number[]) {
    //  for (let j= 0; (j < positions.length); j++) {
    //    System.Diagnostics.Debug.Write((" " + positions[j]));
    //  }
    //  System.Diagnostics.Debug.WriteLine("");
    // }
    // SortLayerBasedOnSolution(layer: number[], solver: ISolverShell) {
    //  let length: number = layer.length;
    //  let positions = new Array(length);
    //  let k= 0;
    //  for (let v: number of layer) {
    //    positions[k++] = solver.GetVariableResolvedPosition(v);
    //  }
    //  Array.Sort(positions, layer);
    //  let i= 0;
    //  for (let v: number of layer) {
    //    i++;
    //  }
    //  this.LayerArrays.x[v] = i;
    // }
    //      /* const */ static ConstrainedVarWeight= 10000000;
    //      /* const */ static PositionOverBaricenterWeight= 5;
    // static NodeToBlockRootSoftOnLayerInfo(layerInfo: LayerInfo, node: number): number {
    //  let root: number;
    //  return layerInfo.nodeToBlockRoot.TryGetValue(node, TODOOUTroot);
    //  // TODO: Warning!!!, inline IF is not supported ?
    //  // TODO: Warning!!!! NULL EXPRESSION DETECTED...
    //  ;
    // }
    // static AddGoalToKeepFlatEdgesShortOnBlockLevel(layerInfo: LayerInfo, solver: ISolverShell) {
    //  if ((layerInfo != null)) {
    //    for (let couple of layerInfo.flatEdges) {
    //      let sourceBlockRoot: number = ConstrainedOrdering.NodeToBlockRootSoftOnLayerInfo(layerInfo, couple.Item1);
    //      let targetBlockRoot: number = ConstrainedOrdering.NodeToBlockRootSoftOnLayerInfo(layerInfo, couple.Item2);
    //      if ((sourceBlockRoot !== targetBlockRoot)) {
    //        solver.AddGoalTwoVariablesAreClose(sourceBlockRoot, targetBlockRoot);
    //      }
    //    }
    //  }
    // }
    // static NodeIsConstrainedBelow(v: number, layerInfo: LayerInfo): boolean {
    //  if ((layerInfo == null )) {
    //    return false;
    //  }
    //  return layerInfo.constrainedFromBelow.ContainsKey(v);
    // }
    // static NodeIsConstrainedAbove(v: number, layerInfo: LayerInfo): boolean {
    //  if ((layerInfo == null )) {
    //    return false;
    //  }
    //  return layerInfo.constrainedFromAbove.ContainsKey(v);
    // }
    static BelongsToNeighbBlock(p, layerInfo) {
        return layerInfo != null && (layerInfo.nodeToBlockRoot.has(p) || layerInfo.neigBlocks.has(p));
        // p is a root of the block
    }
}
ConstrainedOrdering.MaxNumberOfNoGainSteps = 5;
//# sourceMappingURL=constrainedOrdering.js.map