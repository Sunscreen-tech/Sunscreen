import { IntPair } from '../../utils/IntPair';
import { IntPairSet } from '../../utils/IntPairSet';
import { Anchor } from './anchor';
import { LayerArrays } from './LayerArrays';
import { LayerEdge } from './layerEdge';
import { ProperLayeredGraph } from './ProperLayeredGraph';
declare type MedianType = number | IntPair;
export declare class XCoordsWithAlignment {
    la: LayerArrays;
    graph: ProperLayeredGraph;
    nOfOriginalVertices: number;
    root: number[];
    align: number[];
    nOfVertices: number;
    anchors: Anchor[];
    nodeSep: number;
    lowMedians: MedianType[];
    upperMedians: MedianType[];
    markedEdges: IntPairSet;
    h: number;
    LR: boolean;
    BT: boolean;
    get CurrentEnumRightUp(): number;
    IsVirtual(v: number): boolean;
    xCoords: number[][];
    x: number[];
    Source(edge: LayerEdge): number;
    Target(edge: LayerEdge): number;
    static CalculateXCoordinates(layerArrays: LayerArrays, layeredGraph: ProperLayeredGraph, nOfOriginalVs: number, anchors: Anchor[], nodeSeparation: number): void;
    Calculate(): void;
    SortInAndOutEdges(): void;
    private FillUpperMedins;
    CompareByX(a: number, b: number): number;
    private FillUpperMediansForNode;
    private FillLowMedians;
    private FillLowMediansForNode;
    HorizontalBalancing(): void;
    static IsLeftMostAssignment(i: number): boolean;
    AssignmentBounds(i: number, t: {
        a: number;
        b: number;
    }): void;
    CalcBiasedAlignment(): void;
    LeftUpSetup(): void;
    LeftDownSetup(): void;
    RightDownSetup(): void;
    RightUpSetup(): void;
    ConflictElimination(): void;
    UpperEdgeMedians(target: number): IterableIterator<number>;
    MarkConflictingEdges(): void;
    NextUpper(i: number): number;
    NextLower(i: number): number;
    UpperOf(i: number, j: number): number;
    LowerOf(i: number, j: number): number;
    IsBelow(i: number, j: number): boolean;
    LeftMost(pos0: number, pos1: number): number;
    RightMost(pos0: number, pos1: number): number;
    IsNotRightFrom(i: number, pos: number): boolean;
    IsLeftFrom(i: number, j: number): boolean;
    NextRight(i: number): number;
    NextLeft(i: number): number;
    ConflictsWithAtLeastOneInnerEdgeForALayer(layerIndex: number): void;
    InEdgeOfVirtualNode(v: number): LayerEdge;
    InEdges(v: number): IterableIterator<LayerEdge>;
    MarkEdgesBetweenInnerAndNewInnerEdges(lowerLayer: number[], innerEdge: LayerEdge, newInnerEdge: LayerEdge, innerEdgeSourcePos: number, newInnerEdgeSourcePos: number): void;
    private AlignmentToTheRightOfInner;
    private NumberOfInEdges;
    Pos(v: number): number;
    InnerEdgeByTarget(v: number): LayerEdge;
    IsInnerEdge(e: LayerEdge): boolean;
    private RemoveMarksFromEdges;
    constructor(layerArrays: LayerArrays, layeredGraph: ProperLayeredGraph, nOfOriginalVs: number, anchorsP: Anchor[], ns: number);
    Align(): void;
    AssignCoordinatesByLongestPath(): void;
    TryToGetRightNeighbor(u: number, t: {
        neighbor: number;
    }): boolean;
    TryToGetLeftNeighbor(u: number, t: {
        neighbor: number;
    }): boolean;
    CreateBlocks(): void;
    private IsMarked;
    private MarkEdge;
    static infinity: number;
    DeltaBetweenVertices(u: number, v: number): number;
}
export {};
