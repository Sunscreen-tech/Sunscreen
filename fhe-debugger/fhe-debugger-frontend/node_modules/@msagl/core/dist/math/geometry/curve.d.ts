import { ICurve } from './icurve';
import { PN } from './parallelogramNode';
import { Point } from './point';
import { LineSegment } from './lineSegment';
import { IntersectionInfo } from './intersectionInfo';
import { Ellipse } from './ellipse';
import { Polyline } from './polyline';
import { Rectangle } from './rectangle';
import { PlaneTransformation } from './planeTransformation';
import { BezierSeg } from './bezierSeg';
import { CornerSite } from './cornerSite';
declare type Params = {
    start: number;
    end: number;
};
declare type SegParam = {
    seg: ICurve;
    par: number;
};
declare type SegIndexParam = {
    segIndex: number;
    par: number;
};
export declare type MinDistOutput = {
    aSol: number;
    bSol: number;
    aX: Point;
    bX: Point;
};
declare type CurveCrossOutput = {
    aSol: number;
    bSol: number;
    x: Point;
};
export declare enum PointLocation {
    Outside = 0,
    Boundary = 1,
    Inside = 2
}
export declare type SegmentTag = 'ellipse' | 'lineSegment' | 'bezier';
export declare type CurveJSON = {
    segs: {
        tag: SegmentTag;
        segData: any;
    }[];
};
export declare class Curve implements ICurve {
    static fromJSON(eData: CurveJSON): Curve;
    toJSON(): CurveJSON;
    static CurvesIntersect(curve1: ICurve, curve2: ICurve): boolean;
    private parEnd_;
    pBNode: PN;
    /** the segments comprising the curve */
    segs: ICurve[];
    static lengthWithInterpolationAndThreshold(_seg: ICurve, _eps: number): number;
    static lengthWithInterpolation(_seg: ICurve): number;
    get parStart(): number;
    get parEnd(): number;
    lengthPartial(start: number, end: number): number;
    reverse(): Curve;
    constructor();
    mkCurveWithSegs(segs: ICurve[]): void;
    get start(): Point;
    get end(): Point;
    scaleFromOrigin(xScale: number, yScale: number): Curve;
    trim(start: number, end: number): ICurve;
    translate(delta: Point): void;
    adjustStartEndEndParametersToDomain(params: Params): void;
    trimWithWrap(start: number, end: number): ICurve;
    addSegs(segs: ICurve[]): Curve;
    addSegment(curve: ICurve): this;
    pNodeOverICurve(): PN;
    static intersectionOne(curve0: ICurve, curve1: ICurve, liftIntersection: boolean): IntersectionInfo;
    /**
     *   Calculates all intersections between curve0 and curve1.
     *  If liftIntersections is true then the intersections parameters
     *  recalculated, lifted, to the curve parameter domain. Otherwise they * stay in the segment domains
     */
    static getAllIntersections(curve0: ICurve, curve1: ICurve, liftIntersections: boolean): IntersectionInfo[];
    static getAllIntersectionsInternal(curve0: ICurve, curve1: ICurve, liftIntersections: boolean): IntersectionInfo[];
    static getAllIntersectionsOfLineAndICurve(lineSeg: LineSegment, iCurve: ICurve, liftIntersections: boolean): IntersectionInfo[];
    private static getAllIntersectionsOfLineAndCurve;
    static closeIntersections(x: IntersectionInfo, y: IntersectionInfo): boolean;
    static closeIntersectionPoints(x: Point, y: Point): boolean;
    static alreadyInside(ret: IntersectionInfo[], intersectionInfo: IntersectionInfo): boolean;
    static getAllIntersectionsOfLineAndArc(lineSeg: LineSegment, ellipse: Ellipse): IntersectionInfo[];
    static tryToAddPointToLineCircleCrossing(lineSeg: LineSegment, ellipse: Ellipse, ret: IntersectionInfo[], point: Point, segLength: number, lineDir: Point): void;
    static getAllIntersectionsOfLineAndPolyline(lineSeg: LineSegment, poly: Polyline): IntersectionInfo[];
    static adjustSolution(aStart: Point, aEnd: Point, bStart: Point, bEnd: Point, sol: CurveCrossOutput): void;
    static curveCurveXWithParallelogramNodesOne(n0: PN, n1: PN): IntersectionInfo;
    static curveCurveXWithParallelogramNodes(n0: PN, n1: PN, intersections: IntersectionInfo[]): void;
    static crossOverIntervalsOne(n0: PN, n1: PN): IntersectionInfo | undefined;
    static crossOverLeaves(n0: PN, n1: PN, intersections: IntersectionInfo[]): IntersectionInfo[];
    static addIntersection(n0: PN, n1: PN, intersections: IntersectionInfo[], sol: CurveCrossOutput): void;
    static oldIntersection(intersections: IntersectionInfo[], x: Point): boolean;
    static createIntersectionOne(n0: PN, n1: PN, aSol: number, bSol: number, x: Point): IntersectionInfo;
    static liftIntersectionToCurves_(c0: ICurve, c1: ICurve, aSol: number, bSol: number, x: Point, seg0: ICurve, seg1: ICurve): IntersectionInfo;
    static DropIntersectionToSegs(xx: IntersectionInfo): IntersectionInfo;
    static liftIntersectionToCurves(c0: ICurve, c1: ICurve, xx: IntersectionInfo): IntersectionInfo;
    static liftParameterToCurve(curve: ICurve, par: number, seg: ICurve): number;
    static paramSpan(s: ICurve): number;
    static goDeeperOne(nl0: PN, nl1: PN): IntersectionInfo;
    static goDeeper(intersections: IntersectionInfo[], nl0: PN, nl1: PN): void;
    static adjustParameters(l0: PN, ls0: LineSegment, l1: PN, ls1: LineSegment, sol: CurveCrossOutput): void;
    getSegParam(t: number): SegParam;
    /** return the segment index and the parameter inside of the segment */
    getSegIndexParam(t: number): SegIndexParam;
    value(t: number): Point;
    derivative(t: number): Point;
    secondDerivative(t: number): Point;
    thirdDerivative(t: number): Point;
    static crossWithinIntervalsWithGuess(a: ICurve, b: ICurve, amin: number, amax: number, bmin: number, bmax: number, aGuess: number, bGuess: number): CurveCrossOutput | undefined;
    static crossTwoLineSegs(aStart: Point, aEnd: Point, bStart: Point, bEnd: Point, amin: number, amax: number, bmin: number, bmax: number): CurveCrossOutput | undefined;
    static PointRelativeToCurveLocation(point: Point, curve: ICurve): PointLocation;
    static AllIntersectionsAreGood(intersections: Array<IntersectionInfo>, polygon: ICurve): boolean;
    static RealCut(xx: IntersectionInfo, polyline: Curve, onlyFromInsideCuts: boolean): boolean;
    static realCutWithClosedCurve(xx: IntersectionInfo, polygon: Curve, onlyFromInsideCuts: boolean): boolean;
    static minDistWithinIntervals(a: ICurve, b: ICurve, aMin: number, aMax: number, bMin: number, bMax: number, aGuess: number, bGuess: number): MinDistOutput | undefined;
    offsetCurve(offset: number, dir: Point): ICurve;
    private boundingBox_;
    /**
     * The bounding rectangle of the curve
     */
    get boundingBox(): Rectangle;
    /**  clones the curve */
    clone(): Curve;
    getParameterAtLength(length: number): number;
    get length(): number;
    /** returns a new curve */
    transform(transformation: PlaneTransformation): ICurve;
    closestParameterWithinBounds(targetPoint: Point, low: number, high: number): number;
    closestParameter(targetPoint: Point): number;
    static addLineSegment(curve: Curve, pointA: Point, pointB: Point): Curve;
    static addLineSegmentCNNP(c: Curve, x: number, y: number, b: Point): Curve;
    static addLineSegmentCNNNN(curve: Curve, x0: number, y0: number, x1: number, y1: number): void;
    static continueWithLineSegmentNN(c: Curve, x: number, y: number): void;
    static continueWithLineSegmentP(c: Curve, x: Point): void;
    static closeCurve(curve: Curve): Curve;
    leftDerivative(t: number): Point;
    rightDerivative(t: number): Point;
    tryToGetLeftSegment(t: number): ICurve;
    tryToGetRightSegment(t: number): ICurve;
    static ClosestPoint(curve: ICurve, location: Point): Point;
    static CurveIsInsideOther(innerCurve: ICurve, outerCurve: ICurve): boolean;
    static PointsBetweenIntersections(a: ICurve, xx: Array<IntersectionInfo>): IterableIterator<Point>;
    static NonIntersectingCurveIsInsideOther(a: ICurve, b: ICurve): boolean;
    static ClosedCurveInteriorsIntersect(c1: ICurve, c2: ICurve): boolean;
    curvature(t: number): number;
    curvatureDerivative(t: number): number;
    curvatureSecondDerivative(t: number): number;
    static createBezierSeg(kPrev: number, kNext: number, a: CornerSite, b: CornerSite, c: CornerSite): BezierSeg;
    static createBezierSegN(a: Point, b: Point, perp: Point, i: number): BezierSeg;
    static findCorner(a: CornerSite): {
        b: CornerSite;
        c: CornerSite;
    } | undefined;
    static trimEdgeSplineWithNodeBoundaries(sourceBoundary: ICurve, targetBoundary: ICurve, spline: ICurve, narrowestInterval: boolean): ICurve;
    static findNewEnd(spline: ICurve, targetBoundary: ICurve, narrowestInterval: boolean, end: number): number;
    static findNewStart(spline: ICurve, start: number, sourceBoundary: ICurve, narrowestInterval: boolean): number;
    static polylineAroundClosedCurve(curve: ICurve): Polyline;
    static allSegsAreLines(c: Curve): boolean;
    static refineEllipse(ellipse: Ellipse): Polyline;
    static polyFromBox(rectangle: Rectangle): Polyline;
}
export declare function interpolateICurve(s: ICurve, eps: number): Point[];
/** Iterate over all icurve subsegments that intersect the given rectangle.
 * The function might return subsegments that are running outside of the rectangle
 *  but still close to its border.
 *
 * Should be removed
 */
export declare function clipWithRectangle(curve: ICurve, rect: Rectangle): IterableIterator<ICurve>;
/** Looking for all subsegments of of 'curve' intersecting 'rect'
 *  For each such a segment return {start:a, end:b} such that segment = curve.trim(a,b)
 */
export declare function clipWithRectangleInsideInterval(curve: ICurve, rect: Rectangle): IterableIterator<ICurve>;
export {};
