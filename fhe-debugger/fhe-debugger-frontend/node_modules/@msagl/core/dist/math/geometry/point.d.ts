export declare enum TriangleOrientation {
    Clockwise = 0,
    Counterclockwise = 1,
    Collinear = 2
}
export declare type PointJSON = {
    x: number;
    y: number;
};
export declare function distPP(a: Point, b: Point): number;
/** represents a point with two coordinates on the plane */
export declare class Point {
    static RoundPoint(point: Point): Point;
    static RoundDouble(num: number): number;
    toJSON(): PointJSON;
    static fromJSON(pData: PointJSON): Point;
    /** c is projected to line through a, b */
    static ProjectionToLine(a: Point, b: Point, c: Point): Point;
    static RayIntersectsRayInteriors(aOrig: Point, aDir: Point, bOrig: Point, bDir: Point): Point | undefined;
    static IntervalIntersectsRay(segStart: Point, segEnd: Point, rayOrigin: Point, rayDirection: Point): Point | undefined;
    static PointToTheLeftOfLineOrOnLine(point: Point, linePoint0: Point, linePoint1: Point): boolean;
    static PointToTheLeftOfLine(point: Point, linePoint0: Point, linePoint1: Point): boolean;
    static PointIsInsideCone(p: Point, apex: Point, leftSideConePoint: Point, rightSideConePoint: Point): boolean;
    static PointToTheRightOfLineOrOnLine(point: Point, linePoint0: Point, linePoint1: Point): boolean;
    static PointToTheRightOfLine(point: Point, linePoint0: Point, linePoint1: Point): boolean;
    static closeIntersections(a: Point, b: Point): boolean;
    get l1(): number;
    dot(a: Point): number;
    private x_;
    private y_;
    get x(): number;
    get y(): number;
    compareTo(other: Point): number;
    toString(): string;
    static close(a: Point, b: Point, tol: number): boolean;
    static closeSquare(a: Point, b: Point, tol: number): boolean;
    static closeDistEps(a: Point, b: Point, eps?: number): boolean;
    normalize(): Point;
    get length(): number;
    get lengthSquared(): number;
    constructor(x: number, y: number);
    static middle(a: Point, b: Point): Point;
    scale(sx: number, sy: number): Point;
    add(a: Point): Point;
    sub(a: Point): Point;
    mul(c: number): Point;
    div(c: number): Point;
    equal(a: Point): boolean;
    neg(): Point;
    static lineLineIntersection(a: Point, b: Point, c: Point, d: Point): Point | undefined;
    static segSegIntersection(a: Point, b: Point, c: Point, d: Point): Point | undefined;
    static parallelWithinEpsilon(a: Point, b: Point, eps: number): boolean;
    static crossProduct(point0: Point, point1: Point): number;
    static dot(a: Point, b: Point): number;
    static add(a: Point, b: Point): Point;
    rotate90Ccw(): Point;
    rotate90Cw(): Point;
    clone(): Point;
    rotate(angle: number): Point;
    static mkPoint(x: number, a: Point, y: number, b: Point): Point;
    static convSum(x: number, a: Point, b: Point): Point;
    static anglePCP(point1: Point, center: Point, point3: Point): number;
    static angle(side0: Point, side1: Point): number;
    static signedDoubledTriangleArea(a: Point, b: Point, c: Point): number;
    static getTriangleOrientation(cornerA: Point, cornerB: Point, cornerC: Point): TriangleOrientation;
    static getTriangleOrientationWithIntersectionEpsilon(cornerA: Point, cornerB: Point, cornerC: Point): TriangleOrientation;
    static ClosestPointAtLineSegment(point: Point, segmentStart: Point, segmentEnd: Point): Point;
    static pointToTheLeftOfLineOrOnLine(point: Point, linePoint0: Point, linePoint1: Point): boolean;
    static pointToTheLeftOfLine(point: Point, linePoint0: Point, linePoint1: Point): boolean;
    static pointToTheRightOfLineOrOnLine(point: Point, linePoint0: Point, linePoint1: Point): boolean;
    static pointToTheRightOfLine(point: Point, linePoint0: Point, linePoint1: Point): boolean;
    static canProject(point: Point, segmentStart: Point, segmentEnd: Point): boolean;
    static distToLineSegment(a: Point, b: Point, c: Point): {
        par: number;
        dist: number;
    };
}
