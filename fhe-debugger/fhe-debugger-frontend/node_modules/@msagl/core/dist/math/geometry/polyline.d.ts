import { ICurve } from './icurve';
import { PN } from './parallelogramNode';
import { PlaneTransformation } from './planeTransformation';
import { Point, PointJSON } from './point';
import { Rectangle } from './rectangle';
import { PolylinePoint } from './polylinePoint';
import { Parallelogram } from './parallelogram';
import { Curve } from './curve';
declare type AdjustedPar = {
    a: Point;
    b: Point;
    t: number;
};
export declare type PolylineJSON = {
    points: PointJSON[];
};
/** the curve corresponding to the sequence of lines, could be closed when the start coincides with the end */
export declare class Polyline implements ICurve {
    toJSON(): PolylineJSON;
    static fromJSON(data: PolylineJSON): Polyline;
    RemoveStartPoint(): void;
    RemoveEndPoint(): void;
    startPoint: PolylinePoint;
    endPoint: PolylinePoint;
    private initIsRequired;
    private isClosed_;
    pBNode: PN;
    private bBox;
    private count_;
    setInitIsRequired(): void;
    addPointXY(x: number, y: number): void;
    /** should true, by internal assumptions,  in general for convex polylines */
    isClockwise(): boolean;
    /**  adds a point to the polyline */
    addPoint(p: Point): void;
    PrependPoint(p: Point): void;
    [Symbol.iterator](): IterableIterator<Point>;
    polylinePoints(): IterableIterator<PolylinePoint>;
    skip(skipCount: number): IterableIterator<PolylinePoint>;
    static parallelogramOfLineSeg(a: Point, b: Point): Parallelogram;
    static mkFromPoints(ps: Iterable<Point>): Polyline;
    static mkClosedFromPoints(ps: Iterable<Point>): Polyline;
    calculatePbNode(): void;
    init(): void;
    updateCount(): void;
    get count(): number;
    get closed(): boolean;
    set closed(value: boolean);
    value(t: number): Point;
    getAdjustedParamAndStartEndPoints(t: number): AdjustedPar;
    derivative(t: number): Point;
    secondDerivative(t: number): Point;
    thirdDerivative(t: number): Point;
    pNodeOverICurve(): PN;
    get boundingBox(): Rectangle;
    get parStart(): number;
    get parEnd(): number;
    static polylineFromCurve(curve: Curve): Polyline;
    trim(start: number, end: number): ICurve;
    trimWithWrap(start: number, end: number): ICurve;
    translate(delta: Point): void;
    scaleFromOrigin(xScale: number, yScale: number): ICurve;
    get start(): Point;
    get end(): Point;
    reverse(): ICurve;
    offsetCurve(offset: number, dir: Point): ICurve;
    lengthPartial(start: number, end: number): number;
    get length(): number;
    getParameterAtLength(length: number): number;
    transform(transformation: PlaneTransformation): ICurve;
    closestParameterWithinBounds(targetPoint: Point, low: number, high: number): number;
    closestParameter(targetPoint: Point): number;
    clone(): Polyline;
    leftDerivative(t: number): Point;
    rightDerivative(t: number): Point;
    curvature(t: number): number;
    curvatureDerivative(t: number): number;
    curvatureSecondDerivative(t: number): number;
    next(a: PolylinePoint): PolylinePoint;
    prev(a: PolylinePoint): PolylinePoint;
    toCurve(): Curve;
    RemoveCollinearVertices(): Polyline;
}
export {};
