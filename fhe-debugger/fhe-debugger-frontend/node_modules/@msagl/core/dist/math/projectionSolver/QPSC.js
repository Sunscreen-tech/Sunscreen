// Store original weight to be restored when done.  With the ability to re-Solve() after
// updating constraint gaps, we must restore DesiredPos as well.
export class QpscVar {
    constructor(v) {
        this.Variable = v;
        this.OrigWeight = v.Weight;
        this.OrigScale = v.Scale;
        this.OrigDesiredPos = this.Variable.DesiredPos;
    }
}
class MatrixCell {
    constructor(w, index) {
        this.Value = w;
        this.Column = index;
    }
}
export class Qpsc {
    constructor(solverParameters, cVariables) {
        // Array of variables, for perf (avoid nested block/variable Array<> iteration)
        this.newMatrixRow = new Array();
        // If true we're on our first call to Project
        // Holds the value of f(x) = yQ'y + b'y as computed on the last iteration; used to test for
        // convergence and updated before HasConverged() returns.
        this.previousFunctionValue = Number.MAX_VALUE;
        this.solverParameters = solverParameters;
        this.matrixQ = new Array(cVariables).fill(0);
        this.vectorWiDi = new Array(cVariables).fill(0);
        this.vectorQpscVars = new Array(cVariables).fill(0);
        this.gradientVector = new Array(cVariables).fill(0);
        this.vectorQg = new Array(cVariables).fill(0);
        this.vectorPrevY = new Array(cVariables).fill(0);
        this.vectorCurY = new Array(cVariables).fill(0);
    }
    //
    // solver.SolveQpsc drives the Qpsc instance as follows:
    // Initialization:
    //    Qpsc qpsc = new Qpsc(numVariables);
    //    foreach (variable in (foreach block))
    //       qpsc.AddVariable(variable)
    //    qpsc.VariablesComplete()
    // Per iteration:
    //    if (!qpsc.PreProject()) break;
    //    solver.SplitBlocks()
    //    solver.Project()
    //    if (!qpsc.PostProject()) break;
    // Done:
    //    qpsc.ProjectComplete()
    AddVariable(variable) {
        /*Assert.assert(
          this.matrixQ[variable.Ordinal] == null  &&
            this.vectorQpscVars[variable.Ordinal].Variable == null ,
          'variable.Ordinal already exists',
        )*/
        this.isFirstProjectCall = true;
        // This is the weight times desired position, multiplied by 2.0 per the partial derivative.
        // We'll use this to keep as close as possible to the desired position on each iteration.
        this.vectorWiDi[variable.Ordinal] = 2 * (variable.Weight * variable.DesiredPos) * -1;
        // Temporarily hijack vectorPrevY for use as scratch storage, to handle duplicate
        // neighbor pairs (take the highest weight).
        // Sum the weight for cell i,i (the diagonal).
        this.vectorPrevY[variable.Ordinal] = variable.Weight;
        if (null != variable.Neighbors) {
            for (const neighborWeightPair of variable.Neighbors) {
                // We should already have verified this in AddNeighbourPair.
                /*Assert.assert(
                  neighborWeightPair.Neighbor.Ordinal !== variable.Ordinal,
                  'self-neighbors are not allowed',
                )*/
                // For the neighbor KeyValuePairs, Key === neighboring variable and Value === relationship
                // weight.  If we've already encountered this pair then we'll sum the relationship weights, under
                // the assumption the caller will be doing something like creating edges for different reasons,
                // and multiple edges should be like rubber bands, the sum of the strengths.  Mathematica also
                // sums duplicate weights.
                // Per above comments:
                //     First the diagonal entries: A[i][i] = wi + Sum(wij for every neighbor j of i).
                this.vectorPrevY[variable.Ordinal] = this.vectorPrevY[variable.Ordinal] + neighborWeightPair.Weight;
                //     Then the off diagonal entries: A[i][j] = -Sum(wij for time j is a neighbor of i).
                this.vectorPrevY[neighborWeightPair.Neighbor.Ordinal] =
                    this.vectorPrevY[neighborWeightPair.Neighbor.Ordinal] - neighborWeightPair.Weight;
            }
        }
        // endif null !=  variable.Neighbors
        // Add the sparse row to the matrix (all non-zero slots of vectorPrevY are weights to that neighbor).
        for (let ii = 0; ii < this.vectorPrevY.length; ii++) {
            if (0 !== this.vectorPrevY[ii]) {
                // The diagonal must be > 0 and off-diagonal < 0.
                /*Assert.assert(
                  (ii === variable.Ordinal) === this.vectorPrevY[ii] > 0,
                  'Diagonal must be > 0.0',
                )*/
                // All 'A' cells must be 2*(summed weights).
                this.newMatrixRow.push(new MatrixCell(this.vectorPrevY[ii] * 2, ii));
                this.vectorPrevY[ii] = 0;
            }
        }
        this.matrixQ[variable.Ordinal] = Array.from(this.newMatrixRow);
        this.newMatrixRow = [];
        this.vectorQpscVars[variable.Ordinal] = new QpscVar(variable);
        // For the non-Qpsc loop, we consider weights in block reference-position calculation.
        // Here, we have that in vectorWiDi which we use in calculating gradient and alpha, which
        // in turn we use to set the gradient-stepped desiredPos.  So turn it off for the duration
        // of Qpsc - we restore it in QpscComplete().
        variable.Weight = 1;
    }
    // end AddVariable()
    VariablesComplete() {
        for (const qvar of this.vectorQpscVars) {
            const variable = qvar.Variable;
            for (const cell of this.matrixQ[variable.Ordinal]) {
                if (cell.Column === variable.Ordinal) {
                    if (this.solverParameters.Advanced.ScaleInQpsc) {
                        variable.Scale = 1 / Math.sqrt(Math.abs(cell.Value));
                        if (!Number.isFinite(variable.Scale)) {
                            variable.Scale = 1;
                        }
                        // This is the y = Sx step from the Scaling paper.
                        variable.Scale;
                        // This is the b' <- Sb step from the Scaling paper
                        this.vectorWiDi[variable.Ordinal] = this.vectorWiDi[variable.Ordinal] * variable.Scale;
                    }
                    // This is needed for block re-initialization.
                    this.vectorCurY[variable.Ordinal] = variable.ActualPos;
                    variable.DesiredPos = variable.ActualPos;
                }
            }
        }
        if (!this.solverParameters.Advanced.ScaleInQpsc) {
            return;
        }
        // Now convert mxQ to its scaled form S#QS (noting that the transform of a diagonal matrix S is S
        // so this is optimized), and we've made the S matrix such that Q[i][i] is 1.  The result is in-place
        // conversion of Q to scaledQ s.t.
        //   for all ii
        //      for all jj
        //         if ii === jj, scaledQ[ii][jj] = 1
        //         else         scaledQ[ii][jj] = Q[ii][jj] * var[ii].scale * var[jj].scale
        // /
        for (let rowNum = 0; rowNum < this.matrixQ.length; rowNum++) {
            const row = this.matrixQ[rowNum];
            for (let sparseCol = 0; sparseCol < row.length; sparseCol++) {
                if (row[sparseCol].Column === rowNum) {
                    row[sparseCol].Value = 1;
                }
                else {
                    // Diagonal on left scales rows [SQ], on right scales columns [QS].
                    row[sparseCol].Value =
                        row[sparseCol].Value * (this.vectorQpscVars[rowNum].Variable.Scale * this.vectorQpscVars[row[sparseCol].Column].Variable.Scale);
                }
            }
        }
    }
    // end VariablesComplete()
    // Called by SolveQpsc before the split/project phase.  Returns false if the difference in the
    // function value on the current vs. previous iteration is sufficiently small that we're done.
    // @@PERF: Right now this is distinct matrix/vector operations.  Profiling shows most time
    // in Qpsc is taken by MatrixVectorMultiply.  We could gain a bit of performance by combining
    // some things but keep it simple unless that's needed.
    PreProject() {
        if (this.isFirstProjectCall) {
            // Due to MergeEqualityConstraints we may have moved some of the variables.  This won't
            // affect feasibility since QpscMakeFeasible would already have ensured that any unsatisfiable
            // constraints are so marked.
            for (const qvar of this.vectorQpscVars) {
                this.vectorCurY[qvar.Variable.Ordinal] = qvar.Variable.ActualPos;
            }
        }
        //
        // Compute: g = Q'y + b' (in the Scaling paper terminology)
        //
        // g(radient) = Q'y...
        this.MatrixVectorMultiply(this.vectorCurY, this.gradientVector);
        // If we've minimized the goal function (far enough), we're done.
        // This uses the Q'y value we've just put into gradientVector and tests the goal-function value
        // to see if it is sufficiently close to the previous value to be considered converged.
        if (this.HasConverged()) {
            return false;
        }
        // ...g = Q'y + b'
        Qpsc.VectorVectorAdd(this.gradientVector, this.vectorWiDi, this.gradientVector);
        //
        // Compute: alpha = g#g / g#Q'g  (# === transpose)
        //
        const alphaNumerator = Qpsc.VectorVectorMultiply(this.gradientVector, this.gradientVector);
        // Compute numerator of stepsize
        let alphaDenominator = 0;
        if (0 !== alphaNumerator) {
            this.MatrixVectorMultiply(this.gradientVector, this.vectorQg);
            alphaDenominator = Qpsc.VectorVectorMultiply(this.vectorQg, this.gradientVector);
        }
        if (0 === alphaDenominator) {
            return false;
        }
        const alpha = alphaNumerator / alphaDenominator;
        //
        // Store off the current position as the previous position (the paper's y^ (y-hat)),
        // then calculate the new current position by subtracting the (gradient * alpha)
        // from it and update the Variables' desired position.
        //
        Qpsc.VectorCopy(this.vectorPrevY, this.vectorCurY);
        // Update d(esiredpos) = y - alpha*g
        // Use vectorCurY as temp as it is not used again here and is updated at start of PostProject.
        Qpsc.VectorScaledVectorSubtract(this.vectorPrevY, alpha, this.gradientVector, this.vectorCurY);
        for (let ii = 0; ii < this.vectorCurY.length; ii++) {
            this.vectorQpscVars[ii].Variable.DesiredPos = this.vectorCurY[ii];
        }
        return true;
    }
    // end PreProject()
    // Called by SolveQpsc after the split/project phase.
    PostProject() {
        //
        // Update our copy of current positions (y-bar from the paper) and deltaY (p in the Scaling paper; y-bar minus y-hat).
        //
        for (const qvar of this.vectorQpscVars) {
            this.vectorCurY[qvar.Variable.Ordinal] = qvar.Variable.ActualPos;
        }
        // vectorCurY temporarily becomes the p-vector from the Scaling paper since we don't use the "current"
        // position otherwise, until we reset it at the end.
        Qpsc.VectorVectorSubtract(this.vectorPrevY, this.vectorCurY, this.vectorCurY);
        //
        // Compute: Beta = min(g#p / p#Qp, 1)
        //
        const betaNumerator = Qpsc.VectorVectorMultiply(this.gradientVector, this.vectorCurY);
        // Compute numerator of stepsize
        let beta = 0;
        if (0 !== betaNumerator) {
            // Calculate Qp first (matrix ops are associative so (AB)C === A(BC), so calculate the rhs first
            // with MatrixVectorMultiply).  Temporarily hijack vectorQg for this operation.
            this.MatrixVectorMultiply(this.vectorCurY, this.vectorQg);
            // Now p#(Qp).
            const betaDenominator = Qpsc.VectorVectorMultiply(this.vectorQg, this.vectorCurY);
            // Dividing by almost-0 would yield a huge value which we'd cap at 1.0 below.
            beta = 0 === betaDenominator ? 1 : betaNumerator / betaDenominator;
            if (beta > 1) {
                // Note:  With huge ranges, beta is >>1 here - like 50 or millions.  This is expected as
                // we're dividing by p#Qp where p is potentially quite small.
                beta = 1;
            }
            else if (beta < 0) {
                // Setting it above 0.0 can move us away from convergence, so set it to 0.0 which leaves
                // vectorCurY unchanged from vectorPrevY and we'll terminate if there are no splits/violations.
                // If we were close to convergence in preProject, we could have a significantly negative
                // beta here, which means we're basically done unless split/project still have stuff to do.
                beta = 0;
            }
        }
        // Beta numerator is nonzero
        // Update the "Qpsc-local" copy of the current positions for use in the next loop's PreProject().
        Qpsc.VectorScaledVectorSubtract(this.vectorPrevY, beta, this.vectorCurY, this.vectorCurY);
        this.isFirstProjectCall = false;
        return beta > 0;
    }
    // end PostProject()
    QpscComplete() {
        // Restore original desired position and unscale the actual position.
        for (const qvar of this.vectorQpscVars) {
            qvar.Variable.Weight = qvar.OrigWeight;
            qvar.Variable.DesiredPos = qvar.OrigDesiredPos;
            if (this.solverParameters.Advanced.ScaleInQpsc) {
                // This multiplication essentially does what Constraint.Violation does, so the "satisfied" state
                // of constraints won't be changed.
                qvar.Variable.ActualPos = qvar.Variable.ActualPos * qvar.Variable.Scale;
                qvar.Variable.Scale = qvar.OrigScale;
            }
        }
        // This was updated to the final function value before HasConverged returned.
        return this.previousFunctionValue;
    }
    HasConverged() {
        //
        // Compute the function value relative to the previous iteration to test convergence:
        //     (x#Ax)/2 + bx + (w d).d       Note: final term is from Tim's Mathematica
        // where the last term (w d).d is constant and, because we only test decreasing value,
        // can therefore be omitted.
        //
        // We don't need to do the Ax operation as this is done as part of PreProject which has
        // already put this into gradientVector.
        //
        const currentFunctionValue = this.GetFunctionValue(this.vectorCurY);
        // If this is not our first PreProject call, test for convergence.
        let fConverged = false;
        if (!this.isFirstProjectCall) {
            // Check for convergence.  We are monotonically decreasing so prev should be > cur
            // with some allowance for rounding error.
            const diff = this.previousFunctionValue - currentFunctionValue;
            let quotient = 0;
            if (diff !== 0) {
                const divisor = 0 !== this.previousFunctionValue ? this.previousFunctionValue : currentFunctionValue;
                quotient = Math.abs(diff / divisor);
            }
            if (Math.abs(diff) < this.solverParameters.QpscConvergenceEpsilon ||
                Math.abs(quotient) < this.solverParameters.QpscConvergenceQuotient) {
                fConverged = true;
            }
        }
        // endif !isFirstProjectCall
        this.previousFunctionValue = currentFunctionValue;
        return fConverged;
    }
    GetFunctionValue(positions) {
        // (x#Ax)/2...
        const value = Qpsc.VectorVectorMultiply(this.gradientVector, positions) / 2;
        // (x'Ax)/2 + bx...
        return value + Qpsc.VectorVectorMultiply(this.vectorWiDi, positions);
    }
    // Returns the dot product of two column vectors (with an "implicit transpose").
    static VectorVectorMultiply(lhs, rhs) {
        // Do not use LINQ's Sum, it slows end-to-end by over 10%.
        let sum = 0;
        for (let ii = 0; ii < lhs.length; ii++) {
            sum = sum + lhs[ii] * rhs[ii];
        }
        return sum;
    }
    // Multiplies matrixQ with the column vector rhs leaving the result in column vector in result[].
    MatrixVectorMultiply(rhs, result) {
        // The only matrix we have here is (sparse) matrixQ so it's not a parameter.
        let rowIndex = 0;
        for (const row of this.matrixQ) {
            // Do not use LINQ's Sum, it slows end-to-end by over 10%.
            let sum = 0;
            for (const cell of row) {
                sum = sum + cell.Value * rhs[cell.Column];
            }
            result[rowIndex++] = sum;
        }
    }
    // Returns the addition result in result[] (which may be lhs or rhs or a different vector).
    static VectorVectorAdd(lhs, rhs, result) {
        for (let ii = 0; ii < lhs.length; ii++) {
            result[ii] = lhs[ii] + rhs[ii];
        }
    }
    // Returns the subtraction result in result[] (which may be lhs or rhs or a different vector).
    static VectorVectorSubtract(lhs, rhs, result) {
        for (let ii = 0; ii < lhs.length; ii++) {
            result[ii] = lhs[ii] - rhs[ii];
        }
    }
    // Same as VectorVectorSubtract except that rhs is multiplied by the scale value.
    static VectorScaledVectorSubtract(lhs, scale, rhs, result) {
        for (let ii = 0; ii < lhs.length; ii++) {
            result[ii] = lhs[ii] - scale * rhs[ii];
        }
    }
    // Copies src to dest
    static VectorCopy(dest, src) {
        for (let ii = 0; ii < src.length; ii++) {
            dest[ii] = src[ii];
        }
    }
}
//# sourceMappingURL=QPSC.js.map