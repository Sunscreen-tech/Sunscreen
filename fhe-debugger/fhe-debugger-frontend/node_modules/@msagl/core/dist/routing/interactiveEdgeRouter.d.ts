import { ICurve, Rectangle, Point, GeomEdge } from '..';
import { CurvePort } from '../layout/core/curvePort';
import { HookUpAnywhereFromInsidePort } from '../layout/core/hookUpAnywhereFromInsidePort';
import { Polyline, LineSegment } from '../math/geometry';
import { IntersectionInfo } from '../math/geometry/intersectionInfo';
import { PolylinePoint } from '../math/geometry/polylinePoint';
import { RectangleNode } from '../math/geometry/RTree/rectangleNode';
import { SmoothedPolyline } from '../math/geometry/smoothedPolyline';
import { InteractiveObstacleCalculator } from './interactiveObstacleCalculator';
import { Polygon } from './visibility/Polygon';
import { VisibilityGraph } from './visibility/VisibilityGraph';
import { VisibilityVertex } from './visibility/VisibilityVertex';
import { Algorithm } from '../utils/algorithm';
import { Port } from '../layout/core/port';
import { CornerSite } from '../math/geometry/cornerSite';
import { PathOptimizer } from './spline/pathOptimizer';
export declare class InteractiveEdgeRouter extends Algorithm {
    rerouteEdge(edge: GeomEdge): void;
    pathOptimizer: PathOptimizer;
    static constructorANNN(obstacles: ICurve[], padding: number, loosePadding: number, coneSpannerAngle: number): InteractiveEdgeRouter;
    obstacles_: Array<ICurve>;
    targetVV: VisibilityVertex;
    IgnoreTightPadding: boolean;
    get Obstacles(): Array<ICurve>;
    set Obstacles(value: Array<ICurve>);
    enteringAngleBound_: number;
    get EnteringAngleBound(): number;
    set EnteringAngleBound(value: number);
    _sourceTightPolyline: Polyline;
    get SourceTightPolyline(): Polyline;
    set SourceTightPolyline(value: Polyline);
    SourceLoosePolyline: Polyline;
    targetTightPolyline: Polyline;
    get TargetTightPolyline(): Polyline;
    set TargetTightPolyline(value: Polyline);
    targetLoosePolyline: Polyline;
    get TargetLoosePolyline(): Polyline;
    set TargetLoosePolyline(value: Polyline);
    activeRectangle: Rectangle;
    visibilityGraph: VisibilityGraph;
    get VisibilityGraph(): VisibilityGraph;
    set VisibilityGraph(value: VisibilityGraph);
    activePolygons: Array<Polygon>;
    alreadyAddedOrExcludedPolylines: Set<Polyline>;
    private sourcePort;
    get SourcePort(): Port;
    set SourcePort(value: Port);
    private targetPort;
    get TargetPort(): Port;
    set TargetPort(value: Port);
    TightPadding: number;
    loosePadding: number;
    get LoosePadding(): number;
    set LoosePadding(value: number);
    sourceVV: VisibilityVertex;
    _polyline: Polyline;
    get OffsetForPolylineRelaxing(): number;
    ExpectedProgressSteps: number;
    targetIsInsideOfSourceTightPolyline: boolean;
    sourceIsInsideOfTargetTightPolyline: boolean;
    UseEdgeLengthMultiplier: boolean;
    UseInnerPolylingShortcutting: boolean;
    UsePolylineEndShortcutting: boolean;
    AllowedShootingStraightLines: boolean;
    startPointOfRouting_: Point;
    get StartPointOfEdgeRouting(): Point;
    set StartPointOfEdgeRouting(value: Point);
    ExtendVisibilityGraphToLocation(location: Point): void;
    RemovePointVisibilityGraphs(): void;
    CalculateEdgeTargetVisibilityGraph(location: Point): void;
    CalculateSourcePortVisibilityGraph(): void;
    TakeBoundaryPortOutsideOfItsLoosePolyline(nodeBoundary: ICurve, parameter: number, loosePolyline: Polyline): Point;
    static PointInsideOfConvexCurve(nodeBoundary: ICurve): Point;
    GetActivePolylines(): IterableIterator<Polyline>;
    GetAddedPolygonesAndMaybeExtendActiveRectangle(): Array<Polygon>;
    PolylineSegmentIntersectsTightHierarchy(a: Point, b: Point): boolean;
    PolylineIntersectsPolyRectangleNodeOfTightHierarchyPPR(a: Point, b: Point, rect: RectangleNode<Polyline, Point>): boolean;
    PolylineIntersectsPolyRectangleNodeOfTightHierarchy(ls: LineSegment, rect: RectangleNode<Polyline, Point>): boolean;
    static IntersectionsOfLineAndRectangleNodeOverPolylineLR(ls: LineSegment, rectNode: RectangleNode<Polyline, Point>): Array<IntersectionInfo>;
    static IntersectionsOfLineAndRectangleNodeOverPolyline(ls: LineSegment, rectNode: RectangleNode<Polyline, Point>, listOfIntersections: Array<IntersectionInfo>): void;
    LineCanBeAcceptedForRouting(ls: LineSegment): boolean;
    InsideOfTheAllowedConeOfBoundaryPort(pointToTest: Point, port: CurvePort): boolean;
    GetPointOnTheRightBoundaryPortConeSide(portLocation: Point, boundaryCurve: ICurve, curveIsClockwise: boolean, portParam: number): Point;
    GetPointOnTheLeftBoundaryPortConeSide(portLocation: Point, boundaryCurve: ICurve, curveIsClockwise: boolean, portParam: number): Point;
    SmoothenCorners(edgePolyline: SmoothedPolyline): void;
    SmoothOneCorner(a: CornerSite, c: CornerSite, b: CornerSite): CornerSite;
    TryToRemoveInflectionsAndCollinearSegments(underlyingPolyline: SmoothedPolyline): void;
    TryToRemoveInflectionEdge(t: {
        s: CornerSite;
    }): boolean;
    GetShortestPolyline(sourceVisVertex: VisibilityVertex, _targetVisVertex: VisibilityVertex): Polyline;
    CleanTheGraphForShortestPath(): void;
    get OverlapsDetected(): boolean;
    ConeSpannerAngle: number;
    get TightHierarchy(): RectangleNode<Polyline, Point>;
    set TightHierarchy(value: RectangleNode<Polyline, Point>);
    get LooseHierarchy(): RectangleNode<Polyline, Point>;
    set LooseHierarchy(value: RectangleNode<Polyline, Point>);
    UseSpanner: boolean;
    CalculateObstacles(): void;
    static constructorANNNB(obstacles: Array<ICurve>, padding: number, loosePadding: number, coneSpannerAngle: number, ignoreTightPadding: boolean): InteractiveEdgeRouter;
    RouteEdgeToLocation(targetLocation: Point): GeomEdge;
    RouteEdgeToPort(edgeTargetPort: Port, portLoosePolyline: Polyline, smooth: boolean, t: {
        smoothedPolyline: SmoothedPolyline;
    }): ICurve;
    SmoothedPolylineFromTwoPoints(s: Point, e: Point): SmoothedPolyline;
    RouteEdgeToFloatingPortOfNode(portLoosePolyline: Polyline, smooth: boolean, t: {
        smoothedPolyline: SmoothedPolyline;
    }): ICurve;
    RouteFromBoundaryPortToFloatingPort(targetPortLoosePolyline: Polyline, smooth: boolean, t: {
        smoothedPolyline: SmoothedPolyline;
    }): ICurve;
    SmoothCornersAndReturnCurve(smooth: boolean, t: {
        smoothedPolyline: SmoothedPolyline;
    }): ICurve;
    RouteFromFloatingPortToFloatingPort(portLoosePolyline: Polyline, smooth: boolean, t: {
        smoothedPolyline: SmoothedPolyline;
    }): ICurve;
    TryShortcutPolyPoint(pp: PolylinePoint): boolean;
    ExtendVisibilityGraphToLocationOfTargetFloatingPort(portLoosePolyline: Polyline): void;
    CalculateEdgeTargetVisibilityGraphForFloatingPort(targetLocation: Point, targetLoosePoly: Polyline): void;
    AddTransientVisibilityEdgesForPort(point: Point, loosePoly: Iterable<Point>): VisibilityVertex;
    GetVertex(point: Point): VisibilityVertex;
    LookForRoundedVertices: boolean;
    ObstacleCalculator: InteractiveObstacleCalculator;
    GetActivePolylinesWithException(targetLoosePoly: Polyline): IterableIterator<Polyline>;
    RouteEdgeToBoundaryPort(portLoosePolyline: Polyline, smooth: boolean, t: {
        smoothedPolyline: SmoothedPolyline;
    }): ICurve;
    RouteFromBoundaryPortToBoundaryPort(smooth: boolean, t: {
        smoothedPolyline: SmoothedPolyline;
    }): ICurve;
    RecoverSourceTargetTights(tmpSourceTight: Polyline, tmpTargetTight: Polyline): void;
    HideSourceTargetTightsIfNeeded(t: {
        tmpTargetTight: Polyline;
    }): Polyline;
    LineAvoidsTightHierarchy(lineSegment: LineSegment): boolean;
    RouteFromFloatingPortToBoundaryPort(smooth: boolean, r: {
        smoothedPolyline: SmoothedPolyline;
    }): ICurve;
    LineAvoidsTightHierarchyLP(ls: LineSegment, polylineToExclude: Polyline): boolean;
    LineAvoidsTightHierarchyLPP(ls: LineSegment, polylineToExclude0: Polyline, polylineToExclude1: Polyline): boolean;
    LineAvoidsTightHierarchyPPPP(a: Point, b: Point, polylineToExclude0: Polyline, polylineToExclude1: Polyline): boolean;
    ExtendVisibilityGraphToTargetBoundaryPort(takenOutTargetPortLocation: Point): void;
    GetHitLoosePolyline(point: Point): Polyline;
    static GetFirstHitPolyline(point: Point, rectangleNode: RectangleNode<Polyline, Point>): Polyline;
    static GetFirstHitRectangleNode(point: Point, rectangleNode: RectangleNode<Polyline, Point>): RectangleNode<Polyline, Point>;
    Clean(): void;
    SetSourcePortAndSourceLoosePolyline(port: Port, sourceLoosePolylinePar: Polyline): void;
    run(): void;
    CalculateWholeTangentVisibilityGraph(): void;
    CalculateWholeVisibilityGraphOnExistingGraph(): void;
    RouteSplineFromPortToPortWhenTheWholeGraphIsReady(sourcePortLocal: Port, targetPortLocal: Port, smooth: boolean, t: {
        smoothedPolyline: SmoothedPolyline;
    }): ICurve;
    GetEdgeGeomByRouting(smooth: boolean, t: {
        smoothedPolyline: SmoothedPolyline;
    }): ICurve;
    RouteFromFloatingPortToAnywherePort(targetLoosePoly: Polyline, smooth: boolean, t: {
        smoothedPolyline: SmoothedPolyline;
    }, port: HookUpAnywhereFromInsidePort): ICurve;
    BuildHook(port: HookUpAnywhereFromInsidePort): void;
    ExtendPolyline(tangentAtIntersection: Point, x: IntersectionInfo, polylineTangent: Point, port: HookUpAnywhereFromInsidePort): void;
    FixLastPolylinePointForAnywherePort(port: HookUpAnywhereFromInsidePort): void;
    static GetTrimmedCurveForHookingUpAnywhere(curve: ICurve, lastPointInside: PolylinePoint, x0: IntersectionInfo, x1: IntersectionInfo): ICurve;
    GetLastPointInsideOfCurveOnPolyline(curve: ICurve): PolylinePoint;
    GetShortestPolylineToMulitpleTargets(sourceVisVertex: VisibilityVertex, targets: Array<VisibilityVertex>): Polyline;
    Targets(targetLoosePoly: Polyline): Array<VisibilityVertex>;
    ExtendVisibilityGraphFromFloatingSourcePort(): void;
    FigureOutSourceTargetPolylinesAndActiveRectangle(): void;
    AllPolygons(): IterableIterator<Polygon>;
    GetVisibilityGraph(): VisibilityGraph;
    AddActivePolygons(polygons: Array<Polygon>): void;
    ClearActivePolygons(): void;
}
