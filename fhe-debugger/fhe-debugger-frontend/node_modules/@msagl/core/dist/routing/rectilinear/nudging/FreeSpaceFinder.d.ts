import { Point } from '../../../math/geometry/point';
import { Direction } from '../../../math/geometry/direction';
import { Polyline } from '../../../math/geometry/polyline';
import { PolylinePoint } from '../../../math/geometry/polylinePoint';
import { RBNode } from '../../../math/RBTree/rbNode';
import { RBTree } from '../../../math/RBTree/rbTree';
import { SweepEvent } from '../../spline/coneSpanner/SweepEvent';
import { VertexEvent } from '../../spline/coneSpanner/VertexEvent';
import { LineSweeperBase } from '../../visibility/LineSweeperBase';
import { SegmentBase } from '../../visibility/SegmentBase';
import { AxisEdge } from './AxisEdge';
import { AxisEdgeHighPointEvent } from './AxisEdgeHighPointEvent';
import { AxisEdgeLowPointEvent } from './AxisEdgeLowPointEvent';
import { AxisEdgesContainer } from './AxisEdgesContainer';
import { PathEdge } from './PathEdge';
import { DebugCurve } from '../../../math/geometry/debugCurve';
export declare class FreeSpaceFinder extends LineSweeperBase {
    static AreaComparisonEpsilon: number;
    xProjection: (a: Point) => number;
    edgeContainersTree: RBTree<AxisEdgesContainer>;
    PathOrders: Map<AxisEdge, Array<PathEdge>>;
    constructor(direction: Direction, obstacles: Array<Polyline>, axisEdgesToObstaclesTheyOriginatedFrom: Map<AxisEdge, Polyline>, pathOrders: Map<AxisEdge, Array<PathEdge>>, axisEdges: Array<AxisEdge>);
    AxisEdgesToObstaclesTheyOriginatedFrom: Map<AxisEdge, Polyline>;
    SweepPole: Direction;
    FindFreeSpace(): void;
    ProcessEvents(): void;
    ProcessEvent(sweepEvent: SweepEvent): void;
    ProcessHighEdgeEvent(edgeForNudgingHighPointEvent: AxisEdgeHighPointEvent): void;
    ProcessLowEdgeEvent(lowEdgeEvent: AxisEdgeLowPointEvent): void;
    TryToAddRightNeighbor(leftEdge: AxisEdge, rightEdge: AxisEdge): void;
    ProjectionsOfEdgesOverlap(leftEdge: AxisEdge, rightEdge: AxisEdge): boolean;
    GetObstacleBoundaries(color: string): Array<DebugCurve>;
    ConstraintEdgeWithObstaclesAtZ(edge: AxisEdge, point: Point): void;
    ConstraintEdgeWithObstaclesAtZFromRight(edge: AxisEdge, point: Point): void;
    GetActiveSideFromRight(point: Point): RBNode<SegmentBase>;
    ConstraintEdgeWithObstaclesAtZFromLeft(edge: AxisEdge, point: Point): void;
    static PointToTheLeftOfLineOrOnLineLocal(a: Point, linePoint0: Point, linePoint1: Point): boolean;
    static PointToTheRightOfLineOrOnLineLocal(a: Point, linePoint0: Point, linePoint1: Point): boolean;
    GetActiveSideFromLeft(point: Point): RBNode<SegmentBase>;
    static EdgeMidPoint(edge: AxisEdge): Point;
    GetOrCreateAxisEdgesContainer(edge: AxisEdge): RBNode<AxisEdgesContainer>;
    GetAxisEdgesContainerNode(point: Point): RBNode<AxisEdgesContainer>;
    ProcessVertexEvent(vertexEvent: VertexEvent): void;
    ProcessRightVertex(rightVertexEvent: VertexEvent, nextVertex: PolylinePoint): void;
    private RestrictEdgeContainerToTheRightOfEvent;
    NotRestricting(edge: AxisEdge, polyline: Polyline): boolean;
    ProcessPrevSegmentForRightVertex(rightVertexEvent: VertexEvent, site: Point): void;
    RemoveEdge(edge: AxisEdge): void;
    ProcessLeftVertex(leftVertexEvent: VertexEvent, nextVertex: PolylinePoint): void;
    private RestrictEdgeFromTheLeftOfEvent;
    GetContainerNodeToTheLeftOfEvent(site: Point): RBNode<AxisEdgesContainer>;
    private ProcessPrevSegmentForLeftVertex;
    InitTheQueueOfEvents(): void;
    AxisEdges: Array<AxisEdge>;
    EnqueueEventsForEdge(edge: AxisEdge): void;
    EdgeIsParallelToSweepDir(edge: AxisEdge): boolean;
    static EdgeHighPointEvent(edge: AxisEdge, point: Point): SweepEvent;
    static EdgeLowPointEvent(edge: AxisEdge, point: Point): SweepEvent;
    CompareAA(x: AxisEdgesContainer, y: AxisEdgesContainer): number;
}
