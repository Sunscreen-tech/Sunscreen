import { GeomEdge } from '../../../layout/core/geomEdge';
import { Port } from '../../../layout/core/port';
import { ICurve } from '../../../math/geometry/icurve';
import { Point } from '../../../math/geometry/point';
import { Polyline } from '../../../math/geometry/polyline';
import { RectangleNode } from '../../../math/geometry/RTree/rectangleNode';
import { GenericBinaryHeapPriorityQueue } from '../../../structs/genericBinaryHeapPriorityQueue';
import { BundlingSettings } from '../../BundlingSettings';
import { Cdt } from '../../ConstrainedDelaunayTriangulation/Cdt';
import { CdtEdge } from '../../ConstrainedDelaunayTriangulation/CdtEdge';
import { CdtTriangle } from '../../ConstrainedDelaunayTriangulation/CdtTriangle';
import { Shape } from '../../shape';
import { VisibilityGraph } from '../../visibility/VisibilityGraph';
import { VisibilityVertex } from '../../visibility/VisibilityVertex';
import { SdBoneEdge } from './SdBoneEdge';
import { SdVertex } from './SdVertex';
export declare class SdShortestPath {
    VisibilityGraph: VisibilityGraph;
    MakeTransparentShapesOfEdgeGeometry: (eg: GeomEdge) => Array<Shape>;
    BundlingSettings: BundlingSettings;
    geomEdges: GeomEdge[];
    ObstacleHierarchy: RectangleNode<Polyline, Point>;
    vertexArray: SdVertex[];
    cdt: Cdt;
    Gates: Set<CdtEdge>;
    EdgesToRoutes: Map<GeomEdge, Array<SdBoneEdge>>;
    EdgesToRouteSources: Map<GeomEdge, SdVertex>;
    CurrentEdgeGeometry: GeomEdge;
    VisibilityVerticesToSdVerts: Map<VisibilityVertex, SdVertex>;
    LengthCoefficient: number;
    Queue: GenericBinaryHeapPriorityQueue<SdVertex>;
    LowestCostToTarget: number;
    ClosestTargetVertex: SdVertex;
    capacityOverlowPenaltyMultiplier: number;
    sourceLoosePoly: Polyline;
    targetLoosePoly: Polyline;
    constructor(makeTransparentShapesOfEdgeGeometryAndGetTheShapes: (e: GeomEdge) => Array<Shape>, cdt: Cdt, gates: Set<CdtEdge>);
    CreateGraphElements(): void;
    CreateRoutingGraph(): void;
    RouteEdges(): void;
    SetEdgeGeometryCurve(geomEdge: GeomEdge): void;
    static ExtendPolylineEndToClusterBoundary(poly: Polyline, curve: ICurve): void;
    static ExtendPolylineStartToClusterBoundary(poly: Polyline, curve: ICurve): void;
    RerouteEdges(): void;
    RestoreCapacities(): void;
    RerouteEdge(geomEdge: GeomEdge): Array<SdBoneEdge>;
    RouteEdge(geomEdge: GeomEdge): Array<SdBoneEdge>;
    RouteEdgeWithGroups(): Array<SdBoneEdge>;
    RouteOnKnownSourceTargetVertices(pathDirection: Point, lookingForMonotonePath: boolean): Array<SdBoneEdge>;
    ProcessOutcomingBoneEdge(v: SdVertex, outBoneEdge: SdBoneEdge, pathDirection: Point, lookingForMonotonePath: boolean): void;
    ProcessIncomingBoneEdge(v: SdVertex, inBoneEdge: SdBoneEdge, pathDirection: Point, lookingForMonotonePath: boolean): void;
    ProcessBoneEdge(v: SdVertex, queueCandidate: SdVertex, boneEdge: SdBoneEdge): void;
    GetPathAndUpdateRelatedCosts(): Array<SdBoneEdge>;
    RegisterPathInBoneEdge(boneEdge: SdBoneEdge): void;
    UpdateResidualCostsOfCrossedCdtEdges(boneEdge: SdBoneEdge): void;
    H(v: SdVertex): number;
    GetEdgeAdditionalCost(boneEdge: SdBoneEdge, previousCost: number): number;
    CapacityOverflowCost(boneEdge: SdBoneEdge): number;
    CrossedCdtEdgesOfBoneEdge(boneEdge: SdBoneEdge): Array<CdtEdge>;
    ThreadBoneEdgeThroughCdt(boneEdge: SdBoneEdge): Set<CdtEdge>;
    static CostOfCrossingCdtEdge(capacityOverflMult: number, bundlingSettings: BundlingSettings, currentEdgeGeometry: GeomEdge, e: CdtEdge): number;
    CostOfCrossingCdtEdgeLocal(capacityOverflMult: number, bundlingSettings: BundlingSettings, currentEdgeGeometry: GeomEdge, e: CdtEdge): number;
    AdjacentToSourceOrTarget(e: CdtEdge): boolean;
    SetLengthCoefficient(): void;
    GetIdealDistanceBetweenSourceAndTarget(geomEdge: GeomEdge): number;
    SetPortVerticesAndObstacles(port: Port, sources: boolean): Polyline;
    Enqueue(simpleSdVertex: SdVertex): void;
    AddAndEnqueueVertexToEnds(point: Point, isSource: boolean, initialCost: number): void;
    FindVertex(p: Point): VisibilityVertex;
    Initialize(): void;
    CalculateCapacitiesOfTrianglulation(): void;
    static CalculateCdtEdgeCapacityForEdge(e: CdtEdge): void;
    SetVertexTriangles(): void;
    TryToAssigenTriangleToVertex(triangle: CdtTriangle, vertex: SdVertex): void;
    static CapacityOverflowPenaltyMultiplier(bundlingSettings: BundlingSettings): number;
    FillCrossedCdtEdges(crossedCdtEdges: Map<GeomEdge, Set<CdtEdge>>): void;
}
