import { Point } from '../../..';
import { Polyline } from '../../../math/geometry';
import { PolylinePoint } from '../../../math/geometry/polylinePoint';
import { RectangleNode } from '../../../math/geometry/RTree/rectangleNode';
import { PointPairMap } from '../../../utils/pointPairMap';
import { PointSet } from '../../../utils/PointSet';
import { BundlingSettings } from '../../BundlingSettings';
import { MetroGraphData } from './MetroGraphData';
import { Metroline } from './MetroLine';
import { Station } from './Station';
import { TupleMap } from './tupleMap';
export declare class StationPositionsAdjuster {
    bundlingSettings: BundlingSettings;
    metroGraphData: MetroGraphData;
    constructor(metroGraphData: MetroGraphData, bundlingSettings: BundlingSettings);
    /**  apply a number of heuristics to improve current routing */
    static FixRouting(metroGraphData: MetroGraphData, bundlingSettings: BundlingSettings): void;
    /** unite the nodes that are close to each other */
    GlueConflictingStations(): boolean;
    GetCirclesHierarchy(): RectangleNode<Station, Point>;
    GetCurrentHubRadius(node: Station): number;
    TryToGlueStations(i: Station, j: Station, gluingMap: Map<Station, Station>, gluedDomain: Set<Station>): boolean;
    TryGlueOrdered(i: Station, j: Station, gluedDomain: Set<Station>, gluingMap: Map<Station, Station>): boolean;
    Map(i: Station, j: Station, gluedDomain: Set<Station>, gluingMap: Map<Station, Station>): void;
    /**  trying to glue i to j */
    StationGluingIsAllowed(i: Station, j: Station, gluingMap: Map<Station, Station>): boolean;
    ComputeCostDeltaAfterStationGluing(i: Station, j: Station, gluingMap: Map<Station, Station>): number;
    RegenerateEdge(gluingMap: Map<Station, Station>, edgeIndex: number): void;
    static GluedPolyline(metroline: Station[], gluedMap: Map<Station, Station>): Array<Point>;
    static Glued(i: Station, gluedMap: Map<Station, Station>): Station;
    ink: number;
    polylineLength: Map<Metroline, number>;
    UnglueEdgesFromBundleToSaveInk(alwaysExecuteSA: boolean): boolean;
    TrySeparateOnPolyline(metroline: Metroline, segsToPolylines: PointPairMap<Set<Metroline>>, affectedPoints: PointSet, obstaclesAllowedToIntersect: Set<Polyline>): boolean;
    TryShortcutPolypoint(pp: PolylinePoint, segsToPolylines: PointPairMap<Set<Metroline>>, affectedPoints: PointSet, obstaclesAllowedToIntersect: Set<Polyline>): boolean;
    SeparationShortcutAllowed(pp: PolylinePoint, segsToPolylines: PointPairMap<Set<Metroline>>, obstaclesAllowedToIntersect: Set<Polyline>): boolean;
    GetInkgain(pp: PolylinePoint, segsToPolylines: PointPairMap<Set<Metroline>>, a: Point, b: Point, c: Point): number;
    RemoveShortcuttedPolypoint(pp: PolylinePoint, segsToPolylines: PointPairMap<Set<Metroline>>): void;
    FindPolylines(pp: PolylinePoint, segsToPolylines: PointPairMap<Set<Metroline>>): [Set<Metroline>, Set<Metroline>, Set<Metroline>];
    RemovePolypoint(p: PolylinePoint): void;
    /**   Fix the situation where a station has two neighbors that are almost in the same directions */
    GlueCollinearNeighbors(step: number): boolean;
    GlueCollinearNeighborsSPN(node: Station, affectedPoints: PointSet, step: number): boolean;
    TryToGlueEdges(node: Station, a: Station, b: Station, gluedEdges: TupleMap<Station, Station, Point>, step: number): void;
    ConstructGluingPoint(node: Station, a: Station, b: Station): Point;
    EdgeGluingIsAllowedSSS(node: Station, a: Station, b: Station): boolean;
    EdgeGluingIsAllowedSSSP(node: Station, a: Station, b: Station, gluingPoint: Point): boolean;
    ComputeCostDeltaAfterEdgeGluing(node: Station, a: Station, b: Station, newp: Point): number;
    AddEdgeToGlue(node: Station, b: Station, a: Station, newp: Point, gluedEdges: TupleMap<Station, Station, Point>): void;
    GlueEdge(keyValuePair: [Station, Station, Point]): void;
    SplitPolylinePoint(node: PolylinePoint, pointToInsert: Point): void;
    RelaxConstrainedEdges(): boolean;
    RelaxConstrainedEdge(a: Station, b: Station, affectedPoints: PointSet): boolean;
    RemoveDoublePathCrossings(): boolean;
}
