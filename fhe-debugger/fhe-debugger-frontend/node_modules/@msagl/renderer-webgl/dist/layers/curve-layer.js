import { Layer, project32, UNIT, createIterable, } from '@deck.gl/core/typed';
import GL from '@luma.gl/constants';
import { Model, Geometry } from '@luma.gl/engine';
import { picking } from '@luma.gl/shadertools';
const MAX_DRAW_COUNT = 16;
export var CURVE;
(function (CURVE) {
    CURVE[CURVE["Line"] = 0] = "Line";
    CURVE[CURVE["Bezier"] = 1] = "Bezier";
    CURVE[CURVE["Arc"] = 2] = "Arc";
})(CURVE || (CURVE = {}));
const defaultProps = {
    widthUnits: 'common',
    widthScale: { type: 'number', min: 0, value: 1 },
    widthMinPixels: { type: 'number', min: 0, value: 0 },
    widthMaxPixels: { type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER },
    /**
     * CURVE.Line: [startX, startY, endX, endY]
     * CURVE.Bezier: [startX, startY, ctrlPoint1X, ctrPoint1Y, ctrlPoint2X, ctrPoint2Y, endX, endY]
     * CURVE.Arc: [centerX, centerY, axis1X, axis1Y, axis2X, axis2Y, startAngle, endAngle]
     */
    getControlPoints: { type: 'accessor', value: (d) => d.points },
    getCurveType: { type: 'accessor', value: CURVE.Line },
    getResolution: { type: 'accessor', value: 4 },
    getRange: { type: 'accessor', value: [0, 1] },
    getWidth: { type: 'accessor', value: 1 },
    getColor: { type: 'accessor', value: [0, 0, 0, 255] },
};
const vs = `\
#define SHADER_NAME curve-layer-vertex-shader
#define LINE    0.0
#define BEZIER  1.0
#define ARC     2.0

attribute vec2 positions;
attribute vec2 instanceSegments;
attribute vec4 instancePositions1;
attribute vec4 instancePositions2;
attribute float instanceTypes;
attribute float instanceWidths;
attribute vec4 instanceColors;

uniform float opacity;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform int widthUnits;

varying vec4 vColor;

void interpolateLine(float t, vec2 start, vec2 end, out vec2 point) {
  point = mix(start, end, t);
}

void interpolateBezierCurve(float t, vec2 start, vec2 c1, vec2 c2, vec2 end, out vec2 point) {
  vec2 c = (c1 - start) * 3.0;
  vec2 e = (c2 - c1) * 3.0 - c;
  vec2 l = end - start - c - e;

  float t2 = t * t;
  float t3 = t2 * t;
  
  point = l * t3 + e * t2 + c * t + start;
}

void interpolateArc(float t, vec2 center, vec2 aAxis, vec2 bAxis, out vec2 point) {
  point = center + cos(t) * aAxis + sin(t) * bAxis;
}

vec2 getExtrusionOffset(vec2 line, float offset_direction, float width) {
  // normalized direction of the line
  vec2 dir = normalize(line);
  // rotate by 90 degrees
  dir = vec2(-dir.y, dir.x);
  return dir * offset_direction * width / 2.0;
}

void main(void) {
  // Multiply out line width and clamp to limits
  float widthPixels = clamp(
    project_size_to_pixel(widthScale * instanceWidths, widthUnits),
    widthMinPixels, widthMaxPixels
  );
  float widthCommon = project_pixel_size(widthPixels);

  geometry.uv = positions.xy;

  vec2 pointOnCurve;
  vec2 nextPointOnCurve;
  vec2 pointOnCurve64Low = vec2(0.0);
  float r = instanceSegments.x + positions.x * instanceSegments.y;
  float rNext = r + instanceSegments.y;

  if (instanceTypes == BEZIER) {
    interpolateBezierCurve(r, instancePositions1.xy, instancePositions1.zw, instancePositions2.xy, instancePositions2.zw, pointOnCurve);
    interpolateBezierCurve(rNext, instancePositions1.xy, instancePositions1.zw, instancePositions2.xy, instancePositions2.zw, nextPointOnCurve);
  }
  else if (instanceTypes == ARC) {
    interpolateArc(r, instancePositions1.xy, instancePositions1.zw, instancePositions2.xy, pointOnCurve);
    interpolateArc(rNext, instancePositions1.xy, instancePositions1.zw, instancePositions2.xy, nextPointOnCurve);
  }
  else {
    interpolateLine(r, instancePositions1.xy, instancePositions1.zw, pointOnCurve);
    interpolateLine(rNext, instancePositions1.xy, instancePositions1.zw, nextPointOnCurve);
  }
  
  vec3 offset = vec3(getExtrusionOffset(
    nextPointOnCurve - pointOnCurve,
    positions.y,
    widthCommon), 0.0);

  gl_Position = project_position_to_clipspace(
    vec3(pointOnCurve, 0.0),
    vec3(pointOnCurve64Low, 0.0),
    offset,
    geometry.position);

  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  // Apply opacity to instance color, or return instance picking color
  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;
const fs = `\
#define SHADER_NAME curve-layer-fragment-shader
varying vec4 vColor;

void main(void) {
  gl_FragColor = vColor;
  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`;
export default class CurveLayer extends Layer {
    getShaders() {
        return super.getShaders({ vs, fs, modules: [project32, picking] });
    }
    initializeState() {
        this.getAttributeManager().addInstanced({
            instancePositions: {
                size: 8,
                // type: GL.DOUBLE,
                // fp64: true,
                transition: true,
                accessor: 'getControlPoints',
                shaderAttributes: {
                    instancePositions1: {
                        size: 4,
                    },
                    instancePositions2: {
                        size: 4,
                        elementOffset: 4,
                    },
                },
            },
            instanceSegments: {
                size: 2,
                update: this._getSegments,
            },
            instanceTypes: {
                size: 1,
                type: GL.UNSIGNED_BYTE,
                accessor: 'getCurveType',
            },
            instanceWidths: {
                size: 1,
                transition: true,
                accessor: 'getWidth',
                defaultValue: 1,
            },
            instanceColors: {
                size: 4,
                transition: true,
                normalized: true,
                type: GL.UNSIGNED_BYTE,
                accessor: 'getColor',
                defaultValue: [0, 0, 0, 255],
            },
        });
    }
    updateState(params) {
        var _a;
        super.updateState(params);
        const { props, changeFlags } = params;
        if (changeFlags.dataChanged) {
            this.updateGeometry();
        }
        if (changeFlags.extensionsChanged) {
            const { gl } = this.context;
            (_a = this.state.model) === null || _a === void 0 ? void 0 : _a.delete();
            this.state.model = this._getModel(gl);
            this.getAttributeManager().invalidateAll();
        }
    }
    updateGeometry() {
        const { data, getResolution, getCurveType, getRange } = this.props;
        const { iterable, objectInfo } = createIterable(data);
        const startIndices = [0];
        let numInstances = 0;
        const segments = [];
        for (const object of iterable) {
            objectInfo.index++;
            const type = typeof getCurveType === 'function' ? getCurveType(object, objectInfo) : getCurveType;
            const range = typeof getRange === 'function' ? getRange(object, objectInfo) : getRange;
            const res = type === CURVE.Line ? 1 : Math.ceil(typeof getResolution === 'function' ? getResolution(object, objectInfo) : getResolution);
            numInstances += res;
            const step = (range[1] - range[0]) / res;
            startIndices.push(numInstances);
            for (let i = 0; i < res; i++) {
                segments.push(range[0] + step * i, step);
            }
        }
        this.setState({ startIndices, numInstances, segments: new Float32Array(segments) });
    }
    draw({ uniforms }) {
        const { widthUnits, widthScale, widthMinPixels, widthMaxPixels } = this.props;
        this.state.model
            .setUniforms(uniforms)
            .setUniforms({
            widthUnits: UNIT[widthUnits],
            widthScale,
            widthMinPixels,
            widthMaxPixels,
        })
            .draw();
    }
    _getModel(gl) {
        const positions = [0, -1, 1, -1, 1, 1, 0, 1];
        return new Model(gl, {
            ...this.getShaders(),
            id: this.props.id,
            geometry: new Geometry({
                drawMode: GL.TRIANGLE_FAN,
                vertexCount: 4,
                attributes: {
                    positions: { size: 2, value: new Float32Array(positions) },
                },
            }),
            isInstanced: true,
        });
    }
    _getSegments(attribute) {
        attribute.value = this.state.segments;
    }
}
CurveLayer.layerName = 'CurveLayer';
CurveLayer.defaultProps = defaultProps;
//# sourceMappingURL=curve-layer.js.map