#pragma once

#include <inttypes.clhpp>

class Radix16 {
private:
    i8 data[64];

public:
    i8& operator[](size_t i) {
        return data[i];
    }

    const i8& operator[](size_t i) const {
        return data[i];
    }
};

class Scalar29 {
private:
    u32 _limbs[9];

    Scalar29 montgomery_invert() const;

public:
    static Scalar29 Zero();

    constexpr Scalar29(u32 l0, u32 l1, u32 l2, u32 l3, u32 l4, u32 l5, u32 l6, u32 l7, u32 l8): _limbs{l0, l1, l2, l3, l4, l5, l6, l7, l8} {

    }
    Scalar29(const u32 limbs[9]): _limbs{limbs[0], limbs[1], limbs[2], limbs[3], limbs[4], limbs[5], limbs[6], limbs[7], limbs[8]} {}

    //Scalar29(u32 limbs[9]): _limbs{limbs[0], limbs[1], limbs[2], limbs[3], limbs[4], limbs[5], limbs[6], limbs[7], limbs[8]} {}

    /// Loads the value at grid_tid from an `8 x n` row-major u32 matrix. `n` is the length
    /// of the Scalar array.
    ///
    /// # Remarks
    /// Each thread should pass the same base address.
    ///
    /// When reach thread in a group executes this
    /// function with a consecutive grid_tid,
    /// unpacking is fully coalesced.
    static Scalar29 unpack(const u32* ptr, size_t grid_tid, size_t n);
    
    /// Packs this value into an `8 x n` row-major 
    /// u32 matrix.
    ///
    /// # Remarks
    /// Each thread should pass the same base address.
    ///
    /// When reach thread in a group executes this
    /// function with a consecutive grid_tid,
    /// unpacking is fully coalesced.
    void pack(u32* ptr, size_t grid_tid, size_t n);
    
    static Scalar29 add(const Scalar29 a, const Scalar29 b);
    static Scalar29 sub(const Scalar29 a, const Scalar29 b);
    static Scalar29 mul(const Scalar29 a, const Scalar29 b);
    static Scalar29 square(const Scalar29 a);

    Scalar29 operator+(const Scalar29& other) const {
        return Scalar29::add(*this, other);
    }

    Scalar29 operator-(const Scalar29& other) const {
        return Scalar29::sub(*this, other);
    }

    Scalar29 operator*(const Scalar29& other) const {
        return Scalar29::mul(*this, other);
    }

    Scalar29 operator-() const {
        return Scalar29::sub(Zero(), *this);
    }

    Scalar29 invert() const;

    Scalar29 square() const {
        return square(*this);
    }

    const u32& operator[](const size_t index) const {
        return _limbs[index];
    }

    u32& operator[](const size_t index) {
        return _limbs[index];
    }

    Radix16 as_radix_16() const;
};
