{"version":3,"sources":["../../../src/layers/h3-tileset-2d.ts"],"names":["getHexagonsInBoundingBox","resolution","west","north","east","south","longitudeSpan","Math","abs","nSegments","ceil","h3Indices","s","segmentEast","segmentWest","min","concat","Set","oversample","map","i","tileToBoundingBox","index","coordinates","latitudes","c","longitudes","max","BIAS","getHexagonResolution","viewport","hexagonScaleFactor","zoom","latitudeScaleFactor","log","cos","PI","latitude","floor","H3Tileset2D","minZoom","maxZoom","undefined","getBounds","z","indices","Number","isFinite","center","longitude","bbox","Tileset2D"],"mappings":"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","sourcesContent":["import {_Tileset2D as Tileset2D, GeoBoundingBox} from '@deck.gl/geo-layers';\nimport {polyfill, geoToH3, h3GetResolution, h3ToGeoBoundary, h3ToParent, kRing} from 'h3-js';\n\nexport type H3TileIndex = {i: string};\n\nfunction getHexagonsInBoundingBox(\n  {west, north, east, south}: GeoBoundingBox,\n  resolution: number\n): string[] {\n  const longitudeSpan = Math.abs(east - west);\n  if (longitudeSpan > 180) {\n    // This is a known issue in h3-js: polyfill does not work correctly\n    // when longitude span is larger than 180 degrees.\n    const nSegments = Math.ceil(longitudeSpan / 180);\n    let h3Indices: string[] = [];\n    for (let s = 0; s < nSegments; s++) {\n      const segmentEast = east + s * 180;\n      const segmentWest = Math.min(segmentEast + 179.9999999, west);\n      h3Indices = h3Indices.concat(\n        getHexagonsInBoundingBox({west: segmentWest, north, east: segmentEast, south}, resolution)\n      );\n    }\n    return [...new Set(h3Indices)];\n  }\n\n  // `polyfill()` fills based on hexagon center, which means tiles vanish\n  // prematurely. Get more accurate coverage by oversampling\n  const oversample = 2;\n  const h3Indices = polyfill(\n    [\n      [\n        [west, north],\n        [west, south],\n        [east, south],\n        [east, north],\n        [west, north]\n      ]\n    ],\n    resolution + oversample,\n    true\n  );\n\n  return oversample ? [...new Set(h3Indices.map(i => h3ToParent(i, resolution)))] : h3Indices;\n}\n\nfunction tileToBoundingBox(index: string): GeoBoundingBox {\n  const coordinates = h3ToGeoBoundary(index);\n  const latitudes = coordinates.map(c => c[0]);\n  const longitudes = coordinates.map(c => c[1]);\n  const west = Math.min(...longitudes);\n  const south = Math.min(...latitudes);\n  const east = Math.max(...longitudes);\n  const north = Math.max(...latitudes);\n  return {west, south, east, north};\n}\n\n// Resolution conversion function. Takes a WebMercatorViewport and returns\n// a H3 resolution such that the screen space size of the hexagons is\n// similar\n// Relative scale factor (0 = no biasing, 2 = a few hexagons cover view)\nconst BIAS = 2;\nexport function getHexagonResolution(viewport): number {\n  const hexagonScaleFactor = (2 / 3) * viewport.zoom;\n  const latitudeScaleFactor = Math.log(1 / Math.cos((Math.PI * viewport.latitude) / 180));\n\n  // Clip and bias\n  return Math.max(0, Math.floor(hexagonScaleFactor + latitudeScaleFactor - BIAS));\n}\n\nexport default class H3Tileset2D extends Tileset2D {\n  /**\n   * Returns all tile indices in the current viewport. If the current zoom level is smaller\n   * than minZoom, return an empty array. If the current zoom level is greater than maxZoom,\n   * return tiles that are on maxZoom.\n   */\n  // @ts-expect-error Tileset2D should be generic over TileIndex\n  getTileIndices({viewport, minZoom, maxZoom}): H3TileIndex[] {\n    if (viewport.latitude === undefined) return [];\n    const [east, south, west, north] = viewport.getBounds();\n\n    let z = getHexagonResolution(viewport);\n    let indices: string[];\n    if (typeof minZoom === 'number' && Number.isFinite(minZoom) && z < minZoom) {\n      // TODO support `extent` prop\n      return [];\n    }\n    if (typeof maxZoom === 'number' && Number.isFinite(maxZoom) && z > maxZoom) {\n      z = maxZoom;\n\n      // Once we are at max zoom, getHexagonsInBoundingBox doesn't work, simply\n      // get a ring centered on the hexagon in the viewport center\n      const center = geoToH3(viewport.latitude, viewport.longitude, maxZoom);\n      indices = kRing(center, 1);\n    } else {\n      indices = getHexagonsInBoundingBox({west, north, east, south}, z);\n    }\n\n    return indices.map(i => ({i}));\n  }\n\n  // @ts-expect-error Tileset2D should be generic over TileIndex\n  getTileId({i}: H3TileIndex): string {\n    return i;\n  }\n\n  // @ts-expect-error Tileset2D should be generic over TileIndex\n  getTileMetadata({i}: H3TileIndex) {\n    return {bbox: tileToBoundingBox(i)};\n  }\n\n  // @ts-expect-error Tileset2D should be generic over TileIndex\n  getTileZoom({i}: H3TileIndex): number {\n    return h3GetResolution(i);\n  }\n\n  // @ts-expect-error Tileset2D should be generic over TileIndex\n  getParentIndex(index: H3TileIndex): H3TileIndex {\n    const resolution = h3GetResolution(index.i);\n    const i = h3ToParent(index.i, resolution - 1);\n    return {i};\n  }\n}\n"],"file":"h3-tileset-2d.js"}