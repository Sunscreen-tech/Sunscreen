{"version":3,"sources":["../../src/resolve-layers.ts"],"names":["_flatten","flatten","MapboxLayer","UNDEFINED_BEFORE_ID","resolveLayers","map","deck","oldLayers","newLayers","style","_loaded","layers","Boolean","prevLayers","prevLayerIds","Set","l","id","layer","delete","getLayer","removeLayer","mapboxLayer","implementation","setProps","props","addLayer","beforeId","mapLayers","_order","layerGroups","includes","push","layerGroup","lastLayerIndex","length","indexOf","lastLayerId","undefined","i","layerId","layerIndex","moveLayer"],"mappings":"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","sourcesContent":["import {_flatten as flatten} from '@deck.gl/core';\nimport MapboxLayer from './mapbox-layer';\n\nimport type {Deck, LayersList, Layer} from '@deck.gl/core';\nimport type {Map} from 'mapbox-gl';\n\nconst UNDEFINED_BEFORE_ID = '__UNDEFINED__';\n\n/** Insert Deck layers into the mapbox Map according to the user-defined order */\n// eslint-disable-next-line complexity, max-statements\nexport function resolveLayers(\n  map?: Map,\n  deck?: Deck,\n  oldLayers?: LayersList,\n  newLayers?: LayersList\n) {\n  // Wait until map style is loaded\n  // @ts-ignore non-public map property\n  if (!map || !deck || !map.style || !map.style._loaded) {\n    return;\n  }\n\n  const layers = flatten(newLayers, Boolean) as Layer[];\n\n  if (oldLayers !== newLayers) {\n    // Step 1: remove layers that no longer exist\n    const prevLayers = flatten(oldLayers, Boolean) as Layer[];\n    const prevLayerIds = new Set<string>(prevLayers.map(l => l.id));\n\n    for (const layer of layers) {\n      prevLayerIds.delete(layer.id);\n    }\n\n    for (const id of prevLayerIds) {\n      if (map.getLayer(id)) {\n        map.removeLayer(id);\n      }\n    }\n  }\n\n  // Step 2: add missing layers\n  for (const layer of layers) {\n    const mapboxLayer = map.getLayer(layer.id) as MapboxLayer<Layer>;\n    if (mapboxLayer) {\n      // @ts-expect-error not typed\n      mapboxLayer.implementation.setProps(layer.props);\n    } else {\n      map.addLayer(\n        new MapboxLayer({id: layer.id, deck}),\n        // @ts-expect-error beforeId is not defined in LayerProps\n        layer.props.beforeId\n      );\n    }\n  }\n\n  // Step 3: check the order of layers\n  // If beforeId is defined, the deck layer should always render before the mapbox layer [beforeId]\n  // If beforeId is not defined, the deck layer should appear after all mapbox layers\n  // When two deck layers share the same beforeId, they are rendered in the order that is passed into Deck props.layers\n  // @ts-ignore non-public map property\n  const mapLayers: string[] = map.style._order;\n\n  // Group deck layers by beforeId\n  const layerGroups: Record<string, string[]> = {};\n  for (const layer of layers) {\n    // @ts-expect-error beforeId is not defined in LayerProps\n    let {beforeId} = layer.props;\n    if (!beforeId || !mapLayers.includes(beforeId)) {\n      beforeId = UNDEFINED_BEFORE_ID;\n    }\n    layerGroups[beforeId] = layerGroups[beforeId] || [];\n    layerGroups[beforeId].push(layer.id);\n  }\n\n  for (const beforeId in layerGroups) {\n    const layerGroup = layerGroups[beforeId];\n    let lastLayerIndex =\n      beforeId === UNDEFINED_BEFORE_ID ? mapLayers.length : mapLayers.indexOf(beforeId);\n    let lastLayerId = beforeId === UNDEFINED_BEFORE_ID ? undefined : beforeId;\n    for (let i = layerGroup.length - 1; i >= 0; i--) {\n      const layerId = layerGroup[i];\n      const layerIndex = mapLayers.indexOf(layerId);\n      if (layerIndex !== lastLayerIndex - 1) {\n        map.moveLayer(layerId, lastLayerId);\n        if (layerIndex > lastLayerIndex) {\n          // The last layer's index have changed\n          lastLayerIndex++;\n        }\n      }\n      lastLayerIndex--;\n      lastLayerId = layerId;\n    }\n  }\n}\n"],"file":"resolve-layers.js"}