"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = loadTerrain;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _schema = require("@loaders.gl/schema");
var _martini = _interopRequireDefault(require("@mapbox/martini"));
var _delatin = _interopRequireDefault(require("./delatin"));
var _skirt = require("./helpers/skirt");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function getTerrain(imageData, width, height, elevationDecoder, tesselator) {
  var rScaler = elevationDecoder.rScaler,
    bScaler = elevationDecoder.bScaler,
    gScaler = elevationDecoder.gScaler,
    offset = elevationDecoder.offset;
  var terrain = new Float32Array((width + 1) * (height + 1));
  for (var i = 0, y = 0; y < height; y++) {
    for (var x = 0; x < width; x++, i++) {
      var k = i * 4;
      var r = imageData[k + 0];
      var g = imageData[k + 1];
      var b = imageData[k + 2];
      terrain[i + y] = r * rScaler + g * gScaler + b * bScaler + offset;
    }
  }
  if (tesselator === 'martini') {
    for (var _i = (width + 1) * width, _x = 0; _x < width; _x++, _i++) {
      terrain[_i] = terrain[_i - width - 1];
    }
    for (var _i2 = height, _y = 0; _y < height + 1; _y++, _i2 += height + 1) {
      terrain[_i2] = terrain[_i2 - 1];
    }
  }
  return terrain;
}
function getMeshAttributes(vertices, terrain, width, height, bounds) {
  var gridSize = width + 1;
  var numOfVerticies = vertices.length / 2;
  var positions = new Float32Array(numOfVerticies * 3);
  var texCoords = new Float32Array(numOfVerticies * 2);
  var _ref = bounds || [0, 0, width, height],
    _ref2 = (0, _slicedToArray2.default)(_ref, 4),
    minX = _ref2[0],
    minY = _ref2[1],
    maxX = _ref2[2],
    maxY = _ref2[3];
  var xScale = (maxX - minX) / width;
  var yScale = (maxY - minY) / height;
  for (var i = 0; i < numOfVerticies; i++) {
    var x = vertices[i * 2];
    var y = vertices[i * 2 + 1];
    var pixelIdx = y * gridSize + x;
    positions[3 * i + 0] = x * xScale + minX;
    positions[3 * i + 1] = -y * yScale + maxY;
    positions[3 * i + 2] = terrain[pixelIdx];
    texCoords[2 * i + 0] = x / width;
    texCoords[2 * i + 1] = y / height;
  }
  return {
    POSITION: {
      value: positions,
      size: 3
    },
    TEXCOORD_0: {
      value: texCoords,
      size: 2
    }
  };
}
function getMesh(terrainImage, terrainOptions) {
  if (terrainImage === null) {
    return null;
  }
  var meshMaxError = terrainOptions.meshMaxError,
    bounds = terrainOptions.bounds,
    elevationDecoder = terrainOptions.elevationDecoder;
  var data = terrainImage.data,
    width = terrainImage.width,
    height = terrainImage.height;
  var terrain;
  var mesh;
  switch (terrainOptions.tesselator) {
    case 'martini':
      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);
      mesh = getMartiniTileMesh(meshMaxError, width, terrain);
      break;
    case 'delatin':
      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);
      mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);
      break;
    default:
      if (width === height && !(height & width - 1)) {
        terrain = getTerrain(data, width, height, elevationDecoder, 'martini');
        mesh = getMartiniTileMesh(meshMaxError, width, terrain);
      } else {
        terrain = getTerrain(data, width, height, elevationDecoder, 'delatin');
        mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);
      }
      break;
  }
  var _mesh = mesh,
    vertices = _mesh.vertices;
  var _mesh2 = mesh,
    triangles = _mesh2.triangles;
  var attributes = getMeshAttributes(vertices, terrain, width, height, bounds);
  var boundingBox = (0, _schema.getMeshBoundingBox)(attributes);
  if (terrainOptions.skirtHeight) {
    var _addSkirt = (0, _skirt.addSkirt)(attributes, triangles, terrainOptions.skirtHeight),
      newAttributes = _addSkirt.attributes,
      newTriangles = _addSkirt.triangles;
    attributes = newAttributes;
    triangles = newTriangles;
  }
  return {
    loaderData: {
      header: {}
    },
    header: {
      vertexCount: triangles.length,
      boundingBox: boundingBox
    },
    mode: 4,
    indices: {
      value: Uint32Array.from(triangles),
      size: 1
    },
    attributes: attributes
  };
}
function getMartiniTileMesh(meshMaxError, width, terrain) {
  var gridSize = width + 1;
  var martini = new _martini.default(gridSize);
  var tile = martini.createTile(terrain);
  var _tile$getMesh = tile.getMesh(meshMaxError),
    vertices = _tile$getMesh.vertices,
    triangles = _tile$getMesh.triangles;
  return {
    vertices: vertices,
    triangles: triangles
  };
}
function getDelatinTileMesh(meshMaxError, width, height, terrain) {
  var tin = new _delatin.default(terrain, width + 1, height + 1);
  tin.run(meshMaxError);
  var coords = tin.coords,
    triangles = tin.triangles;
  var vertices = coords;
  return {
    vertices: vertices,
    triangles: triangles
  };
}
function loadTerrain(_x2, _x3, _x4) {
  return _loadTerrain.apply(this, arguments);
}
function _loadTerrain() {
  _loadTerrain = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(arrayBuffer, options, context) {
    var loadImageOptions, image;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          loadImageOptions = _objectSpread(_objectSpread({}, options), {}, {
            mimeType: 'application/x.image',
            image: _objectSpread(_objectSpread({}, options.image), {}, {
              type: 'data'
            })
          });
          _context.next = 3;
          return context.parse(arrayBuffer, loadImageOptions);
        case 3:
          image = _context.sent;
          return _context.abrupt("return", getMesh(image, options.terrain));
        case 5:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _loadTerrain.apply(this, arguments);
}
//# sourceMappingURL=parse-terrain.js.map