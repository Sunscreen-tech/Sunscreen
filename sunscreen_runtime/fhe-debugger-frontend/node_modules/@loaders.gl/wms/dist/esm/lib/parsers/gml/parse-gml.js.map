{"version":3,"file":"parse-gml.js","names":["XMLLoader","deepStrictEqual","rewind","noTransform","_len","arguments","length","coords","Array","_key","parseGML","text","options","parsedXML","parseTextSync","transformCoords","stride","context","createChildContext","parseGMLToGeometry","inputXML","childContext","geometry","name","xml","getFirstKeyValue","type","coordinates","parseLinearRingOrLineString","parsePolygonOrRectangle","parseSurface","parseMultiSurface","mutate","parseCoords","s","srsDimension","replace","trim","split","Error","concat","points","i","_options$transformCoo","point","slice","map","parseFloat","push","call","parsePosList","textOf","parsePos","parsePoint","pos","findIn","posList","childName","childXML","Object","entries","parseCurveSegments","points2","end","start","shift","parseRing","lineString","segments","parseExteriorOrInterior","linearRing","ring","exterior","pointLists","patches","polygons","parseCompositeSurface","c2Name","c2Xml","el","surfaceMembers","polygons2","polygons3","parseSurfaceMember","polygonXML","surfaceMemberXML","childXml","root","_len2","tags","_key2","tag","child","object","key","value","srsDimensionAttribute","attributes","parseInt","Number","isNaN","create"],"sources":["../../../../../src/lib/parsers/gml/parse-gml.ts"],"sourcesContent":["// loaders.gl, MIT license\n\n// Forked from https://github.com/derhuerst/parse-gml-polygon/blob/master/index.js\n// under ISC license\n\n/* eslint-disable no-continue, default-case */\n\nimport type {\n  // GeoJSON,\n  // Feature,\n  // FeatureCollection,\n  Geometry,\n  Position\n  // GeoJsonProperties,\n  // Point,\n  // MultiPoint,\n  // LineString,\n  // MultiLineString,\n  // Polygon,\n  // MultiPolygon,\n  // GeometryCollection\n} from '@loaders.gl/schema';\n\nimport {XMLLoader} from '@loaders.gl/xml';\nimport {deepStrictEqual} from './deep-strict-equal';\nimport rewind from '@turf/rewind';\n\nfunction noTransform(...coords) {\n  return coords;\n}\n\nexport type ParseGMLOptions = {\n  transformCoords?: Function;\n  stride?: 2 | 3 | 4;\n};\n\nexport type ParseGMLContext = {\n  srsDimension?: number;\n  [key: string]: any;\n};\n\n/**\n * Parses a typed data structure from raw XML for GML features\n * @note Error handlings is fairly weak\n */\nexport function parseGML(text: string, options) {\n  // GeoJSON | null {\n  const parsedXML = XMLLoader.parseTextSync(text, options);\n\n  options = {transformCoords: noTransform, stride: 2, ...options};\n  const context = createChildContext(parsedXML, options, {});\n\n  return parseGMLToGeometry(parsedXML, options, context);\n}\n\n/** Parse a GeoJSON geometry from GML XML */\nexport function parseGMLToGeometry(\n  inputXML: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Geometry | null {\n  const childContext = createChildContext(inputXML, options, context);\n\n  let geometry: Geometry | null = null;\n\n  const [name, xml] = getFirstKeyValue(inputXML);\n\n  switch (name) {\n    // case 'gml:MultiPoint':\n    //   geometry = {\n    //     type: 'MultiPoint',\n    //     coordinates: parseMultiPoint(xml, options, childContext)\n    //   };\n    //   break;\n\n    case 'gml:LineString':\n      geometry = {\n        type: 'LineString',\n        coordinates: parseLinearRingOrLineString(xml, options, childContext)\n      };\n      break;\n\n      // case 'gml:MultiLineString':\n      //   geometry = {\n      //     type: 'MultiLineString',\n      //     coordinates: parseMultiLineString(xml, options, childContext)\n      //   };\n      //   break;\n\n    case 'gml:Polygon':\n    case 'gml:Rectangle':\n      geometry = {\n        type: 'Polygon',\n        coordinates: parsePolygonOrRectangle(xml, options, childContext)\n      };\n      break;\n    case 'gml:Surface':\n      geometry = {\n        type: 'MultiPolygon',\n        coordinates: parseSurface(xml, options, childContext)\n      };\n      break;\n    case 'gml:MultiSurface':\n      geometry = {\n        type: 'MultiPolygon',\n        coordinates: parseMultiSurface(xml, options, childContext)\n      };\n      break;\n\n    default:\n      return null;\n  }\n\n  // todo\n  return rewind(geometry, {mutate: true});\n}\n\n/** Parse a list of coordinates from a string */\nfunction parseCoords(s: string, options: ParseGMLOptions, context: ParseGMLContext): Position[] {\n  const stride = context.srsDimension || options.stride || 2;\n\n  // Handle white space\n  const coords = s.replace(/\\s+/g, ' ').trim().split(' ');\n\n  if (coords.length === 0 || coords.length % stride !== 0) {\n    throw new Error(`invalid coordinates list (stride ${stride})`);\n  }\n\n  const points: Position[] = [];\n  for (let i = 0; i < coords.length - 1; i += stride) {\n    const point = coords.slice(i, i + stride).map(parseFloat);\n    points.push(options.transformCoords?.(...point) || point);\n  }\n\n  return points;\n}\n\nexport function parsePosList(xml: any, options: ParseGMLOptions, context: ParseGMLContext) {\n  const childContext = createChildContext(xml, options, context);\n\n  const coords = textOf(xml);\n  if (!coords) {\n    throw new Error('invalid gml:posList element');\n  }\n\n  return parseCoords(coords, options, childContext);\n}\n\nexport function parsePos(xml: any, options: ParseGMLOptions, context: ParseGMLContext): Position {\n  const childContext = createChildContext(xml, options, context);\n\n  const coords = textOf(xml);\n  if (!coords) {\n    throw new Error('invalid gml:pos element');\n  }\n\n  const points = parseCoords(coords, options, childContext);\n  if (points.length !== 1) {\n    throw new Error('gml:pos must have 1 point');\n  }\n  return points[0];\n}\n\nexport function parsePoint(xml: any, options: ParseGMLOptions, context: ParseGMLContext): number[] {\n  const childContext = createChildContext(xml, options, context);\n\n  // TODO AV: Parse other gml:Point options\n  const pos = findIn(xml, 'gml:pos');\n  if (!pos) {\n    throw new Error('invalid gml:Point element, expected a gml:pos subelement');\n  }\n  return parsePos(pos, options, childContext);\n}\n\nexport function parseLinearRingOrLineString(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[] {\n  // or a LineStringSegment\n  const childContext = createChildContext(xml, options, context);\n\n  let points: Position[] = [];\n\n  const posList = findIn(xml, 'gml:posList');\n  if (posList) {\n    points = parsePosList(posList, options, childContext);\n  } else {\n    for (const [childName, childXML] of Object.entries(xml)) {\n      switch (childName) {\n        case 'gml:Point':\n          points.push(parsePoint(childXML, options, childContext));\n          break;\n        case 'gml:pos':\n          points.push(parsePos(childXML, options, childContext));\n          break;\n        default:\n          continue;\n      }\n    }\n  }\n\n  if (points.length === 0) {\n    throw new Error(`${xml.name} must have > 0 points`);\n  }\n  return points;\n}\n\nexport function parseCurveSegments(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[] {\n  const points: Position[] = [];\n\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:LineStringSegment':\n        const points2 = parseLinearRingOrLineString(childXML, options, context);\n\n        // remove overlapping\n        const end = points[points.length - 1];\n        const start = points2[0];\n        if (end && start && deepStrictEqual(end, start)) {\n          points2.shift();\n        }\n\n        points.push(...points2);\n        break;\n      default:\n        continue;\n    }\n  }\n\n  if (points.length === 0) {\n    throw new Error('gml:Curve > gml:segments must have > 0 points');\n  }\n  return points;\n}\n\nexport function parseRing(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[] {\n  const childContext = createChildContext(xml, options, context);\n\n  const points: Position[] = [];\n\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:curveMember':\n        let points2;\n\n        const lineString = findIn(childXML, 'gml:LineString');\n        if (lineString) {\n          points2 = parseLinearRingOrLineString(lineString, options, childContext);\n        } else {\n          const segments = findIn(childXML, 'gml:Curve', 'gml:segments');\n          if (!segments) {\n            throw new Error(`invalid ${childName} element`);\n          }\n\n          points2 = parseCurveSegments(segments, options, childContext);\n        }\n\n        // remove overlapping\n        const end = points[points.length - 1];\n        const start = points2[0];\n        if (end && start && deepStrictEqual(end, start)) {\n          points2.shift();\n        }\n\n        points.push(...points2);\n\n        break;\n    }\n  }\n\n  if (points.length < 4) {\n    throw new Error(`${xml.name} must have >= 4 points`);\n  }\n  return points;\n}\n\nexport function parseExteriorOrInterior(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[] {\n  const linearRing = findIn(xml, 'gml:LinearRing');\n  if (linearRing) {\n    return parseLinearRingOrLineString(linearRing, options, context);\n  }\n\n  const ring = findIn(xml, 'gml:Ring');\n  if (!ring) {\n    throw new Error(`invalid ${xml.name} element`);\n  }\n\n  return parseRing(ring, options, context);\n}\n\nexport function parsePolygonOrRectangle(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[][] {\n  // or PolygonPatch\n  const childContext = createChildContext(xml, options, context);\n\n  const exterior = findIn(xml, 'gml:exterior');\n  if (!exterior) {\n    throw new Error(`invalid ${xml.name} element`);\n  }\n\n  const pointLists: Position[][] = [parseExteriorOrInterior(exterior, options, childContext)];\n\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:interior':\n        pointLists.push(parseExteriorOrInterior(childXML, options, childContext));\n        break;\n    }\n  }\n\n  return pointLists;\n}\n\nexport function parseSurface(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[][][] {\n  const childContext = createChildContext(xml, options, context);\n\n  const patches = findIn(xml, 'gml:patches');\n  if (!patches) {\n    throw new Error(`invalid ${xml.name} element`);\n  }\n\n  const polygons: Position[][][] = [];\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:PolygonPatch':\n      case 'gml:Rectangle':\n        polygons.push(parsePolygonOrRectangle(childXML, options, childContext));\n        break;\n\n      default:\n        continue;\n    }\n  }\n\n  if (polygons.length === 0) {\n    throw new Error(`${xml.name} must have > 0 polygons`);\n  }\n\n  return polygons;\n}\n\nexport function parseCompositeSurface(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[][][] {\n  const childContext = createChildContext(xml, options, context);\n\n  const polygons: Position[][][] = [];\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:surfaceMember':\n      case 'gml:surfaceMembers':\n        const [c2Name, c2Xml] = getFirstKeyValue(childXML);\n        switch (c2Name) {\n          case 'gml:Surface':\n            polygons.push(...parseSurface(c2Xml, options, childContext));\n            break;\n          case 'gml:Polygon':\n            polygons.push(parsePolygonOrRectangle(c2Xml, options, childContext));\n            break;\n        }\n        break;\n    }\n  }\n\n  if (polygons.length === 0) {\n    throw new Error(`${xml.name} must have > 0 polygons`);\n  }\n  return polygons;\n}\n\nexport function parseMultiSurface(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[][][] {\n  let el = xml;\n\n  const surfaceMembers = findIn(xml, 'gml:LinearRing');\n  if (surfaceMembers) {\n    el = surfaceMembers;\n  }\n\n  const polygons: Position[][][] = [];\n  for (const [childName, childXML] of Object.entries(el)) {\n    switch (childName) {\n      case 'gml:Surface':\n        const polygons2 = parseSurface(childXML, options, context);\n        polygons.push(...polygons2);\n        break;\n      case 'gml:surfaceMember':\n        const polygons3 = parseSurfaceMember(childXML, options, context);\n        polygons.push(...polygons3);\n        break;\n\n      case 'gml:surfaceMembers':\n        const polygonXML = findIn(childXML, 'gml:Polygon');\n        for (const surfaceMemberXML of polygonXML as []) {\n          const polygons3 = parseSurfaceMember(surfaceMemberXML, options, context);\n          polygons.push(...polygons3);\n        }\n        break;\n    }\n  }\n\n  if (polygons.length === 0) {\n    throw new Error(`${xml.name} must have > 0 polygons`);\n  }\n\n  return polygons;\n}\n\nfunction parseSurfaceMember(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[][][] {\n  const [childName, childXml] = getFirstKeyValue(xml);\n  switch (childName) {\n    case 'gml:CompositeSurface':\n      return parseCompositeSurface(childXml, options, context);\n    case 'gml:Surface':\n      return parseSurface(childXml, options, context);\n    case 'gml:Polygon':\n      return [parsePolygonOrRectangle(childXml, options, context)];\n  }\n  throw new Error(`${childName} must have polygons`);\n}\n\n// Helpers\n\nfunction textOf(el: any): string {\n  if (typeof el !== 'string') {\n    throw new Error('expected string');\n  }\n  return el;\n}\n\nfunction findIn(root: any, ...tags: string[]): any {\n  let el = root;\n  for (const tag of tags) {\n    const child = el[tag];\n    if (!child) {\n      return null;\n    }\n    el = child;\n  }\n  return el;\n}\n\n/** @returns the first [key, value] pair in an object, or ['', null] if empty object */\nfunction getFirstKeyValue(object: any): [string, any] {\n  if (object && typeof object === 'object') {\n    for (const [key, value] of Object.entries(object)) {\n      return [key, value];\n    }\n  }\n  return ['', null];\n}\n\n/** A bit heavyweight for just tracking dimension? */\nfunction createChildContext(xml, options, context): ParseGMLContext {\n  const srsDimensionAttribute = xml.attributes && xml.attributes.srsDimension;\n\n  if (srsDimensionAttribute) {\n    const srsDimension = parseInt(srsDimensionAttribute);\n    if (Number.isNaN(srsDimension) || srsDimension <= 0) {\n      throw new Error(\n        `invalid srsDimension attribute value \"${srsDimensionAttribute}\", expected a positive integer`\n      );\n    }\n\n    const childContext = Object.create(context);\n    childContext.srsDimension = srsDimension;\n    return childContext;\n  }\n\n  return context;\n}\n"],"mappings":"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"}