(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/bundle.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*********************************************************************************************!*\
  !*** /Users/missx/Source/luma.gl/node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _defineProperty; });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/***/ }),

/***/ "../../node_modules/@probe.gl/env/dist/esm/index.js":
/*!********************************************************************************!*\
  !*** /Users/missx/Source/luma.gl/node_modules/@probe.gl/env/dist/esm/index.js ***!
  \********************************************************************************/
/*! exports provided: VERSION, self, window, global, document, process, console, isBrowser, isBrowserMainThread, getBrowser, isMobile, isElectron, assert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/globals */ "../../node_modules/@probe.gl/env/dist/esm/utils/globals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_0__["VERSION"]; });

/* harmony import */ var _lib_globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/globals */ "../../node_modules/@probe.gl/env/dist/esm/lib/globals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "self", function() { return _lib_globals__WEBPACK_IMPORTED_MODULE_1__["self"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _lib_globals__WEBPACK_IMPORTED_MODULE_1__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "global", function() { return _lib_globals__WEBPACK_IMPORTED_MODULE_1__["global"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "document", function() { return _lib_globals__WEBPACK_IMPORTED_MODULE_1__["document"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "process", function() { return _lib_globals__WEBPACK_IMPORTED_MODULE_1__["process"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "console", function() { return _lib_globals__WEBPACK_IMPORTED_MODULE_1__["console"]; });

/* harmony import */ var _lib_is_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/is-browser */ "../../node_modules/@probe.gl/env/dist/esm/lib/is-browser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return _lib_is_browser__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBrowserMainThread", function() { return _lib_is_browser__WEBPACK_IMPORTED_MODULE_2__["isBrowserMainThread"]; });

/* harmony import */ var _lib_get_browser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/get-browser */ "../../node_modules/@probe.gl/env/dist/esm/lib/get-browser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getBrowser", function() { return _lib_get_browser__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMobile", function() { return _lib_get_browser__WEBPACK_IMPORTED_MODULE_3__["isMobile"]; });

/* harmony import */ var _lib_is_electron__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/is-electron */ "../../node_modules/@probe.gl/env/dist/esm/lib/is-electron.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isElectron", function() { return _lib_is_electron__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/assert */ "../../node_modules/@probe.gl/env/dist/esm/utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _utils_assert__WEBPACK_IMPORTED_MODULE_5__["default"]; });







//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/env/dist/esm/lib/get-browser.js":
/*!******************************************************************************************!*\
  !*** /Users/missx/Source/luma.gl/node_modules/@probe.gl/env/dist/esm/lib/get-browser.js ***!
  \******************************************************************************************/
/*! exports provided: isMobile, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMobile", function() { return isMobile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getBrowser; });
/* harmony import */ var _is_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-browser */ "../../node_modules/@probe.gl/env/dist/esm/lib/is-browser.js");
/* harmony import */ var _is_electron__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-electron */ "../../node_modules/@probe.gl/env/dist/esm/lib/is-electron.js");


const window = globalThis;
function isMobile() {
  return typeof window.orientation !== 'undefined';
}
function getBrowser(mockUserAgent) {
  if (!mockUserAgent && !Object(_is_browser__WEBPACK_IMPORTED_MODULE_0__["default"])()) {
    return 'Node';
  }

  if (Object(_is_electron__WEBPACK_IMPORTED_MODULE_1__["default"])(mockUserAgent)) {
    return 'Electron';
  }

  const navigator_ = typeof navigator !== 'undefined' ? navigator : {};
  const userAgent = mockUserAgent || navigator_.userAgent || '';

  if (userAgent.indexOf('Edge') > -1) {
    return 'Edge';
  }

  const isMSIE = userAgent.indexOf('MSIE ') !== -1;
  const isTrident = userAgent.indexOf('Trident/') !== -1;

  if (isMSIE || isTrident) {
    return 'IE';
  }

  if (window.chrome) {
    return 'Chrome';
  }

  if (window.safari) {
    return 'Safari';
  }

  if (window.mozInnerScreenX) {
    return 'Firefox';
  }

  return 'Unknown';
}
//# sourceMappingURL=get-browser.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/env/dist/esm/lib/globals.js":
/*!**************************************************************************************!*\
  !*** /Users/missx/Source/luma.gl/node_modules/@probe.gl/env/dist/esm/lib/globals.js ***!
  \**************************************************************************************/
/*! exports provided: self, window, global, document, process, console */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "self", function() { return self_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return window_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "global", function() { return global_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "document", function() { return document_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "process", function() { return process_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "console", function() { return console_; });
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document,
  process: typeof process === 'object' && process
};
const global_ = globalThis;
const self_ = globals.self || globals.window || globals.global;
const window_ = globals.window || globals.self || globals.global;
const document_ = globals.document || {};
const process_ = globals.process || {};
const console_ = console;

//# sourceMappingURL=globals.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../../../process/browser.js */ "../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../node_modules/@probe.gl/env/dist/esm/lib/is-browser.js":
/*!*****************************************************************************************!*\
  !*** /Users/missx/Source/luma.gl/node_modules/@probe.gl/env/dist/esm/lib/is-browser.js ***!
  \*****************************************************************************************/
/*! exports provided: default, isBrowserMainThread */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowserMainThread", function() { return isBrowserMainThread; });
/* harmony import */ var _is_electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-electron */ "../../node_modules/@probe.gl/env/dist/esm/lib/is-electron.js");

function isBrowser() {
  const isNode = typeof process === 'object' && String(process) === '[object process]' && !process.browser;
  return !isNode || Object(_is_electron__WEBPACK_IMPORTED_MODULE_0__["default"])();
}
function isBrowserMainThread() {
  return isBrowser() && typeof document !== 'undefined';
}
//# sourceMappingURL=is-browser.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../process/browser.js */ "../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../node_modules/@probe.gl/env/dist/esm/lib/is-electron.js":
/*!******************************************************************************************!*\
  !*** /Users/missx/Source/luma.gl/node_modules/@probe.gl/env/dist/esm/lib/is-electron.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isElectron; });
function isElectron(mockUserAgent) {
  if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {
    return true;
  }

  if (typeof process !== 'undefined' && typeof process.versions === 'object' && Boolean(process.versions.electron)) {
    return true;
  }

  const realUserAgent = typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent;
  const userAgent = mockUserAgent || realUserAgent;

  if (userAgent && userAgent.indexOf('Electron') >= 0) {
    return true;
  }

  return false;
}
//# sourceMappingURL=is-electron.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../process/browser.js */ "../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../node_modules/@probe.gl/env/dist/esm/utils/assert.js":
/*!***************************************************************************************!*\
  !*** /Users/missx/Source/luma.gl/node_modules/@probe.gl/env/dist/esm/utils/assert.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/env/dist/esm/utils/globals.js":
/*!****************************************************************************************!*\
  !*** /Users/missx/Source/luma.gl/node_modules/@probe.gl/env/dist/esm/utils/globals.js ***!
  \****************************************************************************************/
/*! exports provided: self, window, global, document, process, console, VERSION, isBrowser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
/* harmony import */ var _lib_is_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/is-browser */ "../../node_modules/@probe.gl/env/dist/esm/lib/is-browser.js");
/* harmony import */ var _lib_globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/globals */ "../../node_modules/@probe.gl/env/dist/esm/lib/globals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "self", function() { return _lib_globals__WEBPACK_IMPORTED_MODULE_1__["self"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _lib_globals__WEBPACK_IMPORTED_MODULE_1__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "global", function() { return _lib_globals__WEBPACK_IMPORTED_MODULE_1__["global"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "document", function() { return _lib_globals__WEBPACK_IMPORTED_MODULE_1__["document"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "process", function() { return _lib_globals__WEBPACK_IMPORTED_MODULE_1__["process"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "console", function() { return _lib_globals__WEBPACK_IMPORTED_MODULE_1__["console"]; });



const VERSION =  true ? "8.5.19" : undefined;
const isBrowser = Object(_lib_is_browser__WEBPACK_IMPORTED_MODULE_0__["default"])();
//# sourceMappingURL=globals.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/esm/index.js":
/*!********************************************************************************!*\
  !*** /Users/missx/Source/luma.gl/node_modules/@probe.gl/log/dist/esm/index.js ***!
  \********************************************************************************/
/*! exports provided: default, Log, COLOR, addColor, leftPad, rightPad, autobind, LocalStorage, getHiResTimestamp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./log */ "../../node_modules/@probe.gl/log/dist/esm/log.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Log", function() { return _log__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _utils_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/color */ "../../node_modules/@probe.gl/log/dist/esm/utils/color.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "COLOR", function() { return _utils_color__WEBPACK_IMPORTED_MODULE_1__["COLOR"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addColor", function() { return _utils_color__WEBPACK_IMPORTED_MODULE_1__["addColor"]; });

/* harmony import */ var _utils_formatters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/formatters */ "../../node_modules/@probe.gl/log/dist/esm/utils/formatters.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "leftPad", function() { return _utils_formatters__WEBPACK_IMPORTED_MODULE_2__["leftPad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rightPad", function() { return _utils_formatters__WEBPACK_IMPORTED_MODULE_2__["rightPad"]; });

/* harmony import */ var _utils_autobind__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/autobind */ "../../node_modules/@probe.gl/log/dist/esm/utils/autobind.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "autobind", function() { return _utils_autobind__WEBPACK_IMPORTED_MODULE_3__["autobind"]; });

/* harmony import */ var _utils_local_storage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/local-storage */ "../../node_modules/@probe.gl/log/dist/esm/utils/local-storage.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LocalStorage", function() { return _utils_local_storage__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/hi-res-timestamp */ "../../node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getHiResTimestamp", function() { return _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_5__["getHiResTimestamp"]; });

/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./init */ "../../node_modules/@probe.gl/log/dist/esm/init.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_init__WEBPACK_IMPORTED_MODULE_6__);

/* harmony default export */ __webpack_exports__["default"] = (new _log__WEBPACK_IMPORTED_MODULE_0__["default"]({
  id: '@probe.gl/log'
}));








//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/esm/init.js":
/*!*******************************************************************************!*\
  !*** /Users/missx/Source/luma.gl/node_modules/@probe.gl/log/dist/esm/init.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

globalThis.probe = {};
//# sourceMappingURL=init.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/esm/log.js":
/*!******************************************************************************!*\
  !*** /Users/missx/Source/luma.gl/node_modules/@probe.gl/log/dist/esm/log.js ***!
  \******************************************************************************/
/*! exports provided: default, normalizeArguments */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Log; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeArguments", function() { return normalizeArguments; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @probe.gl/env */ "../../node_modules/@probe.gl/env/dist/esm/index.js");
/* harmony import */ var _utils_local_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/local-storage */ "../../node_modules/@probe.gl/log/dist/esm/utils/local-storage.js");
/* harmony import */ var _utils_formatters__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/formatters */ "../../node_modules/@probe.gl/log/dist/esm/utils/formatters.js");
/* harmony import */ var _utils_color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/color */ "../../node_modules/@probe.gl/log/dist/esm/utils/color.js");
/* harmony import */ var _utils_autobind__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/autobind */ "../../node_modules/@probe.gl/log/dist/esm/utils/autobind.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/assert */ "../../node_modules/@probe.gl/log/dist/esm/utils/assert.js");
/* harmony import */ var _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/hi-res-timestamp */ "../../node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js");








const originalConsole = {
  debug: _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__["isBrowser"] ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
const DEFAULT_SETTINGS = {
  enabled: true,
  level: 0
};

function noop() {}

const cache = {};
const ONCE = {
  once: true
};
class Log {
  constructor() {
    let {
      id
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      id: ''
    };

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "id", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "VERSION", _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__["VERSION"]);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_startTs", Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_7__["getHiResTimestamp"])());

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_deltaTs", Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_7__["getHiResTimestamp"])());

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_storage", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "userData", {});

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "LOG_THROTTLE_TIMEOUT", 0);

    this.id = id;
    this._storage = new _utils_local_storage__WEBPACK_IMPORTED_MODULE_2__["default"]("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
    this.userData = {};
    this.timeStamp("".concat(this.id, " started"));
    Object(_utils_autobind__WEBPACK_IMPORTED_MODULE_5__["autobind"])(this);
    Object.seal(this);
  }

  set level(newLevel) {
    this.setLevel(newLevel);
  }

  get level() {
    return this.getLevel();
  }

  isEnabled() {
    return this._storage.config.enabled;
  }

  getLevel() {
    return this._storage.config.level;
  }

  getTotal() {
    return Number((Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_7__["getHiResTimestamp"])() - this._startTs).toPrecision(10));
  }

  getDelta() {
    return Number((Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_7__["getHiResTimestamp"])() - this._deltaTs).toPrecision(10));
  }

  set priority(newPriority) {
    this.level = newPriority;
  }

  get priority() {
    return this.level;
  }

  getPriority() {
    return this.level;
  }

  enable() {
    let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    this._storage.updateConfiguration({
      enabled
    });

    return this;
  }

  setLevel(level) {
    this._storage.updateConfiguration({
      level
    });

    return this;
  }

  get(setting) {
    return this._storage.config[setting];
  }

  set(setting, value) {
    this._storage.updateConfiguration({
      [setting]: value
    });
  }

  settings() {
    if (console.table) {
      console.table(this._storage.config);
    } else {
      console.log(this._storage.config);
    }
  }

  assert(condition, message) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_6__["default"])(condition, message);
  }

  warn(message) {
    return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
  }

  error(message) {
    return this._getLogFunction(0, message, originalConsole.error, arguments);
  }

  deprecated(oldUsage, newUsage) {
    return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
  }

  removed(oldUsage, newUsage) {
    return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
  }

  probe(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
      time: true,
      once: true
    });
  }

  log(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
  }

  info(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.info, arguments);
  }

  once(logLevel, message) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
  }

  table(logLevel, table, columns) {
    if (table) {
      return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
        tag: getTableHeader(table)
      });
    }

    return noop;
  }

  image(_ref) {
    let {
      logLevel,
      priority,
      image,
      message = '',
      scale = 1
    } = _ref;

    if (!this._shouldLog(logLevel || priority)) {
      return noop;
    }

    return _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__["isBrowser"] ? logImageInBrowser({
      image,
      message,
      scale
    }) : logImageInNode({
      image,
      message,
      scale
    });
  }

  time(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
  }

  timeEnd(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
  }

  timeStamp(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeStamp || noop);
  }

  group(logLevel, message) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      collapsed: false
    };
    const options = normalizeArguments({
      logLevel,
      message,
      opts
    });
    const {
      collapsed
    } = opts;
    options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
    return this._getLogFunction(options);
  }

  groupCollapsed(logLevel, message) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return this.group(logLevel, message, Object.assign({}, opts, {
      collapsed: true
    }));
  }

  groupEnd(logLevel) {
    return this._getLogFunction(logLevel, '', console.groupEnd || noop);
  }

  withGroup(logLevel, message, func) {
    this.group(logLevel, message)();

    try {
      func();
    } finally {
      this.groupEnd(logLevel)();
    }
  }

  trace() {
    if (console.trace) {
      console.trace();
    }
  }

  _shouldLog(logLevel) {
    return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
  }

  _getLogFunction(logLevel, message, method, args, opts) {
    if (this._shouldLog(logLevel)) {
      opts = normalizeArguments({
        logLevel,
        message,
        args,
        opts
      });
      method = method || opts.method;
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_6__["default"])(method);
      opts.total = this.getTotal();
      opts.delta = this.getDelta();
      this._deltaTs = Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_7__["getHiResTimestamp"])();
      const tag = opts.tag || opts.message;

      if (opts.once) {
        if (!cache[tag]) {
          cache[tag] = Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_7__["getHiResTimestamp"])();
        } else {
          return noop;
        }
      }

      message = decorateMessage(this.id, opts.message, opts);
      return method.bind(console, message, ...opts.args);
    }

    return noop;
  }

}

Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(Log, "VERSION", _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__["VERSION"]);

function normalizeLogLevel(logLevel) {
  if (!logLevel) {
    return 0;
  }

  let resolvedLevel;

  switch (typeof logLevel) {
    case 'number':
      resolvedLevel = logLevel;
      break;

    case 'object':
      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
      break;

    default:
      return 0;
  }

  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_6__["default"])(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
  return resolvedLevel;
}

function normalizeArguments(opts) {
  const {
    logLevel,
    message
  } = opts;
  opts.logLevel = normalizeLogLevel(logLevel);
  const args = opts.args ? Array.from(opts.args) : [];

  while (args.length && args.shift() !== message) {}

  switch (typeof logLevel) {
    case 'string':
    case 'function':
      if (message !== undefined) {
        args.unshift(message);
      }

      opts.message = logLevel;
      break;

    case 'object':
      Object.assign(opts, logLevel);
      break;

    default:
  }

  if (typeof opts.message === 'function') {
    opts.message = opts.message();
  }

  const messageType = typeof opts.message;
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_6__["default"])(messageType === 'string' || messageType === 'object');
  return Object.assign(opts, {
    args
  }, opts.opts);
}

function decorateMessage(id, message, opts) {
  if (typeof message === 'string') {
    const time = opts.time ? Object(_utils_formatters__WEBPACK_IMPORTED_MODULE_3__["leftPad"])(Object(_utils_formatters__WEBPACK_IMPORTED_MODULE_3__["formatTime"])(opts.total)) : '';
    message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
    message = Object(_utils_color__WEBPACK_IMPORTED_MODULE_4__["addColor"])(message, opts.color, opts.background);
  }

  return message;
}

function logImageInNode(_ref2) {
  let {
    image,
    message = '',
    scale = 1
  } = _ref2;
  let asciify = null;

  try {
    asciify = __webpack_require__(/*! asciify-image */ 0);
  } catch (error) {}

  if (asciify) {
    return () => asciify(image, {
      fit: 'box',
      width: "".concat(Math.round(80 * scale), "%")
    }).then(data => console.log(data));
  }

  return noop;
}

function logImageInBrowser(_ref3) {
  let {
    image,
    message = '',
    scale = 1
  } = _ref3;

  if (typeof image === 'string') {
    const img = new Image();

    img.onload = () => {
      const args = Object(_utils_formatters__WEBPACK_IMPORTED_MODULE_3__["formatImage"])(img, message, scale);
      console.log(...args);
    };

    img.src = image;
    return noop;
  }

  const element = image.nodeName || '';

  if (element.toLowerCase() === 'img') {
    console.log(...Object(_utils_formatters__WEBPACK_IMPORTED_MODULE_3__["formatImage"])(image, message, scale));
    return noop;
  }

  if (element.toLowerCase() === 'canvas') {
    const img = new Image();

    img.onload = () => console.log(...Object(_utils_formatters__WEBPACK_IMPORTED_MODULE_3__["formatImage"])(img, message, scale));

    img.src = image.toDataURL();
    return noop;
  }

  return noop;
}

function getTableHeader(table) {
  for (const key in table) {
    for (const title in table[key]) {
      return title || 'untitled';
    }
  }

  return 'empty';
}
//# sourceMappingURL=log.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/esm/utils/assert.js":
/*!***************************************************************************************!*\
  !*** /Users/missx/Source/luma.gl/node_modules/@probe.gl/log/dist/esm/utils/assert.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/esm/utils/autobind.js":
/*!*****************************************************************************************!*\
  !*** /Users/missx/Source/luma.gl/node_modules/@probe.gl/log/dist/esm/utils/autobind.js ***!
  \*****************************************************************************************/
/*! exports provided: autobind */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "autobind", function() { return autobind; });
function autobind(obj) {
  let predefined = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['constructor'];
  const proto = Object.getPrototypeOf(obj);
  const propNames = Object.getOwnPropertyNames(proto);

  for (const key of propNames) {
    if (typeof obj[key] === 'function') {
      if (!predefined.find(name => key === name)) {
        obj[key] = obj[key].bind(obj);
      }
    }
  }
}
//# sourceMappingURL=autobind.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/esm/utils/color.js":
/*!**************************************************************************************!*\
  !*** /Users/missx/Source/luma.gl/node_modules/@probe.gl/log/dist/esm/utils/color.js ***!
  \**************************************************************************************/
/*! exports provided: COLOR, addColor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOR", function() { return COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addColor", function() { return addColor; });
/* harmony import */ var _probe_gl_env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @probe.gl/env */ "../../node_modules/@probe.gl/env/dist/esm/index.js");

let COLOR;

(function (COLOR) {
  COLOR[COLOR["BLACK"] = 30] = "BLACK";
  COLOR[COLOR["RED"] = 31] = "RED";
  COLOR[COLOR["GREEN"] = 32] = "GREEN";
  COLOR[COLOR["YELLOW"] = 33] = "YELLOW";
  COLOR[COLOR["BLUE"] = 34] = "BLUE";
  COLOR[COLOR["MAGENTA"] = 35] = "MAGENTA";
  COLOR[COLOR["CYAN"] = 36] = "CYAN";
  COLOR[COLOR["WHITE"] = 37] = "WHITE";
  COLOR[COLOR["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
  COLOR[COLOR["BRIGHT_RED"] = 91] = "BRIGHT_RED";
  COLOR[COLOR["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
  COLOR[COLOR["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
  COLOR[COLOR["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
  COLOR[COLOR["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
  COLOR[COLOR["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
  COLOR[COLOR["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
})(COLOR || (COLOR = {}));

function getColor(color) {
  return typeof color === 'string' ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;
}

function addColor(string, color, background) {
  if (!_probe_gl_env__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] && typeof string === 'string') {
    if (color) {
      color = getColor(color);
      string = "\x1B[".concat(color, "m").concat(string, "\x1B[39m");
    }

    if (background) {
      color = getColor(background);
      string = "\x1B[".concat(background + 10, "m").concat(string, "\x1B[49m");
    }
  }

  return string;
}
//# sourceMappingURL=color.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/esm/utils/formatters.js":
/*!*******************************************************************************************!*\
  !*** /Users/missx/Source/luma.gl/node_modules/@probe.gl/log/dist/esm/utils/formatters.js ***!
  \*******************************************************************************************/
/*! exports provided: formatTime, leftPad, rightPad, formatValue, formatImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatTime", function() { return formatTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "leftPad", function() { return leftPad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rightPad", function() { return rightPad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatValue", function() { return formatValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatImage", function() { return formatImage; });
function formatTime(ms) {
  let formatted;

  if (ms < 10) {
    formatted = "".concat(ms.toFixed(2), "ms");
  } else if (ms < 100) {
    formatted = "".concat(ms.toFixed(1), "ms");
  } else if (ms < 1000) {
    formatted = "".concat(ms.toFixed(0), "ms");
  } else {
    formatted = "".concat((ms / 1000).toFixed(2), "s");
  }

  return formatted;
}
function leftPad(string) {
  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  const padLength = Math.max(length - string.length, 0);
  return "".concat(' '.repeat(padLength)).concat(string);
}
function rightPad(string) {
  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  const padLength = Math.max(length - string.length, 0);
  return "".concat(string).concat(' '.repeat(padLength));
}
function formatValue(v) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const EPSILON = 1e-16;
  const {
    isInteger = false
  } = opts;

  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }

  if (!Number.isFinite(v)) {
    return String(v);
  }

  if (Math.abs(v) < EPSILON) {
    return isInteger ? '0' : '0.';
  }

  if (isInteger) {
    return v.toFixed(0);
  }

  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }

  const string = v.toPrecision(2);
  const decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}

function formatArrayValue(v, opts) {
  const {
    maxElts = 16,
    size = 1
  } = opts;
  let string = '[';

  for (let i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size === 0 ? ' ' : '');
    }

    string += formatValue(v[i], opts);
  }

  const terminator = v.length > maxElts ? '...' : ']';
  return "".concat(string).concat(terminator);
}

function formatImage(image, message, scale) {
  let maxWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 600;
  const imageUrl = image.src.replace(/\(/g, '%28').replace(/\)/g, '%29');

  if (image.width > maxWidth) {
    scale = Math.min(scale, maxWidth / image.width);
  }

  const width = image.width * scale;
  const height = image.height * scale;
  const style = ['font-size:1px;', "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), 'color:transparent;'].join('');
  return ["".concat(message, " %c+"), style];
}
//# sourceMappingURL=formatters.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js":
/*!*************************************************************************************************!*\
  !*** /Users/missx/Source/luma.gl/node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js ***!
  \*************************************************************************************************/
/*! exports provided: getHiResTimestamp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHiResTimestamp", function() { return getHiResTimestamp; });
/* harmony import */ var _probe_gl_env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @probe.gl/env */ "../../node_modules/@probe.gl/env/dist/esm/index.js");

function getHiResTimestamp() {
  let timestamp;

  if (_probe_gl_env__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] && 'performance' in _probe_gl_env__WEBPACK_IMPORTED_MODULE_0__["window"]) {
    var _window$performance, _window$performance$n;

    timestamp = _probe_gl_env__WEBPACK_IMPORTED_MODULE_0__["window"] === null || _probe_gl_env__WEBPACK_IMPORTED_MODULE_0__["window"] === void 0 ? void 0 : (_window$performance = _probe_gl_env__WEBPACK_IMPORTED_MODULE_0__["window"].performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
  } else if ('hrtime' in _probe_gl_env__WEBPACK_IMPORTED_MODULE_0__["process"]) {
    var _process$hrtime;

    const timeParts = _probe_gl_env__WEBPACK_IMPORTED_MODULE_0__["process"] === null || _probe_gl_env__WEBPACK_IMPORTED_MODULE_0__["process"] === void 0 ? void 0 : (_process$hrtime = _probe_gl_env__WEBPACK_IMPORTED_MODULE_0__["process"].hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(_probe_gl_env__WEBPACK_IMPORTED_MODULE_0__["process"]);
    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }

  return timestamp;
}
//# sourceMappingURL=hi-res-timestamp.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/esm/utils/local-storage.js":
/*!**********************************************************************************************!*\
  !*** /Users/missx/Source/luma.gl/node_modules/@probe.gl/log/dist/esm/utils/local-storage.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LocalStorage; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");


function getStorage(type) {
  try {
    const storage = window[type];
    const x = '__storage_test__';
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e) {
    return null;
  }
}

class LocalStorage {
  constructor(id) {
    let defaultSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'sessionStorage';

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "storage", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "id", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "config", {});

    this.storage = getStorage(type);
    this.id = id;
    this.config = {};
    Object.assign(this.config, defaultSettings);

    this._loadConfiguration();
  }

  getConfiguration() {
    return this.config;
  }

  setConfiguration(configuration) {
    this.config = {};
    return this.updateConfiguration(configuration);
  }

  updateConfiguration(configuration) {
    Object.assign(this.config, configuration);

    if (this.storage) {
      const serialized = JSON.stringify(this.config);
      this.storage.setItem(this.id, serialized);
    }

    return this;
  }

  _loadConfiguration() {
    let configuration = {};

    if (this.storage) {
      const serializedConfiguration = this.storage.getItem(this.id);
      configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
    }

    Object.assign(this.config, configuration);
    return this;
  }

}
//# sourceMappingURL=local-storage.js.map

/***/ }),

/***/ "../../node_modules/process/browser.js":
/*!*******************************************************************!*\
  !*** /Users/missx/Source/luma.gl/node_modules/process/browser.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../constants/src/index.js":
/*!*********************************!*\
  !*** ../constants/src/index.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// GL constants, copied from Mozilla documentation
// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants

// Standard WebGL 1 constants
// These constants are defined on the WebGLRenderingContext interface.

/* eslint-disable key-spacing, max-len, no-inline-comments, camelcase */
// eslint-disable-next-line
/* harmony default export */ __webpack_exports__["default"] = ({
  // Clearing buffers
  // Constants passed to clear() to clear buffer masks.

  DEPTH_BUFFER_BIT: 0x00000100,
  STENCIL_BUFFER_BIT: 0x00000400,
  COLOR_BUFFER_BIT: 0x00004000,

  // Rendering primitives
  // Constants passed to drawElements() or drawArrays() to specify what kind of primitive to render.

  POINTS: 0x0000,
  LINES: 0x0001,
  LINE_LOOP: 0x0002,
  LINE_STRIP: 0x0003,
  TRIANGLES: 0x0004,
  TRIANGLE_STRIP: 0x0005,
  TRIANGLE_FAN: 0x0006,

  // Blending modes
  // Constants passed to blendFunc() or blendFuncSeparate() to specify the blending mode (for both, RBG and alpha, or separately).

  ZERO: 0,
  ONE: 1,
  SRC_COLOR: 0x0300,
  ONE_MINUS_SRC_COLOR: 0x0301,
  SRC_ALPHA: 0x0302,
  ONE_MINUS_SRC_ALPHA: 0x0303,
  DST_ALPHA: 0x0304,
  ONE_MINUS_DST_ALPHA: 0x0305,
  DST_COLOR: 0x0306,
  ONE_MINUS_DST_COLOR: 0x0307,
  SRC_ALPHA_SATURATE: 0x0308,
  CONSTANT_COLOR: 0x8001,
  ONE_MINUS_CONSTANT_COLOR: 0x8002,
  CONSTANT_ALPHA: 0x8003,
  ONE_MINUS_CONSTANT_ALPHA: 0x8004,

  // Blending equations
  // Constants passed to blendEquation() or blendEquationSeparate() to control
  // how the blending is calculated (for both, RBG and alpha, or separately).

  FUNC_ADD: 0x8006,
  FUNC_SUBTRACT: 0x800a,
  FUNC_REVERSE_SUBTRACT: 0x800b,

  // Getting GL parameter information
  // Constants passed to getParameter() to specify what information to return.

  BLEND_EQUATION: 0x8009,
  BLEND_EQUATION_RGB: 0x8009,
  BLEND_EQUATION_ALPHA: 0x883d,
  BLEND_DST_RGB: 0x80c8,
  BLEND_SRC_RGB: 0x80c9,
  BLEND_DST_ALPHA: 0x80ca,
  BLEND_SRC_ALPHA: 0x80cb,
  BLEND_COLOR: 0x8005,
  ARRAY_BUFFER_BINDING: 0x8894,
  ELEMENT_ARRAY_BUFFER_BINDING: 0x8895,
  LINE_WIDTH: 0x0b21,
  ALIASED_POINT_SIZE_RANGE: 0x846d,
  ALIASED_LINE_WIDTH_RANGE: 0x846e,
  CULL_FACE_MODE: 0x0b45,
  FRONT_FACE: 0x0b46,
  DEPTH_RANGE: 0x0b70,
  DEPTH_WRITEMASK: 0x0b72,
  DEPTH_CLEAR_VALUE: 0x0b73,
  DEPTH_FUNC: 0x0b74,
  STENCIL_CLEAR_VALUE: 0x0b91,
  STENCIL_FUNC: 0x0b92,
  STENCIL_FAIL: 0x0b94,
  STENCIL_PASS_DEPTH_FAIL: 0x0b95,
  STENCIL_PASS_DEPTH_PASS: 0x0b96,
  STENCIL_REF: 0x0b97,
  STENCIL_VALUE_MASK: 0x0b93,
  STENCIL_WRITEMASK: 0x0b98,
  STENCIL_BACK_FUNC: 0x8800,
  STENCIL_BACK_FAIL: 0x8801,
  STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802,
  STENCIL_BACK_PASS_DEPTH_PASS: 0x8803,
  STENCIL_BACK_REF: 0x8ca3,
  STENCIL_BACK_VALUE_MASK: 0x8ca4,
  STENCIL_BACK_WRITEMASK: 0x8ca5,
  VIEWPORT: 0x0ba2,
  SCISSOR_BOX: 0x0c10,
  COLOR_CLEAR_VALUE: 0x0c22,
  COLOR_WRITEMASK: 0x0c23,
  UNPACK_ALIGNMENT: 0x0cf5,
  PACK_ALIGNMENT: 0x0d05,
  MAX_TEXTURE_SIZE: 0x0d33,
  MAX_VIEWPORT_DIMS: 0x0d3a,
  SUBPIXEL_BITS: 0x0d50,
  RED_BITS: 0x0d52,
  GREEN_BITS: 0x0d53,
  BLUE_BITS: 0x0d54,
  ALPHA_BITS: 0x0d55,
  DEPTH_BITS: 0x0d56,
  STENCIL_BITS: 0x0d57,
  POLYGON_OFFSET_UNITS: 0x2a00,
  POLYGON_OFFSET_FACTOR: 0x8038,
  TEXTURE_BINDING_2D: 0x8069,
  SAMPLE_BUFFERS: 0x80a8,
  SAMPLES: 0x80a9,
  SAMPLE_COVERAGE_VALUE: 0x80aa,
  SAMPLE_COVERAGE_INVERT: 0x80ab,
  COMPRESSED_TEXTURE_FORMATS: 0x86a3,
  VENDOR: 0x1f00,
  RENDERER: 0x1f01,
  VERSION: 0x1f02,
  IMPLEMENTATION_COLOR_READ_TYPE: 0x8b9a,
  IMPLEMENTATION_COLOR_READ_FORMAT: 0x8b9b,
  BROWSER_DEFAULT_WEBGL: 0x9244,

  // Buffers
  // Constants passed to bufferData(), bufferSubData(), bindBuffer(), or
  // getBufferParameter().

  STATIC_DRAW: 0x88e4,
  STREAM_DRAW: 0x88e0,
  DYNAMIC_DRAW: 0x88e8,
  ARRAY_BUFFER: 0x8892,
  ELEMENT_ARRAY_BUFFER: 0x8893,
  BUFFER_SIZE: 0x8764,
  BUFFER_USAGE: 0x8765,

  // Vertex attributes
  // Constants passed to getVertexAttrib().

  CURRENT_VERTEX_ATTRIB: 0x8626,
  VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622,
  VERTEX_ATTRIB_ARRAY_SIZE: 0x8623,
  VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624,
  VERTEX_ATTRIB_ARRAY_TYPE: 0x8625,
  VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886a,
  VERTEX_ATTRIB_ARRAY_POINTER: 0x8645,
  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889f,

  // Culling
  // Constants passed to cullFace().

  CULL_FACE: 0x0b44,
  FRONT: 0x0404,
  BACK: 0x0405,
  FRONT_AND_BACK: 0x0408,

  // Enabling and disabling
  // Constants passed to enable() or disable().

  BLEND: 0x0be2,
  DEPTH_TEST: 0x0b71,
  DITHER: 0x0bd0,
  POLYGON_OFFSET_FILL: 0x8037,
  SAMPLE_ALPHA_TO_COVERAGE: 0x809e,
  SAMPLE_COVERAGE: 0x80a0,
  SCISSOR_TEST: 0x0c11,
  STENCIL_TEST: 0x0b90,

  // Errors
  // Constants returned from getError().

  NO_ERROR: 0,
  INVALID_ENUM: 0x0500,
  INVALID_VALUE: 0x0501,
  INVALID_OPERATION: 0x0502,
  OUT_OF_MEMORY: 0x0505,
  CONTEXT_LOST_WEBGL: 0x9242,

  // Front face directions
  // Constants passed to frontFace().

  CW: 0x0900,
  CCW: 0x0901,

  // Hints
  // Constants passed to hint()

  DONT_CARE: 0x1100,
  FASTEST: 0x1101,
  NICEST: 0x1102,
  GENERATE_MIPMAP_HINT: 0x8192,

  // Data types

  BYTE: 0x1400,
  UNSIGNED_BYTE: 0x1401,
  SHORT: 0x1402,
  UNSIGNED_SHORT: 0x1403,
  INT: 0x1404,
  UNSIGNED_INT: 0x1405,
  FLOAT: 0x1406,
  DOUBLE: 0x140a,

  // Pixel formats

  DEPTH_COMPONENT: 0x1902,
  ALPHA: 0x1906,
  RGB: 0x1907,
  RGBA: 0x1908,
  LUMINANCE: 0x1909,
  LUMINANCE_ALPHA: 0x190a,

  // Pixel types

  // UNSIGNED_BYTE: 0x1401,
  UNSIGNED_SHORT_4_4_4_4: 0x8033,
  UNSIGNED_SHORT_5_5_5_1: 0x8034,
  UNSIGNED_SHORT_5_6_5: 0x8363,

  // Shaders
  // Constants passed to createShader() or getShaderParameter()

  FRAGMENT_SHADER: 0x8b30,
  VERTEX_SHADER: 0x8b31,
  COMPILE_STATUS: 0x8b81,
  DELETE_STATUS: 0x8b80,
  LINK_STATUS: 0x8b82,
  VALIDATE_STATUS: 0x8b83,
  ATTACHED_SHADERS: 0x8b85,
  ACTIVE_ATTRIBUTES: 0x8b89,
  ACTIVE_UNIFORMS: 0x8b86,
  MAX_VERTEX_ATTRIBS: 0x8869,
  MAX_VERTEX_UNIFORM_VECTORS: 0x8dfb,
  MAX_VARYING_VECTORS: 0x8dfc,
  MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8b4d,
  MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8b4c,
  MAX_TEXTURE_IMAGE_UNITS: 0x8872,
  MAX_FRAGMENT_UNIFORM_VECTORS: 0x8dfd,
  SHADER_TYPE: 0x8b4f,
  SHADING_LANGUAGE_VERSION: 0x8b8c,
  CURRENT_PROGRAM: 0x8b8d,

  // Depth or stencil tests
  // Constants passed to depthFunc() or stencilFunc().

  NEVER: 0x0200,
  ALWAYS: 0x0207,
  LESS: 0x0201,
  EQUAL: 0x0202,
  LEQUAL: 0x0203,
  GREATER: 0x0204,
  GEQUAL: 0x0206,
  NOTEQUAL: 0x0205,

  // Stencil actions
  // Constants passed to stencilOp().

  KEEP: 0x1e00,
  REPLACE: 0x1e01,
  INCR: 0x1e02,
  DECR: 0x1e03,
  INVERT: 0x150a,
  INCR_WRAP: 0x8507,
  DECR_WRAP: 0x8508,

  // Textures
  // Constants passed to texParameteri(),
  // texParameterf(), bindTexture(), texImage2D(), and others.

  NEAREST: 0x2600,
  LINEAR: 0x2601,
  NEAREST_MIPMAP_NEAREST: 0x2700,
  LINEAR_MIPMAP_NEAREST: 0x2701,
  NEAREST_MIPMAP_LINEAR: 0x2702,
  LINEAR_MIPMAP_LINEAR: 0x2703,
  TEXTURE_MAG_FILTER: 0x2800,
  TEXTURE_MIN_FILTER: 0x2801,
  TEXTURE_WRAP_S: 0x2802,
  TEXTURE_WRAP_T: 0x2803,
  TEXTURE_2D: 0x0de1,
  TEXTURE: 0x1702,
  TEXTURE_CUBE_MAP: 0x8513,
  TEXTURE_BINDING_CUBE_MAP: 0x8514,
  TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515,
  TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516,
  TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517,
  TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518,
  TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519,
  TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851a,
  MAX_CUBE_MAP_TEXTURE_SIZE: 0x851c,
  // TEXTURE0 - 31 0x84C0 - 0x84DF A texture unit.
  TEXTURE0: 0x84c0,
  ACTIVE_TEXTURE: 0x84e0,
  REPEAT: 0x2901,
  CLAMP_TO_EDGE: 0x812f,
  MIRRORED_REPEAT: 0x8370,

  // Emulation
  TEXTURE_WIDTH: 0x1000,
  TEXTURE_HEIGHT: 0x1001,

  // Uniform types

  FLOAT_VEC2: 0x8b50,
  FLOAT_VEC3: 0x8b51,
  FLOAT_VEC4: 0x8b52,
  INT_VEC2: 0x8b53,
  INT_VEC3: 0x8b54,
  INT_VEC4: 0x8b55,
  BOOL: 0x8b56,
  BOOL_VEC2: 0x8b57,
  BOOL_VEC3: 0x8b58,
  BOOL_VEC4: 0x8b59,
  FLOAT_MAT2: 0x8b5a,
  FLOAT_MAT3: 0x8b5b,
  FLOAT_MAT4: 0x8b5c,
  SAMPLER_2D: 0x8b5e,
  SAMPLER_CUBE: 0x8b60,

  // Shader precision-specified types

  LOW_FLOAT: 0x8df0,
  MEDIUM_FLOAT: 0x8df1,
  HIGH_FLOAT: 0x8df2,
  LOW_INT: 0x8df3,
  MEDIUM_INT: 0x8df4,
  HIGH_INT: 0x8df5,

  // Framebuffers and renderbuffers

  FRAMEBUFFER: 0x8d40,
  RENDERBUFFER: 0x8d41,
  RGBA4: 0x8056,
  RGB5_A1: 0x8057,
  RGB565: 0x8d62,
  DEPTH_COMPONENT16: 0x81a5,
  STENCIL_INDEX: 0x1901,
  STENCIL_INDEX8: 0x8d48,
  DEPTH_STENCIL: 0x84f9,
  RENDERBUFFER_WIDTH: 0x8d42,
  RENDERBUFFER_HEIGHT: 0x8d43,
  RENDERBUFFER_INTERNAL_FORMAT: 0x8d44,
  RENDERBUFFER_RED_SIZE: 0x8d50,
  RENDERBUFFER_GREEN_SIZE: 0x8d51,
  RENDERBUFFER_BLUE_SIZE: 0x8d52,
  RENDERBUFFER_ALPHA_SIZE: 0x8d53,
  RENDERBUFFER_DEPTH_SIZE: 0x8d54,
  RENDERBUFFER_STENCIL_SIZE: 0x8d55,
  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8cd0,
  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8cd1,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8cd2,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8cd3,
  COLOR_ATTACHMENT0: 0x8ce0,
  DEPTH_ATTACHMENT: 0x8d00,
  STENCIL_ATTACHMENT: 0x8d20,
  DEPTH_STENCIL_ATTACHMENT: 0x821a,
  NONE: 0,
  FRAMEBUFFER_COMPLETE: 0x8cd5,
  FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8cd6,
  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8cd7,
  FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8cd9,
  FRAMEBUFFER_UNSUPPORTED: 0x8cdd,
  FRAMEBUFFER_BINDING: 0x8ca6,
  RENDERBUFFER_BINDING: 0x8ca7,
  READ_FRAMEBUFFER: 0x8ca8,
  DRAW_FRAMEBUFFER: 0x8ca9,
  MAX_RENDERBUFFER_SIZE: 0x84e8,
  INVALID_FRAMEBUFFER_OPERATION: 0x0506,

  // Pixel storage modes
  // Constants passed to pixelStorei().

  UNPACK_FLIP_Y_WEBGL: 0x9240,
  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241,
  UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243,

  // /////////////////////////////////////////////////////
  // Additional constants defined WebGL 2
  // These constants are defined on the WebGL2RenderingContext interface.
  // All WebGL 1 constants are also available in a WebGL 2 context.
  // /////////////////////////////////////////////////////

  // Getting GL parameter information
  // Constants passed to getParameter()
  // to specify what information to return.

  READ_BUFFER: 0x0c02,
  UNPACK_ROW_LENGTH: 0x0cf2,
  UNPACK_SKIP_ROWS: 0x0cf3,
  UNPACK_SKIP_PIXELS: 0x0cf4,
  PACK_ROW_LENGTH: 0x0d02,
  PACK_SKIP_ROWS: 0x0d03,
  PACK_SKIP_PIXELS: 0x0d04,
  TEXTURE_BINDING_3D: 0x806a,
  UNPACK_SKIP_IMAGES: 0x806d,
  UNPACK_IMAGE_HEIGHT: 0x806e,
  MAX_3D_TEXTURE_SIZE: 0x8073,
  MAX_ELEMENTS_VERTICES: 0x80e8,
  MAX_ELEMENTS_INDICES: 0x80e9,
  MAX_TEXTURE_LOD_BIAS: 0x84fd,
  MAX_FRAGMENT_UNIFORM_COMPONENTS: 0x8b49,
  MAX_VERTEX_UNIFORM_COMPONENTS: 0x8b4a,
  MAX_ARRAY_TEXTURE_LAYERS: 0x88ff,
  MIN_PROGRAM_TEXEL_OFFSET: 0x8904,
  MAX_PROGRAM_TEXEL_OFFSET: 0x8905,
  MAX_VARYING_COMPONENTS: 0x8b4b,
  FRAGMENT_SHADER_DERIVATIVE_HINT: 0x8b8b,
  RASTERIZER_DISCARD: 0x8c89,
  VERTEX_ARRAY_BINDING: 0x85b5,
  MAX_VERTEX_OUTPUT_COMPONENTS: 0x9122,
  MAX_FRAGMENT_INPUT_COMPONENTS: 0x9125,
  MAX_SERVER_WAIT_TIMEOUT: 0x9111,
  MAX_ELEMENT_INDEX: 0x8d6b,

  // Textures
  // Constants passed to texParameteri(),
  // texParameterf(), bindTexture(), texImage2D(), and others.

  RED: 0x1903,
  RGB8: 0x8051,
  RGBA8: 0x8058,
  RGB10_A2: 0x8059,
  TEXTURE_3D: 0x806f,
  TEXTURE_WRAP_R: 0x8072,
  TEXTURE_MIN_LOD: 0x813a,
  TEXTURE_MAX_LOD: 0x813b,
  TEXTURE_BASE_LEVEL: 0x813c,
  TEXTURE_MAX_LEVEL: 0x813d,
  TEXTURE_COMPARE_MODE: 0x884c,
  TEXTURE_COMPARE_FUNC: 0x884d,
  SRGB: 0x8c40,
  SRGB8: 0x8c41,
  SRGB8_ALPHA8: 0x8c43,
  COMPARE_REF_TO_TEXTURE: 0x884e,
  RGBA32F: 0x8814,
  RGB32F: 0x8815,
  RGBA16F: 0x881a,
  RGB16F: 0x881b,
  TEXTURE_2D_ARRAY: 0x8c1a,
  TEXTURE_BINDING_2D_ARRAY: 0x8c1d,
  R11F_G11F_B10F: 0x8c3a,
  RGB9_E5: 0x8c3d,
  RGBA32UI: 0x8d70,
  RGB32UI: 0x8d71,
  RGBA16UI: 0x8d76,
  RGB16UI: 0x8d77,
  RGBA8UI: 0x8d7c,
  RGB8UI: 0x8d7d,
  RGBA32I: 0x8d82,
  RGB32I: 0x8d83,
  RGBA16I: 0x8d88,
  RGB16I: 0x8d89,
  RGBA8I: 0x8d8e,
  RGB8I: 0x8d8f,
  RED_INTEGER: 0x8d94,
  RGB_INTEGER: 0x8d98,
  RGBA_INTEGER: 0x8d99,
  R8: 0x8229,
  RG8: 0x822b,
  R16F: 0x822d,
  R32F: 0x822e,
  RG16F: 0x822f,
  RG32F: 0x8230,
  R8I: 0x8231,
  R8UI: 0x8232,
  R16I: 0x8233,
  R16UI: 0x8234,
  R32I: 0x8235,
  R32UI: 0x8236,
  RG8I: 0x8237,
  RG8UI: 0x8238,
  RG16I: 0x8239,
  RG16UI: 0x823a,
  RG32I: 0x823b,
  RG32UI: 0x823c,
  R8_SNORM: 0x8f94,
  RG8_SNORM: 0x8f95,
  RGB8_SNORM: 0x8f96,
  RGBA8_SNORM: 0x8f97,
  RGB10_A2UI: 0x906f,

  /* covered by extension
  COMPRESSED_R11_EAC : 0x9270,
  COMPRESSED_SIGNED_R11_EAC: 0x9271,
  COMPRESSED_RG11_EAC: 0x9272,
  COMPRESSED_SIGNED_RG11_EAC : 0x9273,
  COMPRESSED_RGB8_ETC2 : 0x9274,
  COMPRESSED_SRGB8_ETC2: 0x9275,
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 : 0x9276,
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC : 0x9277,
  COMPRESSED_RGBA8_ETC2_EAC: 0x9278,
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : 0x9279,
  */
  TEXTURE_IMMUTABLE_FORMAT: 0x912f,
  TEXTURE_IMMUTABLE_LEVELS: 0x82df,

  // Pixel types

  UNSIGNED_INT_2_10_10_10_REV: 0x8368,
  UNSIGNED_INT_10F_11F_11F_REV: 0x8c3b,
  UNSIGNED_INT_5_9_9_9_REV: 0x8c3e,
  FLOAT_32_UNSIGNED_INT_24_8_REV: 0x8dad,
  UNSIGNED_INT_24_8: 0x84fa,
  HALF_FLOAT: 0x140b,
  RG: 0x8227,
  RG_INTEGER: 0x8228,
  INT_2_10_10_10_REV: 0x8d9f,

  // Queries

  CURRENT_QUERY: 0x8865,
  QUERY_RESULT: 0x8866,
  QUERY_RESULT_AVAILABLE: 0x8867,
  ANY_SAMPLES_PASSED: 0x8c2f,
  ANY_SAMPLES_PASSED_CONSERVATIVE: 0x8d6a,

  // Draw buffers

  MAX_DRAW_BUFFERS: 0x8824,
  DRAW_BUFFER0: 0x8825,
  DRAW_BUFFER1: 0x8826,
  DRAW_BUFFER2: 0x8827,
  DRAW_BUFFER3: 0x8828,
  DRAW_BUFFER4: 0x8829,
  DRAW_BUFFER5: 0x882a,
  DRAW_BUFFER6: 0x882b,
  DRAW_BUFFER7: 0x882c,
  DRAW_BUFFER8: 0x882d,
  DRAW_BUFFER9: 0x882e,
  DRAW_BUFFER10: 0x882f,
  DRAW_BUFFER11: 0x8830,
  DRAW_BUFFER12: 0x8831,
  DRAW_BUFFER13: 0x8832,
  DRAW_BUFFER14: 0x8833,
  DRAW_BUFFER15: 0x8834,
  MAX_COLOR_ATTACHMENTS: 0x8cdf,
  COLOR_ATTACHMENT1: 0x8ce1,
  COLOR_ATTACHMENT2: 0x8ce2,
  COLOR_ATTACHMENT3: 0x8ce3,
  COLOR_ATTACHMENT4: 0x8ce4,
  COLOR_ATTACHMENT5: 0x8ce5,
  COLOR_ATTACHMENT6: 0x8ce6,
  COLOR_ATTACHMENT7: 0x8ce7,
  COLOR_ATTACHMENT8: 0x8ce8,
  COLOR_ATTACHMENT9: 0x8ce9,
  COLOR_ATTACHMENT10: 0x8cea,
  COLOR_ATTACHMENT11: 0x8ceb,
  COLOR_ATTACHMENT12: 0x8cec,
  COLOR_ATTACHMENT13: 0x8ced,
  COLOR_ATTACHMENT14: 0x8cee,
  COLOR_ATTACHMENT15: 0x8cef,

  // Samplers

  SAMPLER_3D: 0x8b5f,
  SAMPLER_2D_SHADOW: 0x8b62,
  SAMPLER_2D_ARRAY: 0x8dc1,
  SAMPLER_2D_ARRAY_SHADOW: 0x8dc4,
  SAMPLER_CUBE_SHADOW: 0x8dc5,
  INT_SAMPLER_2D: 0x8dca,
  INT_SAMPLER_3D: 0x8dcb,
  INT_SAMPLER_CUBE: 0x8dcc,
  INT_SAMPLER_2D_ARRAY: 0x8dcf,
  UNSIGNED_INT_SAMPLER_2D: 0x8dd2,
  UNSIGNED_INT_SAMPLER_3D: 0x8dd3,
  UNSIGNED_INT_SAMPLER_CUBE: 0x8dd4,
  UNSIGNED_INT_SAMPLER_2D_ARRAY: 0x8dd7,
  MAX_SAMPLES: 0x8d57,
  SAMPLER_BINDING: 0x8919,

  // Buffers

  PIXEL_PACK_BUFFER: 0x88eb,
  PIXEL_UNPACK_BUFFER: 0x88ec,
  PIXEL_PACK_BUFFER_BINDING: 0x88ed,
  PIXEL_UNPACK_BUFFER_BINDING: 0x88ef,
  COPY_READ_BUFFER: 0x8f36,
  COPY_WRITE_BUFFER: 0x8f37,
  COPY_READ_BUFFER_BINDING: 0x8f36,
  COPY_WRITE_BUFFER_BINDING: 0x8f37,

  // Data types

  FLOAT_MAT2x3: 0x8b65,
  FLOAT_MAT2x4: 0x8b66,
  FLOAT_MAT3x2: 0x8b67,
  FLOAT_MAT3x4: 0x8b68,
  FLOAT_MAT4x2: 0x8b69,
  FLOAT_MAT4x3: 0x8b6a,
  UNSIGNED_INT_VEC2: 0x8dc6,
  UNSIGNED_INT_VEC3: 0x8dc7,
  UNSIGNED_INT_VEC4: 0x8dc8,
  UNSIGNED_NORMALIZED: 0x8c17,
  SIGNED_NORMALIZED: 0x8f9c,

  // Vertex attributes

  VERTEX_ATTRIB_ARRAY_INTEGER: 0x88fd,
  VERTEX_ATTRIB_ARRAY_DIVISOR: 0x88fe,

  // Transform feedback

  TRANSFORM_FEEDBACK_BUFFER_MODE: 0x8c7f,
  MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 0x8c80,
  TRANSFORM_FEEDBACK_VARYINGS: 0x8c83,
  TRANSFORM_FEEDBACK_BUFFER_START: 0x8c84,
  TRANSFORM_FEEDBACK_BUFFER_SIZE: 0x8c85,
  TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 0x8c88,
  MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 0x8c8a,
  MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 0x8c8b,
  INTERLEAVED_ATTRIBS: 0x8c8c,
  SEPARATE_ATTRIBS: 0x8c8d,
  TRANSFORM_FEEDBACK_BUFFER: 0x8c8e,
  TRANSFORM_FEEDBACK_BUFFER_BINDING: 0x8c8f,
  TRANSFORM_FEEDBACK: 0x8e22,
  TRANSFORM_FEEDBACK_PAUSED: 0x8e23,
  TRANSFORM_FEEDBACK_ACTIVE: 0x8e24,
  TRANSFORM_FEEDBACK_BINDING: 0x8e25,

  // Framebuffers and renderbuffers

  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 0x8210,
  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 0x8211,
  FRAMEBUFFER_ATTACHMENT_RED_SIZE: 0x8212,
  FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 0x8213,
  FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 0x8214,
  FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 0x8215,
  FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 0x8216,
  FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 0x8217,
  FRAMEBUFFER_DEFAULT: 0x8218,
  // DEPTH_STENCIL_ATTACHMENT : 0x821A,
  // DEPTH_STENCIL: 0x84F9,
  DEPTH24_STENCIL8: 0x88f0,
  DRAW_FRAMEBUFFER_BINDING: 0x8ca6,
  READ_FRAMEBUFFER_BINDING: 0x8caa,
  RENDERBUFFER_SAMPLES: 0x8cab,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 0x8cd4,
  FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 0x8d56,

  // Uniforms

  UNIFORM_BUFFER: 0x8a11,
  UNIFORM_BUFFER_BINDING: 0x8a28,
  UNIFORM_BUFFER_START: 0x8a29,
  UNIFORM_BUFFER_SIZE: 0x8a2a,
  MAX_VERTEX_UNIFORM_BLOCKS: 0x8a2b,
  MAX_FRAGMENT_UNIFORM_BLOCKS: 0x8a2d,
  MAX_COMBINED_UNIFORM_BLOCKS: 0x8a2e,
  MAX_UNIFORM_BUFFER_BINDINGS: 0x8a2f,
  MAX_UNIFORM_BLOCK_SIZE: 0x8a30,
  MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 0x8a31,
  MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 0x8a33,
  UNIFORM_BUFFER_OFFSET_ALIGNMENT: 0x8a34,
  ACTIVE_UNIFORM_BLOCKS: 0x8a36,
  UNIFORM_TYPE: 0x8a37,
  UNIFORM_SIZE: 0x8a38,
  UNIFORM_BLOCK_INDEX: 0x8a3a,
  UNIFORM_OFFSET: 0x8a3b,
  UNIFORM_ARRAY_STRIDE: 0x8a3c,
  UNIFORM_MATRIX_STRIDE: 0x8a3d,
  UNIFORM_IS_ROW_MAJOR: 0x8a3e,
  UNIFORM_BLOCK_BINDING: 0x8a3f,
  UNIFORM_BLOCK_DATA_SIZE: 0x8a40,
  UNIFORM_BLOCK_ACTIVE_UNIFORMS: 0x8a42,
  UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 0x8a43,
  UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 0x8a44,
  UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 0x8a46,

  // Sync objects

  OBJECT_TYPE: 0x9112,
  SYNC_CONDITION: 0x9113,
  SYNC_STATUS: 0x9114,
  SYNC_FLAGS: 0x9115,
  SYNC_FENCE: 0x9116,
  SYNC_GPU_COMMANDS_COMPLETE: 0x9117,
  UNSIGNALED: 0x9118,
  SIGNALED: 0x9119,
  ALREADY_SIGNALED: 0x911a,
  TIMEOUT_EXPIRED: 0x911b,
  CONDITION_SATISFIED: 0x911c,
  WAIT_FAILED: 0x911d,
  SYNC_FLUSH_COMMANDS_BIT: 0x00000001,

  // Miscellaneous constants

  COLOR: 0x1800,
  DEPTH: 0x1801,
  STENCIL: 0x1802,
  MIN: 0x8007,
  MAX: 0x8008,
  DEPTH_COMPONENT24: 0x81a6,
  STREAM_READ: 0x88e1,
  STREAM_COPY: 0x88e2,
  STATIC_READ: 0x88e5,
  STATIC_COPY: 0x88e6,
  DYNAMIC_READ: 0x88e9,
  DYNAMIC_COPY: 0x88ea,
  DEPTH_COMPONENT32F: 0x8cac,
  DEPTH32F_STENCIL8: 0x8cad,
  INVALID_INDEX: 0xffffffff,
  TIMEOUT_IGNORED: -1,
  MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 0x9247,

  // Constants defined in WebGL extensions

  // ANGLE_instanced_arrays

  VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 0x88fe,

  // WEBGL_debug_renderer_info

  UNMASKED_VENDOR_WEBGL: 0x9245,
  UNMASKED_RENDERER_WEBGL: 0x9246,

  // EXT_texture_filter_anisotropic

  MAX_TEXTURE_MAX_ANISOTROPY_EXT: 0x84ff,
  TEXTURE_MAX_ANISOTROPY_EXT: 0x84fe,

  // WEBGL_compressed_texture_s3tc

  COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83f0,
  COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83f1,
  COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83f2,
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83f3,

  // WEBGL_compressed_texture_es3

  COMPRESSED_R11_EAC: 0x9270,
  COMPRESSED_SIGNED_R11_EAC: 0x9271,
  COMPRESSED_RG11_EAC: 0x9272,
  COMPRESSED_SIGNED_RG11_EAC: 0x9273,
  COMPRESSED_RGB8_ETC2: 0x9274,
  COMPRESSED_RGBA8_ETC2_EAC: 0x9275,
  COMPRESSED_SRGB8_ETC2: 0x9276,
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9277,
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9278,
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9279,

  // WEBGL_compressed_texture_pvrtc

  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8c00,
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8c02,
  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8c01,
  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8c03,

  // WEBGL_compressed_texture_etc1

  COMPRESSED_RGB_ETC1_WEBGL: 0x8d64,

  // WEBGL_compressed_texture_atc

  COMPRESSED_RGB_ATC_WEBGL: 0x8c92,
  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 0x8c92,
  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 0x87ee,

  // WEBGL_depth_texture

  UNSIGNED_INT_24_8_WEBGL: 0x84fa,

  // OES_texture_half_float

  HALF_FLOAT_OES: 0x8d61,

  // WEBGL_color_buffer_float

  RGBA32F_EXT: 0x8814,
  RGB32F_EXT: 0x8815,
  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211,
  UNSIGNED_NORMALIZED_EXT: 0x8c17,

  // EXT_blend_minmax

  MIN_EXT: 0x8007,
  MAX_EXT: 0x8008,

  // EXT_sRGB

  SRGB_EXT: 0x8c40,
  SRGB_ALPHA_EXT: 0x8c42,
  SRGB8_ALPHA8_EXT: 0x8c43,
  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: 0x8210,

  // OES_standard_derivatives

  FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 0x8b8b,

  // WEBGL_draw_buffers

  COLOR_ATTACHMENT0_WEBGL: 0x8ce0,
  COLOR_ATTACHMENT1_WEBGL: 0x8ce1,
  COLOR_ATTACHMENT2_WEBGL: 0x8ce2,
  COLOR_ATTACHMENT3_WEBGL: 0x8ce3,
  COLOR_ATTACHMENT4_WEBGL: 0x8ce4,
  COLOR_ATTACHMENT5_WEBGL: 0x8ce5,
  COLOR_ATTACHMENT6_WEBGL: 0x8ce6,
  COLOR_ATTACHMENT7_WEBGL: 0x8ce7,
  COLOR_ATTACHMENT8_WEBGL: 0x8ce8,
  COLOR_ATTACHMENT9_WEBGL: 0x8ce9,
  COLOR_ATTACHMENT10_WEBGL: 0x8cea,
  COLOR_ATTACHMENT11_WEBGL: 0x8ceb,
  COLOR_ATTACHMENT12_WEBGL: 0x8cec,
  COLOR_ATTACHMENT13_WEBGL: 0x8ced,
  COLOR_ATTACHMENT14_WEBGL: 0x8cee,
  COLOR_ATTACHMENT15_WEBGL: 0x8cef,
  DRAW_BUFFER0_WEBGL: 0x8825,
  DRAW_BUFFER1_WEBGL: 0x8826,
  DRAW_BUFFER2_WEBGL: 0x8827,
  DRAW_BUFFER3_WEBGL: 0x8828,
  DRAW_BUFFER4_WEBGL: 0x8829,
  DRAW_BUFFER5_WEBGL: 0x882a,
  DRAW_BUFFER6_WEBGL: 0x882b,
  DRAW_BUFFER7_WEBGL: 0x882c,
  DRAW_BUFFER8_WEBGL: 0x882d,
  DRAW_BUFFER9_WEBGL: 0x882e,
  DRAW_BUFFER10_WEBGL: 0x882f,
  DRAW_BUFFER11_WEBGL: 0x8830,
  DRAW_BUFFER12_WEBGL: 0x8831,
  DRAW_BUFFER13_WEBGL: 0x8832,
  DRAW_BUFFER14_WEBGL: 0x8833,
  DRAW_BUFFER15_WEBGL: 0x8834,
  MAX_COLOR_ATTACHMENTS_WEBGL: 0x8cdf,
  MAX_DRAW_BUFFERS_WEBGL: 0x8824,

  // OES_vertex_array_object

  VERTEX_ARRAY_BINDING_OES: 0x85b5,

  // EXT_disjoint_timer_query

  QUERY_COUNTER_BITS_EXT: 0x8864,
  CURRENT_QUERY_EXT: 0x8865,
  QUERY_RESULT_EXT: 0x8866,
  QUERY_RESULT_AVAILABLE_EXT: 0x8867,
  TIME_ELAPSED_EXT: 0x88bf,
  TIMESTAMP_EXT: 0x8e28,
  GPU_DISJOINT_EXT: 0x8fbb // A Boolean indicating whether or not the GPU performed any disjoint operation.
});


/***/ }),

/***/ "./src/bundle.js":
/*!***********************!*\
  !*** ./src/bundle.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const moduleExports = __webpack_require__(/*! ./index */ "./src/index.js");

// @ts-ignore
globalThis.luma = globalThis.luma || {};
// @ts-ignore
module.exports = Object.assign(globalThis.luma, moduleExports);


/***/ }),

/***/ "./src/context/context.js":
/*!********************************!*\
  !*** ./src/context/context.js ***!
  \********************************/
/*! exports provided: createGLContext, instrumentGLContext, getContextDebugInfo, resizeGLContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createGLContext", function() { return createGLContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "instrumentGLContext", function() { return instrumentGLContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContextDebugInfo", function() { return getContextDebugInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resizeGLContext", function() { return resizeGLContext; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @probe.gl/env */ "../../node_modules/@probe.gl/env/dist/esm/index.js");
/* harmony import */ var _state_tracker_track_context_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../state-tracker/track-context-state */ "./src/state-tracker/track-context-state.js");
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/log */ "./src/utils/log.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/assert */ "./src/utils/assert.js");
/* harmony import */ var _utils_device_pixels__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/device-pixels */ "./src/utils/device-pixels.js");
/* harmony import */ var _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/webgl-checks */ "./src/utils/webgl-checks.js");
// WebGLRenderingContext related methods

/** @typedef {import('./context')} types */

/* eslint-disable quotes */









const isBrowser = Object(_probe_gl_env__WEBPACK_IMPORTED_MODULE_1__["isBrowser"])();
const isPage = isBrowser && typeof document !== 'undefined';

const CONTEXT_DEFAULTS = {
  // COMMON CONTEXT PARAMETERS
  // Attempt to allocate WebGL2 context
  webgl2: true, // Attempt to create a WebGL2 context (false to force webgl1)
  webgl1: true, // Attempt to create a WebGL1 context (false to fail if webgl2 not available)
  throwOnError: true,
  manageState: true,
  // BROWSER CONTEXT PARAMETERS
  canvas: null, // A canvas element or a canvas string id
  debug: false, // Instrument context (at the expense of performance)
  // HEADLESS CONTEXT PARAMETERS
  width: 800, // width are height are only used by headless gl
  height: 600
  // WEBGL/HEADLESS CONTEXT PARAMETERS
  // Remaining options are passed through to context creator
};

/**
 * Creates a context giving access to the WebGL API
 * @type {types['createGLContext']}
 */
/* eslint-disable complexity, max-statements */
function createGLContext(options = {}) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_4__["assert"])(
    isBrowser,
    "createGLContext only available in the browser.\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils"
  );

  options = Object.assign({}, CONTEXT_DEFAULTS, options);
  const {width, height} = options;

  // Error reporting function, enables exceptions to be disabled
  function onError(message) {
    if (options.throwOnError) {
      throw new Error(message);
    }
    // eslint-disable-next-line
    console.error(message);
    return null;
  }
  options.onError = onError;

  let gl;
  // Get or create a canvas
  const {canvas} = options;
  const targetCanvas = getCanvas({canvas, width, height, onError});
  // Create a WebGL context in the canvas
  gl = createBrowserContext(targetCanvas, options);

  if (!gl) {
    return null;
  }

  gl = instrumentGLContext(gl, options);

  // Log some debug info about the newly created context
  logInfo(gl);

  // Add to seer integration
  return gl;
}

/**
 * Creates a context giving access to the WebGL API
 * @type {types['instrumentGLContext']}
 */
function instrumentGLContext(gl, options = {}) {
  // Avoid multiple instrumentations
  // @ts-ignore
  if (!gl || gl._instrumented) {
    return gl;
  }

  // @ts-ignore
  gl._version = gl._version || getVersion(gl);

  // Cache canvas size information to avoid setting it on every frame.
  // @ts-ignore
  gl.luma = gl.luma || {};
  // @ts-ignore
  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};

  options = Object.assign({}, CONTEXT_DEFAULTS, options);
  const {manageState, debug} = options;

  // Install context state tracking
  if (manageState) {
    Object(_state_tracker_track_context_state__WEBPACK_IMPORTED_MODULE_2__["trackContextState"])(gl, {
      copyState: false,
      log: (...args) => _utils_log__WEBPACK_IMPORTED_MODULE_3__["log"].log(1, ...args)()
    });
  }

  // Add debug instrumentation to the context
  if (isBrowser && debug) {
    // @ts-ignore
    if (!globalThis.makeDebugContext) {
      _utils_log__WEBPACK_IMPORTED_MODULE_3__["log"].warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')();
    } else {
      // @ts-ignore
      gl = globalThis.makeDebugContext(gl, options);
      // Debug forces log level to at least 1
      _utils_log__WEBPACK_IMPORTED_MODULE_3__["log"].level = Math.max(_utils_log__WEBPACK_IMPORTED_MODULE_3__["log"].level, 1);
    }
  }

  // @ts-ignore
  gl._instrumented = true;

  return gl;
}

/**
 * Provides strings identifying the GPU vendor and driver.
 * @type {types['getContextDebugInfo']}
 */
function getContextDebugInfo(gl) {
  const vendorMasked = gl.getParameter(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].VENDOR);
  const rendererMasked = gl.getParameter(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].RENDERER);
  const ext = gl.getExtension('WEBGL_debug_renderer_info');
  const vendorUnmasked = ext && gl.getParameter(ext.UNMASKED_VENDOR_WEBGL || _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].VENDOR);
  const rendererUnmasked = ext && gl.getParameter(ext.UNMASKED_RENDERER_WEBGL || _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].RENDERER);
  return {
    vendor: vendorUnmasked || vendorMasked,
    renderer: rendererUnmasked || rendererMasked,
    vendorMasked,
    rendererMasked,
    version: gl.getParameter(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].VERSION),
    shadingLanguageVersion: gl.getParameter(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SHADING_LANGUAGE_VERSION)
  };
}

/**
 * Resize the canvas' drawing buffer.
 * @type {types['resizeGLContext']}
 */
function resizeGLContext(gl, options = {}) {
  // Resize browser context
  if (gl.canvas) {
    const devicePixelRatio = Object(_utils_device_pixels__WEBPACK_IMPORTED_MODULE_5__["getDevicePixelRatio"])(options.useDevicePixels);
    setDevicePixelRatio(gl, devicePixelRatio, options);
    return;
  }

  // Resize headless gl context
  const ext = gl.getExtension('STACKGL_resize_drawingbuffer');
  if (ext && `width` in options && `height` in options) {
    ext.resize(options.width, options.height);
  }
}

// HELPER METHODS

/**
 * Create a WebGL context for a canvas
 * Note calling this multiple time on the same canvas does return the same context
 */

function createBrowserContext(canvas, options) {
  const {onError} = options;

  // Try to extract any extra information about why context creation failed
  let errorMessage = null;
  const onCreateError = error => (errorMessage = error.statusMessage || errorMessage);
  canvas.addEventListener('webglcontextcreationerror', onCreateError, false);

  const {webgl1 = true, webgl2 = true} = options;
  let gl = null;
  // Prefer webgl2 over webgl1, prefer conformant over experimental
  if (webgl2) {
    gl = gl || canvas.getContext('webgl2', options);
    gl = gl || canvas.getContext('experimental-webgl2', options);
  }
  if (webgl1) {
    gl = gl || canvas.getContext('webgl', options);
    gl = gl || canvas.getContext('experimental-webgl', options);
  }

  canvas.removeEventListener('webglcontextcreationerror', onCreateError, false);

  if (!gl) {
    return onError(
      `Failed to create ${webgl2 && !webgl1 ? 'WebGL2' : 'WebGL'} context: ${errorMessage ||
        'Unknown error'}`
    );
  }

  if (options.onContextLost) {
    canvas.addEventListener('webglcontextlost', options.onContextLost, false);
  }

  if (options.onContextRestored) {
    canvas.addEventListener('webglcontextrestored', options.onContextRestored, false);
  }

  return gl;
}

function getCanvas({canvas, width = 800, height = 600, onError}) {
  let targetCanvas;
  if (typeof canvas === 'string') {
    const isPageLoaded = isPage && document.readyState === 'complete';
    if (!isPageLoaded) {
      onError(`createGLContext called on canvas '${canvas}' before page was loaded`);
    }
    targetCanvas = document.getElementById(canvas);
  } else if (canvas) {
    targetCanvas = canvas;
  } else {
    targetCanvas = document.createElement('canvas');
    targetCanvas.id = 'lumagl-canvas';
    targetCanvas.style.width = Number.isFinite(width) ? `${width}px` : '100%';
    targetCanvas.style.height = Number.isFinite(height) ? `${height}px` : '100%';
    document.body.insertBefore(targetCanvas, document.body.firstChild);
  }

  return targetCanvas;
}

function logInfo(gl) {
  const webGL = Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_6__["isWebGL2"])(gl) ? 'WebGL2' : 'WebGL1';
  const info = getContextDebugInfo(gl);
  const driver = info ? `(${info.vendor},${info.renderer})` : '';
  const debug = gl.debug ? ' debug' : '';
  _utils_log__WEBPACK_IMPORTED_MODULE_3__["log"].info(1, `${webGL}${debug} context ${driver}`)();
}

function getVersion(gl) {
  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
    // WebGL2 context.
    return 2;
  }
  // Must be a WebGL1 context.
  return 1;
}

// use devicePixelRatio to set canvas width and height
function setDevicePixelRatio(gl, devicePixelRatio, options) {
  // NOTE: if options.width and options.height not used remove in v8
  let clientWidth = 'width' in options ? options.width : gl.canvas.clientWidth;
  let clientHeight = 'height' in options ? options.height : gl.canvas.clientHeight;

  if (!clientWidth || !clientHeight) {
    _utils_log__WEBPACK_IMPORTED_MODULE_3__["log"].log(1, 'Canvas clientWidth/clientHeight is 0')();
    // by forcing devicePixel ratio to 1, we do not scale gl.canvas.width and height in each frame.
    devicePixelRatio = 1;
    clientWidth = gl.canvas.width || 1;
    clientHeight = gl.canvas.height || 1;
  }

  gl.luma = gl.luma || {};
  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
  const cachedSize = gl.luma.canvasSizeInfo;
  // Check if canvas needs to be resized
  if (
    cachedSize.clientWidth !== clientWidth ||
    cachedSize.clientHeight !== clientHeight ||
    cachedSize.devicePixelRatio !== devicePixelRatio
  ) {
    let clampedPixelRatio = devicePixelRatio;

    const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
    const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
    gl.canvas.width = canvasWidth;
    gl.canvas.height = canvasHeight;

    // Note: when devicePixelRatio is too high, it is possible we might hit system limit for
    // drawing buffer width and hight, in those cases they get clamped and resulting aspect ration may not be maintained
    // for those cases, reduce devicePixelRatio.
    if (gl.drawingBufferWidth !== canvasWidth || gl.drawingBufferHeight !== canvasHeight) {
      _utils_log__WEBPACK_IMPORTED_MODULE_3__["log"].warn(`Device pixel ratio clamped`)();
      clampedPixelRatio = Math.min(
        gl.drawingBufferWidth / clientWidth,
        gl.drawingBufferHeight / clientHeight
      );

      gl.canvas.width = Math.floor(clientWidth * clampedPixelRatio);
      gl.canvas.height = Math.floor(clientHeight * clampedPixelRatio);
    }

    Object.assign(gl.luma.canvasSizeInfo, {clientWidth, clientHeight, devicePixelRatio});
  }
}


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: log, isWebGL, isWebGL2, getWebGL2Context, assertWebGLContext, assertWebGL2Context, polyfillContext, getParameters, setParameters, resetParameters, withParameters, trackContextState, pushContextState, popContextState, createGLContext, resizeGLContext, instrumentGLContext, getContextDebugInfo, cssToDeviceRatio, cssToDevicePixels */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/log */ "./src/utils/log.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "log", function() { return _utils_log__WEBPACK_IMPORTED_MODULE_0__["log"]; });

/* harmony import */ var _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/webgl-checks */ "./src/utils/webgl-checks.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWebGL", function() { return _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__["isWebGL"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWebGL2", function() { return _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getWebGL2Context", function() { return _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__["getWebGL2Context"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assertWebGLContext", function() { return _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__["assertWebGLContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assertWebGL2Context", function() { return _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__["assertWebGL2Context"]; });

/* harmony import */ var _polyfill_polyfill_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polyfill/polyfill-context */ "./src/polyfill/polyfill-context.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "polyfillContext", function() { return _polyfill_polyfill_context__WEBPACK_IMPORTED_MODULE_2__["polyfillContext"]; });

/* harmony import */ var _state_tracker_unified_parameter_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./state-tracker/unified-parameter-api */ "./src/state-tracker/unified-parameter-api.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getParameters", function() { return _state_tracker_unified_parameter_api__WEBPACK_IMPORTED_MODULE_3__["getParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setParameters", function() { return _state_tracker_unified_parameter_api__WEBPACK_IMPORTED_MODULE_3__["setParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resetParameters", function() { return _state_tracker_unified_parameter_api__WEBPACK_IMPORTED_MODULE_3__["resetParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withParameters", function() { return _state_tracker_unified_parameter_api__WEBPACK_IMPORTED_MODULE_3__["withParameters"]; });

/* harmony import */ var _state_tracker_track_context_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./state-tracker/track-context-state */ "./src/state-tracker/track-context-state.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "trackContextState", function() { return _state_tracker_track_context_state__WEBPACK_IMPORTED_MODULE_4__["trackContextState"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pushContextState", function() { return _state_tracker_track_context_state__WEBPACK_IMPORTED_MODULE_4__["pushContextState"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "popContextState", function() { return _state_tracker_track_context_state__WEBPACK_IMPORTED_MODULE_4__["popContextState"]; });

/* harmony import */ var _context_context__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./context/context */ "./src/context/context.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createGLContext", function() { return _context_context__WEBPACK_IMPORTED_MODULE_5__["createGLContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resizeGLContext", function() { return _context_context__WEBPACK_IMPORTED_MODULE_5__["resizeGLContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "instrumentGLContext", function() { return _context_context__WEBPACK_IMPORTED_MODULE_5__["instrumentGLContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getContextDebugInfo", function() { return _context_context__WEBPACK_IMPORTED_MODULE_5__["getContextDebugInfo"]; });

/* harmony import */ var _utils_device_pixels__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/device-pixels */ "./src/utils/device-pixels.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cssToDeviceRatio", function() { return _utils_device_pixels__WEBPACK_IMPORTED_MODULE_6__["cssToDeviceRatio"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cssToDevicePixels", function() { return _utils_device_pixels__WEBPACK_IMPORTED_MODULE_6__["cssToDevicePixels"]; });

// Utils



// Polyfills to support a subset of WebGL2 APIs on WebGL1 contexts


// unified parameter APIs


// state tracking







/***/ }),

/***/ "./src/polyfill/get-parameter-polyfill.js":
/*!************************************************!*\
  !*** ./src/polyfill/get-parameter-polyfill.js ***!
  \************************************************/
/*! exports provided: getParameterPolyfill */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getParameterPolyfill", function() { return getParameterPolyfill; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/webgl-checks */ "./src/utils/webgl-checks.js");
/* eslint-disable no-inline-comments, max-len, camelcase */



const OES_element_index = 'OES_element_index';
const WEBGL_draw_buffers = 'WEBGL_draw_buffers';
const EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';
const EXT_disjoint_timer_query_webgl2 = 'EXT_disjoint_timer_query_webgl2';
const EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';
const WEBGL_debug_renderer_info = 'WEBGL_debug_renderer_info';

const GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8b8b;
const GL_DONT_CARE = 0x1100;
const GL_GPU_DISJOINT_EXT = 0x8fbb;
const GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84ff;
const GL_UNMASKED_VENDOR_WEBGL = 0x9245; // vendor string of the graphics driver.
const GL_UNMASKED_RENDERER_WEBGL = 0x9246; // renderer string of the graphics driver.

const getWebGL2ValueOrZero = gl => (!Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(gl) ? 0 : undefined);

// if a function returns undefined in this table,
// the original getParameter will be called, defeating the override
const WEBGL_PARAMETERS = {
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].READ_BUFFER]: gl => (!Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(gl) ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].COLOR_ATTACHMENT0 : undefined),

  // WebGL2 context parameters
  [GL_FRAGMENT_SHADER_DERIVATIVE_HINT]: gl => (!Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(gl) ? GL_DONT_CARE : undefined),

  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].RASTERIZER_DISCARD]: getWebGL2ValueOrZero,

  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SAMPLES]: getWebGL2ValueOrZero,

  // WebGL2 extension context parameters
  [GL_GPU_DISJOINT_EXT]: (gl, getParameter) => {
    const ext = Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(gl)
      ? gl.getExtension(EXT_disjoint_timer_query_webgl2)
      : gl.getExtension(EXT_disjoint_timer_query);
    return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
  },

  // Extension fixed values
  [GL_UNMASKED_VENDOR_WEBGL]: (gl, getParameter) => {
    const ext = gl.getExtension(WEBGL_debug_renderer_info);
    return getParameter((ext && ext.UNMASKED_VENDOR_WEBGL) || _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].VENDOR);
  },

  [GL_UNMASKED_RENDERER_WEBGL]: (gl, getParameter) => {
    const ext = gl.getExtension(WEBGL_debug_renderer_info);
    return getParameter((ext && ext.UNMASKED_RENDERER_WEBGL) || _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].RENDERER);
  },

  // Extension LIMITS
  [GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT]: (gl, getParameter) => {
    const ext = gl.luma.extensions[EXT_texture_filter_anisotropic];
    return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1.0;
  },

  // WebGL2 Limits
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_3D_TEXTURE_SIZE]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_ARRAY_TEXTURE_LAYERS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_CLIENT_WAIT_TIMEOUT_WEBGL]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_COLOR_ATTACHMENTS]: (gl, getParameter) => {
    if (!Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(gl)) {
      const ext = gl.getExtension(WEBGL_draw_buffers);
      return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
    }
    return undefined;
  },
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_COMBINED_UNIFORM_BLOCKS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_DRAW_BUFFERS]: gl => {
    if (!Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(gl)) {
      const ext = gl.getExtension(WEBGL_draw_buffers);
      return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
    }
    return undefined;
  },
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_ELEMENT_INDEX]:
    // Guess: per webglstats.com 99.6% of webgl2 supports 2147483647
    gl => (gl.getExtension(OES_element_index) ? 2147483647 : 65535),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_ELEMENTS_INDICES]:
    // Guess: "Reasonably safe" per webglstats.com - could be higher/lower (on some mobile devices)
    gl => (gl.getExtension(OES_element_index) ? 16777216 : 65535),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_ELEMENTS_VERTICES]:
    // Guess: "Reasonably safe" per webglstats.com - could be higher/lower (on some mobile devices)
    gl => 16777216,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_FRAGMENT_INPUT_COMPONENTS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_FRAGMENT_UNIFORM_BLOCKS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_FRAGMENT_UNIFORM_COMPONENTS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_SAMPLES]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_SERVER_WAIT_TIMEOUT]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_TEXTURE_LOD_BIAS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_UNIFORM_BLOCK_SIZE]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_UNIFORM_BUFFER_BINDINGS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_VARYING_COMPONENTS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_VERTEX_OUTPUT_COMPONENTS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_VERTEX_UNIFORM_BLOCKS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_VERTEX_UNIFORM_COMPONENTS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MIN_PROGRAM_TEXEL_OFFSET]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_PROGRAM_TEXEL_OFFSET]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].UNIFORM_BUFFER_OFFSET_ALIGNMENT]: getWebGL2ValueOrZero
};

// A "replacement" gl.getParameter that accepts "enums" from extensions and WebGL2
// and returns reasonably safe defaults
function getParameterPolyfill(gl, originalGetParameter, pname) {
  // Return mock limits (usually 0) for WebGL2 constants to ensure these
  // can be queries without error
  const limit = WEBGL_PARAMETERS[pname];
  // @ts-ignore TODO pname parameter not declared
  const value = typeof limit === 'function' ? limit(gl, originalGetParameter, pname) : limit;
  const result = value !== undefined ? value : originalGetParameter(pname);
  return result;
}


/***/ }),

/***/ "./src/polyfill/polyfill-context.js":
/*!******************************************!*\
  !*** ./src/polyfill/polyfill-context.js ***!
  \******************************************/
/*! exports provided: polyfillContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyfillContext", function() { return polyfillContext; });
/* harmony import */ var _polyfill_vertex_array_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polyfill-vertex-array-object */ "./src/polyfill/polyfill-vertex-array-object.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/assert */ "./src/utils/assert.js");
/* harmony import */ var _polyfill_table__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polyfill-table */ "./src/polyfill/polyfill-table.js");
// WebGL1/WebGL2 extension polyfill support
//
// Provides a function that creates polyfills for WebGL2 functions based
// on available extensions and installs them on a supplied target (could be
// the WebGLContext or its prototype, or a separate object).
//
// This is intended to be a stand-alone file with minimal dependencies,
// easy to reuse or repurpose in other projects.

/** @typedef {import('./polyfill-context')} types */






/** @type {types['polyfillContext']} */
function polyfillContext(gl) {
  // @ts-ignore
  gl.luma = gl.luma || {};
  // @ts-ignore
  const {luma} = gl;

  if (!luma.polyfilled) {
    Object(_polyfill_vertex_array_object__WEBPACK_IMPORTED_MODULE_0__["polyfillVertexArrayObject"])(gl);
    initializeExtensions(gl);
    installPolyfills(gl, _polyfill_table__WEBPACK_IMPORTED_MODULE_2__["WEBGL2_CONTEXT_POLYFILLS"]);
    installOverrides(gl, {target: luma, target2: gl});
    luma.polyfilled = true;
  }

  // TODO - only supporting a few members
  /** @type {WebGL2RenderingContext} */
  // @ts-ignore
  return gl;
}

// TODO - is this still required?
// @ts-ignore
globalThis.polyfillContext = polyfillContext;

function initializeExtensions(gl) {
  gl.luma.extensions = {};
  // `getSupportedExtensions` can return null when context is lost.
  const EXTENSIONS = gl.getSupportedExtensions() || [];
  for (const extension of EXTENSIONS) {
    gl.luma[extension] = gl.getExtension(extension);
  }
}

// Install simple overrides (mostly get* functions)
function installOverrides(gl, {target, target2}) {
  Object.keys(_polyfill_table__WEBPACK_IMPORTED_MODULE_2__["WEBGL2_CONTEXT_OVERRIDES"]).forEach(key => {
    if (typeof _polyfill_table__WEBPACK_IMPORTED_MODULE_2__["WEBGL2_CONTEXT_OVERRIDES"][key] === 'function') {
      // install an override, if no implementation was detected
      const originalFunc = gl[key] ? gl[key].bind(gl) : () => {};
      const polyfill = _polyfill_table__WEBPACK_IMPORTED_MODULE_2__["WEBGL2_CONTEXT_OVERRIDES"][key].bind(null, gl, originalFunc);
      target[key] = polyfill;
      target2[key] = polyfill;
    }
  });
}

function installPolyfills(gl, polyfills) {
  for (const extension of Object.getOwnPropertyNames(polyfills)) {
    if (extension !== 'overrides') {
      polyfillExtension(gl, {extension, target: gl.luma, target2: gl});
    }
  }
}

// Polyfills a single WebGL extension into the `target` object
function polyfillExtension(gl, {extension, target, target2}) {
  const defaults = _polyfill_table__WEBPACK_IMPORTED_MODULE_2__["WEBGL2_CONTEXT_POLYFILLS"][extension];
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["assert"])(defaults);

  const {meta = {}} = defaults;
  const {suffix = ''} = meta;

  const ext = gl.getExtension(extension);

  for (const key of Object.keys(defaults)) {
    const extKey = `${key}${suffix}`;

    let polyfill = null;
    if (key === 'meta') {
      // ignore
    } else if (typeof gl[key] === 'function') {
      // WebGL2 implementation is already
    } else if (ext && typeof ext[extKey] === 'function') {
      // pick extension implemenentation,if available
      polyfill = (...args) => ext[extKey](...args);
    } else if (typeof defaults[key] === 'function') {
      // pick the mock implementation, if no implementation was detected
      polyfill = defaults[key].bind(target);
    }

    if (polyfill) {
      target[key] = polyfill;
      target2[key] = polyfill;
    }
  }
}


/***/ }),

/***/ "./src/polyfill/polyfill-table.js":
/*!****************************************!*\
  !*** ./src/polyfill/polyfill-table.js ***!
  \****************************************/
/*! exports provided: WEBGL2_CONTEXT_POLYFILLS, WEBGL2_CONTEXT_OVERRIDES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEBGL2_CONTEXT_POLYFILLS", function() { return WEBGL2_CONTEXT_POLYFILLS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEBGL2_CONTEXT_OVERRIDES", function() { return WEBGL2_CONTEXT_OVERRIDES; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/assert */ "./src/utils/assert.js");
/* harmony import */ var _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/webgl-checks */ "./src/utils/webgl-checks.js");
/* harmony import */ var _get_parameter_polyfill__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-parameter-polyfill */ "./src/polyfill/get-parameter-polyfill.js");






const OES_vertex_array_object = 'OES_vertex_array_object';
const ANGLE_instanced_arrays = 'ANGLE_instanced_arrays';
const WEBGL_draw_buffers = 'WEBGL_draw_buffers';
const EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';
const EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';

const ERR_VAO_NOT_SUPPORTED = 'VertexArray requires WebGL2 or OES_vertex_array_object extension';

// Return object with webgl2 flag and an extension
function getExtensionData(gl, extension) {
  return {
    webgl2: Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_2__["isWebGL2"])(gl),
    ext: gl.getExtension(extension)
  };
}

// function mapExtensionConstant(gl, constant) {
//   switch (constant) {
//   case ext.FRAGMENT_SHADER_DERIVATIVE_HINT_OES: return GL.FRAGMENT_SHADER_DERIVATIVE_HINT;
//   }
// }

const WEBGL2_CONTEXT_POLYFILLS = {
  // POLYFILL TABLE
  [OES_vertex_array_object]: {
    meta: {suffix: 'OES'},
    // NEW METHODS
    createVertexArray: () => {
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["assert"])(false, ERR_VAO_NOT_SUPPORTED);
    },
    deleteVertexArray: () => {},
    bindVertexArray: () => {},
    isVertexArray: () => false
  },
  [ANGLE_instanced_arrays]: {
    meta: {
      suffix: 'ANGLE'
      // constants: {
      //   VERTEX_ATTRIB_ARRAY_DIVISOR: 'VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE'
      // }
    },
    vertexAttribDivisor(location, divisor) {
      // Accept divisor 0 even if instancing is not supported (0 = no instancing)
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["assert"])(divisor === 0, 'WebGL instanced rendering not supported');
    },
    drawElementsInstanced: () => {},
    drawArraysInstanced: () => {}
  },
  [WEBGL_draw_buffers]: {
    meta: {
      suffix: 'WEBGL'
    },
    drawBuffers: () => {
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["assert"])(false);
    }
  },
  [EXT_disjoint_timer_query]: {
    meta: {suffix: 'EXT'},
    // WebGL1: Polyfills the WebGL2 Query API
    createQuery: () => {
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["assert"])(false);
    },
    deleteQuery: () => {
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["assert"])(false);
    },
    beginQuery: () => {
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["assert"])(false);
    },
    endQuery: () => {},
    getQuery(handle, pname) {
      // @ts-ignore
      return this.getQueryObject(handle, pname);
    },
    // The WebGL1 extension uses getQueryObject rather then getQueryParameter
    getQueryParameter(handle, pname) {
      // @ts-ignore
      return this.getQueryObject(handle, pname);
    },
    getQueryObject: () => {}
  }
};

const WEBGL2_CONTEXT_OVERRIDES = {
  // Ensure readBuffer is a no-op
  readBuffer: (gl, originalFunc, attachment) => {
    if (Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_2__["isWebGL2"])(gl)) {
      originalFunc(attachment);
    } else {
      // assert(attachment !== GL_COLOR_ATTACHMENT0 && attachment !== GL_FRONT);
    }
  },
  // Override for getVertexAttrib that returns sane values for non-WebGL1 constants
  getVertexAttrib: (gl, originalFunc, location, pname) => {
    // const gl = this; // eslint-disable-line
    const {webgl2, ext} = getExtensionData(gl, ANGLE_instanced_arrays);

    let result;
    switch (pname) {
      // WebGL1 attributes will never be integer
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].VERTEX_ATTRIB_ARRAY_INTEGER:
        result = !webgl2 ? false : undefined;
        break;
      // if instancing is not available, return 0 meaning divisor has not been set
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].VERTEX_ATTRIB_ARRAY_DIVISOR:
        result = !webgl2 && !ext ? 0 : undefined;
        break;
      default:
    }

    return result !== undefined ? result : originalFunc(location, pname);
  },
  // Handle transform feedback and uniform block queries in WebGL1
  getProgramParameter: (gl, originalFunc, program, pname) => {
    if (!Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_2__["isWebGL2"])(gl)) {
      switch (pname) {
        case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].TRANSFORM_FEEDBACK_BUFFER_MODE:
          return _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SEPARATE_ATTRIBS;
        case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].TRANSFORM_FEEDBACK_VARYINGS:
          return 0;
        case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].ACTIVE_UNIFORM_BLOCKS:
          return 0;
        default:
      }
    }
    return originalFunc(program, pname);
  },
  getInternalformatParameter: (gl, originalFunc, target, format, pname) => {
    if (!Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_2__["isWebGL2"])(gl)) {
      switch (pname) {
        case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SAMPLES:
          return new Int32Array([0]);
        default:
      }
    }
    return gl.getInternalformatParameter(target, format, pname);
  },
  getTexParameter(gl, originalFunc, target, pname) {
    switch (pname) {
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].TEXTURE_MAX_ANISOTROPY_EXT:
        const {extensions} = gl.luma;
        const ext = extensions[EXT_texture_filter_anisotropic];
        pname = (ext && ext.TEXTURE_MAX_ANISOTROPY_EXT) || _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].TEXTURE_MAX_ANISOTROPY_EXT;
        break;
      default:
    }
    return originalFunc(target, pname);
  },
  getParameter: _get_parameter_polyfill__WEBPACK_IMPORTED_MODULE_3__["getParameterPolyfill"],
  hint(gl, originalFunc, pname, value) {
    // TODO - handle GL.FRAGMENT_SHADER_DERIVATIVE_HINT:
    // switch (pname) {
    // case GL.FRAGMENT_SHADER_DERIVATIVE_HINT:
    // }
    return originalFunc(pname, value);
  }
};


/***/ }),

/***/ "./src/polyfill/polyfill-vertex-array-object.js":
/*!******************************************************!*\
  !*** ./src/polyfill/polyfill-vertex-array-object.js ***!
  \******************************************************/
/*! exports provided: polyfillVertexArrayObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyfillVertexArrayObject", function() { return polyfillVertexArrayObject; });
/*
** Copyright (c) 2015 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

// Modified to use ES6 and polyfill a provided context rather than
// the global class.

// @ts-nocheck external code

const glErrorShadow = {};

function error(msg) {
  if (globalThis.console && globalThis.console.error) {
    globalThis.console.error(msg);
  }
}

function log(msg) {
  if (globalThis.console && globalThis.console.log) {
    globalThis.console.log(msg);
  }
}

function synthesizeGLError(err, opt_msg) {
  glErrorShadow[err] = true;
  if (opt_msg !== undefined) {
    error(opt_msg);
  }
}

function wrapGLError(gl) {
  const f = gl.getError;
  gl.getError = function getError() {
    let err;
    do {
      err = f.apply(gl);
      if (err !== gl.NO_ERROR) {
        glErrorShadow[err] = true;
      }
    } while (err !== gl.NO_ERROR);

    for (err in glErrorShadow) {
      if (glErrorShadow[err]) {
        delete glErrorShadow[err];
        return parseInt(err, 10);
      }
    }

    return gl.NO_ERROR;
  };
}

const WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES(ext) {
  const gl = ext.gl;

  this.ext = ext;
  this.isAlive = true;
  this.hasBeenBound = false;

  this.elementArrayBuffer = null;
  this.attribs = new Array(ext.maxVertexAttribs);
  for (let n = 0; n < this.attribs.length; n++) {
    const attrib = new WebGLVertexArrayObjectOES.VertexAttrib(gl);
    this.attribs[n] = attrib;
  }

  this.maxAttrib = 0;
};

WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
  this.enabled = false;
  this.buffer = null;
  this.size = 4;
  this.type = gl.FLOAT;
  this.normalized = false;
  this.stride = 16;
  this.offset = 0;

  this.cached = '';
  this.recache();
};
WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
  this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(':');
};

const OESVertexArrayObject = function OESVertexArrayObject(gl) {
  const self = this;
  this.gl = gl;

  wrapGLError(gl);

  const original = (this.original = {
    getParameter: gl.getParameter,
    enableVertexAttribArray: gl.enableVertexAttribArray,
    disableVertexAttribArray: gl.disableVertexAttribArray,
    bindBuffer: gl.bindBuffer,
    getVertexAttrib: gl.getVertexAttrib,
    vertexAttribPointer: gl.vertexAttribPointer
  });

  gl.getParameter = function getParameter(pname) {
    if (pname === self.VERTEX_ARRAY_BINDING_OES) {
      if (self.currentVertexArrayObject === self.defaultVertexArrayObject) {
        return null;
      }
      return self.currentVertexArrayObject;
    }
    return original.getParameter.apply(this, arguments);
  };

  gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
    const vao = self.currentVertexArrayObject;
    vao.maxAttrib = Math.max(vao.maxAttrib, index);
    const attrib = vao.attribs[index];
    attrib.enabled = true;
    return original.enableVertexAttribArray.apply(this, arguments);
  };
  gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
    const vao = self.currentVertexArrayObject;
    vao.maxAttrib = Math.max(vao.maxAttrib, index);
    const attrib = vao.attribs[index];
    attrib.enabled = false;
    return original.disableVertexAttribArray.apply(this, arguments);
  };

  gl.bindBuffer = function bindBuffer(target, buffer) {
    switch (target) {
      case gl.ARRAY_BUFFER:
        self.currentArrayBuffer = buffer;
        break;
      case gl.ELEMENT_ARRAY_BUFFER:
        self.currentVertexArrayObject.elementArrayBuffer = buffer;
        break;
      default:
    }
    return original.bindBuffer.apply(this, arguments);
  };

  gl.getVertexAttrib = function getVertexAttrib(index, pname) {
    const vao = self.currentVertexArrayObject;
    const attrib = vao.attribs[index];
    switch (pname) {
      case gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
        return attrib.buffer;
      case gl.VERTEX_ATTRIB_ARRAY_ENABLED:
        return attrib.enabled;
      case gl.VERTEX_ATTRIB_ARRAY_SIZE:
        return attrib.size;
      case gl.VERTEX_ATTRIB_ARRAY_STRIDE:
        return attrib.stride;
      case gl.VERTEX_ATTRIB_ARRAY_TYPE:
        return attrib.type;
      case gl.VERTEX_ATTRIB_ARRAY_NORMALIZED:
        return attrib.normalized;
      default:
        return original.getVertexAttrib.apply(this, arguments);
    }
  };

  gl.vertexAttribPointer = function vertexAttribPointer(
    indx,
    size,
    type,
    normalized,
    stride,
    offset
  ) {
    const vao = self.currentVertexArrayObject;
    vao.maxAttrib = Math.max(vao.maxAttrib, indx);
    const attrib = vao.attribs[indx];
    attrib.buffer = self.currentArrayBuffer;
    attrib.size = size;
    attrib.type = type;
    attrib.normalized = normalized;
    attrib.stride = stride;
    attrib.offset = offset;
    attrib.recache();
    return original.vertexAttribPointer.apply(this, arguments);
  };

  if (gl.instrumentExtension) {
    gl.instrumentExtension(this, 'OES_vertex_array_object');
  }

  // undefined for headless gl
  if (gl.canvas) {
    gl.canvas.addEventListener(
      'webglcontextrestored',
      () => {
        log('OESVertexArrayObject emulation library context restored');
        self.reset_();
      },
      true
    );
  }

  this.reset_();
};

OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 0x85b5;

OESVertexArrayObject.prototype.reset_ = function reset_() {
  const contextWasLost = this.vertexArrayObjects !== undefined;
  if (contextWasLost) {
    for (let ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
      this.vertexArrayObjects.isAlive = false;
    }
  }
  const gl = this.gl;
  this.maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);

  this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
  this.currentVertexArrayObject = null;
  this.currentArrayBuffer = null;
  this.vertexArrayObjects = [this.defaultVertexArrayObject];

  this.bindVertexArrayOES(null);
};

OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
  const arrayObject = new WebGLVertexArrayObjectOES(this);
  this.vertexArrayObjects.push(arrayObject);
  return arrayObject;
};

OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
  arrayObject.isAlive = false;
  this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);
  if (this.currentVertexArrayObject === arrayObject) {
    this.bindVertexArrayOES(null);
  }
};

OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
  if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
    if (arrayObject.hasBeenBound && arrayObject.ext === this) {
      return true;
    }
  }
  return false;
};

OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
  const gl = this.gl;
  if (arrayObject && !arrayObject.isAlive) {
    synthesizeGLError(
      gl.INVALID_OPERATION,
      'bindVertexArrayOES: attempt to bind deleted arrayObject'
    );
    return;
  }
  const original = this.original;

  const oldVAO = this.currentVertexArrayObject;
  this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
  this.currentVertexArrayObject.hasBeenBound = true;
  const newVAO = this.currentVertexArrayObject;

  if (oldVAO === newVAO) {
    return;
  }

  if (!oldVAO || newVAO.elementArrayBuffer !== oldVAO.elementArrayBuffer) {
    original.bindBuffer.call(gl, gl.ELEMENT_ARRAY_BUFFER, newVAO.elementArrayBuffer);
  }

  let currentBinding = this.currentArrayBuffer;
  const maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);
  for (let n = 0; n <= maxAttrib; n++) {
    const attrib = newVAO.attribs[n];
    const oldAttrib = oldVAO ? oldVAO.attribs[n] : null;

    if (!oldVAO || attrib.enabled !== oldAttrib.enabled) {
      if (attrib.enabled) {
        original.enableVertexAttribArray.call(gl, n);
      } else {
        original.disableVertexAttribArray.call(gl, n);
      }
    }

    if (attrib.enabled) {
      let bufferChanged = false;
      if (!oldVAO || attrib.buffer !== oldAttrib.buffer) {
        if (currentBinding !== attrib.buffer) {
          original.bindBuffer.call(gl, gl.ARRAY_BUFFER, attrib.buffer);
          currentBinding = attrib.buffer;
        }
        bufferChanged = true;
      }

      if (bufferChanged || attrib.cached !== oldAttrib.cached) {
        original.vertexAttribPointer.call(
          gl,
          n,
          attrib.size,
          attrib.type,
          attrib.normalized,
          attrib.stride,
          attrib.offset
        );
      }
    }
  }

  if (this.currentArrayBuffer !== currentBinding) {
    original.bindBuffer.call(gl, gl.ARRAY_BUFFER, this.currentArrayBuffer);
  }
};

function polyfillVertexArrayObject(gl) {
  if (typeof gl.createVertexArray === 'function') {
    // VAOs directly supported on object (i.e. WebGL 2 context)
    return;
  }

  const original_getSupportedExtensions = gl.getSupportedExtensions;
  gl.getSupportedExtensions = function getSupportedExtensions() {
    const list = original_getSupportedExtensions.call(this) || [];
    if (list.indexOf('OES_vertex_array_object') < 0) {
      list.push('OES_vertex_array_object');
    }
    return list;
  };

  const original_getExtension = gl.getExtension;
  gl.getExtension = function getExtension(name) {
    const ext = original_getExtension.call(this, name);
    if (ext) {
      return ext;
    }
    if (name !== 'OES_vertex_array_object') {
      return null;
    }

    if (!gl.__OESVertexArrayObject) {
      this.__OESVertexArrayObject = new OESVertexArrayObject(this);
    }
    return this.__OESVertexArrayObject;
  };
}


/***/ }),

/***/ "./src/state-tracker/track-context-state.js":
/*!**************************************************!*\
  !*** ./src/state-tracker/track-context-state.js ***!
  \**************************************************/
/*! exports provided: trackContextState, pushContextState, popContextState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackContextState", function() { return trackContextState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pushContextState", function() { return pushContextState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "popContextState", function() { return popContextState; });
/* harmony import */ var _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl-parameter-tables */ "./src/state-tracker/webgl-parameter-tables.js");
/* harmony import */ var _unified_parameter_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unified-parameter-api */ "./src/state-tracker/unified-parameter-api.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/assert */ "./src/utils/assert.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/utils */ "./src/utils/utils.js");
// Support for listening to context state changes and intercepting state queries
// NOTE: this system does not handle buffer bindings
/** @typedef {import('./track-context-state')} types */






// HELPER FUNCTIONS - INSTALL GET/SET INTERCEPTORS (SPYS) ON THE CONTEXT

// Overrides a WebGLRenderingContext state "getter" function
// to return values directly from cache
function installGetterOverride(gl, functionName) {
  // Get the original function from the WebGLRenderingContext
  const originalGetterFunc = gl[functionName].bind(gl);

  // Wrap it with a spy so that we can update our state cache when it gets called
  gl[functionName] = function get(...params) {
    const pname = params[0];

    // WebGL limits are not prepopulated in the cache, it's neither undefined in GL_PARAMETER_DEFAULTS
    // nor intercepted by GL_HOOKED_SETTERS. Query the original getter.
    if (!(pname in gl.state.cache)) {
      return originalGetterFunc(...params);
    }

    // Optionally call the original function to do a "hard" query from the WebGLRenderingContext
    return gl.state.enable
      ? // Call the getter the params so that it can e.g. serve from a cache
        gl.state.cache[pname]
      : // Optionally call the original function to do a "hard" query from the WebGLRenderingContext
        originalGetterFunc(...params);
  };

  // Set the name of this anonymous function to help in debugging and profiling
  Object.defineProperty(gl[functionName], 'name', {
    value: `${functionName}-from-cache`,
    configurable: false
  });
}

// Overrides a WebGLRenderingContext state "setter" function
// to call a setter spy before the actual setter. Allows us to keep a cache
// updated with a copy of the WebGL context state.
function installSetterSpy(gl, functionName, setter) {
  // Get the original function from the WebGLRenderingContext
  const originalSetterFunc = gl[functionName].bind(gl);

  // Wrap it with a spy so that we can update our state cache when it gets called
  gl[functionName] = function set(...params) {
    // Update the value
    // Call the setter with the state cache and the params so that it can store the parameters
    const {valueChanged, oldValue} = setter(gl.state._updateCache, ...params);

    // Call the original WebGLRenderingContext func to make sure the context actually gets updated
    if (valueChanged) {
      originalSetterFunc(...params);
    }

    // Note: if the original function fails to set the value, our state cache will be bad
    // No solution for this at the moment, but assuming that this is unlikely to be a real problem
    // We could call the setter after the originalSetterFunc. Concern is that this would
    // cause different behavior in debug mode, where originalSetterFunc can throw exceptions

    return oldValue;
  };

  // Set the name of this anonymous function to help in debugging and profiling
  Object.defineProperty(gl[functionName], 'name', {
    value: `${functionName}-to-cache`,
    configurable: false
  });
}

function installProgramSpy(gl) {
  const originalUseProgram = gl.useProgram.bind(gl);

  gl.useProgram = function useProgramLuma(handle) {
    if (gl.state.program !== handle) {
      originalUseProgram(handle);
      gl.state.program = handle;
    }
  };
}

// HELPER CLASS - GLState

/* eslint-disable no-shadow */
class GLState {
  constructor(
    gl,
    {
      copyState = false, // Copy cache from params (slow) or initialize from WebGL defaults (fast)
      log = () => {} // Logging function, called when gl parameter change calls are actually issued
    } = {}
  ) {
    this.gl = gl;
    this.program = null;
    this.stateStack = [];
    this.enable = true;
    this.cache = copyState ? Object(_unified_parameter_api__WEBPACK_IMPORTED_MODULE_1__["getParameters"])(gl) : Object.assign({}, _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_PARAMETER_DEFAULTS"]);
    this.log = log;

    this._updateCache = this._updateCache.bind(this);
    Object.seal(this);
  }

  push(values = {}) {
    this.stateStack.push({});
  }

  pop() {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["assert"])(this.stateStack.length > 0);
    // Use the saved values in the state stack to restore parameters
    const oldValues = this.stateStack[this.stateStack.length - 1];
    Object(_unified_parameter_api__WEBPACK_IMPORTED_MODULE_1__["setParameters"])(this.gl, oldValues);
    // Don't pop until we have reset parameters (to make sure other "stack frames" are not affected)
    this.stateStack.pop();
  }

  // interceptor for context set functions - update our cache and our stack
  // values (Object) - the key values for this setter
  _updateCache(values) {
    let valueChanged = false;
    let oldValue; // = undefined

    const oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];

    for (const key in values) {
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["assert"])(key !== undefined);
      const value = values[key];
      const cached = this.cache[key];
      // Check that value hasn't already been shadowed
      if (!Object(_utils_utils__WEBPACK_IMPORTED_MODULE_3__["deepArrayEqual"])(value, cached)) {
        valueChanged = true;
        oldValue = cached;

        // First, save current value being shadowed
        // If a state stack frame is active, save the current parameter values for pop
        // but first check that value hasn't already been shadowed and saved
        if (oldValues && !(key in oldValues)) {
          oldValues[key] = cached;
        }

        // Save current value being shadowed
        this.cache[key] = value;
      }
    }

    return {valueChanged, oldValue};
  }
}

// PUBLIC API

/**
 * Initialize WebGL state caching on a context
 * @type {types['trackContextState']}
 */
// After calling this function, context state will be cached
// gl.state.push() and gl.state.pop() will be available for saving,
// temporarily modifying, and then restoring state.
function trackContextState(gl, options = {}) {
  const {enable = true, copyState} = options;
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["assert"])(copyState !== undefined);
  // @ts-ignore
  if (!gl.state) {
    // @ts-ignore
    const {polyfillContext} = globalThis;
    if (polyfillContext) {
      polyfillContext(gl);
    }

    // Create a state cache
    // @ts-ignore
    gl.state = new GLState(gl, {copyState});

    installProgramSpy(gl);

    // intercept all setter functions in the table
    for (const key in _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_HOOKED_SETTERS"]) {
      const setter = _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_HOOKED_SETTERS"][key];
      installSetterSpy(gl, key, setter);
    }

    // intercept all getter functions in the table
    installGetterOverride(gl, 'getParameter');
    installGetterOverride(gl, 'isEnabled');
  }

  // @ts-ignore
  gl.state.enable = enable;

  return gl;
}

/**
 * Initialize WebGL state caching on a context
 * @type {types['pushContextState']}
 */
function pushContextState(gl) {
  // @ts-ignore
  if (!gl.state) {
    trackContextState(gl, {copyState: false});
  }
  // @ts-ignore
  gl.state.push();
}

/**
 * Initialize WebGL state caching on a context
 * @type {types['popContextState']}
 */
function popContextState(gl) {
  // @ts-ignore
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["assert"])(gl.state);
  // @ts-ignore
  gl.state.pop();
}


/***/ }),

/***/ "./src/state-tracker/unified-parameter-api.js":
/*!****************************************************!*\
  !*** ./src/state-tracker/unified-parameter-api.js ***!
  \****************************************************/
/*! exports provided: setParameters, getParameters, resetParameters, withParameters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setParameters", function() { return setParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getParameters", function() { return getParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetParameters", function() { return resetParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withParameters", function() { return withParameters; });
/* harmony import */ var _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl-parameter-tables */ "./src/state-tracker/webgl-parameter-tables.js");
/* harmony import */ var _track_context_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./track-context-state */ "./src/state-tracker/track-context-state.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/assert */ "./src/utils/assert.js");
/* harmony import */ var _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/webgl-checks */ "./src/utils/webgl-checks.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/utils */ "./src/utils/utils.js");
// Provides a unified API for getting and setting any WebGL parameter
// Also knows default values of all parameters, enabling fast cache initialization
// Provides base functionality for the state caching.







// Sets any GL parameter regardless of function (gl.blendMode, ...)
// Note: requires a `cache` object to be set on the context (gl.state.cache)
// This object is used to fill in any missing values for composite setter functions
function setParameters(gl, values) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["assert"])(Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_3__["isWebGL"])(gl), 'setParameters requires a WebGL context');

  if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_4__["isObjectEmpty"])(values)) {
    return;
  }

  const compositeSetters = {};

  // HANDLE PRIMITIVE SETTERS (and make note of any composite setters)

  for (const key in values) {
    const glConstant = Number(key);
    const setter = _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_PARAMETER_SETTERS"][key];
    if (setter) {
      // Composite setters should only be called once, so save them
      if (typeof setter === 'string') {
        compositeSetters[setter] = true;
      } else {
        // if (gl[glConstant] !== undefined) {
        // TODO - added above check since this is being called on WebGL2 values in WebGL1...
        // TODO - deep equal on values? only call setter if value has changed?
        // NOTE - the setter will automatically update this.state
        setter(gl, values[key], glConstant);
      }
    }
  }

  // HANDLE COMPOSITE SETTERS

  // NOTE: any non-provided values needed by composite setters are filled in from state cache
  // The cache parameter is automatically retrieved from the context
  // This depends on `trackContextState`, which is technically a "circular" dependency.
  // But it is too inconvenient to always require a cache parameter here.
  // This is the ONLY external dependency in this module/
  const cache = gl.state && gl.state.cache;
  if (cache) {
    for (const key in compositeSetters) {
      // TODO - avoid calling composite setters if values have not changed.
      const compositeSetter = _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_COMPOSITE_PARAMETER_SETTERS"][key];
      // Note - if `trackContextState` has been called,
      // the setter will automatically update this.state.cache
      compositeSetter(gl, values, cache);
    }
  }

  // Add a log for the else case?
}

// Copies the state from a context (gl.getParameter should not be overriden)
// Reads the entire WebGL state from a context
// Caveat: This generates a huge amount of synchronous driver roundtrips and should be
// considered a very slow operation, to be used only if/when a context already manipulated
// by external code needs to be synchronized for the first time
// @return {Object} - a newly created map, with values keyed by GL parameters
function getParameters(gl, parameters) {
  // default to querying all parameters
  parameters = parameters || _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_PARAMETER_DEFAULTS"];
  // support both arrays of parameters and objects (keys represent parameters)

  if (typeof parameters === 'number') {
    // single GL enum
    const key = parameters;
    const getter = _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_PARAMETER_GETTERS"][key];
    return getter ? getter(gl, key) : gl.getParameter(key);
  }

  const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);

  const state = {};
  for (const key of parameterKeys) {
    const getter = _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_PARAMETER_GETTERS"][key];
    state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
  }
  return state;
}

// Reset all parameters to a (almost) pure context state
// NOTE: viewport and scissor will be set to the values in GL_PARAMETER_DEFAULTS,
//   NOT the canvas size dimensions, so they will have to be properly set after
//   calling this function.
function resetParameters(gl) {
  setParameters(gl, _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_PARAMETER_DEFAULTS"]);
}

// Stores current "global" WebGL context settings, changes selected parameters,
// executes function, restores parameters
function withParameters(gl, parameters, func) {
  if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_4__["isObjectEmpty"])(parameters)) {
    // Avoid setting state if no parameters provided. Just call and return
    return func(gl);
  }

  const {nocatch = true} = parameters;

  Object(_track_context_state__WEBPACK_IMPORTED_MODULE_1__["pushContextState"])(gl);
  setParameters(gl, parameters);

  // Setup is done, call the function
  let value;

  if (nocatch) {
    // Avoid try catch to minimize stack size impact for safe execution paths
    value = func(gl);
    Object(_track_context_state__WEBPACK_IMPORTED_MODULE_1__["popContextState"])(gl);
  } else {
    // Wrap in a try-catch to ensure that parameters are restored on exceptions
    try {
      value = func(gl);
    } finally {
      Object(_track_context_state__WEBPACK_IMPORTED_MODULE_1__["popContextState"])(gl);
    }
  }

  return value;
}


/***/ }),

/***/ "./src/state-tracker/webgl-parameter-tables.js":
/*!*****************************************************!*\
  !*** ./src/state-tracker/webgl-parameter-tables.js ***!
  \*****************************************************/
/*! exports provided: GL_PARAMETER_DEFAULTS, GL_PARAMETER_SETTERS, GL_COMPOSITE_PARAMETER_SETTERS, GL_HOOKED_SETTERS, GL_PARAMETER_GETTERS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GL_PARAMETER_DEFAULTS", function() { return GL_PARAMETER_DEFAULTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GL_PARAMETER_SETTERS", function() { return GL_PARAMETER_SETTERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GL_COMPOSITE_PARAMETER_SETTERS", function() { return GL_COMPOSITE_PARAMETER_SETTERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GL_HOOKED_SETTERS", function() { return GL_HOOKED_SETTERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GL_PARAMETER_GETTERS", function() { return GL_PARAMETER_GETTERS; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/webgl-checks */ "./src/utils/webgl-checks.js");
// Tables describing WebGL parameters



// DEFAULT SETTINGS - FOR FAST CACHE INITIALIZATION AND CONTEXT RESETS

/* eslint-disable no-shadow */

const GL_PARAMETER_DEFAULTS = {
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND]: false,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_COLOR]: new Float32Array([0, 0, 0, 0]),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_EQUATION_RGB]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FUNC_ADD,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_EQUATION_ALPHA]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FUNC_ADD,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_SRC_RGB]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].ONE,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_DST_RGB]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].ZERO,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_SRC_ALPHA]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].ONE,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_DST_ALPHA]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].ZERO,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].COLOR_CLEAR_VALUE]: new Float32Array([0, 0, 0, 0]), // TBD
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].COLOR_WRITEMASK]: [true, true, true, true],
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].CULL_FACE]: false,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].CULL_FACE_MODE]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BACK,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DEPTH_TEST]: false,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DEPTH_CLEAR_VALUE]: 1,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DEPTH_FUNC]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].LESS,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DEPTH_RANGE]: new Float32Array([0, 1]), // TBD
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DEPTH_WRITEMASK]: true,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DITHER]: true,
  // FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRAMEBUFFER_BINDING]: null,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRONT_FACE]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].CCW,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].GENERATE_MIPMAP_HINT]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DONT_CARE,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].LINE_WIDTH]: 1,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON_OFFSET_FILL]: false,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON_OFFSET_FACTOR]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON_OFFSET_UNITS]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SAMPLE_COVERAGE_VALUE]: 1.0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SAMPLE_COVERAGE_INVERT]: false,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SCISSOR_TEST]: false,
  // Note: Dynamic value. If scissor test enabled we expect users to set correct scissor box
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SCISSOR_BOX]: new Int32Array([0, 0, 1024, 1024]),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_TEST]: false,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_CLEAR_VALUE]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_WRITEMASK]: 0xffffffff,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_WRITEMASK]: 0xffffffff,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_FUNC]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].ALWAYS,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_REF]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_VALUE_MASK]: 0xffffffff,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_FUNC]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].ALWAYS,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_REF]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_VALUE_MASK]: 0xffffffff,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_FAIL]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].KEEP,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_PASS_DEPTH_FAIL]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].KEEP,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_PASS_DEPTH_PASS]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].KEEP,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_FAIL]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].KEEP,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_PASS_DEPTH_FAIL]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].KEEP,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_PASS_DEPTH_PASS]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].KEEP,
  // Dynamic value: We use [0, 0, 1024, 1024] as default, but usually this is updated in each frame.
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].VIEWPORT]: [0, 0, 1024, 1024],
  // WEBGL1 PIXEL PACK/UNPACK MODES
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].PACK_ALIGNMENT]: 4,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].UNPACK_ALIGNMENT]: 4,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].UNPACK_FLIP_Y_WEBGL]: false,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].UNPACK_PREMULTIPLY_ALPHA_WEBGL]: false,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].UNPACK_COLORSPACE_CONVERSION_WEBGL]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BROWSER_DEFAULT_WEBGL,

  // WEBGL2 / EXTENSIONS
  // gl1: 'OES_standard_derivatives'
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRAGMENT_SHADER_DERIVATIVE_HINT]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DONT_CARE,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].READ_FRAMEBUFFER_BINDING]: null,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].RASTERIZER_DISCARD]: false,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].PACK_ROW_LENGTH]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].PACK_SKIP_PIXELS]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].PACK_SKIP_ROWS]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].UNPACK_ROW_LENGTH]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].UNPACK_IMAGE_HEIGHT]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].UNPACK_SKIP_PIXELS]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].UNPACK_SKIP_ROWS]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].UNPACK_SKIP_IMAGES]: 0
};

// SETTER TABLES - ENABLES SETTING ANY PARAMETER WITH A COMMON API

const enable = (gl, value, key) => (value ? gl.enable(key) : gl.disable(key));
const hint = (gl, value, key) => gl.hint(key, value);
const pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);

const drawFramebuffer = (gl, value) => {
  const target = Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(gl) ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DRAW_FRAMEBUFFER : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRAMEBUFFER;
  return gl.bindFramebuffer(target, value);
};
const readFramebuffer = (gl, value) => {
  return gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].READ_FRAMEBUFFER, value);
};

// Utility
function isArray(array) {
  return Array.isArray(array) || ArrayBuffer.isView(array);
}

// Map from WebGL parameter names to corresponding WebGL setter functions
// WegGL constants are read by parameter names, but set by function names
// NOTE: When value type is a string, it will be handled by 'GL_COMPOSITE_PARAMETER_SETTERS'
const GL_PARAMETER_SETTERS = {
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND]: enable,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_COLOR]: (gl, value) => gl.blendColor(...value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_EQUATION_RGB]: 'blendEquation',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_EQUATION_ALPHA]: 'blendEquation',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_SRC_RGB]: 'blendFunc',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_DST_RGB]: 'blendFunc',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_SRC_ALPHA]: 'blendFunc',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_DST_ALPHA]: 'blendFunc',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].COLOR_CLEAR_VALUE]: (gl, value) => gl.clearColor(...value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].COLOR_WRITEMASK]: (gl, value) => gl.colorMask(...value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].CULL_FACE]: enable,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].CULL_FACE_MODE]: (gl, value) => gl.cullFace(value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DEPTH_TEST]: enable,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DEPTH_CLEAR_VALUE]: (gl, value) => gl.clearDepth(value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DEPTH_FUNC]: (gl, value) => gl.depthFunc(value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DEPTH_RANGE]: (gl, value) => gl.depthRange(...value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DEPTH_WRITEMASK]: (gl, value) => gl.depthMask(value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DITHER]: enable,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRAGMENT_SHADER_DERIVATIVE_HINT]: hint,
  // NOTE: FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRAMEBUFFER_BINDING]: drawFramebuffer,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRONT_FACE]: (gl, value) => gl.frontFace(value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].GENERATE_MIPMAP_HINT]: hint,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].LINE_WIDTH]: (gl, value) => gl.lineWidth(value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON_OFFSET_FILL]: enable,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON_OFFSET_FACTOR]: 'polygonOffset',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON_OFFSET_UNITS]: 'polygonOffset',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].RASTERIZER_DISCARD]: enable,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SAMPLE_COVERAGE_VALUE]: 'sampleCoverage',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SAMPLE_COVERAGE_INVERT]: 'sampleCoverage',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SCISSOR_TEST]: enable,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SCISSOR_BOX]: (gl, value) => gl.scissor(...value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_TEST]: enable,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_CLEAR_VALUE]: (gl, value) => gl.clearStencil(value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_WRITEMASK]: (gl, value) => gl.stencilMaskSeparate(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRONT, value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_WRITEMASK]: (gl, value) => gl.stencilMaskSeparate(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BACK, value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_FUNC]: 'stencilFuncFront',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_REF]: 'stencilFuncFront',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_VALUE_MASK]: 'stencilFuncFront',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_FUNC]: 'stencilFuncBack',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_REF]: 'stencilFuncBack',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_VALUE_MASK]: 'stencilFuncBack',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_FAIL]: 'stencilOpFront',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_PASS_DEPTH_FAIL]: 'stencilOpFront',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_PASS_DEPTH_PASS]: 'stencilOpFront',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_FAIL]: 'stencilOpBack',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_PASS_DEPTH_FAIL]: 'stencilOpBack',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_PASS_DEPTH_PASS]: 'stencilOpBack',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].VIEWPORT]: (gl, value) => gl.viewport(...value),

  // WEBGL1 PIXEL PACK/UNPACK MODES
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].PACK_ALIGNMENT]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].UNPACK_ALIGNMENT]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].UNPACK_FLIP_Y_WEBGL]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].UNPACK_PREMULTIPLY_ALPHA_WEBGL]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].UNPACK_COLORSPACE_CONVERSION_WEBGL]: pixelStorei,

  // WEBGL2 PIXEL PACK/UNPACK MODES
  // RASTERIZER_DISCARD ...
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].PACK_ROW_LENGTH]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].PACK_SKIP_PIXELS]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].PACK_SKIP_ROWS]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].READ_FRAMEBUFFER_BINDING]: readFramebuffer,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].UNPACK_ROW_LENGTH]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].UNPACK_IMAGE_HEIGHT]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].UNPACK_SKIP_PIXELS]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].UNPACK_SKIP_ROWS]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].UNPACK_SKIP_IMAGES]: pixelStorei,

  // Function-style setters
  framebuffer: (gl, framebuffer) => {
    // accepts 1) a WebGLFramebuffer 2) null (default framebuffer), or 3) luma.gl Framebuffer class
    // framebuffer is null when restoring to default framebuffer, otherwise use the WebGL handle.
    const handle = framebuffer && 'handle' in framebuffer ? framebuffer.handle : framebuffer;
    return gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRAMEBUFFER, handle);
  },
  blend: (gl, value) => (value ? gl.enable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND) : gl.disable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND)),
  blendColor: (gl, value) => gl.blendColor(...value),
  blendEquation: (gl, args) => {
    args = isArray(args) ? args : [args, args];
    gl.blendEquationSeparate(...args);
  },
  blendFunc: (gl, args) => {
    args = isArray(args) && args.length === 2 ? [...args, ...args] : args;
    gl.blendFuncSeparate(...args);
  },

  clearColor: (gl, value) => gl.clearColor(...value),
  clearDepth: (gl, value) => gl.clearDepth(value),
  clearStencil: (gl, value) => gl.clearStencil(value),

  colorMask: (gl, value) => gl.colorMask(...value),

  cull: (gl, value) => (value ? gl.enable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].CULL_FACE) : gl.disable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].CULL_FACE)),
  cullFace: (gl, value) => gl.cullFace(value),

  depthTest: (gl, value) => (value ? gl.enable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DEPTH_TEST) : gl.disable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DEPTH_TEST)),
  depthFunc: (gl, value) => gl.depthFunc(value),
  depthMask: (gl, value) => gl.depthMask(value),
  depthRange: (gl, value) => gl.depthRange(...value),

  dither: (gl, value) => (value ? gl.enable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DITHER) : gl.disable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DITHER)),

  derivativeHint: (gl, value) => {
    // gl1: 'OES_standard_derivatives'
    gl.hint(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRAGMENT_SHADER_DERIVATIVE_HINT, value);
  },

  frontFace: (gl, value) => gl.frontFace(value),

  mipmapHint: (gl, value) => gl.hint(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].GENERATE_MIPMAP_HINT, value),

  lineWidth: (gl, value) => gl.lineWidth(value),

  polygonOffsetFill: (gl, value) =>
    value ? gl.enable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON_OFFSET_FILL) : gl.disable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON_OFFSET_FILL),
  polygonOffset: (gl, value) => gl.polygonOffset(...value),

  sampleCoverage: (gl, value) => gl.sampleCoverage(...value),

  scissorTest: (gl, value) => (value ? gl.enable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SCISSOR_TEST) : gl.disable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SCISSOR_TEST)),
  scissor: (gl, value) => gl.scissor(...value),

  stencilTest: (gl, value) => (value ? gl.enable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_TEST) : gl.disable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_TEST)),
  stencilMask: (gl, value) => {
    value = isArray(value) ? value : [value, value];
    const [mask, backMask] = value;
    gl.stencilMaskSeparate(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRONT, mask);
    gl.stencilMaskSeparate(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BACK, backMask);
  },
  stencilFunc: (gl, args) => {
    args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
    const [func, ref, mask, backFunc, backRef, backMask] = args;
    gl.stencilFuncSeparate(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRONT, func, ref, mask);
    gl.stencilFuncSeparate(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BACK, backFunc, backRef, backMask);
  },
  stencilOp: (gl, args) => {
    args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
    const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
    gl.stencilOpSeparate(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRONT, sfail, dpfail, dppass);
    gl.stencilOpSeparate(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BACK, backSfail, backDpfail, backDppass);
  },

  viewport: (gl, value) => gl.viewport(...value)
};

function getValue(glEnum, values, cache) {
  return values[glEnum] !== undefined ? values[glEnum] : cache[glEnum];
}

// COMPOSITE_WEBGL_PARAMETER_
const GL_COMPOSITE_PARAMETER_SETTERS = {
  blendEquation: (gl, values, cache) =>
    gl.blendEquationSeparate(
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_EQUATION_RGB, values, cache),
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_EQUATION_ALPHA, values, cache)
    ),
  blendFunc: (gl, values, cache) =>
    gl.blendFuncSeparate(
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_SRC_RGB, values, cache),
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_DST_RGB, values, cache),
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_SRC_ALPHA, values, cache),
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_DST_ALPHA, values, cache)
    ),
  polygonOffset: (gl, values, cache) =>
    gl.polygonOffset(
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON_OFFSET_FACTOR, values, cache),
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON_OFFSET_UNITS, values, cache)
    ),
  sampleCoverage: (gl, values, cache) =>
    gl.sampleCoverage(
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SAMPLE_COVERAGE_VALUE, values, cache),
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SAMPLE_COVERAGE_INVERT, values, cache)
    ),
  stencilFuncFront: (gl, values, cache) =>
    gl.stencilFuncSeparate(
      _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRONT,
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_FUNC, values, cache),
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_REF, values, cache),
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_VALUE_MASK, values, cache)
    ),
  stencilFuncBack: (gl, values, cache) =>
    gl.stencilFuncSeparate(
      _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BACK,
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_FUNC, values, cache),
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_REF, values, cache),
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_VALUE_MASK, values, cache)
    ),
  stencilOpFront: (gl, values, cache) =>
    gl.stencilOpSeparate(
      _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRONT,
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_FAIL, values, cache),
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_PASS_DEPTH_FAIL, values, cache),
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_PASS_DEPTH_PASS, values, cache)
    ),
  stencilOpBack: (gl, values, cache) =>
    gl.stencilOpSeparate(
      _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BACK,
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_FAIL, values, cache),
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_PASS_DEPTH_FAIL, values, cache),
      getValue(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_PASS_DEPTH_PASS, values, cache)
    )
};

// Setter functions intercepted for cache updates
const GL_HOOKED_SETTERS = {
  // GENERIC SETTERS

  enable: (update, capability) =>
    update({
      [capability]: true
    }),
  disable: (update, capability) =>
    update({
      [capability]: false
    }),
  pixelStorei: (update, pname, value) =>
    update({
      [pname]: value
    }),
  hint: (update, pname, hint) =>
    update({
      [pname]: hint
    }),

  // SPECIFIC SETTERS

  bindFramebuffer: (update, target, framebuffer) => {
    switch (target) {
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRAMEBUFFER:
        return update({
          [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DRAW_FRAMEBUFFER_BINDING]: framebuffer,
          [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].READ_FRAMEBUFFER_BINDING]: framebuffer
        });
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DRAW_FRAMEBUFFER:
        return update({[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DRAW_FRAMEBUFFER_BINDING]: framebuffer});
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].READ_FRAMEBUFFER:
        return update({[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].READ_FRAMEBUFFER_BINDING]: framebuffer});
      default:
        return null;
    }
  },
  blendColor: (update, r, g, b, a) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_COLOR]: new Float32Array([r, g, b, a])
    }),

  blendEquation: (update, mode) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_EQUATION_RGB]: mode,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_EQUATION_ALPHA]: mode
    }),

  blendEquationSeparate: (update, modeRGB, modeAlpha) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_EQUATION_RGB]: modeRGB,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_EQUATION_ALPHA]: modeAlpha
    }),

  blendFunc: (update, src, dst) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_SRC_RGB]: src,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_DST_RGB]: dst,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_SRC_ALPHA]: src,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_DST_ALPHA]: dst
    }),

  blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_SRC_RGB]: srcRGB,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_DST_RGB]: dstRGB,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_SRC_ALPHA]: srcAlpha,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND_DST_ALPHA]: dstAlpha
    }),

  clearColor: (update, r, g, b, a) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].COLOR_CLEAR_VALUE]: new Float32Array([r, g, b, a])
    }),

  clearDepth: (update, depth) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DEPTH_CLEAR_VALUE]: depth
    }),

  clearStencil: (update, s) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_CLEAR_VALUE]: s
    }),

  colorMask: (update, r, g, b, a) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].COLOR_WRITEMASK]: [r, g, b, a]
    }),

  cullFace: (update, mode) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].CULL_FACE_MODE]: mode
    }),

  depthFunc: (update, func) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DEPTH_FUNC]: func
    }),

  depthRange: (update, zNear, zFar) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DEPTH_RANGE]: new Float32Array([zNear, zFar])
    }),

  depthMask: (update, mask) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DEPTH_WRITEMASK]: mask
    }),

  frontFace: (update, face) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRONT_FACE]: face
    }),

  lineWidth: (update, width) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].LINE_WIDTH]: width
    }),

  polygonOffset: (update, factor, units) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON_OFFSET_FACTOR]: factor,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON_OFFSET_UNITS]: units
    }),

  sampleCoverage: (update, value, invert) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SAMPLE_COVERAGE_VALUE]: value,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SAMPLE_COVERAGE_INVERT]: invert
    }),

  scissor: (update, x, y, width, height) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SCISSOR_BOX]: new Int32Array([x, y, width, height])
    }),

  stencilMask: (update, mask) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_WRITEMASK]: mask,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_WRITEMASK]: mask
    }),

  stencilMaskSeparate: (update, face, mask) =>
    update({
      [face === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRONT ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_WRITEMASK : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_WRITEMASK]: mask
    }),

  stencilFunc: (update, func, ref, mask) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_FUNC]: func,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_REF]: ref,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_VALUE_MASK]: mask,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_FUNC]: func,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_REF]: ref,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_VALUE_MASK]: mask
    }),

  stencilFuncSeparate: (update, face, func, ref, mask) =>
    update({
      [face === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRONT ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_FUNC : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_FUNC]: func,
      [face === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRONT ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_REF : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_REF]: ref,
      [face === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRONT ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_VALUE_MASK : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_VALUE_MASK]: mask
    }),

  stencilOp: (update, fail, zfail, zpass) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_FAIL]: fail,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_PASS_DEPTH_FAIL]: zfail,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_PASS_DEPTH_PASS]: zpass,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_FAIL]: fail,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_PASS_DEPTH_FAIL]: zfail,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_PASS_DEPTH_PASS]: zpass
    }),

  stencilOpSeparate: (update, face, fail, zfail, zpass) =>
    update({
      [face === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRONT ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_FAIL : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_FAIL]: fail,
      [face === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRONT ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_PASS_DEPTH_FAIL : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_PASS_DEPTH_FAIL]: zfail,
      [face === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].FRONT ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_PASS_DEPTH_PASS : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_BACK_PASS_DEPTH_PASS]: zpass
    }),

  viewport: (update, x, y, width, height) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].VIEWPORT]: [x, y, width, height]
    })
};

// GETTER TABLE - FOR READING OUT AN ENTIRE CONTEXT

const isEnabled = (gl, key) => gl.isEnabled(key);

// Exceptions for any keys that cannot be queried by gl.getParameters
const GL_PARAMETER_GETTERS = {
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].BLEND]: isEnabled,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].CULL_FACE]: isEnabled,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DEPTH_TEST]: isEnabled,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].DITHER]: isEnabled,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON_OFFSET_FILL]: isEnabled,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SAMPLE_ALPHA_TO_COVERAGE]: isEnabled,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SAMPLE_COVERAGE]: isEnabled,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].SCISSOR_TEST]: isEnabled,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].STENCIL_TEST]: isEnabled,

  // WebGL 2
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["default"].RASTERIZER_DISCARD]: isEnabled
};


/***/ }),

/***/ "./src/utils/assert.js":
/*!*****************************!*\
  !*** ./src/utils/assert.js ***!
  \*****************************/
/*! exports provided: assert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return assert; });
// Avoid bundling assert polyfill module
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'luma.gl: assertion failed.');
  }
}


/***/ }),

/***/ "./src/utils/device-pixels.js":
/*!************************************!*\
  !*** ./src/utils/device-pixels.js ***!
  \************************************/
/*! exports provided: cssToDeviceRatio, cssToDevicePixels, getDevicePixelRatio */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssToDeviceRatio", function() { return cssToDeviceRatio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssToDevicePixels", function() { return cssToDevicePixels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDevicePixelRatio", function() { return getDevicePixelRatio; });
/** @typedef {import('./device-pixels')} types */

/**
 * Returns multiplier need to convert CSS size to Device size
 * @type {types['cssToDeviceRatio']}
 */
function cssToDeviceRatio(gl) {
  // @ts-ignore
  const {luma} = gl;

  if (gl.canvas && luma) {
    // For headless gl we might have used custom width and height
    // hence prioritize cached clientWidth
    const cachedSize = luma.canvasSizeInfo;
    const clientWidth =
      'clientWidth' in cachedSize ? cachedSize.clientWidth : gl.canvas.clientWidth;
    return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;
  }
  // use default device pixel ratio
  return 1;
}

/**
 * Maps CSS pixel position to device pixel position
 * @type {types['cssToDevicePixels']}
 */
function cssToDevicePixels(gl, cssPixel, yInvert = true) {
  const ratio = cssToDeviceRatio(gl);
  const width = gl.drawingBufferWidth;
  const height = gl.drawingBufferHeight;
  return scalePixels(cssPixel, ratio, width, height, yInvert);
}

// HELPER METHOD

/**
 * Calulates device pixel ratio, used during context creation
 * @type {types['getDevicePixelRatio']}
 */
function getDevicePixelRatio(useDevicePixels) {
  const windowRatio = typeof window === 'undefined' ? 1 : window.devicePixelRatio || 1;
  if (Number.isFinite(useDevicePixels)) {
    // @ts-ignore Can no longer be boolean after previous line
    return useDevicePixels <= 0 ? 1 : useDevicePixels;
  }
  return useDevicePixels ? windowRatio : 1;
}

// PRIVATE

function scalePixels(pixel, ratio, width, height, yInvert) {
  const x = scaleX(pixel[0], ratio, width);
  let y = scaleY(pixel[1], ratio, height, yInvert);

  // Find boundaries of next pixel to provide valid range of device pixel locaitons

  let t = scaleX(pixel[0] + 1, ratio, width);
  // If next pixel's position is clamped to boundary, use it as is, otherwise subtract 1 for current pixel boundary
  const xHigh = t === width - 1 ? t : t - 1;

  t = scaleY(pixel[1] + 1, ratio, height, yInvert);
  let yHigh;
  if (yInvert) {
    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range
    t = t === 0 ? t : t + 1;
    // swap y and yHigh
    yHigh = y;
    y = t;
  } else {
    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range
    yHigh = t === height - 1 ? t : t - 1;
    // y remains same
  }
  return {
    x,
    y,
    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.
    width: Math.max(xHigh - x + 1, 1),
    height: Math.max(yHigh - y + 1, 1)
  };
}

function scaleX(x, ratio, width) {
  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit
  const r = Math.min(Math.round(x * ratio), width - 1);
  return r;
}

function scaleY(y, ratio, height, yInvert) {
  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit
  return yInvert
    ? Math.max(0, height - 1 - Math.round(y * ratio))
    : Math.min(Math.round(y * ratio), height - 1);
}


/***/ }),

/***/ "./src/utils/log.js":
/*!**************************!*\
  !*** ./src/utils/log.js ***!
  \**************************/
/*! exports provided: log */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return log; });
/* harmony import */ var _probe_gl_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @probe.gl/log */ "../../node_modules/@probe.gl/log/dist/esm/index.js");


const log = new _probe_gl_log__WEBPACK_IMPORTED_MODULE_0__["Log"]({id: 'luma.gl'});


/***/ }),

/***/ "./src/utils/utils.js":
/*!****************************!*\
  !*** ./src/utils/utils.js ***!
  \****************************/
/*! exports provided: isObjectEmpty, deepArrayEqual */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObjectEmpty", function() { return isObjectEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepArrayEqual", function() { return deepArrayEqual; });
// Returns true if given object is empty, false otherwise.
function isObjectEmpty(object) {
  for (const key in object) {
    return false;
  }
  return true;
}

function deepArrayEqual(x, y) {
  if (x === y) {
    return true;
  }
  const isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
  const isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);

  // @ts-expect-error DataView...
  if (isArrayX && isArrayY && x.length === y.length) {
    // @ts-expect-error DataView...
    for (let i = 0; i < x.length; ++i) {
      if (x[i] !== y[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}


/***/ }),

/***/ "./src/utils/webgl-checks.js":
/*!***********************************!*\
  !*** ./src/utils/webgl-checks.js ***!
  \***********************************/
/*! exports provided: ERR_WEBGL, ERR_WEBGL2, isWebGL, isWebGL2, getWebGL2Context, assertWebGLContext, assertWebGL2Context */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERR_WEBGL", function() { return ERR_WEBGL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERR_WEBGL2", function() { return ERR_WEBGL2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWebGL", function() { return isWebGL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWebGL2", function() { return isWebGL2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWebGL2Context", function() { return getWebGL2Context; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assertWebGLContext", function() { return assertWebGLContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assertWebGL2Context", function() { return assertWebGL2Context; });
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert */ "./src/utils/assert.js");


const ERR_CONTEXT = 'Invalid WebGLRenderingContext';
const ERR_WEBGL = ERR_CONTEXT;
const ERR_WEBGL2 = 'Requires WebGL2';

function isWebGL(gl) {
  if (typeof WebGLRenderingContext !== 'undefined' && gl instanceof WebGLRenderingContext) {
    return true;
  }
  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  // Look for debug contexts, headless gl etc
  return Boolean(gl && Number.isFinite(gl._version));
}

function isWebGL2(gl) {
  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  // Look for debug contexts, headless gl etc
  return Boolean(gl && gl._version === 2);
}

function getWebGL2Context(gl) {
  return isWebGL2(gl) ? gl : null;
}

function assertWebGLContext(gl) {
  Object(_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(isWebGL(gl), ERR_CONTEXT);
  return gl;
}

function assertWebGL2Context(gl) {
  Object(_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(isWebGL2(gl), ERR_WEBGL2);
  return gl;
}


/***/ }),

/***/ 0:
/*!*******************************!*\
  !*** asciify-image (ignored) ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
});