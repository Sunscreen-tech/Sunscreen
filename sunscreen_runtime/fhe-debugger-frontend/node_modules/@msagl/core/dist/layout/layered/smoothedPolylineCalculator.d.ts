import { CornerSite } from '../../math/geometry/cornerSite';
import { Curve } from '../../math/geometry/curve';
import { ICurve } from '../../math/geometry/icurve';
import { PN } from '../../math/geometry/parallelogramNode';
import { Point } from '../../math/geometry/point';
import { Polyline } from '../../math/geometry/polyline';
import { SmoothedPolyline } from '../../math/geometry/smoothedPolyline';
import { GeomGraph } from '../core/geomGraph';
import { Anchor } from './anchor';
import { Database } from './Database';
import { LayerArrays } from './LayerArrays';
import { PolyIntEdge } from './polyIntEdge';
import { ProperLayeredGraph } from './ProperLayeredGraph';
import { SugiyamaLayoutSettings } from './sugiyamaLayoutSettings';
import { BezierSeg } from '../../math/geometry/bezierSeg';
import { NodeKind } from './NodeKind';
export declare class SmoothedPolylineCalculator {
    headSite: CornerSite;
    edgePath: PolyIntEdge;
    anchors: Anchor[];
    originalGraph: GeomGraph;
    eastHierarchy: PN;
    westHierarchy: PN;
    thinEastHierarchy: PN;
    thinWestHierarchy: PN;
    thinRightNodes: PN[];
    thinWestNodes: PN[];
    database: Database;
    layeredGraph: ProperLayeredGraph;
    layerArrays: LayerArrays;
    settings: SugiyamaLayoutSettings;
    constructor(edgePathPar: PolyIntEdge, anchorsP: Anchor[], origGraph: GeomGraph, settings: SugiyamaLayoutSettings, la: LayerArrays, layerGraph: ProperLayeredGraph, databaseP: Database);
    private BuildEastHierarchy;
    private BuildWestHierarchy;
    FindEastBoundaryAnchorCurves(): Array<Polyline>;
    private FindWestBoundaryAnchorCurves;
    FillRightTopAndBottomVerts(layer: number[], vPosition: number, nodeKind: NodeKind): IterableIterator<number>;
    FillLeftTopAndBottomVerts(layer: number[], vPosition: number, nodeKind: NodeKind): IterableIterator<number>;
    IsVirtualVertex(v: number): boolean;
    IsLabel(u: number): boolean;
    private NodeUCanBeCrossedByNodeV;
    private EdgesIntersectSomewhere;
    private UVAreMiddlesOfTheSameMultiEdge;
    SourceOfTheOriginalEdgeContainingAVirtualNode(u: number): number;
    private IntersectBelow;
    private IntersectAbove;
    private Intersect;
    private IncomingEdge;
    private OutcomingEdge;
    private EastBoundaryNodesOfANode;
    private NodeLayer;
    private LeftBoundaryNodesOfANode;
    getSpline(optimizeShortEdges: boolean): ICurve;
    get GetPolyline(): SmoothedPolyline;
    LineSegIntersectBound(a: Point, b: Point): boolean;
    SegIntersectWestBound(a: CornerSite, b: CornerSite): boolean;
    SegIntersectEastBound(a: CornerSite, b: CornerSite): boolean;
    private TryToRemoveInflectionCorner;
    static SegIntersectsBound(a: CornerSite, b: CornerSite, hierarchy: PN): boolean;
    private static CurveIntersectsHierarchy;
    static Flat(i: CornerSite): boolean;
    Reverse(): SmoothedPolylineCalculator;
    private createRefinedPolyline;
    private RefineBeetweenNeighborLayers;
    private CreateInitialListOfSites;
    get TailSite(): CornerSite;
    OptimizeForThreeSites(): void;
    OptimizeForTwoSites(): void;
    private FindLegalPositions;
    private FindPositions;
    private OriginToOriginSegCrossesAnchorSide;
    private OptimizeShortPath;
    private PositionsAreLegal;
    private MiddleAnchorLegal;
    private MiddlePos;
    private TryToRemoveInflections;
    private TurningAlwaySameDirection;
    EdgePathPoint(i: number): Point;
    EdgePathNode(i: number): number;
    createSmoothedPolyline(): Curve;
    curveIsLegal(curve: Curve): boolean;
    private RemoveVerticesWithNoTurns;
    private RemoveVerticesWithNoTurnsOnePass;
    private ExtendCurveToEndpoints;
    private createFilletCurve;
    private AddSmoothedCorner;
    private BezierSegIntersectsBoundary;
    private BezierSegIntersectsTree;
    static BezierSegIntersectsBoundary(seg: BezierSeg, ic: ICurve): boolean;
}
