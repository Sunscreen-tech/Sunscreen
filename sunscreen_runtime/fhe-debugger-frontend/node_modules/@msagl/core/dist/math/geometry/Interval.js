import { GeomConstants } from '../../math/geometry/geomConstants';
export class Interval {
    // constructor
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    add(n) {
        this.add_d(n);
    }
    add_rect(rectangle) {
        const r = rectangle;
        const ret = this.clone();
        ret.add_d(r.start);
        ret.add_d(r.end);
        return ret;
    }
    clone() {
        return new Interval(this.start, this.end);
    }
    contains_point(n) {
        return this.contains_d(n);
    }
    contains_rect(rect) {
        const r = rect;
        return this.contains_d(r.start) && this.contains_d(r.end);
    }
    intersection_rect(rectangle) {
        const r = rectangle;
        return new Interval(Math.max(this.start, r.start), Math.min(this.end, r.end));
    }
    intersects_rect(rectangle) {
        const r = rectangle;
        return this.intersects(r);
    }
    contains_point_radius(p, radius) {
        return this.contains_d(p - radius) && this.contains_d(p + radius);
    }
    //
    static mkInterval(a, b) {
        const i = new Interval(a.start, a.end);
        i.add_d(b.start);
        i.add_d(b.end);
        return i;
    }
    // expanding the range to hold v
    add_d(v) {
        if (this.start > v) {
            this.start = v;
        }
        if (this.end < v) {
            this.end = v;
        }
    }
    get Start() {
        return this.start;
    }
    set Start(value) {
        this.start = value;
    }
    // the length
    get Length() {
        return this.end - this.start;
    }
    // return true if the value is inside the range
    contains_d(v) {
        return this.start <= v && v <= this.end;
    }
    // bringe v into the range
    GetInRange(v) {
        return v < this.start ? this.start : v > this.end ? this.end : v;
    }
    // returns true if and only if two intervals are intersecting
    intersects(other) {
        if (other.start > this.end + GeomConstants.distanceEpsilon) {
            return false;
        }
        return !(other.end < this.start - GeomConstants.distanceEpsilon);
    }
}
//# sourceMappingURL=Interval.js.map