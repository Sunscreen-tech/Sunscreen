import { Point, TriangleOrientation } from './point';
import { Rectangle } from './rectangle';
import { PolylinePoint } from './polylinePoint';
import { Parallelogram } from './parallelogram';
import { LineSegment } from './lineSegment';
import { Curve } from './curve';
/** the curve corresponding to the sequence of lines, could be closed when the start coincides with the end */
export class Polyline {
    constructor() {
        this.initIsRequired = true;
        this.isClosed_ = false;
    }
    toJSON() {
        return { points: Array.from(this).map((p) => p.toJSON()) };
    }
    static fromJSON(data) {
        return Polyline.mkFromPoints(data.points.map((p) => Point.fromJSON(p)));
    }
    RemoveStartPoint() {
        const p = this.startPoint.next;
        p.prev = null;
        this.startPoint = p;
        this.setInitIsRequired();
    }
    RemoveEndPoint() {
        const p = this.endPoint.prev;
        p.next = null;
        this.endPoint = p;
        this.setInitIsRequired();
    }
    setInitIsRequired() {
        this.initIsRequired = true;
    }
    addPointXY(x, y) {
        this.addPoint(new Point(x, y));
    }
    /** should true, by internal assumptions,  in general for convex polylines */
    isClockwise() {
        return (Point.getTriangleOrientation(this.startPoint.point, this.startPoint.next.point, this.startPoint.next.next.point) ==
            TriangleOrientation.Clockwise);
    }
    /**  adds a point to the polyline */
    addPoint(p) {
        // Assert.assert(
        //  this.endPoint == null  || !Point.closeDistEps(p, this.endPoint.point),
        // )
        const pp = new PolylinePoint();
        pp.polyline = this;
        pp.point = p.clone();
        if (this.endPoint != null) {
            // if (!ApproximateComparer.Close(point, this.endPoint.Point)) {
            this.endPoint.next = pp;
            pp.prev = this.endPoint;
            this.endPoint = pp;
            // }
        }
        else {
            this.startPoint = this.endPoint = pp;
        }
        this.setInitIsRequired();
    }
    PrependPoint(p) {
        // Assert.assert(this.endPoint == null  || !Point.closeDistEps(p, this.endPoint.point))
        const pp = PolylinePoint.mkFromPoint(p);
        pp.polyline = this;
        if (this.startPoint != null) {
            if (!Point.closeDistEps(p, this.startPoint.point)) {
                this.startPoint.prev = pp;
                pp.next = this.startPoint;
                this.startPoint = pp;
            }
        }
        else {
            this.endPoint = pp;
            this.startPoint = pp;
        }
        this.setInitIsRequired();
    }
    *[Symbol.iterator]() {
        for (let s = this.startPoint; s != null; s = s.next)
            yield s.point;
    }
    *polylinePoints() {
        for (let s = this.startPoint; s != null; s = s.next)
            yield s;
    }
    *skip(skipCount) {
        for (let s = this.startPoint; s != null; s = s.next) {
            if (skipCount > 0)
                skipCount--;
            else
                yield s;
        }
    }
    static parallelogramOfLineSeg(a, b) {
        const side = b.sub(a).div(2);
        return Parallelogram.parallelogramByCornerSideSide(a, side, side);
    }
    static mkFromPoints(ps) {
        const r = new Polyline();
        for (const p of ps) {
            r.addPoint(p);
        }
        return r;
    }
    static mkClosedFromPoints(ps) {
        const r = Polyline.mkFromPoints(ps);
        r.closed = true;
        return r;
    }
    calculatePbNode() {
        const parallelograms = [];
        const children = [];
        let pp = this.startPoint;
        let offset = 0;
        while (pp.next != null) {
            const parallelogram = Polyline.parallelogramOfLineSeg(pp.point, pp.next.point);
            parallelograms.push(parallelogram);
            children.push({
                parallelogram: parallelogram,
                seg: this,
                leafBoxesOffset: 0,
                node: {
                    low: offset,
                    high: offset + 1,
                    chord: LineSegment.mkPP(pp.point, pp.next.point),
                },
            });
            pp = pp.next;
            offset++;
        }
        if (this.isClosed_) {
            const parallelogram = Polyline.parallelogramOfLineSeg(this.endPoint.point, this.startPoint.point);
            parallelograms.push(parallelogram);
            children.push({
                parallelogram: parallelogram,
                seg: this,
                leafBoxesOffset: 0,
                node: {
                    low: offset,
                    high: offset + 1,
                    chord: LineSegment.mkPP(this.endPoint.point, this.startPoint.point),
                },
            });
        }
        this.pBNode = {
            parallelogram: Parallelogram.getParallelogramOfAGroup(parallelograms),
            seg: this,
            leafBoxesOffset: 0,
            node: {
                children: children,
            },
        };
    }
    init() {
        this.bBox = Rectangle.rectangleOnPoint(this.startPoint.point);
        for (const p of this.skip(1)) {
            this.bBox.add(p.point);
        }
        this.updateCount();
        this.calculatePbNode();
        this.initIsRequired = false;
    }
    updateCount() {
        this.count_ = 0;
        for (let pp = this.startPoint; pp != null; pp = pp.next) {
            this.count_++;
        }
    }
    get count() {
        if (this.initIsRequired)
            this.init();
        return this.count_;
    }
    get closed() {
        return this.isClosed_;
    }
    set closed(value) {
        this.isClosed_ = value;
    }
    value(t) {
        if (this.initIsRequired)
            this.init();
        const p = this.getAdjustedParamAndStartEndPoints(t);
        return Point.convSum(p.t, p.a, p.b);
    }
    getAdjustedParamAndStartEndPoints(t) {
        /*Assert.assert(t >= -GeomConstants.tolerance)*/
        /*Assert.assert(this.startPoint != null)*/
        let s = this.startPoint;
        while (s.next != null) {
            if (t <= 1) {
                return {
                    a: s.point,
                    b: s.next.point,
                    t: t,
                };
            }
            s = s.next;
            t -= 1;
        }
        if (this.closed) {
            if (t <= 1) {
                return {
                    a: this.endPoint.point,
                    b: this.startPoint.point,
                    t: t,
                };
            }
        }
        throw new Error('out of the parameter domain');
    }
    derivative(t) {
        const ap = this.getAdjustedParamAndStartEndPoints(t);
        return ap.b.sub(ap.a);
    }
    secondDerivative(t) {
        return new Point(0, 0);
    }
    thirdDerivative(t) {
        return new Point(0, 0);
    }
    pNodeOverICurve() {
        if (this.initIsRequired)
            this.init();
        return this.pBNode;
    }
    get boundingBox() {
        if (this.initIsRequired)
            this.init();
        return this.bBox;
    }
    get parStart() {
        return 0;
    }
    get parEnd() {
        if (this.initIsRequired)
            this.init();
        return this.closed ? this.count_ : this.count_ - 1;
    }
    static polylineFromCurve(curve) {
        const ret = new Polyline();
        ret.addPoint(curve.start);
        for (const ls of curve.segs)
            ret.addPoint(ls.end);
        ret.closed = curve.start === curve.end;
        return ret;
    }
    trim(start, end) {
        //this is a very lazy version!
        let curve = this.toCurve();
        curve = curve.trim(start, end);
        /* always convert to Polyline */
        if (curve instanceof Curve)
            return Polyline.polylineFromCurve(curve);
        else
            return Polyline.mkFromPoints([curve.start, curve.end]);
    }
    trimWithWrap(start, end) {
        throw new Error('Method not implemented.');
    }
    translate(delta) {
        let p = this.startPoint;
        do {
            p.point = p.point.add(delta);
            if (p === this.endPoint)
                break;
            p = p.getNext();
        } while (true);
        this.setInitIsRequired();
    }
    scaleFromOrigin(xScale, yScale) {
        throw new Error('Method not implemented.');
    }
    get start() {
        return this.startPoint.point;
    }
    get end() {
        return this.endPoint.point;
    }
    reverse() {
        const r = new Polyline();
        r.closed = this.closed;
        let p = this.endPoint;
        do {
            r.addPoint(p.point);
            if (p === this.startPoint)
                break;
            p = p.getPrev();
        } while (true);
        return r;
    }
    offsetCurve(offset, dir) {
        throw new Error('Method not implemented.');
    }
    lengthPartial(start, end) {
        throw new Error('Method not implemented.');
    }
    get length() {
        throw new Error('Method not implemented.');
    }
    getParameterAtLength(length) {
        throw new Error('Method not implemented.');
    }
    transform(transformation) {
        const ret = new Polyline();
        for (const p of this.polylinePoints()) {
            ret.addPoint(transformation.multiplyPoint(p.point));
        }
        ret.closed = this.closed;
        return ret;
    }
    closestParameterWithinBounds(targetPoint, low, high) {
        throw new Error('Method not implemented.');
    }
    closestParameter(targetPoint) {
        let ret = 0;
        let dist = Number.MAX_VALUE;
        let offset = 0;
        let pp = this.startPoint;
        while (pp.next != null) {
            const ls = LineSegment.mkPP(pp.point, pp.next.point);
            const t = ls.closestParameter(targetPoint);
            const delta = ls.value(t).sub(targetPoint);
            const newDist = delta.dot(delta);
            if (newDist < dist) {
                dist = newDist;
                ret = t + offset;
            }
            pp = pp.next;
            offset++;
        }
        if (this.closed) {
            const ls = LineSegment.mkPP(this.endPoint.point, this.startPoint.point);
            const t = ls.closestParameter(targetPoint);
            const delta = ls.value(t).sub(targetPoint);
            const newDist = delta.dot(delta);
            if (newDist < dist) {
                ret = t + offset;
            }
        }
        return ret;
    }
    clone() {
        const r = new Polyline();
        r.closed = this.closed;
        let p = this.startPoint;
        do {
            r.addPoint(p.point);
            if (p === this.endPoint)
                break;
            p = p.getNext();
        } while (true);
        return r;
    }
    leftDerivative(t) {
        throw new Error('Method not implemented.');
    }
    rightDerivative(t) {
        throw new Error('Method not implemented.');
    }
    curvature(t) {
        throw new Error('Method not implemented.');
    }
    curvatureDerivative(t) {
        throw new Error('Method not implemented.');
    }
    curvatureSecondDerivative(t) {
        throw new Error('Method not implemented.');
    }
    next(a) {
        var _a;
        return (_a = a.next) !== null && _a !== void 0 ? _a : (this.closed ? this.startPoint : null);
    }
    prev(a) {
        var _a;
        return (_a = a.prev) !== null && _a !== void 0 ? _a : (this.closed ? this.endPoint : null);
    }
    toCurve() {
        const c = new Curve();
        Curve.addLineSegment(c, this.startPoint.point, this.startPoint.next.point);
        let p = this.startPoint.next;
        while ((p = p.next) != null)
            Curve.continueWithLineSegmentP(c, p.point);
        if (this.closed)
            Curve.continueWithLineSegmentP(c, this.startPoint.point);
        return c;
    }
    RemoveCollinearVertices() {
        for (let pp = this.startPoint.next; pp.next != null; pp = pp.next) {
            if (Point.getTriangleOrientation(pp.prev.point, pp.point, pp.next.point) === TriangleOrientation.Collinear) {
                pp.prev.next = pp.next;
                pp.next.prev = pp.prev;
            }
        }
        this.setInitIsRequired();
        return this;
    }
}
//# sourceMappingURL=polyline.js.map