import { String } from 'typescript-string-operations';
import { Cdt } from './Cdt';
export class CdtEdge {
    constructor(a, b) {
        // is an obstacle side, or a given segment
        this.constrained = false;
        // the amount of free space around the edge
        this.Capacity = 1000000;
        const above = Cdt.AbovePP(a.point, b.point);
        if (above === 1) {
            this.upperSite = a;
            this.lowerSite = b;
        }
        else {
            /*Assert.assert(above !== 0)*/
            this.lowerSite = a;
            this.upperSite = b;
        }
        this.upperSite.AddEdgeToSite(this);
    }
    get CcwTriangle() {
        return this.ccwTriangle;
    }
    set CcwTriangle(value) {
        /*Assert.assert(
          value == null  ||
            this.cwTriangle == null  ||
            value.OppositeSite(this) !== this.cwTriangle.OppositeSite(this),
        )*/
        this.ccwTriangle = value;
    }
    get CwTriangle() {
        return this.cwTriangle;
    }
    set CwTriangle(value) {
        /*Assert.assert(
          value == null  ||
            this.ccwTriangle == null  ||
            value.OppositeSite(this) !== this.ccwTriangle.OppositeSite(this),
        )*/
        this.cwTriangle = value;
    }
    // returns the trianlge on the edge opposite to the site
    GetOtherTriangle_c(p) {
        return this.cwTriangle.Contains(p) ? this.ccwTriangle : this.cwTriangle;
    }
    IsAdjacent(pi) {
        return pi === this.upperSite || pi === this.lowerSite;
    }
    GetOtherTriangle_T(triangle) {
        return this.ccwTriangle === triangle ? this.cwTriangle : this.ccwTriangle;
    }
    // A string that represents the current object.
    toString() {
        return String.Format('({0},{1})', this.upperSite, this.lowerSite);
    }
    OtherSite(site) {
        /*Assert.assert(this.IsAdjacent(site))*/
        return this.upperSite === site ? this.lowerSite : this.upperSite;
    }
}
//# sourceMappingURL=CdtEdge.js.map