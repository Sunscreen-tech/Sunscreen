import { DebugCurve } from '../../math/geometry/debugCurve';
import { ICurve } from '../../math/geometry/icurve';
import { RBNode } from '../../math/RBTree/rbNode';
import { RBTree } from '../../math/RBTree/rbTree';
import { Algorithm } from '../../utils/algorithm';
import { CdtEdge } from './CdtEdge';
import { CdtFrontElement } from './CdtFrontElement';
import { CdtSite } from './CdtSite';
import { CdtTriangle } from './CdtTriangle';
import { PerimeterEdge } from './PerimeterEdge';
export declare class CdtSweeper extends Algorithm {
    front: RBTree<CdtFrontElement>;
    triangles: Set<CdtTriangle>;
    listOfSites: Array<CdtSite>;
    p_2: CdtSite;
    createEdgeDelegate: (a: CdtSite, b: CdtSite) => CdtEdge;
    p_1: CdtSite;
    constructor(listOfSites: Array<CdtSite>, p_1: CdtSite, p_2: CdtSite, createEdgeDelegate: (a: CdtSite, b: CdtSite) => CdtEdge);
    run(): void;
    FinalizeTriangulation(): void;
    MakePerimeterConvex(): void;
    FindConcaveEdge(firstPerimeterEdge: PerimeterEdge): PerimeterEdge;
    static FindPivot(firstPerimeterEdge: PerimeterEdge): PerimeterEdge;
    FindFirsePerimeterEdge(): CdtEdge;
    CreateDoubleLinkedListOfPerimeter(): PerimeterEdge;
    static FindNextEdgeOnPerimeter(e: CdtEdge): CdtEdge;
    static CreatePerimeterElementFromEdge(edge: CdtEdge): PerimeterEdge;
    RemoveP1AndP2Triangles(): void;
    static RemoveTriangleWithEdges(cdtTriangles: Set<CdtTriangle>, t: CdtTriangle): void;
    static RemoveTriangleButLeaveEdges(cdtTriangles: Set<CdtTriangle>, t: CdtTriangle): void;
    ProcessSite(site: CdtSite): void;
    EdgeEvent(edge: CdtEdge): void;
    static EdgeIsProcessed(edge: CdtEdge): boolean;
    ShowFrontWithSite(site: CdtSite, redCurves?: ICurve[]): void;
    Show(fn: string): void;
    static ShowCdt(cdtTriangles: CdtTriangle[], cdtFrontElements: RBTree<CdtFrontElement>, redCurves: Array<ICurve>, blueCurves: Array<ICurve>, dc: DebugCurve[], fn: string): void;
    static GetDebugCurveOfCdtEdge(e: CdtEdge): DebugCurve;
    PointEvent(pi: CdtSite): void;
    LeftCase(pi: CdtSite, hittedFrontElementNode: RBNode<CdtFrontElement>, t: {
        rightSite: CdtSite;
    }): CdtSite;
    MiddleCase(pi: CdtSite, hittedFrontElementNode: RBNode<CdtFrontElement>, t: {
        rightSite: CdtSite;
    }): CdtSite;
    TriangulateEmptySpaceToTheLeft(leftLegNode: RBNode<CdtFrontElement>): void;
    ShortcutTwoListElements(a: PerimeterEdge): PerimeterEdge;
    ShortcutTwoFrontElements(aNode: RBNode<CdtFrontElement>, bNode: RBNode<CdtFrontElement>): RBNode<CdtFrontElement>;
    TryTriangulateBasinToTheLeft(leftLegNode: RBNode<CdtFrontElement>): void;
    static DropsSharpEnoughToTheLeft(frontElement: CdtFrontElement): boolean;
    InsertSiteIntoFront(leftSite: CdtSite, pi: CdtSite, rightSite: CdtSite): RBNode<CdtFrontElement>;
    TriangulateEmptySpaceToTheRight(piNode: RBNode<CdtFrontElement>): void;
    TryTriangulateBasinToTheRight(piNode: RBNode<CdtFrontElement>): void;
    static DropsSharpEnoughToTheRight(frontElement: CdtFrontElement): boolean;
    static FindNodeInFrontBySite(cdtFrontElements: RBTree<CdtFrontElement>, piSite: CdtSite): RBNode<CdtFrontElement>;
    InsertAndLegalizeTriangle(pi: CdtSite, frontElement: CdtFrontElement): void;
    LegalizeEdge(pi: CdtSite, edge: CdtEdge): void;
    LegalizeEdgeForOtherCwTriangle(pi: CdtSite, edge: CdtEdge): void;
    LegalizeEdgeForOtherCcwTriangle(pi: CdtSite, edge: CdtEdge): void;
    ProjectToFront(site: CdtSite): RBNode<CdtFrontElement>;
    /** start of edge insert region */
    traversingEdge: CdtEdge;
    rightPolygon: Array<CdtSite>;
    leftPolygon: Array<CdtSite>;
    addedTriangles: Array<CdtTriangle>;
    private runEdgeInserter;
    initEdgeInserter(): void;
    UpdateFront(): void;
    AddEdgeToFront(e: CdtEdge): void;
    TriangulatePolygon0(polygon: Array<CdtSite>, a: CdtSite, b: CdtSite, reverseTrangleWhenCompare: boolean): void;
    TriangulatePolygon1(start: number, end: number, polygon: Array<CdtSite>, a: CdtSite, b: CdtSite, reverseTrangleWhenCompare: boolean): void;
    TraceEdgeThroughTriangles(): void;
    /** edge tracer region */
    a: CdtSite;
    b: CdtSite;
    piercedEdge: CdtEdge;
    piercedTriangle: CdtTriangle;
    piercedToTheLeftFrontElemNode: RBNode<CdtFrontElement>;
    piercedToTheRightFrontElemNode: RBNode<CdtFrontElement>;
    elementsToBeRemovedFromFront: Array<CdtFrontElement>;
    removedTriangles: Array<CdtTriangle>;
    Traverse(): void;
    ProcessLeftFrontPiercedElement(): void;
    FindPiercedTriangle(v: RBNode<CdtFrontElement>): void;
    FindMoreRemovedFromFrontElements(): void;
    ProcessPiercedEdge(): void;
    PrepareNextStateAfterPiercedEdge(): void;
    removePiercedTriangle(t: CdtTriangle): void;
    ProcessRightFrontPiercedElement(): void;
    AddSiteToLeftPolygon(site: CdtSite): void;
    AddSiteToPolygonWithCheck(site: CdtSite, list: Array<CdtSite>): void;
    AddSiteToRightPolygon(site: CdtSite): void;
    BIsReached(): boolean;
    initEdgeTracer(): void;
}
export declare function InCircle(d: CdtSite, a: CdtSite, b: CdtSite, c: CdtSite): boolean;
