import { PointLocation, GeomConstants } from '../../math/geometry';
import { segmentsIntersect } from '../../math/geometry/lineSegment';
import { Point, TriangleOrientation } from '../../math/geometry/point';
import { Rectangle } from '../../math/geometry/rectangle';
import { ThreeArray } from './ThreeArray';
// a trianlge oriented counterclockwise
export class CdtTriangle {
    constructor() {
        // the edges
        this.Edges = new ThreeArray();
        // the sites
        this.Sites = new ThreeArray();
    }
    containsPoint(p) {
        return CdtTriangle.PointLocationForTriangle(p, this) !== PointLocation.Outside;
    }
    static PointLocationForTriangle(p, triangle) {
        let seenBoundary = false;
        for (let i = 0; i < 3; i++) {
            const area = Point.signedDoubledTriangleArea(p, triangle.Sites.getItem(i).point, triangle.Sites.getItem(i + 1).point);
            if (area < -GeomConstants.distanceEpsilon) {
                return PointLocation.Outside;
            }
            if (area < GeomConstants.distanceEpsilon) {
                seenBoundary = true;
            }
        }
        return seenBoundary ? PointLocation.Boundary : PointLocation.Inside;
    }
    /** extend by eps the triangles edges before the test */
    intersectsLine(a, b, eps) {
        if (CdtTriangle.PointLocationForTriangle(a, this) != PointLocation.Outside)
            return true;
        if (CdtTriangle.PointLocationForTriangle(b, this) != PointLocation.Outside)
            return true;
        for (const e of this.Edges) {
            if (this.abIntersectsTrianglSide(a, b, e))
                return true;
        }
        return false;
    }
    abIntersectsTrianglSide(a, b, e) {
        return segmentsIntersect(a, b, e.lowerSite.point, e.upperSite.point);
    }
    static mkSSSD(a, b, c, createEdgeDelegate) {
        const orientation = Point.getTriangleOrientation(a.point, b.point, c.point);
        const r = new CdtTriangle();
        switch (orientation) {
            case TriangleOrientation.Counterclockwise:
                r.FillCcwTriangle(a, b, c, createEdgeDelegate);
                break;
            case TriangleOrientation.Clockwise:
                r.FillCcwTriangle(a, c, b, createEdgeDelegate);
                break;
            default:
                throw new Error();
                break;
        }
        return r;
    }
    static mkSED(pi, edge, createEdgeDelegate) {
        const tri = new CdtTriangle();
        switch (Point.getTriangleOrientation(edge.upperSite.point, edge.lowerSite.point, pi.point)) {
            case TriangleOrientation.Counterclockwise:
                edge.CcwTriangle = tri;
                tri.Sites.setItem(0, edge.upperSite);
                tri.Sites.setItem(1, edge.lowerSite);
                break;
            case TriangleOrientation.Clockwise:
                edge.CwTriangle = tri;
                tri.Sites.setItem(0, edge.lowerSite);
                tri.Sites.setItem(1, edge.upperSite);
                break;
            default:
                throw new Error();
        }
        tri.Edges.setItem(0, edge);
        tri.Sites.setItem(2, pi);
        tri.CreateEdge(1, createEdgeDelegate);
        tri.CreateEdge(2, createEdgeDelegate);
        return tri;
    }
    //
    static mkSSSEE(aLeft, aRight, bRight, a, b, createEdgeDelegate) {
        /*Assert.assert(
          Point.getTriangleOrientation(aLeft.point, aRight.point, bRight.point) ==
            TriangleOrientation.Counterclockwise,
        )*/
        const tri = CdtTriangle.mkSSSD(aLeft, aRight, bRight, createEdgeDelegate);
        tri.Edges.setItem(0, a);
        tri.Edges.setItem(1, b);
        tri.BindEdgeToTriangle(aLeft, a);
        tri.BindEdgeToTriangle(aRight, b);
        tri.CreateEdge(2, createEdgeDelegate);
        return tri;
    }
    // in the trianlge, which is always oriented counterclockwise, the edge starts at site
    BindEdgeToTriangle(site, edge) {
        if (site === edge.upperSite) {
            edge.CcwTriangle = this;
        }
        else {
            edge.CwTriangle = this;
        }
    }
    // here a,b,c comprise a ccw triangle
    FillCcwTriangle(a, b, c, createEdgeDelegate) {
        this.Sites.setItem(0, a);
        this.Sites.setItem(1, b);
        this.Sites.setItem(2, c);
        for (let i = 0; i < 3; i++) {
            this.CreateEdge(i, createEdgeDelegate);
        }
    }
    CreateEdge(i, createEdgeDelegate) {
        const a = this.Sites.getItem(i);
        const b = this.Sites.getItem(i + 1);
        const edge = createEdgeDelegate(a, b);
        this.Edges.setItem(i, edge);
        this.BindEdgeToTriangle(a, edge);
    }
    Contains(cdtSite) {
        return this.Sites.has(cdtSite);
    }
    OppositeEdge(pi) {
        const index = this.Sites.index(pi);
        /*Assert.assert(index !== -1)*/
        return this.Edges.getItem(index + 1);
    }
    // #if TEST_MSAGL&&TEST_MSAGL
    //         // Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
    //         // A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
    //         // <filterpriority>2</filterpriority>
    //         public override string ToString() {
    //             return String.Format("({0},{1},{2}", Sites[0], Sites[1], Sites[2]);
    //         }
    // #endif
    OppositeSite(cdtEdge) {
        const i = this.Edges.index(cdtEdge);
        return this.Sites.getItem(i + 2);
    }
    BoundingBox() {
        const rect = Rectangle.mkPP(this.Sites.getItem(0).point, this.Sites.getItem(1).point);
        rect.add(this.Sites.getItem(2).point);
        return rect;
    }
    static mkSSSEED(aLeft, aRight, bRight, a, b, createEdgeDelegate) {
        const t = new CdtTriangle();
        t.Sites.setItem(0, aLeft);
        t.Sites.setItem(1, aRight);
        t.Sites.setItem(2, bRight);
        t.Edges.setItem(0, a);
        t.Edges.setItem(1, b);
        t.BindEdgeToTriangle(aLeft, a);
        t.BindEdgeToTriangle(aRight, b);
        t.CreateEdge(2, createEdgeDelegate);
        return t;
    }
    toString() {
        return this.Sites.getItem(0).toString() + ',' + this.Sites.getItem(1).toString() + ',' + this.Sites.getItem(2).toString();
    }
}
//# sourceMappingURL=CdtTriangle.js.map