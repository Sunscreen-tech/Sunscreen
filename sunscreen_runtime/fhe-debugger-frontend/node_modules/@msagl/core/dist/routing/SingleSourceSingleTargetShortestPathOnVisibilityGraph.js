import { GenericBinaryHeapPriorityQueue } from '../structs/genericBinaryHeapPriorityQueue';
import { compareNumbers } from '../utils/compare';
import { TollFreeVisibilityEdge } from './visibility/TollFreeVisibilityEdge';
export class SingleSourceSingleTargetShortestPathOnVisibilityGraph {
    constructor(visGraph, sourceVisVertex, targetVisVertex) {
        this._lengthMultiplier = 1;
        this._lengthMultiplierForAStar = 1;
        this._visGraph = visGraph;
        this._source = sourceVisVertex;
        this._target = targetVisVertex;
        this._source.Distance = 0;
    }
    get LengthMultiplier() {
        return this._lengthMultiplier;
    }
    set LengthMultiplier(value) {
        this._lengthMultiplier = value;
    }
    get LengthMultiplierForAStar() {
        return this._lengthMultiplierForAStar;
    }
    set LengthMultiplierForAStar(value) {
        this._lengthMultiplierForAStar = value;
    }
    // Returns  a  path
    GetPath(shrinkEdgeLength) {
        const pq = new GenericBinaryHeapPriorityQueue(compareNumbers);
        this._source.Distance = 0;
        this._target.Distance = Number.POSITIVE_INFINITY;
        pq.Enqueue(this._source, this.H(this._source));
        while (!pq.IsEmpty()) {
            const hu = { priority: 0 };
            const u = pq.DequeueAndGetPriority(hu);
            if (hu.priority >= this._target.Distance) {
                break;
            }
            for (const e of u.OutEdges) {
                if (this.PassableOutEdge(e)) {
                    const v = e.Target;
                    this.ProcessNeighbor(pq, u, e, v);
                }
            }
            for (const e of u.InEdges) {
                if (this.PassableInEdge(e)) {
                    const v = e.Source;
                    this.ProcessNeighbor(pq, u, e, v);
                }
            }
        }
        return this._visGraph.PreviosVertex(this._target) == null ? null : this.CalculatePath(shrinkEdgeLength);
    }
    // private AssertEdgesPassable(path: Array<VisibilityEdge>) {
    //  for (const edge of path) Assert.assert(this.PassableOutEdge(edge) || this.PassableInEdge(edge))
    // }
    PassableOutEdge(e) {
        return e.Source === this._source || e.Target === this._target || !SingleSourceSingleTargetShortestPathOnVisibilityGraph.IsForbidden(e);
    }
    PassableInEdge(e) {
        return e.Source === this._target || e.Target === this._source || !SingleSourceSingleTargetShortestPathOnVisibilityGraph.IsForbidden(e);
    }
    static IsForbidden(e) {
        return (e.IsPassable != null && !e.IsPassable()) || e instanceof TollFreeVisibilityEdge;
    }
    ProcessNeighborN(pq, u, l, v, penalty) {
        const len = l.Length + penalty;
        const c = u.Distance + len;
        if (v !== this._source && this._visGraph.PreviosVertex(v) == null) {
            v.Distance = c;
            this._visGraph.SetPreviousEdge(v, l);
            if (v !== this._target) {
                pq.Enqueue(v, this.H(v));
            }
        }
        else if (v !== this._source && c < v.Distance) {
            // This condition should never hold for the dequeued nodes.
            // However because of a very rare case of an epsilon error it might!
            // In this case DecreasePriority will fail to find "v" and the algorithm will continue working.
            // Since v is not in the queue changing its .Distance will not influence other nodes.
            // Changing v.Prev is fine since we come up with the path with an insignificantly
            // smaller distance.
            v.Distance = c;
            this._visGraph.SetPreviousEdge(v, l);
            if (v !== this._target) {
                pq.DecreasePriority(v, this.H(v));
            }
        }
    }
    ProcessNeighbor(pq, u, l, v) {
        const len = l.Length;
        const c = u.Distance + len;
        if (v !== this._source && this._visGraph.PreviosVertex(v) == null) {
            v.Distance = c;
            this._visGraph.SetPreviousEdge(v, l);
            if (v !== this._target) {
                pq.Enqueue(v, this.H(v));
            }
        }
        else if (v !== this._source && c < v.Distance) {
            // This condition should never hold for the dequeued nodes.
            // However because of a very rare case of an epsilon error it might!
            // In this case DecreasePriority will fail to find "v" and the algorithm will continue working.
            // Since v is not in the queue changing its .Distance will not influence other nodes.
            // Changing v.Prev is fine since we come up with the path with an insignificantly
            // smaller distance.
            v.Distance = c;
            this._visGraph.SetPreviousEdge(v, l);
            if (v !== this._target) {
                pq.DecreasePriority(v, this.H(v));
            }
        }
    }
    H(visibilityVertex) {
        return visibilityVertex.Distance + visibilityVertex.point.sub(this._target.point).length * this.LengthMultiplierForAStar;
    }
    CalculatePath(shrinkEdgeLength) {
        const ret = new Array();
        let v = this._target;
        do {
            ret.push(v);
            if (shrinkEdgeLength) {
                this._visGraph.ShrinkLengthOfPrevEdge(v, this.LengthMultiplier);
            }
            v = this._visGraph.PreviosVertex(v);
        } while (v !== this._source);
        ret.push(this._source);
        return ret.reverse();
    }
}
//# sourceMappingURL=SingleSourceSingleTargetShortestPathOnVisibilityGraph.js.map