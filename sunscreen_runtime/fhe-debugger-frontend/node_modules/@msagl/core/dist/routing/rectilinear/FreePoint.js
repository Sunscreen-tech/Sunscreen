// This is a point on a path that is not associated with an obstacle, such as
// a port for the end of a dragged path, or a waypoint.
import { CompassVector, Direction } from '../../math/geometry';
import { PointComparer } from './PointComparer';
import { ScanSegment } from './ScanSegment';
import { StaticGraphUtility } from './StaticGraphUtility';
export class FreePoint {
    // Called if we must create the vertex.
    constructor(transUtil, point) {
        this.maxVisibilitySegmentsAndCrossings = new Array(4);
        this.OutOfBoundsDirectionFromGraph = Direction.None;
        this.GetVertex(transUtil, point);
    }
    get Point() {
        return this.Vertex.point;
    }
    get InitialWeight() {
        return this.IsOverlapped ? ScanSegment.OverlappedWeight : ScanSegment.NormalWeight;
    }
    get IsOutOfBounds() {
        return Direction.None !== this.OutOfBoundsDirectionFromGraph;
    }
    GetVertex(transUtil, point) {
        this.Vertex = transUtil.FindOrAddVertex(point);
    }
    // Adds an edge from this.Vertex to a (possibly new) vertex at an intersection with an
    // existing Edge that adjoins the point.  We take 'dir' as an input parameter for edge
    // extension because we may be on the edge so can't calculate the direction.
    AddEdgeToAdjacentEdge(transUtil, targetEdge, dirToExtend, limitRect) {
        const targetIntersect = StaticGraphUtility.SegmentIntersectionEP(targetEdge, this.Point);
        let targetVertex = transUtil.VisGraph.FindVertex(targetIntersect);
        if (null != targetVertex) {
            this.AddToAdjacentVertex(transUtil, targetVertex, dirToExtend, limitRect);
        }
        else {
            targetVertex = transUtil.AddEdgeToTargetEdge(this.Vertex, targetEdge, targetIntersect);
        }
        this.ExtendEdgeChain(transUtil, targetVertex, dirToExtend, limitRect);
        return targetVertex;
    }
    AddToAdjacentVertex(transUtil, targetVertex, dirToExtend, limitRect) {
        if (!PointComparer.EqualPP(this.Point, targetVertex.point)) {
            transUtil.FindOrAddEdge(this.Vertex, targetVertex, this.InitialWeight);
        }
        this.ExtendEdgeChain(transUtil, targetVertex, dirToExtend, limitRect);
    }
    ExtendEdgeChain(transUtil, targetVertex, dirToExtend, limitRect) {
        // Extend the edge chain to the opposite side of the limit rectangle.
        // StaticGraphUtility.Assert((PointComparer.Equal(this.Point, targetVertex.point)
        //                || (PointComparer.GetPureDirectionVV(this.Point, targetVertex.point) === dirToExtend)), "input dir does not match with to-targetVertex direction", transUtil.ObstacleTree, transUtil.VisGraph);
        let extendOverlapped = this.IsOverlapped;
        if (extendOverlapped) {
            // The initial vertex we connected to may be on the border of the enclosing obstacle,
            // or of another also-overlapped obstacle.  If the former, we turn off overlap now.
            extendOverlapped = transUtil.ObstacleTree.PointIsInsideAnObstaclePD(targetVertex.point, dirToExtend);
        }
        // If we're inside an obstacle's boundaries we'll never extend past the end of the obstacle
        // due to encountering the boundary from the inside.  So start the extension at targetVertex.
        const segmentAndCrossings = this.GetSegmentAndCrossings(this.IsOverlapped ? targetVertex : this.Vertex, dirToExtend, transUtil);
        transUtil.ExtendEdgeChainVRLPB(targetVertex, limitRect, segmentAndCrossings[0], segmentAndCrossings[1], extendOverlapped);
    }
    GetSegmentAndCrossings(startVertex, dirToExtend, transUtil) {
        const dirIndex = CompassVector.ToIndex(dirToExtend);
        let segmentAndCrossings = this.maxVisibilitySegmentsAndCrossings[dirIndex];
        if (segmentAndCrossings == null) {
            const t = { pacList: null };
            const maxVisibilitySegment = transUtil.ObstacleTree.CreateMaxVisibilitySegment(startVertex.point, dirToExtend, t);
            segmentAndCrossings = [maxVisibilitySegment, t.pacList];
            this.maxVisibilitySegmentsAndCrossings[dirIndex] = segmentAndCrossings;
        }
        else {
            // For a waypoint this will be a target and then a source, so there may be a different lateral edge to
            // connect to. In that case make sure we are consistent in directions - back up the start point if needed.
            if (PointComparer.GetDirections(startVertex.point, segmentAndCrossings[0].start) === dirToExtend) {
                segmentAndCrossings[0].start = startVertex.point;
            }
        }
        return segmentAndCrossings;
    }
    MaxVisibilityInDirectionForNonOverlappedFreePoint(dirToExtend, transUtil) {
        /*Assert.assert(
          !this.IsOverlapped,
          'Do not precalculate overlapped obstacle visibility as we should extend from the outer target vertex instead',
        )*/
        const segmentAndCrossings = this.GetSegmentAndCrossings(this.Vertex, dirToExtend, transUtil);
        return segmentAndCrossings[0].end;
    }
    AddOobEdgesFromGraphCorner(transUtil, cornerPoint) {
        const dirs = PointComparer.GetDirections(cornerPoint, this.Vertex.point);
        const cornerVertex = transUtil.VisGraph.FindVertex(cornerPoint);
        // For waypoints we want to be able to enter in both directions.
        transUtil.ConnectVertexToTargetVertex(cornerVertex, this.Vertex, dirs & (Direction.North | Direction.South), ScanSegment.NormalWeight);
        transUtil.ConnectVertexToTargetVertex(cornerVertex, this.Vertex, dirs & (Direction.East | Direction.West), ScanSegment.NormalWeight);
    }
    RemoveFromGraph() {
        // Currently all transient removals and edge restorations are done by TransientGraphUtility itself.
        this.Vertex = null;
    }
    toString() {
        return this.Vertex.toString();
    }
}
//# sourceMappingURL=FreePoint.js.map