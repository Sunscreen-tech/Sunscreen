import { String } from 'typescript-string-operations';
import { PointMap } from '../../utils/PointMap';
import { GroupBoundaryCrossing } from './GroupBoundaryCrossing';
import { PointAndCrossingsList } from './PointAndCrossingsList';
import { PointComparer } from './PointComparer';
// A Group is a Shape that has children.
// This class maps between intersection points on Group boundaries and the groups and crossing
// directions at those intersection points.
export class GroupBoundaryCrossingMap {
    constructor() {
        // Note:  Like VisibilityGraph, this does not use PointComparer but assumes already-rounded key values.
        this.pointCrossingMap = new PointMap();
        this.pointList = new Array();
    }
    AddIntersection(intersection, group, dirToInside) {
        let crossings = this.pointCrossingMap.get(intersection);
        if (!crossings) {
            crossings = new Array();
            this.pointCrossingMap.set(intersection, crossings);
        }
        // We may hit the same point on neighbor traversal in multiple directions.  We will have more than one item
        // in this list only if there are multiple group boundaries at this point, which should be unusual.
        const crossingsCount = crossings.length;
        // cache for perf
        for (let ii = 0; ii < crossingsCount; ii++) {
            const crossing = crossings[ii];
            if (crossing.Group === group) {
                // At a given location for a given group, there is only one valid dirToInside.
                /*Assert.assert(
                  dirToInside === crossing.DirectionToInside,
                  'Mismatched dirToInside',
                )*/
                return crossing;
            }
        }
        const newCrossing = new GroupBoundaryCrossing(group, dirToInside);
        crossings.push(newCrossing);
        return newCrossing;
    }
    Clear() {
        this.pointCrossingMap.clear();
    }
    GetOrderedListBetween(start, end) {
        if (this.pointCrossingMap.size === 0) {
            return null;
        }
        if (PointComparer.ComparePP(start, end) > 0) {
            const temp = start;
            start = end;
            end = temp;
        }
        // Start and end are inclusive.
        this.pointList = [];
        for (const intersection of this.pointCrossingMap.keys()) {
            if (PointComparer.ComparePP(intersection, start) >= 0 && PointComparer.ComparePP(intersection, end) <= 0) {
                this.pointList.push(intersection);
            }
        }
        this.pointList.sort((a, b) => a.compareTo(b));
        const pointAndCrossingList = new PointAndCrossingsList();
        const numCrossings = this.pointList.length;
        for (let ii = 0; ii < numCrossings; ii++) {
            const intersect = this.pointList[ii];
            pointAndCrossingList.Add(intersect, this.pointCrossingMap.get(intersect));
        }
        return pointAndCrossingList;
    }
    toString() {
        return String.Format('{0}', this.pointCrossingMap.size);
    }
}
//# sourceMappingURL=GroupBoundaryCrossingMap.js.map