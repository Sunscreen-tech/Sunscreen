import { ICurve, Point } from '../../math/geometry';
import { CancelToken } from '../../utils/cancelToken';
import { GeomEdge } from '../../layout/core/geomEdge';
import { GeomGraph } from '../../layout/core/geomGraph';
import { Ellipse } from '../../math/geometry/ellipse';
import { Polyline } from '../../math/geometry/polyline';
import { Algorithm } from '../../utils/algorithm';
import { Shape } from '../shape';
import { VisibilityGraph } from '../visibility/VisibilityGraph';
import { MsmtRectilinearPath } from './MsmtRectilinearPath';
import { Path } from './nudging/Path';
import { Obstacle } from './obstacle';
import { PortManager } from './PortManager';
import { VisibilityGraphGenerator } from './VisibilityGraphGenerator';
export declare class RectilinearEdgeRouter extends Algorithm {
    Padding: number;
    /**  The radius of the arc inscribed into the path corners. */
    CornerFitRadius: number;
    /** the minimal distance between to parrallel segments */
    edgeSeparatian: number;
    BendPenaltyAsAPercentageOfDistance: number;
    get RouteToCenterOfObstacles(): boolean;
    set RouteToCenterOfObstacles(value: boolean);
    get LimitPortVisibilitySpliceToEndpointBoundingBox(): boolean;
    set LimitPortVisibilitySpliceToEndpointBoundingBox(value: boolean);
    AddEdgeGeometryToRoute(edgeGeometry: GeomEdge): void;
    get EdgeGeometriesToRoute(): Array<GeomEdge>;
    RemoveAllEdgeGeometriesToRoute(): void;
    get UseSparseVisibilityGraph(): boolean;
    get Obstacles(): Array<Shape>;
    get PaddedObstacles(): Array<Polyline>;
    AddObstacles(obstacles: Iterable<Shape>): void;
    private AddShapes;
    AddObstacle(shape: Shape): void;
    UpdateObstacles(obstacles: Iterable<Shape>): void;
    UpdateObstacle(obstacle: Shape): void;
    RemoveObstacles(obstacles: Iterable<Shape>): void;
    RemoveObstacle(obstacle: Shape): void;
    AddObstacleWithoutRebuild(shape: Shape): void;
    UpdateObstacleWithoutRebuild(shape: Shape): void;
    private CreatePaddedObstacle;
    RemoveObstacleWithoutRebuild(shape: Shape): void;
    RemoveAllObstacles(): void;
    RebuildTreeAndGraph(): void;
    get VisibilityGraph(): VisibilityGraph;
    Clear(): void;
    GraphGenerator: VisibilityGraphGenerator;
    ShapeToObstacleMap: Map<Shape, Obstacle>;
    EdgesToRoute: Array<GeomEdge>;
    PortManager: PortManager;
    AncestorsSets: Map<Shape, Set<Shape>>;
    static constructorEmpty(): RectilinearEdgeRouter;
    static constructorC(cancelToket: CancelToken): RectilinearEdgeRouter;
    static DefaultPadding: number;
    static DefaultCornerFitRadius: number;
    static constructorI(Obstacle: Iterable<Shape>): RectilinearEdgeRouter;
    static constructorINN(obstacles: Iterable<Shape>, padding: number, cornerFitRadius: number): RectilinearEdgeRouter;
    constructor(obstacles: Iterable<Shape>, padding: number, cornerFitRadius: number);
    static constructorGNAN(graph: GeomGraph, geomEdges: GeomEdge[], padding: number, cornerFitRadius: number): RectilinearEdgeRouter;
    run(): void;
    GeneratePaths(): void;
    RouteSelfEdges(): void;
    private FillEdgePathsWithShortestPaths;
    private AddControlPointsAndGeneratePath;
    GeneratePathThroughVisibilityIntersection(edgePath: Path, intersectPoints: Point[]): void;
    SpliceVisibilityAndGeneratePath(shortestPathRouter: MsmtRectilinearPath, edgePath: Path): void;
    GeneratePath(shortestPathRouter: MsmtRectilinearPath, edgePath: Path, lastChance: boolean): boolean;
    private static GetSingleStagePath;
    private static EnsureNonNullPath;
    RetryPathsWithAdditionalGroupsEnabled(shortestPathRouter: MsmtRectilinearPath, edgePath: Path): void;
    NudgePaths(edgePaths: Array<Path>): void;
    private removeStaircases;
    selfEdges: Array<GeomEdge>;
    get RemoveStaircases(): boolean;
    set RemoveStaircases(value: boolean);
    FinaliseEdgeGeometries(): void;
    CreateVisibilityGraph(): void;
    private static CalculateArrowheads;
    private get ObsTree();
    private GenerateObstacleTree;
    InitObstacleTree(): void;
    private InternalClear;
    private ClearShortestPaths;
    GenerateVisibilityGraph(): void;
    static FitArcsIntoCorners(radius: number, polyline: Point[]): ICurve;
    static CornerPoint(ellipse: Ellipse): Point;
    private static EllipseIsAlmostLineSegment;
    private static GetFittedArcSegs;
}
