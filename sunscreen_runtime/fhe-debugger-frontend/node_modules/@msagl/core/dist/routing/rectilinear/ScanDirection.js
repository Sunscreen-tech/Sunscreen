import { CompassVector } from '../../math/geometry/compassVector';
import { Direction } from '../../math/geometry/direction';
import { PointComparer } from './PointComparer';
import { StaticGraphUtility } from './StaticGraphUtility';
export class ScanDirection {
    // Use the internal static xxxInstance properties to get an instance.
    constructor(directionAlongScanLine) {
        /*Assert.assert(
          StaticGraphUtility.IsAscending(directionAlongScanLine),
          'directionAlongScanLine must be ascending',
        )*/
        this.Dir = directionAlongScanLine;
        this.DirectionAsPoint = CompassVector.toPoint(this.Dir);
        this.PerpDirection = Direction.North === directionAlongScanLine ? Direction.East : Direction.North;
        this.PerpDirectionAsPoint = CompassVector.toPoint(this.PerpDirection);
        this.OppositeDirection = CompassVector.OppositeDir(directionAlongScanLine);
    }
    get Dir() {
        return this.dir;
    }
    set Dir(value) {
        this.dir = value;
    }
    get IsHorizontal() {
        return Direction.East === this.Dir;
    }
    get IsVertical() {
        return Direction.North === this.Dir;
    }
    // Compare in perpendicular direction first, then parallel direction.
    Compare(lhs, rhs) {
        const cmp = this.ComparePerpCoord(lhs, rhs);
        return 0 !== cmp ? cmp : this.CompareScanCoord(lhs, rhs);
    }
    CompareScanCoord(lhs, rhs) {
        return PointComparer.Compare(lhs.sub(rhs).dot(this.DirectionAsPoint), 0);
    }
    ComparePerpCoord(lhs, rhs) {
        return PointComparer.Compare(lhs.sub(rhs).dot(this.PerpDirectionAsPoint), 0);
    }
    IsFlatS(seg) {
        return this.IsFlatPP(seg.Start, seg.End);
    }
    IsFlatPP(start, end) {
        // Return true if there is no change in the perpendicular direction.
        return PointComparer.Equal(end.sub(start).dot(this.PerpDirectionAsPoint), 0);
    }
    IsPerpendicularS(seg) {
        return this.IsPerpendicularPP(seg.Start, seg.End);
    }
    IsPerpendicularPP(start, end) {
        // Return true if there is no change in the primary direction.
        return PointComparer.Equal(end.sub(start).dot(this.DirectionAsPoint), 0);
    }
    Coord(point) {
        return point.dot(this.DirectionAsPoint);
    }
    Min(first, second) {
        return this.Compare(first, second) <= 0 ? first : second;
    }
    Max(first, second) {
        return this.Compare(first, second) >= 0 ? first : second;
    }
    get PerpendicularInstance() {
        return this.IsHorizontal ? ScanDirection.VerticalInstance : ScanDirection.HorizontalInstance;
    }
    static GetInstance(dir) {
        return StaticGraphUtility.IsVerticalD(dir) ? ScanDirection.VerticalInstance : ScanDirection.HorizontalInstance;
    }
    ToString() {
        return this.Dir.toString();
    }
}
ScanDirection.HorizontalInstance = new ScanDirection(Direction.East);
ScanDirection.VerticalInstance = new ScanDirection(Direction.North);
//# sourceMappingURL=ScanDirection.js.map