import { Point } from '../../math/geometry/point';
export class SpliceUtility {
    // Most of the original contents of this file have been subsumed into ObstacleTree and TransientGraphUtility.
    static MungeClosestIntersectionInfo(rayOrigin, closestIntersection, isHorizontal) {
        const bbox = closestIntersection.seg1.boundingBox;
        const closest = Point.RoundPoint(closestIntersection.x).clone();
        return isHorizontal
            ? new Point(SpliceUtility.MungeIntersect(rayOrigin.x, closest.x, bbox.left, bbox.right), closest.y)
            : new Point(closest.x, SpliceUtility.MungeIntersect(rayOrigin.y, closest.y, bbox.bottom, bbox.top));
    }
    // Make sure that we intersect the object space.
    static MungeIntersect(site, intersect, start, end) {
        if (site < intersect) {
            const min = Math.min(start, end);
            if (intersect < min) {
                intersect = min;
            }
        }
        else if (site > intersect) {
            const max = Math.max(start, end);
            if (intersect > max) {
                intersect = max;
            }
        }
        return Point.RoundDouble(intersect);
    }
}
//# sourceMappingURL=SpliceUtility.js.map