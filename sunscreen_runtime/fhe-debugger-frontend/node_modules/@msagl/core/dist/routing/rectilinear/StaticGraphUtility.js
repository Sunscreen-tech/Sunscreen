// import {CompassVector} from '../../math/geometry/compassVector'
import { Direction } from '../../math/geometry/direction';
import { Point } from '../../math/geometry/point';
import { PointComparer } from './PointComparer';
export class StaticGraphUtility {
    // Determine the direction of an edge.
    static EdgeDirectionVE(edge) {
        return StaticGraphUtility.EdgeDirectionVV(edge.Source, edge.Target);
    }
    static EdgeDirectionVV(source, target) {
        return PointComparer.GetDirections(source.point, target.point);
    }
    static GetEdgeEnd(edge, dir) {
        const edgeDir = StaticGraphUtility.EdgeDirectionVE(edge);
        /*Assert.assert(
          0 !== (dir & (edgeDir | CompassVector.OppositeDir(edgeDir))),
          'dir is orthogonal to edge',
        )*/
        return dir === edgeDir ? edge.Target : edge.Source;
    }
    static FindAdjacentVertex(vertex, dir) {
        // This function finds the next vertex in the desired direction relative to the
        // current vertex, not necessarily the edge orientation, hence it does not use
        // EdgeDirection().  This is so the caller can operate on a desired movement
        // direction without having to track whether we're going forward or backward
        // through the In/OutEdge chain.
        for (const edge of vertex.InEdges) {
            if (PointComparer.GetDirections(vertex.point, edge.SourcePoint) === dir) {
                return edge.Source;
            }
        }
        // Avoid GetEnumerator overhead.
        for (const edge of vertex.OutEdges) {
            if (PointComparer.GetDirections(vertex.point, edge.TargetPoint) === dir) {
                return edge.Target;
            }
        }
        return null;
    }
    static FindAdjacentEdge(a, dir) {
        for (const edge of a.InEdges) {
            if (PointComparer.GetDirections(edge.SourcePoint, a.point) === dir) {
                return edge;
            }
        }
        for (const edge of a.OutEdges) {
            if (PointComparer.GetDirections(a.point, edge.TargetPoint) === dir) {
                return edge;
            }
        }
        return null;
    }
    static FindBendPointBetween(sourcePoint, targetPoint, finalEdgeDir) {
        return !StaticGraphUtility.IsVerticalD(finalEdgeDir) ? new Point(sourcePoint.x, targetPoint.y) : new Point(targetPoint.x, sourcePoint.y);
    }
    static SegmentIntersectionPPP(first, second, from) {
        const dir = PointComparer.GetDirections(first, second);
        return StaticGraphUtility.IsVerticalD(dir) ? new Point(first.x, from.y) : new Point(from.x, first.y);
    }
    static SegmentIntersectionSP(seg, from) {
        return StaticGraphUtility.SegmentIntersectionPPP(seg.Start, seg.End, from);
    }
    static SegmentsIntersection(first, second) {
        return StaticGraphUtility.IntervalsIntersect(first.Start, first.End, second.Start, second.End);
    }
    static SegmentsIntersectLL(first, second) {
        return StaticGraphUtility.IntervalsIntersect(first.start, first.end, second.start, second.end);
    }
    static IntervalsOverlapSS(first, second) {
        return StaticGraphUtility.IntervalsOverlapPPPP(first.Start, first.End, second.Start, second.End);
    }
    static IntervalsOverlapPPPP(start1, end1, start2, end2) {
        return (StaticGraphUtility.IntervalsAreCollinear(start1, end1, start2, end2) &&
            PointComparer.ComparePP(start1, end2) !== PointComparer.ComparePP(end1, start2));
    }
    static IntervalsAreCollinear(start1, end1, start2, end2) {
        /*Assert.assert(
          StaticGraphUtility.IsVerticalPP(start1, end1) ==
            StaticGraphUtility.IsVerticalPP(start2, end2),
          'segments are not in the same orientation',
        )*/
        const vertical = StaticGraphUtility.IsVerticalPP(start1, end1);
        if (StaticGraphUtility.IsVerticalPP(start2, end2) === vertical) {
            // This handles touching endpoints as well.
            return vertical ? PointComparer.Equal(start1.x, start2.x) : PointComparer.Equal(start1.y, start2.y);
        }
        return false;
    }
    static IntervalsAreSame(start1, end1, start2, end2) {
        return PointComparer.EqualPP(start1, start2) && PointComparer.EqualPP(end1, end2);
    }
    static IntervalsIntersect(firstStart, firstEnd, secondStart, secondEnd) {
        /*Assert.assert(
          StaticGraphUtility.IsVerticalPP(firstStart, firstEnd) !=
            StaticGraphUtility.IsVerticalPP(secondStart, secondEnd),
          'cannot intersect two parallel segments',
        )*/
        const intersect = StaticGraphUtility.SegmentIntersectionPPP(firstStart, firstEnd, secondStart);
        return StaticGraphUtility.PointIsOnSegmentPPP(firstStart, firstEnd, intersect) &&
            StaticGraphUtility.PointIsOnSegmentPPP(secondStart, secondEnd, intersect)
            ? intersect
            : undefined;
    }
    static SegmentIntersectionEP(edge, from) {
        return StaticGraphUtility.SegmentIntersectionPPP(edge.SourcePoint, edge.TargetPoint, from);
    }
    static PointIsOnSegmentPPP(first, second, test) {
        return (PointComparer.EqualPP(first, test) ||
            PointComparer.EqualPP(second, test) ||
            PointComparer.GetDirections(first, test) === PointComparer.GetDirections(test, second));
    }
    static PointIsOnSegmentSP(seg, test) {
        return StaticGraphUtility.PointIsOnSegmentPPP(seg.Start, seg.End, test);
    }
    static IsVerticalD(dir) {
        return 0 !== (dir & (Direction.North | Direction.South));
    }
    static IsVerticalE(edge) {
        return StaticGraphUtility.IsVerticalD(PointComparer.GetDirections(edge.SourcePoint, edge.TargetPoint));
    }
    static IsVerticalPP(first, second) {
        return StaticGraphUtility.IsVerticalD(PointComparer.GetDirections(first, second));
    }
    static IsVertical(seg) {
        return StaticGraphUtility.IsVerticalD(PointComparer.GetDirections(seg.start, seg.end));
    }
    static IsAscending(dir) {
        return (dir & (Direction.North | Direction.East)) !== 0;
    }
    static Slope(start, end, scanDir) {
        // Find the slope relative to scanline - how much scan coord changes per sweep change.
        const lineDir = end.sub(start);
        return lineDir.dot(scanDir.PerpDirectionAsPoint) / lineDir.dot(scanDir.DirectionAsPoint);
    }
    static SortAscending(a, b) {
        const dir = PointComparer.GetDirections(a, b);
        /*Assert.assert(
          Direction.None === dir || PointComparer.IsPureDirectionD(dir),
          'SortAscending with impure direction',
        )*/
        return Direction.None === dir || StaticGraphUtility.IsAscending(dir) ? [a, b] : [b, a];
    }
    static RectangleBorderIntersect(boundingBox, point, dir) {
        switch (dir) {
            case Direction.North:
            case Direction.South:
                return new Point(point.x, StaticGraphUtility.GetRectangleBound(boundingBox, dir));
                break;
            case Direction.East:
            case Direction.West:
                return new Point(StaticGraphUtility.GetRectangleBound(boundingBox, dir), point.y);
                break;
            default:
                throw new Error();
                break;
        }
    }
    static GetRectangleBound(rect, dir) {
        switch (dir) {
            case Direction.North:
                return rect.top;
                break;
            case Direction.South:
                return rect.bottom;
                break;
            case Direction.East:
                return rect.right;
                break;
            case Direction.West:
                return rect.left;
                break;
            default:
                throw new Error();
                break;
        }
    }
    static RectangleInteriorsIntersect(a, b) {
        return (PointComparer.Compare(a.bottom, b.top) < 0 &&
            PointComparer.Compare(b.bottom, a.top) < 0 &&
            PointComparer.Compare(a.left, b.right) < 0 &&
            PointComparer.Compare(b.left, a.right) < 0);
    }
    static PointIsInRectangleInterior(point, rect) {
        return (PointComparer.Compare(point.y, rect.top) < 0 &&
            PointComparer.Compare(rect.bottom, point.y) < 0 &&
            PointComparer.Compare(point.x, rect.right) < 0 &&
            PointComparer.Compare(rect.left, point.x) < 0);
    }
}
//# sourceMappingURL=StaticGraphUtility.js.map