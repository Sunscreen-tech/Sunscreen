// a wrapper arownd VisibilityEdge representing the same edge
import { CompassVector } from '../../../math/geometry/compassVector';
import { VisibilityEdge } from '../../visibility/VisibilityEdge';
// but oriented along the X or the Y axis
export class AxisEdge extends VisibilityEdge {
    constructor(source, target) {
        super(source, target);
        this.RightNeighbors = new Set();
        this.setOfLongestSegs = new Set();
        this.RightBound = Number.POSITIVE_INFINITY;
        this.LeftBound = Number.NEGATIVE_INFINITY;
        this.Direction = CompassVector.DirectionFromPointToPoint(source.point, target.point);
        /*Assert.assert(
          this.Direction === Direction.East || this.Direction === Direction.North,
        )*/
    }
    AddRightNeighbor(edge) {
        this.RightNeighbors.add(edge);
    }
    get LongestNudgedSegments() {
        return this.setOfLongestSegs;
    }
    AddLongestNudgedSegment(segment) {
        this.setOfLongestSegs.add(segment);
    }
    BoundFromRight(rightbound) {
        rightbound = Math.max(rightbound, this.LeftBound);
        this.RightBound = Math.min(rightbound, this.RightBound);
    }
    BoundFromLeft(leftbound) {
        leftbound = Math.min(leftbound, this.RightBound);
        this.LeftBound = Math.max(leftbound, this.LeftBound);
    }
}
//# sourceMappingURL=AxisEdge.js.map