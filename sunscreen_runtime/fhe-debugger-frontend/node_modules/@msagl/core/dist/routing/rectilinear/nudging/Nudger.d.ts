import { Point } from '../../../math/geometry/point';
import { ICurve } from '../../../math/geometry/icurve';
import { Rectangle } from '../../../math/geometry/rectangle';
import { UniformOneDimensionalSolver } from '../../../math/projectionSolver/UniformOneDimensionalSolver';
import { Port } from '../../../layout/core/port';
import { DebugCurve } from '../../../math/geometry/debugCurve';
import { Direction } from '../../../math/geometry/direction';
import { Polyline } from '../../../math/geometry/polyline';
import { Shape } from '../../shape';
import { SegmentBase } from '../../visibility/SegmentBase';
import { VisibilityEdge } from '../../visibility/VisibilityEdge';
import { VisibilityGraph } from '../../visibility/VisibilityGraph';
import { AxisEdge } from './AxisEdge';
import { LongestNudgedSegment } from './LongestNudgedSegment';
import { Path } from './Path';
import { PathEdge } from './PathEdge';
import { HitTestBehavior } from '../../../math/geometry/RTree/hitTestBehavior';
import { RectangleNode } from '../../../math/geometry/RTree/rectangleNode';
import { GeomEdge } from '../../..';
declare type PointProjection = (p: Point) => number;
export declare class Nudger {
    get HasGroups(): boolean;
    axisEdgesToObstaclesTheyOriginatedFrom: Map<AxisEdge, Polyline>;
    Paths: Array<Path>;
    Obstacles: Array<Polyline>;
    PathVisibilityGraph: VisibilityGraph;
    constructor(paths: Array<Path>, cornerFitRad: number, obstacles: Array<Polyline>, ancestorsSets: Map<Shape, Set<Shape>>);
    AncestorsSets: Map<Shape, Set<Shape>>;
    MapPathsToTheirObstacles(): void;
    MapPathToItsObstacles(path: Path): void;
    static ObstacleTest(pnt: Point, polyline: Polyline): HitTestBehavior;
    HierarchyOfObstacles: RectangleNode<Polyline, Point>;
    HierarchyOfGroups: RectangleNode<Shape, Point>;
    Calculate(direction: Direction, mergePaths: boolean): void;
    MapAxisEdgesToTheirObstacles(): void;
    UmmapPathInteriourFromStrangerObstacles(path: Path): void;
    FindLastUnmappedEdge(path: Path): PathEdge;
    FindFirstUnmappedEdge(path: Path): PathEdge;
    MapPathEndAxisEdgesToTheirObstacles(path: Path): void;
    ProcessThePathEndToMapAxisEdgesToTheirObstacles(path: Path, endPolyline: Polyline): void;
    ProcessThePathStartToMapAxisEdgesToTheirObstacles(path: Path, startPolyline: Polyline): void;
    GetPathOrdersAndPathGraph(): void;
    NudgingDirection: Direction;
    static GetCurvesForShow(paths: Iterable<Path>, obstacles: Iterable<Polyline>): ICurve[];
    DrawPaths(): void;
    SetWidthsOfArrowheads(): void;
    static SetWidthsOfArrowheadsForEdge(path: Path): void;
    EdgeSeparation: number;
    PositionShiftedEdqges(): void;
    MoveLongestSegsIdealPositionsInsideFeasibleIntervals(): void;
    static MoveLongestSegIdealPositionsInsideFeasibleInterval(seg: LongestNudgedSegment): void;
    ShiftPathEdges(): void;
    GetShiftedPoints(path: Path): Array<Point>;
    static Rectilinearise(a: Point, b: Point): Point;
    GetShiftedPointsSimple(path: Path): Array<Point>;
    ShiftedEdgePositionOfTarget(e: PathEdge): Point;
    ShiftedPoint(point: Point, segment: LongestNudgedSegment): Point;
    static LineSegOfLongestSeg(ls: LongestNudgedSegment, dir: Direction): ICurve;
    static UpdateMinMaxWithPoint(mm: {
        min: number;
        max: number;
    }, projectionToDir: PointProjection, point: Point): void;
    CreateConstraintsBetweenLongestSegments(): void;
    CreateConstraintsBetweenLongestSegmentsForSegment(segment: LongestNudgedSegment): void;
    CreateConstraintsOfTheOrder(): void;
    static ParallelToDirection(edge: VisibilityEdge, direction: Direction): boolean;
    CreateConstraintsOfThePathOrder(pathOrder: Array<PathEdge>): void;
    ConstraintTwoLongestSegs(prevSeg: LongestNudgedSegment, seg: LongestNudgedSegment): void;
    Solver: UniformOneDimensionalSolver;
    CreateVariablesOfLongestSegment(segment: LongestNudgedSegment): void;
    static SegmentPosition(segment: SegmentBase, direction: Direction): number;
    LongestNudgedSegs: Array<LongestNudgedSegment>;
    PathOrders: Map<AxisEdge, Array<PathEdge>>;
    PathToObstacles: Map<Path, [Polyline, Polyline]>;
    FindFreeSpaceInDirection(axisEdges: Array<AxisEdge>): void;
    BoundAxisEdgesByRectsKnownInAdvance(): void;
    BoundPathByMinCommonAncestors(path: Path): void;
    GetMinCommonAncestors(edge: GeomEdge): Iterable<Shape>;
    PortToShapes: Map<Port, Shape>;
    AncestorsForPort(port: Port): Set<Shape>;
    BoundAxisEdgeAdjacentToObstaclePort(port: Port, axisEdge: AxisEdge): void;
    BoundAxisByPoint(point: Point, axisEdge: AxisEdge): void;
    BoundAxisEdgesAdjacentToSourceAndTargetOnEdge(path: Path): void;
    BoundAxisEdgeByRect(rectangle: Rectangle, axisEdge: AxisEdge): void;
    CreateLongestNudgedSegments(): void;
    CreateLongestNudgedSegmentsForPath(path: Path, projectionToPerp: PointProjection): void;
    static CalculateIdealPositionsForLongestSegs(path: Path, projectionToPerp: PointProjection): void;
    static SetIdealPositionForSeg(segment: LongestNudgedSegment, segPosition: number, offset0: number, offset1: number): void;
    GoOverPathAndCreateLongSegs(path: Path): void;
    static BuildPolylineForPath(path: Path): Iterable<Point>;
    static ExtendPolylineToPorts(t: {
        points: Point[];
    }, path: Path): void;
    static ExtendPolylineToTargetPort(t: {
        points: Point[];
    }, location: Point): void;
    static ProjectionsAreClose(a: Point, dir: Direction, b: Point): boolean;
    static ExtendPolylineToSourcePort(t: {
        points: Point[];
    }, location: Point): void;
    static RemoveSwitchbacksAndMiddlePoints(points: Array<Point>): Array<Point>;
    static NudgePaths(paths: Array<Path>, cornerFitRadius: number, paddedObstacles: Array<Polyline>, ancestorsSets: Map<Shape, Set<Shape>>, removeStaircases: boolean): void;
    RemoveStaircases(): void;
    static MapPortsToShapes(listOfShapes: Iterable<Shape>): Map<Port, Shape>;
    static GetEdgePathFromPathEdgesAsDebugCurves(startWidth: number, endWidth: number, color: string, path: Path): IterableIterator<DebugCurve>;
}
export {};
