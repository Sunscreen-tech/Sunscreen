import { Point } from '../../..';
import { Polyline, PointLocation } from '../../../math/geometry';
import { PolylinePoint } from '../../../math/geometry/polylinePoint';
import { BundlingSettings } from '../../BundlingSettings';
import { CdtTriangle } from '../../ConstrainedDelaunayTriangulation/CdtTriangle';
import { MetroGraphData } from './MetroGraphData';
import { Station } from './Station';
export declare class CdtIntersections {
    EdgeIsLegal_(start: Point, end: Point, currentTriangle: CdtTriangle, obstaclesToIgnore: Set<Polyline>): boolean;
    metroGraphData: MetroGraphData;
    bundlingSettings: BundlingSettings;
    ComputeForcesForBundles: boolean;
    constructor(metroGraphData: MetroGraphData, bundlingSettings: BundlingSettings);
    /**   returns false iff an edge overlap an obstacle,
   otherwise it calulates distances to the closest obstacles */
    BundleAvoidsObstacles(v: Station, u: Station, vPosition: Point, uPosition: Point, upperBound: number, t: {
        closestDist: Array<[Point, Point]>;
    }): boolean;
    FindCloseObstaclesForBundle(startTriangle: CdtTriangle, start: Point, end: Point, obstaclesToIgnore: Set<Polyline>, upperBound: number): Map<Polyline, [Point, Point]>;
    /**   returns false iff the edge overlap an obstacle*/
    ThreadLineSegmentThroughTriangles(currentTriangle: CdtTriangle, start: Point, end: Point, obstaclesToIgnore: Set<Polyline>, triangles: Array<CdtTriangle>): boolean;
    static PointLocationInsideTriangle(p: Point, triangle: CdtTriangle): PointLocation;
    static FindPolylinePoint(poly: Polyline, point: Point): PolylinePoint;
    EdgeIsLegal(v: Station, u: Station, vPosition: Point, uPosition: Point): boolean;
    EdgeIsLegalSSPPS(v: Station, u: Station, obstaclesToIgnore: Set<Polyline>): boolean;
}
