import { Point, ICurve, GeomEdge } from '../../..';
import { BezierSeg } from '../../../math/geometry/bezierSeg';
import { DebugCurve } from '../../../math/geometry/debugCurve';
import { PolylinePoint } from '../../../math/geometry/polylinePoint';
import { Algorithm } from '../../../utils/algorithm';
import { BundlingSettings } from '../../BundlingSettings';
import { BundleBase } from './BundleBase';
import { GeneralMetroMapOrdering } from './GeneralMetroMapOrdering';
import { MetroGraphData } from './MetroGraphData';
import { Metroline } from './MetroLine';
import { OrientedHubSegment } from './OrientedHubSegment';
import { Station } from './Station';
/** this class nudges the edges, sorts the edges that run in parallel in a way that minimezes the number of crossings*/
export declare class EdgeNudger extends Algorithm {
    bundlingSettings: BundlingSettings;
    metroGraphData: MetroGraphData;
    metroOrdering: GeneralMetroMapOrdering;
    constructor(metroGraphData: MetroGraphData, bundlingSettings: BundlingSettings);
    run(): void;
    InitRadii(): void;
    CreateMetroOrdering(): void;
    FinalizePaths(): void;
    CreateBundleBases(): void;
    CreateCurves(): void;
    CreateCurveLine(line: Metroline, edge: GeomEdge): void;
    static FindCurveStart(metroGraphData: MetroGraphData, metroOrdering: GeneralMetroMapOrdering, metroline: Metroline): Point;
    static FindCurveEnd(metroGraphData: MetroGraphData, metroOrdering: GeneralMetroMapOrdering, metroline: Metroline): Point;
    static HubSegsOfLine(metroGraphData: MetroGraphData, metroOrdering: GeneralMetroMapOrdering, line: Metroline): IterableIterator<ICurve>;
    static SegOnLineVertex(metroGraphData: MetroGraphData, metroOrdering: GeneralMetroMapOrdering, line: Metroline, i: PolylinePoint): ICurve;
    CreateSegmentsInsideHubs(): void;
    CreateOrientedSegsOnLine(line: Metroline): void;
    CreateICurveForOrientedSeg(line: Metroline, polyPoint: PolylinePoint): void;
    static ShowHubs(metroGraphData: MetroGraphData, metroMapOrdering: GeneralMetroMapOrdering, station: Station, fileName: string, moreCurves?: DebugCurve[]): void;
    static GetAllDebugCurves(metroMapOrdering: GeneralMetroMapOrdering, metroGraphData: MetroGraphData): Array<DebugCurve>;
    static DebugEdges(metroGraphData1: MetroGraphData): Array<DebugCurve>;
    static VertexDebugCurves(metroMapOrdering: GeneralMetroMapOrdering, metroGraphData: MetroGraphData): Array<DebugCurve>;
    static BetweenHubs(metroMapOrdering: GeneralMetroMapOrdering, metroGraphData: MetroGraphData): Array<DebugCurve>;
    static GetInterestingSegs(metroGraphData: MetroGraphData, metroMapOrdering: GeneralMetroMapOrdering, line: Metroline): Array<[Point, Point]>;
    static GetMonotoneColor(start: Point, end: Point, segs: Array<[Point, Point]>): string;
    static DebugHubBases(metroGraphData: MetroGraphData): Array<DebugCurve>;
    static DebugCircles(metroGraphData: MetroGraphData): Array<DebugCurve>;
    static DebugSegs(metroGraphData: MetroGraphData): Array<DebugCurve>;
    static GraphNodes(metroGraphData: MetroGraphData): Array<DebugCurve>;
    static BiArc(p0: Point, ts: Point, p4: Point, te: Point): ICurve;
    static ArcOn(a: Point, b: Point, c: Point): ICurve;
    static FindArcCenter(a: Point, b: Point, c: Point, t: {
        center: Point;
    }): boolean;
    static StandardBezier(segStart: Point, tangentAtStart: Point, segEnd: Point, tangentAtEnd: Point): BezierSeg;
    FanBezierSegs(): void;
    FanEdgesOfHubSegment(bundleHub: BundleBase): boolean;
    FanCouple(bundleHub: BundleBase, i: number, center: Point, radius: number): boolean;
    AdjustLongerSeg(longerSeg: OrientedHubSegment, shorterSeg: OrientedHubSegment, center: Point, radius: number): boolean;
    static SqueezeBound: number;
    FitLonger(longerOrientedSeg: OrientedHubSegment, del0: Point, del1: Point, midPointOfShorter: Point, minDelLength: number, maxDel: number, center: Point, radius: number): boolean;
    PullControlPointToTheCircle(start: Point, t: {
        highP: Point;
    }, center: Point, radius: number): void;
    NicelyAligned(longerSeg: BezierSeg, del0: Point, del1: Point, midPointOfShorter: Point, minDelLength: number, maxDelLen: number): number;
    BaseLength(seg: OrientedHubSegment): number;
}
