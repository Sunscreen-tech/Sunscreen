import { Point } from '../../..';
import { PointSet } from '../../../utils/PointSet';
import { BundlingSettings } from '../../BundlingSettings';
import { CostCalculator } from './CostCalculator';
import { IntersectionCache } from './IntersectionCache';
import { MetroGraphData } from './MetroGraphData';
import { Station } from './Station';
export declare class SimulatedAnnealing {
    metroGraphData: MetroGraphData;
    bundlingSettings: BundlingSettings;
    costCalculator: CostCalculator;
    cache: IntersectionCache;
    static FixRouting(metroGraphData: MetroGraphData, bundlingSettings: BundlingSettings): boolean;
    static FixRoutingMBP(metroGraphData: MetroGraphData, bundlingSettings: BundlingSettings, changedPoints: PointSet): boolean;
    constructor(metroGraphData: MetroGraphData, bundlingSettings: BundlingSettings);
    static MaxIterations: number;
    static MaxStep: number;
    static MinStep: number;
    static MinRelativeChange: number;
    stationsForOptimizations: Set<Station>;
    FixRoutingP(changedPoints: PointSet): boolean;
    static stationsArePositionedCorrectly(metroGraphData: MetroGraphData): boolean;
    static edgeIsPositionedCorrectly(e: [Station, Station], metroGraphData: MetroGraphData): boolean;
    GetStationsForOptimizations(changedPoints: PointSet): Set<Station>;
    Converged(step: number, oldx: Array<Point>, newx: Array<Point>): boolean;
    stepsWithProgress: number;
    UpdateMaxStep(step: number, oldEnergy: number, newEnergy: number): number;
    TryMoveStations(): boolean;
    /**
      Move node to decrease the cost of the drawing
     Returns true iff position has changed
  */
    TryMoveStation(s: Station): boolean;
    /** checking the node position and neigborhood bundles */
    moveIsLegalForAdjacentBundles(s: Station, sNewPosition: Point): boolean;
    BuildDirection(node: Station): Point;
    BuildStepLength(node: Station, direction: Point): number;
    CostGain(node: Station, newPosition: Point): number;
    BuildForceForInk(node: Station): Point;
    BuildForceForPathLengths(node: Station): Point;
    BuildForceForRadius(node: Station): Point;
    /** calculates the direction to push a bundle away from obstacle*/
    BuildForceForBundle(station: Station): Point;
}
