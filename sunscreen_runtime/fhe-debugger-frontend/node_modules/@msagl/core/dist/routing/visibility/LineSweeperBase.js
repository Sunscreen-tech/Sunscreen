//
import { Point } from '../../math/geometry/point';
import { GeomConstants } from '../../math/geometry/geomConstants';
import { BinaryHeapWithComparer } from '../../structs/BinaryHeapWithComparer';
import { RBTree } from '../../math/RBTree/rbTree';
import { LowestVertexEvent } from '../spline/coneSpanner/LowestVertexEvent';
import { ObstacleSideComparer } from './ObstacleSideComparer';
import { PortObstacleEvent } from './PortObstacleEvent';
export class LineSweeperBase {
    constructor(obstacles, sweepDirection) {
        this.PreviousZ = Number.NEGATIVE_INFINITY;
        this.z = Number.NEGATIVE_INFINITY;
        this.Obstacles = obstacles !== null && obstacles !== void 0 ? obstacles : [];
        this.SweepDirection = sweepDirection;
        this.DirectionPerp = sweepDirection.rotate(-Math.PI / 2);
        this.EventQueue = new BinaryHeapWithComparer((a, b) => this.Compare(a, b));
        this.ObstacleSideComparer = new ObstacleSideComparer(this);
        this.LeftObstacleSideTree = new RBTree((a, b) => this.ObstacleSideComparer.Compare(a, b));
        this.RightObstacleSideTree = new RBTree((a, b) => this.ObstacleSideComparer.Compare(a, b));
    }
    get EventQueue() {
        return this.eventQueue;
    }
    set EventQueue(value) {
        this.eventQueue = value;
    }
    // sweep direction rotated by 90 degrees clockwise
    get DirectionPerp() {
        return this.directionPerp;
    }
    set DirectionPerp(value) {
        this.directionPerp = value;
    }
    get Z() {
        return this.z;
    }
    set Z(value) {
        if (value > this.z + GeomConstants.tolerance) {
            this.PreviousZ = this.z;
        }
        this.z = value;
    }
    GetZS(eve) {
        return this.SweepDirection.dot(eve.Site);
    }
    GetZP(point) {
        return this.SweepDirection.dot(point);
    }
    SegmentIsNotHorizontal(a, b) {
        return Math.abs(a.sub(b).dot(this.SweepDirection)) > GeomConstants.distanceEpsilon;
    }
    RemoveLeftSide(side) {
        this.ObstacleSideComparer.SetOperand(side);
        this.LeftObstacleSideTree.remove(side);
    }
    RemoveRightSide(side) {
        this.ObstacleSideComparer.SetOperand(side);
        this.RightObstacleSideTree.remove(side);
    }
    InsertLeftSide(side) {
        this.ObstacleSideComparer.SetOperand(side);
        this.LeftObstacleSideTree.insert(side);
    }
    InsertRightSide(side) {
        this.ObstacleSideComparer.SetOperand(side);
        this.RightObstacleSideTree.insert(side);
    }
    FindFirstObstacleSideToTheLeftOfPoint(point) {
        const node = this.RightObstacleSideTree.findLast((s) => Point.pointToTheRightOfLineOrOnLine(point, s.Start, s.End));
        return node == null ? null : node.item;
    }
    FindFirstObstacleSideToToTheRightOfPoint(point) {
        const node = this.LeftObstacleSideTree.findFirst((s) => !Point.pointToTheRightOfLineOrOnLine(point, s.Start, s.End));
        return node == null ? null : node.item;
    }
    EnqueueEvent(eve) {
        /*Assert.assert(this.GetZP(eve.Site) >= this.PreviousZ)*/
        this.eventQueue.Enqueue(eve);
    }
    InitQueueOfEvents() {
        for (const obstacle of this.Obstacles) {
            this.EnqueueLowestPointsOnObstacles(obstacle);
        }
        if (this.Ports != null) {
            for (const point of this.Ports.values()) {
                this.EnqueueEvent(new PortObstacleEvent(point));
            }
        }
    }
    EnqueueLowestPointsOnObstacles(poly) {
        const candidate = this.GetLowestPoint(poly);
        this.EnqueueEvent(new LowestVertexEvent(candidate));
    }
    GetLowestPoint(poly) {
        let candidate = poly.startPoint;
        let pp = poly.startPoint.next;
        for (; pp != null; pp = pp.next) {
            if (this.Less(pp.point, candidate.point)) {
                candidate = pp;
            }
        }
        return candidate;
    }
    // imagine that direction points up,
    // lower events have higher priorities,
    // for events at the same level events to the left have higher priority
    Compare(a, b) {
        const aSite = a.Site;
        const bSite = b.Site;
        return this.ComparePoints(/* ref */ aSite, /* ref */ bSite);
    }
    Less(a, b) {
        return this.ComparePoints(/* ref */ a, /* ref */ b) < 0;
    }
    ComparePoints(aSite, bSite) {
        let aProjection = this.SweepDirection.dot(aSite);
        let bProjection = this.SweepDirection.dot(bSite);
        if (aProjection < bProjection) {
            return -1;
        }
        if (aProjection > bProjection) {
            return 1;
        }
        aProjection = this.directionPerp.dot(aSite);
        bProjection = this.directionPerp.dot(bSite);
        return aProjection < bProjection ? -1 : aProjection > bProjection ? 1 : 0;
    }
}
//# sourceMappingURL=LineSweeperBase.js.map