import { IntPair } from './IntPair';
export class IntPairMap {
    /** n is the maximum of (x + 1) where (x, *) runs over the keys  */
    constructor(n) {
        this.arrayOfMaps = new Array(n);
        for (let i = 0; i < n; i++)
            this.arrayOfMaps[i] = new Map();
    }
    isEmpty() {
        if (this.arrayOfMaps.length === 0)
            return true;
        for (const t of this.arrayOfMaps) {
            if (t.size > 0) {
                return false;
            }
        }
        return true;
    }
    set(x, y, v) {
        this.arrayOfMaps[x].set(y, v);
    }
    setPair(p, v) {
        this.set(p.x, p.y, v);
    }
    delete(x, y) {
        if (x < 0 || x >= this.arrayOfMaps.length) {
            return;
        }
        this.arrayOfMaps[x].delete(y);
    }
    has(x, y) {
        if (x < 0 || x >= this.arrayOfMaps.length) {
            return false;
        }
        return this.arrayOfMaps[x].has(y);
    }
    get(x, y) {
        if (x < 0 || x >= this.arrayOfMaps.length) {
            return null;
        }
        return this.arrayOfMaps[x].get(y);
    }
    getI(p) {
        return this.get(p.x, p.y);
    }
    *keys() {
        for (let i = 0; i < this.arrayOfMaps.length; i++) {
            const map = this.arrayOfMaps[i];
            for (const p of map) {
                yield new IntPair(i, p[0]);
            }
        }
    }
    *keyValues() {
        for (let i = 0; i < this.arrayOfMaps.length; i++) {
            const map = this.arrayOfMaps[i];
            for (const p of map) {
                yield [new IntPair(i, p[0]), p[1]];
            }
        }
    }
    *values() {
        for (let i = 0; i < this.arrayOfMaps.length; i++) {
            const map = this.arrayOfMaps[i];
            for (const p of map) {
                yield p[1];
            }
        }
    }
}
//# sourceMappingURL=IntPairMap.js.map