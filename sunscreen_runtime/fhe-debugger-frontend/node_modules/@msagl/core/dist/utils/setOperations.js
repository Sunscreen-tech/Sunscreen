import { PointPair } from '../math/geometry/pointPair';
import { PointSet } from './PointSet';
export function substractSets(a, b) {
    const ret = new Set();
    for (const u of a) {
        if (!b.has(u))
            ret.add(u);
    }
    return ret;
}
export function substractPointSets(a, b) {
    const ret = new PointSet();
    for (const u of a) {
        if (!b.has(u))
            ret.add(u);
    }
    return ret;
}
export function uniteSets(a, b) {
    const ret = new Set(a);
    for (const v of b) {
        ret.add(v);
    }
    return ret;
}
export function addRange(array, addedIterable) {
    for (const t of addedIterable)
        array.push(t);
}
export function setIntersection(a, b) {
    const ret = new Set();
    if (a.size < b.size) {
        for (const t of a) {
            if (b.has(t))
                ret.add(t);
        }
    }
    else {
        for (const t of b) {
            if (a.has(t))
                ret.add(t);
        }
    }
    return ret;
}
export function setIntersectionOfArray(arr) {
    if (arr.length === 0)
        return new Set();
    let ret = arr[0];
    for (let i = 1; i < arr.length; i++) {
        ret = setIntersection(ret, arr[i]);
    }
    return ret;
}
export function insertRange(collection, addedArray) {
    for (const t of addedArray)
        collection.add(t);
}
export function setsAreEqual(a, b) {
    if (a.size !== b.size)
        return false;
    for (const u of a)
        if (!b.has(u))
            return false;
    return true;
}
/** return the concatenated array of items */
export function flattenArray(arr, callback) {
    const ret = [];
    for (const f of arr) {
        for (const u of callback(f))
            ret.push(u);
    }
    return ret;
}
/** adds val to map.get(key) if the key exists, otherwise creates the key pair and
 * executes the former instruction
 */
export function addToMapOfSets(map, key, val) {
    let s = map.get(key);
    if (!s) {
        s = new Set();
        map.set(key, s);
    }
    s.add(val);
}
export function addToMapOfArrays(map, key, val) {
    let s = map.get(key);
    if (!s) {
        s = new Array();
        map.set(key, s);
    }
    s.push(val);
}
export function addToPointPairMap(map, key, val) {
    let s = map.get(key);
    if (!s) {
        s = new Set();
        map.set(key, s);
    }
    s.add(val);
}
export function addToPointMapTuple(map, key, val) {
    addToPointPairMap(map, new PointPair(key[0], key[1]), val);
}
export function removeFromPointPairMap(map, key, val) {
    const s = map.get(key);
    if (s)
        s.delete(val);
}
export function removeFromPointPairMapTuple(map, key, val) {
    removeFromPointPairMap(map, new PointPair(key[0], key[1]), val);
}
export function removeFromArray(arr, OverlapRemovalNode) {
    const i = arr.findIndex((a) => a === OverlapRemovalNode);
    if (i >= 0) {
        arr.splice(i, 1);
    }
}
//# sourceMappingURL=setOperations.js.map