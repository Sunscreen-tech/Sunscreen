(()=>{var Af=Object.create;var Tc=Object.defineProperty;var If=Object.getOwnPropertyDescriptor;var xf=Object.getOwnPropertyNames;var wf=Object.getPrototypeOf,Tf=Object.prototype.hasOwnProperty;var Ri=(l,t)=>()=>(t||l((t={exports:{}}).exports,t),t.exports);var Of=(l,t,e,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of xf(t))!Tf.call(l,n)&&n!==e&&Tc(l,n,{get:()=>t[n],enumerable:!(i=If(t,n))||i.enumerable});return l};var he=(l,t,e)=>(e=l!=null?Af(wf(l)):{},Of(t||!l||!l.__esModule?Tc(e,"default",{value:l,enumerable:!0}):e,l));var Nu=Ri(Da=>{"use strict";Object.defineProperty(Da,"__esModule",{value:!0});var Ru=class{constructor(...t){this._head=this._tail=null,this._length=0,t.length>0&&t.forEach(e=>{this.append(e)})}*iterator(){let t=this._head;for(;t;)yield t.value,t=t.next}[Symbol.iterator](){return this.iterator()}get head(){return this._head?this._head.value:null}get tail(){return this._tail?this._tail.value:null}get length(){return this._length}insert(t,e,i=!1){if(i&&this.isDuplicate(t))return!1;let n=new Mo(t),o=this._head;if(o)for(;;){if(o.value===e)return n.next=o.next,n.prev=o,o.next=n,n.next?n.next.prev=n:this._tail=n,this._length++,!0;if(o.next)o=o.next;else return!1}else return!1}append(t,e=!1){if(e&&this.isDuplicate(t))return!1;let i=new Mo(t);return this._tail?(this._tail.next=i,i.prev=this._tail,this._tail=i):this._head=this._tail=i,this._length++,!0}prepend(t,e=!1){if(e&&this.isDuplicate(t))return!1;let i=new Mo(t);return this._head?(i.next=this._head,this._head.prev=i,this._head=i):this._head=this._tail=i,this._length++,!0}remove(t){let e=this._head;if(!!e){if(e.value===t)return this._head=e.next,this._head.prev=null,e.next=e.prev=null,this._length--,e.value;for(;;){if(e.value===t)return e.next?(e.prev.next=e.next,e.next.prev=e.prev,e.next=e.prev=null):(e.prev.next=null,this._tail=e.prev,e.next=e.prev=null),this._length--,e.value;if(e.next)e=e.next;else return}}}removeHead(){let t=this._head;if(!!t)return this._head.next?(this._head.next.prev=null,this._head=this._head.next,t.next=t.prev=null):(this._head=null,this._tail=null),this._length--,t.value}removeTail(){let t=this._tail;if(!!t)return this._tail.prev?(this._tail.prev.next=null,this._tail=this._tail.prev,t.next=t.prev=null):(this._head=null,this._tail=null),this._length--,t.value}first(t){let e=this.iterator(),i=[],n=Math.min(t,this.length);for(let o=0;o<n;o++){let s=e.next();i.push(s.value)}return i}toArray(){return[...this]}isDuplicate(t){return new Set(this.toArray()).has(t)}};Da.LinkedList=Ru;var Mo=class{constructor(t){this.value=t,this.next=null,this.prev=null}};Da.LinkedListItem=Mo});var Gr=Ri(Fu=>{"use strict";Object.defineProperty(Fu,"__esModule",{value:!0});var kf=Nu(),Du=class extends kf.LinkedList{constructor(...t){super(...t)}get top(){return this.head}get size(){return this.length}push(t){this.prepend(t)}pop(){return this.removeHead()}};Fu.Stack=Du});var Qr=Ri(Hu=>{"use strict";Object.defineProperty(Hu,"__esModule",{value:!0});var zf=Nu(),Wu=class extends zf.LinkedList{constructor(...t){super(...t)}get front(){return this.head}enqueue(t){this.append(t)}dequeue(){return this.removeHead()}};Hu.Queue=Wu});var gt=Ri(cn=>{"use strict";var Ua=cn&&cn.__spreadArrays||function(){for(var l=0,t=0,e=arguments.length;t<e;t++)l+=arguments[t].length;for(var i=Array(l),n=0,t=0;t<e;t++)for(var o=arguments[t],s=0,a=o.length;s<a;s++,n++)i[n]=o[s];return i};Object.defineProperty(cn,"__esModule",{value:!0});cn.StringBuilder=cn.String=void 0;var zo=function(){function l(){}return l.IsNullOrWhiteSpace=function(t){try{return t==null||t=="undefined"?!0:t.toString().replace(/\s/g,"").length<1}catch(e){return console.log(e),!1}},l.Join=function(t){for(var e=[],i=1;i<arguments.length;i++)e[i-1]=arguments[i];try{var n=e[0];if(Array.isArray(n)||n instanceof Array){for(var o=l.Empty,s=0,a=0;a<n.length;a++){var u=n[a];a<n.length-1?o+=u+t:o+=u}return o}else if(typeof n=="object"){var h=l.Empty,c=n,f=Object.keys(n);return f.forEach(function(v){h+=c[v]+t}),h=h.slice(0,h.length-t.length),h}var P=e;return l.join.apply(l,Ua([t],P))}catch(v){return console.log(v),l.Empty}},l.Format=function(t){for(var e=[],i=1;i<arguments.length;i++)e[i-1]=arguments[i];try{return t.match(l.regexNumber)?l.format(l.regexNumber,t,e):t.match(l.regexObject)?l.format(l.regexObject,t,e,!0):t}catch(n){return console.log(n),l.Empty}},l.format=function(t,e,i,n){return n===void 0&&(n=!1),e.replace(t,function(o,s){var a=o.split(":");a.length>1&&(s=a[0].replace("{",""),o=a[1].replace("}",""));var u;return n?u=i[0][s]:u=i[s],u==null||u==null||o.match(/{\d+}/)?u:(u=l.parsePattern(o,u),typeof u<"u"&&u!=null?u:l.Empty)})},l.parsePattern=function(t,e){switch(t){case"L":return e=e.toLocaleLowerCase(),e;case"U":return e=e.toLocaleUpperCase(),e;case"d":{if(typeof e=="string")return l.getDisplayDateFromString(e);if(e instanceof Date)return l.Format("{0:00}.{1:00}.{2:0000}",e.getDate(),e.getMonth(),e.getFullYear());break}case"s":{if(typeof e=="string")return l.getSortableDateFromString(e);if(e instanceof Date)return l.Format("{0:0000}-{1:00}-{2:00}",e.getFullYear(),e.getMonth(),e.getDate());break}case"n":{typeof e!="string"&&(e=e.toString());var i=e.replace(/,/g,".");if(isNaN(parseFloat(i))||i.length<=3)break;var n=i.split(/[^0-9]+/g),o=n;n.length>1&&(o=[l.join.apply(l,Ua([""],n.splice(0,n.length-1))),n[n.length-1]]);var s=o[0],a=s.length%3,u=a>0?s.substring(0,a):l.Empty,h=u,c=s.substring(a).match(/.{3}/g);return u=u+"."+l.Join(".",c),e=u+(o.length>1?","+o[1]:""),e}case"x":return this.decimalToHexString(e);case"X":return this.decimalToHexString(e,!0);default:break}return(typeof e=="number"||!isNaN(e))&&!isNaN(+t)&&!l.IsNullOrWhiteSpace(e)?l.formatNumber(e,t):e},l.decimalToHexString=function(t,e){e===void 0&&(e=!1);var i=parseFloat(t),n=i.toString(16);return e?n.toLocaleUpperCase():n},l.getDisplayDateFromString=function(t){var e;if(e=t.split("-"),e.length<=1)return t;var i=e[e.length-1],n=e[e.length-2],o=e[e.length-3];return i=i.split("T")[0],i=i.split(" ")[0],i+"."+n+"."+o},l.getSortableDateFromString=function(t){var e=t.replace(",","").split(".");if(e.length<=1)return t;var i=e[e.length-1].split(" "),n=l.Empty;i.length>1&&(n=i[i.length-1]);var o=e[e.length-1].split(" ")[0],s=e[e.length-2],a=e[e.length-3],u=o+"-"+s+"-"+a;return!l.IsNullOrWhiteSpace(n)&&n.length>1?u+="T"+n:u+="T00:00:00",u},l.formatNumber=function(t,e){var i=e.length,n=t.toString();if(i<=n.length)return n;var o=i-n.length;return o+=1,new Array(o).join("0")+n},l.join=function(t){for(var e=[],i=1;i<arguments.length;i++)e[i-1]=arguments[i];for(var n=l.Empty,o=0;o<e.length;o++)if(!(typeof e[o]=="string"&&l.IsNullOrWhiteSpace(e[o])||typeof e[o]!="number"&&typeof e[o]!="string")){var s=""+e[o];n+=s;for(var a=o+1;a<e.length;a++)if(!l.IsNullOrWhiteSpace(e[a])){n+=t,o=a-1;break}}return n},l.regexNumber=/{(\d+(:\w*)?)}/g,l.regexObject=/{(\w+(:\w*)?)}/g,l.Empty="",l}();cn.String=zo;var Qf=function(){function l(t){this.Values=[],zo.IsNullOrWhiteSpace(t)||(this.Values=new Array(t))}return l.prototype.ToString=function(){return this.Values.join("")},l.prototype.Append=function(t){this.Values.push(t)},l.prototype.AppendLine=function(t){this.Values.push(`\r
`+t)},l.prototype.AppendFormat=function(t){for(var e=[],i=1;i<arguments.length;i++)e[i-1]=arguments[i];this.Values.push(zo.Format.apply(zo,Ua([t],e)))},l.prototype.AppendLineFormat=function(t){for(var e=[],i=1;i<arguments.length;i++)e[i-1]=arguments[i];this.Values.push(`\r
`+zo.Format.apply(zo,Ua([t],e)))},l.prototype.Clear=function(){this.Values=[]},l}();cn.StringBuilder=Qf});var og=Ri((HW,ng)=>{"use strict";function fb(l,t){function e(){this.constructor=l}e.prototype=t.prototype,l.prototype=new e}function xo(l,t,e,i){this.message=l,this.expected=t,this.found=e,this.location=i,this.name="SyntaxError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,xo)}fb(xo,Error);xo.buildMessage=function(l,t){var e={literal:function(h){return'"'+n(h.text)+'"'},class:function(h){var c="",f;for(f=0;f<h.parts.length;f++)c+=h.parts[f]instanceof Array?o(h.parts[f][0])+"-"+o(h.parts[f][1]):o(h.parts[f]);return"["+(h.inverted?"^":"")+c+"]"},any:function(h){return"any character"},end:function(h){return"end of input"},other:function(h){return h.description}};function i(h){return h.charCodeAt(0).toString(16).toUpperCase()}function n(h){return h.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,function(c){return"\\x0"+i(c)}).replace(/[\x10-\x1F\x7F-\x9F]/g,function(c){return"\\x"+i(c)})}function o(h){return h.replace(/\\/g,"\\\\").replace(/\]/g,"\\]").replace(/\^/g,"\\^").replace(/-/g,"\\-").replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,function(c){return"\\x0"+i(c)}).replace(/[\x10-\x1F\x7F-\x9F]/g,function(c){return"\\x"+i(c)})}function s(h){return e[h.type](h)}function a(h){var c=new Array(h.length),f,P;for(f=0;f<h.length;f++)c[f]=s(h[f]);if(c.sort(),c.length>0){for(f=1,P=1;f<c.length;f++)c[f-1]!==c[f]&&(c[P]=c[f],P++);c.length=P}switch(c.length){case 1:return c[0];case 2:return c[0]+" or "+c[1];default:return c.slice(0,-1).join(", ")+", or "+c[c.length-1]}}function u(h){return h?'"'+n(h)+'"':"end of input"}return"Expected "+a(l)+" but "+u(t)+" found."};function pb(l,t){t=t!==void 0?t:{};var e={},i={start:dc},n=dc,o="strict",s=se("strict",!0),a="graph",u=se("graph",!0),h="digraph",c=se("digraph",!0),f="{",P=se("{",!1),v="}",A=se("}",!1),O=function(m,y,x,I){I===null&&(I=[]);var G={type:y.toLowerCase(),children:I};return m&&(G.strict=!0),x&&(G.id=x),G},M=";",z=se(";",!1),$=function(m,y){return y},N=function(m,y){return[m].concat(y)},q="=",Te=se("=",!1),ve=function(m,y){return{type:"attr_stmt",target:"graph",attr_list:[{type:"attr",id:m,eq:y}]}},Wt="node",Bo=se("node",!0),Es="edge",R=se("edge",!0),T=function(m,y){return{type:"attr_stmt",target:m,attr_list:y}},W="[",U=se("[",!1),Y="]",X=se("]",!1),K=function(m,y){return(m||[]).concat(y||[])},ge=function(m,y){return y},Pe=",",Gt=se(",",!1),pr=function(m,y,x){return[{type:"attr",id:m,eq:y}].concat(x||[])},oi=function(m,y,x){var I=[m];return I=I.concat(y.map(function(G){return G.id})),{type:"edge_stmt",edge_list:I,attr_list:x||[]}},qh="->",vg=se("->",!1),Uh="--",Ag=se("--",!1),Ig=function(m,y,x){return[{type:"edgeRHS",edgeop:m,id:y}].concat(x||[])},xg=function(m,y){return{type:"node_stmt",node_id:m,attr_list:y||[]}},wg=function(m,y){return y?{type:"node_id",id:m,port:y}:{type:"node_id",id:m}},Tg=li("port"),pu=":",bu=se(":",!1),Og=function(m,y){return y},Bg=function(m,y){return{type:"port",id:m,compass_pt:y||null}},Lg=function(m){return{type:"port",compass_pt:m||null}},Gg="subgraph",Rg=se("subgraph",!0),Ng=function(m){return m?{type:"subgraph",id:m}:{type:"subgraph"}},Dg=function(m,y){return m=m||{type:"subgraph"},m.children=y||[],m},Fg="n",Vg=se("n",!1),jh="ne",kg=se("ne",!1),Mg="e",Wg=se("e",!1),Qh="se",Hg=se("se",!1),zg="s",qg=se("s",!1),Xh="sw",Ug=se("sw",!1),jg="w",Qg=se("w",!1),Jh="nw",Xg=se("nw",!1),Jg=li("UNICODE_STRING"),$g=function(m,y){return m+y.join("")},Kg=function(m,y){return m+y},Yg="$",Zg=se("$",!1),_g="_",em=se("_",!1),tm=li("NUMBER"),rm="-",im=se("-",!1),$h=".",Kh=se(".",!1),Lo=/^[0-9]/,Go=br([["0","9"]],!1,!1),nm=function(m){return parseFloat(uc())},om=function(m){return{type:"id",value:m.slice(1,m.length-1),html:!0}},Pu="<",yu=se("<",!1),Su=">",Cu=se(">",!1),sm=function(m){return"<"+m.join("")+">"},si=Ym(),Ro=function(m){return m},am=function(m){return m.join("")},Eu='"',vu=se('"',!1),Yh=function(m){return m.join("")},lm=function(){return uc()},Aa="\\",Ia=se("\\",!1),um=function(m){return m[1]==='"'?'"':m[0]+m[1]},Zh=function(){return""},hm=/^[\n\r\u2028\u2029]/,cm=br([`
`,"\r","\u2028","\u2029"],!1,!1),dm=li("end of line"),gm=`
`,mm=se(`
`,!1),_h=`\r
`,fm=se(`\r
`,!1),pm="\r",bm=se("\r",!1),Pm="\u2028",ym=se("\u2028",!1),Sm="\u2029",Cm=se("\u2029",!1),Em=/^[^"\\\0-\x1F\x7F]/,vm=br(['"',"\\",["\0",""],"\x7F"],!0,!1),ec='\\"',Am=se('\\"',!1),Im=function(){return'"'},xm=function(){return"\\"},wm=li("COMMENT"),Tm=li("BLOCK_COMMENT"),tc="/*",Om=se("/*",!1),No="*/",Au=se("*/",!1),rc=function(m){return m},Bm=function(m){return m.join("")},Lm=li("C_COMMENT"),ic="//",Gm=se("//",!1),Do=/^[\n]/,Fo=br([`
`],!1,!1),nc=function(m){return m.join("")},Rm=li("MACRO_COMMENT"),Nm="#",Dm=se("#",!1),Fm=li("WHITESPACE"),oc=/^[\n\r]/,sc=br([`
`,"\r"],!1,!1),ac=/^[ \t]/,lc=br([" ","	"],!1,!1),Vm=/^[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137-\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148-\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C-\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA-\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9-\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC-\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF-\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F-\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0-\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB-\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE-\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0561-\u0587\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6-\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FC7\u1FD0-\u1FD3\u1FD6-\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6-\u1FF7\u210A\u210E-\u210F\u2113\u212F\u2134\u2139\u213C-\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65-\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73-\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3-\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7FA\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]/,km=br([["a","z"],"\xB5",["\xDF","\xF6"],["\xF8","\xFF"],"\u0101","\u0103","\u0105","\u0107","\u0109","\u010B","\u010D","\u010F","\u0111","\u0113","\u0115","\u0117","\u0119","\u011B","\u011D","\u011F","\u0121","\u0123","\u0125","\u0127","\u0129","\u012B","\u012D","\u012F","\u0131","\u0133","\u0135",["\u0137","\u0138"],"\u013A","\u013C","\u013E","\u0140","\u0142","\u0144","\u0146",["\u0148","\u0149"],"\u014B","\u014D","\u014F","\u0151","\u0153","\u0155","\u0157","\u0159","\u015B","\u015D","\u015F","\u0161","\u0163","\u0165","\u0167","\u0169","\u016B","\u016D","\u016F","\u0171","\u0173","\u0175","\u0177","\u017A","\u017C",["\u017E","\u0180"],"\u0183","\u0185","\u0188",["\u018C","\u018D"],"\u0192","\u0195",["\u0199","\u019B"],"\u019E","\u01A1","\u01A3","\u01A5","\u01A8",["\u01AA","\u01AB"],"\u01AD","\u01B0","\u01B4","\u01B6",["\u01B9","\u01BA"],["\u01BD","\u01BF"],"\u01C6","\u01C9","\u01CC","\u01CE","\u01D0","\u01D2","\u01D4","\u01D6","\u01D8","\u01DA",["\u01DC","\u01DD"],"\u01DF","\u01E1","\u01E3","\u01E5","\u01E7","\u01E9","\u01EB","\u01ED",["\u01EF","\u01F0"],"\u01F3","\u01F5","\u01F9","\u01FB","\u01FD","\u01FF","\u0201","\u0203","\u0205","\u0207","\u0209","\u020B","\u020D","\u020F","\u0211","\u0213","\u0215","\u0217","\u0219","\u021B","\u021D","\u021F","\u0221","\u0223","\u0225","\u0227","\u0229","\u022B","\u022D","\u022F","\u0231",["\u0233","\u0239"],"\u023C",["\u023F","\u0240"],"\u0242","\u0247","\u0249","\u024B","\u024D",["\u024F","\u0293"],["\u0295","\u02AF"],"\u0371","\u0373","\u0377",["\u037B","\u037D"],"\u0390",["\u03AC","\u03CE"],["\u03D0","\u03D1"],["\u03D5","\u03D7"],"\u03D9","\u03DB","\u03DD","\u03DF","\u03E1","\u03E3","\u03E5","\u03E7","\u03E9","\u03EB","\u03ED",["\u03EF","\u03F3"],"\u03F5","\u03F8",["\u03FB","\u03FC"],["\u0430","\u045F"],"\u0461","\u0463","\u0465","\u0467","\u0469","\u046B","\u046D","\u046F","\u0471","\u0473","\u0475","\u0477","\u0479","\u047B","\u047D","\u047F","\u0481","\u048B","\u048D","\u048F","\u0491","\u0493","\u0495","\u0497","\u0499","\u049B","\u049D","\u049F","\u04A1","\u04A3","\u04A5","\u04A7","\u04A9","\u04AB","\u04AD","\u04AF","\u04B1","\u04B3","\u04B5","\u04B7","\u04B9","\u04BB","\u04BD","\u04BF","\u04C2","\u04C4","\u04C6","\u04C8","\u04CA","\u04CC",["\u04CE","\u04CF"],"\u04D1","\u04D3","\u04D5","\u04D7","\u04D9","\u04DB","\u04DD","\u04DF","\u04E1","\u04E3","\u04E5","\u04E7","\u04E9","\u04EB","\u04ED","\u04EF","\u04F1","\u04F3","\u04F5","\u04F7","\u04F9","\u04FB","\u04FD","\u04FF","\u0501","\u0503","\u0505","\u0507","\u0509","\u050B","\u050D","\u050F","\u0511","\u0513","\u0515","\u0517","\u0519","\u051B","\u051D","\u051F","\u0521","\u0523","\u0525","\u0527",["\u0561","\u0587"],["\u1D00","\u1D2B"],["\u1D6B","\u1D77"],["\u1D79","\u1D9A"],"\u1E01","\u1E03","\u1E05","\u1E07","\u1E09","\u1E0B","\u1E0D","\u1E0F","\u1E11","\u1E13","\u1E15","\u1E17","\u1E19","\u1E1B","\u1E1D","\u1E1F","\u1E21","\u1E23","\u1E25","\u1E27","\u1E29","\u1E2B","\u1E2D","\u1E2F","\u1E31","\u1E33","\u1E35","\u1E37","\u1E39","\u1E3B","\u1E3D","\u1E3F","\u1E41","\u1E43","\u1E45","\u1E47","\u1E49","\u1E4B","\u1E4D","\u1E4F","\u1E51","\u1E53","\u1E55","\u1E57","\u1E59","\u1E5B","\u1E5D","\u1E5F","\u1E61","\u1E63","\u1E65","\u1E67","\u1E69","\u1E6B","\u1E6D","\u1E6F","\u1E71","\u1E73","\u1E75","\u1E77","\u1E79","\u1E7B","\u1E7D","\u1E7F","\u1E81","\u1E83","\u1E85","\u1E87","\u1E89","\u1E8B","\u1E8D","\u1E8F","\u1E91","\u1E93",["\u1E95","\u1E9D"],"\u1E9F","\u1EA1","\u1EA3","\u1EA5","\u1EA7","\u1EA9","\u1EAB","\u1EAD","\u1EAF","\u1EB1","\u1EB3","\u1EB5","\u1EB7","\u1EB9","\u1EBB","\u1EBD","\u1EBF","\u1EC1","\u1EC3","\u1EC5","\u1EC7","\u1EC9","\u1ECB","\u1ECD","\u1ECF","\u1ED1","\u1ED3","\u1ED5","\u1ED7","\u1ED9","\u1EDB","\u1EDD","\u1EDF","\u1EE1","\u1EE3","\u1EE5","\u1EE7","\u1EE9","\u1EEB","\u1EED","\u1EEF","\u1EF1","\u1EF3","\u1EF5","\u1EF7","\u1EF9","\u1EFB","\u1EFD",["\u1EFF","\u1F07"],["\u1F10","\u1F15"],["\u1F20","\u1F27"],["\u1F30","\u1F37"],["\u1F40","\u1F45"],["\u1F50","\u1F57"],["\u1F60","\u1F67"],["\u1F70","\u1F7D"],["\u1F80","\u1F87"],["\u1F90","\u1F97"],["\u1FA0","\u1FA7"],["\u1FB0","\u1FB4"],["\u1FB6","\u1FB7"],"\u1FBE",["\u1FC2","\u1FC4"],["\u1FC6","\u1FC7"],["\u1FD0","\u1FD3"],["\u1FD6","\u1FD7"],["\u1FE0","\u1FE7"],["\u1FF2","\u1FF4"],["\u1FF6","\u1FF7"],"\u210A",["\u210E","\u210F"],"\u2113","\u212F","\u2134","\u2139",["\u213C","\u213D"],["\u2146","\u2149"],"\u214E","\u2184",["\u2C30","\u2C5E"],"\u2C61",["\u2C65","\u2C66"],"\u2C68","\u2C6A","\u2C6C","\u2C71",["\u2C73","\u2C74"],["\u2C76","\u2C7B"],"\u2C81","\u2C83","\u2C85","\u2C87","\u2C89","\u2C8B","\u2C8D","\u2C8F","\u2C91","\u2C93","\u2C95","\u2C97","\u2C99","\u2C9B","\u2C9D","\u2C9F","\u2CA1","\u2CA3","\u2CA5","\u2CA7","\u2CA9","\u2CAB","\u2CAD","\u2CAF","\u2CB1","\u2CB3","\u2CB5","\u2CB7","\u2CB9","\u2CBB","\u2CBD","\u2CBF","\u2CC1","\u2CC3","\u2CC5","\u2CC7","\u2CC9","\u2CCB","\u2CCD","\u2CCF","\u2CD1","\u2CD3","\u2CD5","\u2CD7","\u2CD9","\u2CDB","\u2CDD","\u2CDF","\u2CE1",["\u2CE3","\u2CE4"],"\u2CEC","\u2CEE","\u2CF3",["\u2D00","\u2D25"],"\u2D27","\u2D2D","\uA641","\uA643","\uA645","\uA647","\uA649","\uA64B","\uA64D","\uA64F","\uA651","\uA653","\uA655","\uA657","\uA659","\uA65B","\uA65D","\uA65F","\uA661","\uA663","\uA665","\uA667","\uA669","\uA66B","\uA66D","\uA681","\uA683","\uA685","\uA687","\uA689","\uA68B","\uA68D","\uA68F","\uA691","\uA693","\uA695","\uA697","\uA723","\uA725","\uA727","\uA729","\uA72B","\uA72D",["\uA72F","\uA731"],"\uA733","\uA735","\uA737","\uA739","\uA73B","\uA73D","\uA73F","\uA741","\uA743","\uA745","\uA747","\uA749","\uA74B","\uA74D","\uA74F","\uA751","\uA753","\uA755","\uA757","\uA759","\uA75B","\uA75D","\uA75F","\uA761","\uA763","\uA765","\uA767","\uA769","\uA76B","\uA76D","\uA76F",["\uA771","\uA778"],"\uA77A","\uA77C","\uA77F","\uA781","\uA783","\uA785","\uA787","\uA78C","\uA78E","\uA791","\uA793","\uA7A1","\uA7A3","\uA7A5","\uA7A7","\uA7A9","\uA7FA",["\uFB00","\uFB06"],["\uFB13","\uFB17"],["\uFF41","\uFF5A"]],!1,!1),Mm=/^[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5-\u06E6\u07F4-\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C-\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D-\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA717-\uA71F\uA770\uA788\uA7F8-\uA7F9\uA9CF\uAA70\uAADD\uAAF3-\uAAF4\uFF70\uFF9E-\uFF9F]/,Wm=br([["\u02B0","\u02C1"],["\u02C6","\u02D1"],["\u02E0","\u02E4"],"\u02EC","\u02EE","\u0374","\u037A","\u0559","\u0640",["\u06E5","\u06E6"],["\u07F4","\u07F5"],"\u07FA","\u081A","\u0824","\u0828","\u0971","\u0E46","\u0EC6","\u10FC","\u17D7","\u1843","\u1AA7",["\u1C78","\u1C7D"],["\u1D2C","\u1D6A"],"\u1D78",["\u1D9B","\u1DBF"],"\u2071","\u207F",["\u2090","\u209C"],["\u2C7C","\u2C7D"],"\u2D6F","\u2E2F","\u3005",["\u3031","\u3035"],"\u303B",["\u309D","\u309E"],["\u30FC","\u30FE"],"\uA015",["\uA4F8","\uA4FD"],"\uA60C","\uA67F",["\uA717","\uA71F"],"\uA770","\uA788",["\uA7F8","\uA7F9"],"\uA9CF","\uAA70","\uAADD",["\uAAF3","\uAAF4"],"\uFF70",["\uFF9E","\uFF9F"]],!1,!1),Hm=/^[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E-\u066F\u0671-\u06D3\u06D5\u06EE-\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0977\u0979-\u097F\u0985-\u098C\u098F-\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC-\u09DD\u09DF-\u09E1\u09F0-\u09F1\u0A05-\u0A0A\u0A0F-\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32-\u0A33\u0A35-\u0A36\u0A38-\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2-\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0-\u0AE1\u0B05-\u0B0C\u0B0F-\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32-\u0B33\u0B35-\u0B39\u0B3D\u0B5C-\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99-\u0B9A\u0B9C\u0B9E-\u0B9F\u0BA3-\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58-\u0C59\u0C60-\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0-\u0CE1\u0CF1-\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32-\u0E33\u0E40-\u0E45\u0E81-\u0E82\u0E84\u0E87-\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA-\u0EAB\u0EAD-\u0EB0\u0EB2-\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065-\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE-\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5-\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A-\uA62B\uA66E\uA6A0-\uA6E5\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5-\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40-\uFB41\uFB43-\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,zm=br(["\xAA","\xBA","\u01BB",["\u01C0","\u01C3"],"\u0294",["\u05D0","\u05EA"],["\u05F0","\u05F2"],["\u0620","\u063F"],["\u0641","\u064A"],["\u066E","\u066F"],["\u0671","\u06D3"],"\u06D5",["\u06EE","\u06EF"],["\u06FA","\u06FC"],"\u06FF","\u0710",["\u0712","\u072F"],["\u074D","\u07A5"],"\u07B1",["\u07CA","\u07EA"],["\u0800","\u0815"],["\u0840","\u0858"],"\u08A0",["\u08A2","\u08AC"],["\u0904","\u0939"],"\u093D","\u0950",["\u0958","\u0961"],["\u0972","\u0977"],["\u0979","\u097F"],["\u0985","\u098C"],["\u098F","\u0990"],["\u0993","\u09A8"],["\u09AA","\u09B0"],"\u09B2",["\u09B6","\u09B9"],"\u09BD","\u09CE",["\u09DC","\u09DD"],["\u09DF","\u09E1"],["\u09F0","\u09F1"],["\u0A05","\u0A0A"],["\u0A0F","\u0A10"],["\u0A13","\u0A28"],["\u0A2A","\u0A30"],["\u0A32","\u0A33"],["\u0A35","\u0A36"],["\u0A38","\u0A39"],["\u0A59","\u0A5C"],"\u0A5E",["\u0A72","\u0A74"],["\u0A85","\u0A8D"],["\u0A8F","\u0A91"],["\u0A93","\u0AA8"],["\u0AAA","\u0AB0"],["\u0AB2","\u0AB3"],["\u0AB5","\u0AB9"],"\u0ABD","\u0AD0",["\u0AE0","\u0AE1"],["\u0B05","\u0B0C"],["\u0B0F","\u0B10"],["\u0B13","\u0B28"],["\u0B2A","\u0B30"],["\u0B32","\u0B33"],["\u0B35","\u0B39"],"\u0B3D",["\u0B5C","\u0B5D"],["\u0B5F","\u0B61"],"\u0B71","\u0B83",["\u0B85","\u0B8A"],["\u0B8E","\u0B90"],["\u0B92","\u0B95"],["\u0B99","\u0B9A"],"\u0B9C",["\u0B9E","\u0B9F"],["\u0BA3","\u0BA4"],["\u0BA8","\u0BAA"],["\u0BAE","\u0BB9"],"\u0BD0",["\u0C05","\u0C0C"],["\u0C0E","\u0C10"],["\u0C12","\u0C28"],["\u0C2A","\u0C33"],["\u0C35","\u0C39"],"\u0C3D",["\u0C58","\u0C59"],["\u0C60","\u0C61"],["\u0C85","\u0C8C"],["\u0C8E","\u0C90"],["\u0C92","\u0CA8"],["\u0CAA","\u0CB3"],["\u0CB5","\u0CB9"],"\u0CBD","\u0CDE",["\u0CE0","\u0CE1"],["\u0CF1","\u0CF2"],["\u0D05","\u0D0C"],["\u0D0E","\u0D10"],["\u0D12","\u0D3A"],"\u0D3D","\u0D4E",["\u0D60","\u0D61"],["\u0D7A","\u0D7F"],["\u0D85","\u0D96"],["\u0D9A","\u0DB1"],["\u0DB3","\u0DBB"],"\u0DBD",["\u0DC0","\u0DC6"],["\u0E01","\u0E30"],["\u0E32","\u0E33"],["\u0E40","\u0E45"],["\u0E81","\u0E82"],"\u0E84",["\u0E87","\u0E88"],"\u0E8A","\u0E8D",["\u0E94","\u0E97"],["\u0E99","\u0E9F"],["\u0EA1","\u0EA3"],"\u0EA5","\u0EA7",["\u0EAA","\u0EAB"],["\u0EAD","\u0EB0"],["\u0EB2","\u0EB3"],"\u0EBD",["\u0EC0","\u0EC4"],["\u0EDC","\u0EDF"],"\u0F00",["\u0F40","\u0F47"],["\u0F49","\u0F6C"],["\u0F88","\u0F8C"],["\u1000","\u102A"],"\u103F",["\u1050","\u1055"],["\u105A","\u105D"],"\u1061",["\u1065","\u1066"],["\u106E","\u1070"],["\u1075","\u1081"],"\u108E",["\u10D0","\u10FA"],["\u10FD","\u1248"],["\u124A","\u124D"],["\u1250","\u1256"],"\u1258",["\u125A","\u125D"],["\u1260","\u1288"],["\u128A","\u128D"],["\u1290","\u12B0"],["\u12B2","\u12B5"],["\u12B8","\u12BE"],"\u12C0",["\u12C2","\u12C5"],["\u12C8","\u12D6"],["\u12D8","\u1310"],["\u1312","\u1315"],["\u1318","\u135A"],["\u1380","\u138F"],["\u13A0","\u13F4"],["\u1401","\u166C"],["\u166F","\u167F"],["\u1681","\u169A"],["\u16A0","\u16EA"],["\u1700","\u170C"],["\u170E","\u1711"],["\u1720","\u1731"],["\u1740","\u1751"],["\u1760","\u176C"],["\u176E","\u1770"],["\u1780","\u17B3"],"\u17DC",["\u1820","\u1842"],["\u1844","\u1877"],["\u1880","\u18A8"],"\u18AA",["\u18B0","\u18F5"],["\u1900","\u191C"],["\u1950","\u196D"],["\u1970","\u1974"],["\u1980","\u19AB"],["\u19C1","\u19C7"],["\u1A00","\u1A16"],["\u1A20","\u1A54"],["\u1B05","\u1B33"],["\u1B45","\u1B4B"],["\u1B83","\u1BA0"],["\u1BAE","\u1BAF"],["\u1BBA","\u1BE5"],["\u1C00","\u1C23"],["\u1C4D","\u1C4F"],["\u1C5A","\u1C77"],["\u1CE9","\u1CEC"],["\u1CEE","\u1CF1"],["\u1CF5","\u1CF6"],["\u2135","\u2138"],["\u2D30","\u2D67"],["\u2D80","\u2D96"],["\u2DA0","\u2DA6"],["\u2DA8","\u2DAE"],["\u2DB0","\u2DB6"],["\u2DB8","\u2DBE"],["\u2DC0","\u2DC6"],["\u2DC8","\u2DCE"],["\u2DD0","\u2DD6"],["\u2DD8","\u2DDE"],"\u3006","\u303C",["\u3041","\u3096"],"\u309F",["\u30A1","\u30FA"],"\u30FF",["\u3105","\u312D"],["\u3131","\u318E"],["\u31A0","\u31BA"],["\u31F0","\u31FF"],["\u3400","\u4DB5"],["\u4E00","\u9FCC"],["\uA000","\uA014"],["\uA016","\uA48C"],["\uA4D0","\uA4F7"],["\uA500","\uA60B"],["\uA610","\uA61F"],["\uA62A","\uA62B"],"\uA66E",["\uA6A0","\uA6E5"],["\uA7FB","\uA801"],["\uA803","\uA805"],["\uA807","\uA80A"],["\uA80C","\uA822"],["\uA840","\uA873"],["\uA882","\uA8B3"],["\uA8F2","\uA8F7"],"\uA8FB",["\uA90A","\uA925"],["\uA930","\uA946"],["\uA960","\uA97C"],["\uA984","\uA9B2"],["\uAA00","\uAA28"],["\uAA40","\uAA42"],["\uAA44","\uAA4B"],["\uAA60","\uAA6F"],["\uAA71","\uAA76"],"\uAA7A",["\uAA80","\uAAAF"],"\uAAB1",["\uAAB5","\uAAB6"],["\uAAB9","\uAABD"],"\uAAC0","\uAAC2",["\uAADB","\uAADC"],["\uAAE0","\uAAEA"],"\uAAF2",["\uAB01","\uAB06"],["\uAB09","\uAB0E"],["\uAB11","\uAB16"],["\uAB20","\uAB26"],["\uAB28","\uAB2E"],["\uABC0","\uABE2"],["\uAC00","\uD7A3"],["\uD7B0","\uD7C6"],["\uD7CB","\uD7FB"],["\uF900","\uFA6D"],["\uFA70","\uFAD9"],"\uFB1D",["\uFB1F","\uFB28"],["\uFB2A","\uFB36"],["\uFB38","\uFB3C"],"\uFB3E",["\uFB40","\uFB41"],["\uFB43","\uFB44"],["\uFB46","\uFBB1"],["\uFBD3","\uFD3D"],["\uFD50","\uFD8F"],["\uFD92","\uFDC7"],["\uFDF0","\uFDFB"],["\uFE70","\uFE74"],["\uFE76","\uFEFC"],["\uFF66","\uFF6F"],["\uFF71","\uFF9D"],["\uFFA0","\uFFBE"],["\uFFC2","\uFFC7"],["\uFFCA","\uFFCF"],["\uFFD2","\uFFD7"],["\uFFDA","\uFFDC"]],!1,!1),qm=/^[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]/,Um=br(["\u01C5","\u01C8","\u01CB","\u01F2",["\u1F88","\u1F8F"],["\u1F98","\u1F9F"],["\u1FA8","\u1FAF"],"\u1FBC","\u1FCC","\u1FFC"],!1,!1),jm=/^[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178-\u0179\u017B\u017D\u0181-\u0182\u0184\u0186-\u0187\u0189-\u018B\u018E-\u0191\u0193-\u0194\u0196-\u0198\u019C-\u019D\u019F-\u01A0\u01A2\u01A4\u01A6-\u01A7\u01A9\u01AC\u01AE-\u01AF\u01B1-\u01B3\u01B5\u01B7-\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A-\u023B\u023D-\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u0386\u0388-\u038A\u038C\u038E-\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9-\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0-\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E-\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D-\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA\uFF21-\uFF3A]/,Qm=br([["A","Z"],["\xC0","\xD6"],["\xD8","\xDE"],"\u0100","\u0102","\u0104","\u0106","\u0108","\u010A","\u010C","\u010E","\u0110","\u0112","\u0114","\u0116","\u0118","\u011A","\u011C","\u011E","\u0120","\u0122","\u0124","\u0126","\u0128","\u012A","\u012C","\u012E","\u0130","\u0132","\u0134","\u0136","\u0139","\u013B","\u013D","\u013F","\u0141","\u0143","\u0145","\u0147","\u014A","\u014C","\u014E","\u0150","\u0152","\u0154","\u0156","\u0158","\u015A","\u015C","\u015E","\u0160","\u0162","\u0164","\u0166","\u0168","\u016A","\u016C","\u016E","\u0170","\u0172","\u0174","\u0176",["\u0178","\u0179"],"\u017B","\u017D",["\u0181","\u0182"],"\u0184",["\u0186","\u0187"],["\u0189","\u018B"],["\u018E","\u0191"],["\u0193","\u0194"],["\u0196","\u0198"],["\u019C","\u019D"],["\u019F","\u01A0"],"\u01A2","\u01A4",["\u01A6","\u01A7"],"\u01A9","\u01AC",["\u01AE","\u01AF"],["\u01B1","\u01B3"],"\u01B5",["\u01B7","\u01B8"],"\u01BC","\u01C4","\u01C7","\u01CA","\u01CD","\u01CF","\u01D1","\u01D3","\u01D5","\u01D7","\u01D9","\u01DB","\u01DE","\u01E0","\u01E2","\u01E4","\u01E6","\u01E8","\u01EA","\u01EC","\u01EE","\u01F1","\u01F4",["\u01F6","\u01F8"],"\u01FA","\u01FC","\u01FE","\u0200","\u0202","\u0204","\u0206","\u0208","\u020A","\u020C","\u020E","\u0210","\u0212","\u0214","\u0216","\u0218","\u021A","\u021C","\u021E","\u0220","\u0222","\u0224","\u0226","\u0228","\u022A","\u022C","\u022E","\u0230","\u0232",["\u023A","\u023B"],["\u023D","\u023E"],"\u0241",["\u0243","\u0246"],"\u0248","\u024A","\u024C","\u024E","\u0370","\u0372","\u0376","\u0386",["\u0388","\u038A"],"\u038C",["\u038E","\u038F"],["\u0391","\u03A1"],["\u03A3","\u03AB"],"\u03CF",["\u03D2","\u03D4"],"\u03D8","\u03DA","\u03DC","\u03DE","\u03E0","\u03E2","\u03E4","\u03E6","\u03E8","\u03EA","\u03EC","\u03EE","\u03F4","\u03F7",["\u03F9","\u03FA"],["\u03FD","\u042F"],"\u0460","\u0462","\u0464","\u0466","\u0468","\u046A","\u046C","\u046E","\u0470","\u0472","\u0474","\u0476","\u0478","\u047A","\u047C","\u047E","\u0480","\u048A","\u048C","\u048E","\u0490","\u0492","\u0494","\u0496","\u0498","\u049A","\u049C","\u049E","\u04A0","\u04A2","\u04A4","\u04A6","\u04A8","\u04AA","\u04AC","\u04AE","\u04B0","\u04B2","\u04B4","\u04B6","\u04B8","\u04BA","\u04BC","\u04BE",["\u04C0","\u04C1"],"\u04C3","\u04C5","\u04C7","\u04C9","\u04CB","\u04CD","\u04D0","\u04D2","\u04D4","\u04D6","\u04D8","\u04DA","\u04DC","\u04DE","\u04E0","\u04E2","\u04E4","\u04E6","\u04E8","\u04EA","\u04EC","\u04EE","\u04F0","\u04F2","\u04F4","\u04F6","\u04F8","\u04FA","\u04FC","\u04FE","\u0500","\u0502","\u0504","\u0506","\u0508","\u050A","\u050C","\u050E","\u0510","\u0512","\u0514","\u0516","\u0518","\u051A","\u051C","\u051E","\u0520","\u0522","\u0524","\u0526",["\u0531","\u0556"],["\u10A0","\u10C5"],"\u10C7","\u10CD","\u1E00","\u1E02","\u1E04","\u1E06","\u1E08","\u1E0A","\u1E0C","\u1E0E","\u1E10","\u1E12","\u1E14","\u1E16","\u1E18","\u1E1A","\u1E1C","\u1E1E","\u1E20","\u1E22","\u1E24","\u1E26","\u1E28","\u1E2A","\u1E2C","\u1E2E","\u1E30","\u1E32","\u1E34","\u1E36","\u1E38","\u1E3A","\u1E3C","\u1E3E","\u1E40","\u1E42","\u1E44","\u1E46","\u1E48","\u1E4A","\u1E4C","\u1E4E","\u1E50","\u1E52","\u1E54","\u1E56","\u1E58","\u1E5A","\u1E5C","\u1E5E","\u1E60","\u1E62","\u1E64","\u1E66","\u1E68","\u1E6A","\u1E6C","\u1E6E","\u1E70","\u1E72","\u1E74","\u1E76","\u1E78","\u1E7A","\u1E7C","\u1E7E","\u1E80","\u1E82","\u1E84","\u1E86","\u1E88","\u1E8A","\u1E8C","\u1E8E","\u1E90","\u1E92","\u1E94","\u1E9E","\u1EA0","\u1EA2","\u1EA4","\u1EA6","\u1EA8","\u1EAA","\u1EAC","\u1EAE","\u1EB0","\u1EB2","\u1EB4","\u1EB6","\u1EB8","\u1EBA","\u1EBC","\u1EBE","\u1EC0","\u1EC2","\u1EC4","\u1EC6","\u1EC8","\u1ECA","\u1ECC","\u1ECE","\u1ED0","\u1ED2","\u1ED4","\u1ED6","\u1ED8","\u1EDA","\u1EDC","\u1EDE","\u1EE0","\u1EE2","\u1EE4","\u1EE6","\u1EE8","\u1EEA","\u1EEC","\u1EEE","\u1EF0","\u1EF2","\u1EF4","\u1EF6","\u1EF8","\u1EFA","\u1EFC","\u1EFE",["\u1F08","\u1F0F"],["\u1F18","\u1F1D"],["\u1F28","\u1F2F"],["\u1F38","\u1F3F"],["\u1F48","\u1F4D"],"\u1F59","\u1F5B","\u1F5D","\u1F5F",["\u1F68","\u1F6F"],["\u1FB8","\u1FBB"],["\u1FC8","\u1FCB"],["\u1FD8","\u1FDB"],["\u1FE8","\u1FEC"],["\u1FF8","\u1FFB"],"\u2102","\u2107",["\u210B","\u210D"],["\u2110","\u2112"],"\u2115",["\u2119","\u211D"],"\u2124","\u2126","\u2128",["\u212A","\u212D"],["\u2130","\u2133"],["\u213E","\u213F"],"\u2145","\u2183",["\u2C00","\u2C2E"],"\u2C60",["\u2C62","\u2C64"],"\u2C67","\u2C69","\u2C6B",["\u2C6D","\u2C70"],"\u2C72","\u2C75",["\u2C7E","\u2C80"],"\u2C82","\u2C84","\u2C86","\u2C88","\u2C8A","\u2C8C","\u2C8E","\u2C90","\u2C92","\u2C94","\u2C96","\u2C98","\u2C9A","\u2C9C","\u2C9E","\u2CA0","\u2CA2","\u2CA4","\u2CA6","\u2CA8","\u2CAA","\u2CAC","\u2CAE","\u2CB0","\u2CB2","\u2CB4","\u2CB6","\u2CB8","\u2CBA","\u2CBC","\u2CBE","\u2CC0","\u2CC2","\u2CC4","\u2CC6","\u2CC8","\u2CCA","\u2CCC","\u2CCE","\u2CD0","\u2CD2","\u2CD4","\u2CD6","\u2CD8","\u2CDA","\u2CDC","\u2CDE","\u2CE0","\u2CE2","\u2CEB","\u2CED","\u2CF2","\uA640","\uA642","\uA644","\uA646","\uA648","\uA64A","\uA64C","\uA64E","\uA650","\uA652","\uA654","\uA656","\uA658","\uA65A","\uA65C","\uA65E","\uA660","\uA662","\uA664","\uA666","\uA668","\uA66A","\uA66C","\uA680","\uA682","\uA684","\uA686","\uA688","\uA68A","\uA68C","\uA68E","\uA690","\uA692","\uA694","\uA696","\uA722","\uA724","\uA726","\uA728","\uA72A","\uA72C","\uA72E","\uA732","\uA734","\uA736","\uA738","\uA73A","\uA73C","\uA73E","\uA740","\uA742","\uA744","\uA746","\uA748","\uA74A","\uA74C","\uA74E","\uA750","\uA752","\uA754","\uA756","\uA758","\uA75A","\uA75C","\uA75E","\uA760","\uA762","\uA764","\uA766","\uA768","\uA76A","\uA76C","\uA76E","\uA779","\uA77B",["\uA77D","\uA77E"],"\uA780","\uA782","\uA784","\uA786","\uA78B","\uA78D","\uA790","\uA792","\uA7A0","\uA7A2","\uA7A4","\uA7A6","\uA7A8","\uA7AA",["\uFF21","\uFF3A"]],!1,!1),Xm=/^[\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF]/,Jm=br([["\u16EE","\u16F0"],["\u2160","\u2182"],["\u2185","\u2188"],"\u3007",["\u3021","\u3029"],["\u3038","\u303A"],["\uA6E6","\uA6EF"]],!1,!1),$m=/^[0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]/,Km=br([["0","9"],["\u0660","\u0669"],["\u06F0","\u06F9"],["\u07C0","\u07C9"],["\u0966","\u096F"],["\u09E6","\u09EF"],["\u0A66","\u0A6F"],["\u0AE6","\u0AEF"],["\u0B66","\u0B6F"],["\u0BE6","\u0BEF"],["\u0C66","\u0C6F"],["\u0CE6","\u0CEF"],["\u0D66","\u0D6F"],["\u0E50","\u0E59"],["\u0ED0","\u0ED9"],["\u0F20","\u0F29"],["\u1040","\u1049"],["\u1090","\u1099"],["\u17E0","\u17E9"],["\u1810","\u1819"],["\u1946","\u194F"],["\u19D0","\u19D9"],["\u1A80","\u1A89"],["\u1A90","\u1A99"],["\u1B50","\u1B59"],["\u1BB0","\u1BB9"],["\u1C40","\u1C49"],["\u1C50","\u1C59"],["\uA620","\uA629"],["\uA8D0","\uA8D9"],["\uA900","\uA909"],["\uA9D0","\uA9D9"],["\uAA50","\uAA59"],["\uABF0","\uABF9"],["\uFF10","\uFF19"]],!1,!1),p=0,te=0,xa=[{line:1,column:1}],ai=0,Iu=[],L=0,wa;if("startRule"in t){if(!(t.startRule in i))throw new Error(`Can't start parsing from rule "`+t.startRule+'".');n=i[t.startRule]}function uc(){return l.substring(te,p)}function SP(){return vs(te,p)}function CP(m,y){throw y=y!==void 0?y:vs(te,p),cc([li(m)],l.substring(te,p),y)}function EP(m,y){throw y=y!==void 0?y:vs(te,p),_m(m,y)}function se(m,y){return{type:"literal",text:m,ignoreCase:y}}function br(m,y,x){return{type:"class",parts:m,inverted:y,ignoreCase:x}}function Ym(){return{type:"any"}}function Zm(){return{type:"end"}}function li(m){return{type:"other",description:m}}function hc(m){var y=xa[m],x;if(y)return y;for(x=m-1;!xa[x];)x--;for(y=xa[x],y={line:y.line,column:y.column};x<m;)l.charCodeAt(x)===10?(y.line++,y.column=1):y.column++,x++;return xa[m]=y,y}function vs(m,y){var x=hc(m),I=hc(y);return{start:{offset:m,line:x.line,column:x.column},end:{offset:y,line:I.line,column:I.column}}}function V(m){p<ai||(p>ai&&(ai=p,Iu=[]),Iu.push(m))}function _m(m,y){return new xo(m,null,null,y)}function cc(m,y,x){return new xo(xo.buildMessage(m,y),m,y,x)}function dc(){var m,y;if(m=[],y=gc(),y!==e)for(;y!==e;)m.push(y),y=gc();else m=e;return m}function gc(){var m,y,x,I,G,k,J,Je,$e,hi,Pr,Lu,wc;return m=p,y=De(),y!==e?(l.substr(p,6).toLowerCase()===o?(x=l.substr(p,6),p+=6):(x=e,L===0&&V(s)),x===e&&(x=null),x!==e?(I=De(),I!==e?(l.substr(p,5).toLowerCase()===a?(G=l.substr(p,5),p+=5):(G=e,L===0&&V(u)),G===e&&(l.substr(p,7).toLowerCase()===h?(G=l.substr(p,7),p+=7):(G=e,L===0&&V(c))),G!==e?(k=De(),k!==e?(J=ui(),J===e&&(J=null),J!==e?(Je=De(),Je!==e?(l.charCodeAt(p)===123?($e=f,p++):($e=e,L===0&&V(P)),$e!==e?(hi=mc(),hi===e&&(hi=null),hi!==e?(Pr=De(),Pr!==e?(l.charCodeAt(p)===125?(Lu=v,p++):(Lu=e,L===0&&V(A)),Lu!==e?(wc=De(),wc!==e?(te=m,y=O(x,G,J,hi),m=y):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e),m}function mc(){var m,y,x,I,G,k,J,Je,$e,hi,Pr;if(m=p,y=De(),y!==e)if(x=xu(),x!==e)if(I=De(),I!==e)if(l.charCodeAt(p)===59?(G=M,p++):(G=e,L===0&&V(z)),G===e&&(G=null),G!==e){for(k=[],J=p,Je=De(),Je!==e?($e=xu(),$e!==e?(hi=De(),hi!==e?(l.charCodeAt(p)===59?(Pr=M,p++):(Pr=e,L===0&&V(z)),Pr===e&&(Pr=null),Pr!==e?(te=J,Je=$(x,$e),J=Je):(p=J,J=e)):(p=J,J=e)):(p=J,J=e)):(p=J,J=e);J!==e;)k.push(J),J=p,Je=De(),Je!==e?($e=xu(),$e!==e?(hi=De(),hi!==e?(l.charCodeAt(p)===59?(Pr=M,p++):(Pr=e,L===0&&V(z)),Pr===e&&(Pr=null),Pr!==e?(te=J,Je=$(x,$e),J=Je):(p=J,J=e)):(p=J,J=e)):(p=J,J=e)):(p=J,J=e);k!==e?(te=m,y=N(x,k),m=y):(p=m,m=e)}else p=m,m=e;else p=m,m=e;else p=m,m=e;else p=m,m=e;return m}function xu(){var m,y,x,I,G,k;return m=p,y=ui(),y!==e?(x=De(),x!==e?(l.charCodeAt(p)===61?(I=q,p++):(I=e,L===0&&V(Te)),I!==e?(G=De(),G!==e?(k=ui(),k!==e?(te=m,y=ve(y,k),m=y):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e),m===e&&(m=ef(),m===e&&(m=tf(),m===e&&(m=Tu(),m===e&&(m=rf(),m===e&&(m=p,y=ui(),y!==e?(l.charCodeAt(p)===61?(x=q,p++):(x=e,L===0&&V(Te)),x!==e?(I=ui(),I!==e?(y=[y,x,I],m=y):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)))))),m}function ef(){var m,y,x;return m=p,l.substr(p,5).toLowerCase()===a?(y=l.substr(p,5),p+=5):(y=e,L===0&&V(u)),y===e&&(l.substr(p,4).toLowerCase()===Wt?(y=l.substr(p,4),p+=4):(y=e,L===0&&V(Bo)),y===e&&(l.substr(p,4).toLowerCase()===Es?(y=l.substr(p,4),p+=4):(y=e,L===0&&V(R)))),y!==e?(x=Ta(),x!==e?(te=m,y=T(y,x),m=y):(p=m,m=e)):(p=m,m=e),m}function Ta(){var m,y,x,I,G,k,J,Je,$e;return m=p,y=De(),y!==e?(l.charCodeAt(p)===91?(x=W,p++):(x=e,L===0&&V(U)),x!==e?(I=De(),I!==e?(G=fc(),G===e&&(G=null),G!==e?(k=De(),k!==e?(l.charCodeAt(p)===93?(J=Y,p++):(J=e,L===0&&V(X)),J!==e?(Je=De(),Je!==e?($e=Ta(),$e===e&&($e=null),$e!==e?(te=m,y=K(G,$e),m=y):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e),m}function fc(){var m,y,x,I,G,k,J,Je;return m=p,y=De(),y!==e?(x=ui(),x!==e?(I=p,G=De(),G!==e?(l.charCodeAt(p)===61?(k=q,p++):(k=e,L===0&&V(Te)),k!==e?(J=De(),J!==e?(Je=ui(),Je!==e?(te=I,G=ge(x,Je),I=G):(p=I,I=e)):(p=I,I=e)):(p=I,I=e)):(p=I,I=e),I===e&&(I=null),I!==e?(G=De(),G!==e?(l.charCodeAt(p)===44?(k=Pe,p++):(k=e,L===0&&V(Gt)),k===e&&(l.charCodeAt(p)===59?(k=M,p++):(k=e,L===0&&V(z))),k===e&&(k=null),k!==e?(J=fc(),J===e&&(J=null),J!==e?(te=m,y=pr(x,I,J),m=y):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e),m}function tf(){var m,y,x,I;return m=p,y=Tu(),y===e&&(y=wu()),y!==e?(x=pc(),x!==e?(I=Ta(),I===e&&(I=null),I!==e?(te=m,y=oi(y,x,I),m=y):(p=m,m=e)):(p=m,m=e)):(p=m,m=e),m}function pc(){var m,y,x,I,G,k,J;return m=p,y=De(),y!==e?(l.substr(p,2)===qh?(x=qh,p+=2):(x=e,L===0&&V(vg)),x===e&&(l.substr(p,2)===Uh?(x=Uh,p+=2):(x=e,L===0&&V(Ag))),x!==e?(I=De(),I!==e?(G=Tu(),G===e&&(G=wu()),G!==e?(k=De(),k!==e?(J=pc(),J===e&&(J=null),J!==e?(te=m,y=Ig(x,G,J),m=y):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e),m}function rf(){var m,y,x;return m=p,y=wu(),y!==e?(x=Ta(),x===e&&(x=null),x!==e?(te=m,y=xg(y,x),m=y):(p=m,m=e)):(p=m,m=e),m}function wu(){var m,y,x;return m=p,y=ui(),y!==e?(x=nf(),x===e&&(x=null),x!==e?(te=m,y=wg(y,x),m=y):(p=m,m=e)):(p=m,m=e),m}function nf(){var m,y,x,I,G,k;return L++,m=p,l.charCodeAt(p)===58?(y=pu,p++):(y=e,L===0&&V(bu)),y!==e?(x=ui(),x!==e?(I=p,l.charCodeAt(p)===58?(G=pu,p++):(G=e,L===0&&V(bu)),G!==e?(k=bc(),k!==e?(te=I,G=Og(x,k),I=G):(p=I,I=e)):(p=I,I=e),I===e&&(I=null),I!==e?(te=m,y=Bg(x,I),m=y):(p=m,m=e)):(p=m,m=e)):(p=m,m=e),m===e&&(m=p,l.charCodeAt(p)===58?(y=pu,p++):(y=e,L===0&&V(bu)),y!==e?(x=bc(),x!==e?(te=m,y=Lg(x),m=y):(p=m,m=e)):(p=m,m=e)),L--,m===e&&(y=e,L===0&&V(Tg)),m}function Tu(){var m,y,x,I,G,k;return m=p,y=p,l.substr(p,8).toLowerCase()===Gg?(x=l.substr(p,8),p+=8):(x=e,L===0&&V(Rg)),x!==e?(I=De(),I!==e?(G=ui(),G===e&&(G=null),G!==e?(k=De(),k!==e?(te=y,x=Ng(G),y=x):(p=y,y=e)):(p=y,y=e)):(p=y,y=e)):(p=y,y=e),y===e&&(y=null),y!==e?(l.charCodeAt(p)===123?(x=f,p++):(x=e,L===0&&V(P)),x!==e?(I=mc(),I===e&&(I=null),I!==e?(G=De(),G!==e?(l.charCodeAt(p)===125?(k=v,p++):(k=e,L===0&&V(A)),k!==e?(te=m,y=Dg(y,I),m=y):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e)):(p=m,m=e),m}function bc(){var m;return l.charCodeAt(p)===110?(m=Fg,p++):(m=e,L===0&&V(Vg)),m===e&&(l.substr(p,2)===jh?(m=jh,p+=2):(m=e,L===0&&V(kg)),m===e&&(l.charCodeAt(p)===101?(m=Mg,p++):(m=e,L===0&&V(Wg)),m===e&&(l.substr(p,2)===Qh?(m=Qh,p+=2):(m=e,L===0&&V(Hg)),m===e&&(l.charCodeAt(p)===115?(m=zg,p++):(m=e,L===0&&V(qg)),m===e&&(l.substr(p,2)===Xh?(m=Xh,p+=2):(m=e,L===0&&V(Ug)),m===e&&(l.charCodeAt(p)===119?(m=jg,p++):(m=e,L===0&&V(Qg)),m===e&&(l.substr(p,2)===Jh?(m=Jh,p+=2):(m=e,L===0&&V(Xg))))))))),m}function ui(){var m;return m=Pc(),m===e&&(m=of(),m===e&&(m=Cc(),m===e&&(m=af(),m===e&&(m=sf())))),m}function Pc(){var m,y,x,I;if(L++,m=p,y=yc(),y!==e){for(x=[],I=Sc();I!==e;)x.push(I),I=Sc();x!==e?(te=m,y=$g(y,x),m=y):(p=m,m=e)}else p=m,m=e;return L--,m===e&&(y=e,L===0&&V(Jg)),m}function of(){var m,y,x;return m=p,y=Cc(),y!==e?(x=Pc(),x!==e?(te=m,y=Kg(y,x),m=y):(p=m,m=e)):(p=m,m=e),m}function yc(){var m;return m=pf(),m===e&&(l.charCodeAt(p)===36?(m=Yg,p++):(m=e,L===0&&V(Zg)),m===e&&(l.charCodeAt(p)===95?(m=_g,p++):(m=e,L===0&&V(em)))),m}function Sc(){var m;return m=yc(),m===e&&(m=vf()),m}function Cc(){var m,y,x,I,G,k,J,Je,$e;if(L++,m=p,y=p,l.charCodeAt(p)===45?(x=rm,p++):(x=e,L===0&&V(im)),x===e&&(x=null),x!==e){if(I=p,l.charCodeAt(p)===46?(G=$h,p++):(G=e,L===0&&V(Kh)),G!==e){if(k=[],Lo.test(l.charAt(p))?(J=l.charAt(p),p++):(J=e,L===0&&V(Go)),J!==e)for(;J!==e;)k.push(J),Lo.test(l.charAt(p))?(J=l.charAt(p),p++):(J=e,L===0&&V(Go));else k=e;k!==e?(G=[G,k],I=G):(p=I,I=e)}else p=I,I=e;if(I===e){if(I=p,G=[],Lo.test(l.charAt(p))?(k=l.charAt(p),p++):(k=e,L===0&&V(Go)),k!==e)for(;k!==e;)G.push(k),Lo.test(l.charAt(p))?(k=l.charAt(p),p++):(k=e,L===0&&V(Go));else G=e;if(G!==e){if(k=p,l.charCodeAt(p)===46?(J=$h,p++):(J=e,L===0&&V(Kh)),J!==e){for(Je=[],Lo.test(l.charAt(p))?($e=l.charAt(p),p++):($e=e,L===0&&V(Go));$e!==e;)Je.push($e),Lo.test(l.charAt(p))?($e=l.charAt(p),p++):($e=e,L===0&&V(Go));Je!==e?(J=[J,Je],k=J):(p=k,k=e)}else p=k,k=e;k===e&&(k=null),k!==e?(G=[G,k],I=G):(p=I,I=e)}else p=I,I=e}I!==e?(x=[x,I],y=x):(p=y,y=e)}else p=y,y=e;return y!==e&&(te=m,y=nm(y)),m=y,L--,m===e&&(y=e,L===0&&V(tm)),m}function sf(){var m,y;return m=p,y=Ou(),y!==e&&(te=m,y=om(y)),m=y,m}function Ou(){var m,y,x,I;if(m=p,l.charCodeAt(p)===60?(y=Pu,p++):(y=e,L===0&&V(yu)),y!==e){for(x=[],I=Ec(),I===e&&(I=Ou());I!==e;)x.push(I),I=Ec(),I===e&&(I=Ou());x!==e?(l.charCodeAt(p)===62?(I=Su,p++):(I=e,L===0&&V(Cu)),I!==e?(te=m,y=sm(x),m=y):(p=m,m=e)):(p=m,m=e)}else p=m,m=e;return m}function Ec(){var m,y,x,I,G;if(m=p,y=[],x=p,I=p,L++,l.charCodeAt(p)===62?(G=Su,p++):(G=e,L===0&&V(Cu)),G===e&&(l.charCodeAt(p)===60?(G=Pu,p++):(G=e,L===0&&V(yu))),L--,G===e?I=void 0:(p=I,I=e),I!==e?(l.length>p?(G=l.charAt(p),p++):(G=e,L===0&&V(si)),G!==e?(te=x,I=Ro(G),x=I):(p=x,x=e)):(p=x,x=e),x!==e)for(;x!==e;)y.push(x),x=p,I=p,L++,l.charCodeAt(p)===62?(G=Su,p++):(G=e,L===0&&V(Cu)),G===e&&(l.charCodeAt(p)===60?(G=Pu,p++):(G=e,L===0&&V(yu))),L--,G===e?I=void 0:(p=I,I=e),I!==e?(l.length>p?(G=l.charAt(p),p++):(G=e,L===0&&V(si)),G!==e?(te=x,I=Ro(G),x=I):(p=x,x=e)):(p=x,x=e);else y=e;return y!==e&&(te=m,y=am(y)),m=y,m}function af(){var m,y,x,I;if(m=p,l.charCodeAt(p)===34?(y=Eu,p++):(y=e,L===0&&V(vu)),y!==e){for(x=[],I=vc();I!==e;)x.push(I),I=vc();x!==e?(l.charCodeAt(p)===34?(I=Eu,p++):(I=e,L===0&&V(vu)),I!==e?(te=m,y=Yh(x),m=y):(p=m,m=e)):(p=m,m=e)}else p=m,m=e;return m}function vc(){var m,y,x;return m=lf(),m===e&&(m=p,y=p,L++,l.charCodeAt(p)===34?(x=Eu,p++):(x=e,L===0&&V(vu)),x===e&&(x=hf()),L--,x===e?y=void 0:(p=y,y=e),y!==e?(x=df(),x!==e?(te=m,y=lm(),m=y):(p=m,m=e)):(p=m,m=e),m===e&&(m=uf())),m}function lf(){var m,y,x,I;return m=p,y=p,l.charCodeAt(p)===92?(x=Aa,p++):(x=e,L===0&&V(Ia)),x!==e?(l.length>p?(I=l.charAt(p),p++):(I=e,L===0&&V(si)),I!==e?(x=[x,I],y=x):(p=y,y=e)):(p=y,y=e),y!==e&&(te=m,y=um(y)),m=y,m}function uf(){var m,y,x;return m=p,l.charCodeAt(p)===92?(y=Aa,p++):(y=e,L===0&&V(Ia)),y!==e?(x=cf(),x!==e?(te=m,y=Zh(),m=y):(p=m,m=e)):(p=m,m=e),m}function hf(){var m;return hm.test(l.charAt(p))?(m=l.charAt(p),p++):(m=e,L===0&&V(cm)),m}function cf(){var m,y;return L++,l.charCodeAt(p)===10?(m=gm,p++):(m=e,L===0&&V(mm)),m===e&&(l.substr(p,2)===_h?(m=_h,p+=2):(m=e,L===0&&V(fm)),m===e&&(l.charCodeAt(p)===13?(m=pm,p++):(m=e,L===0&&V(bm)),m===e&&(l.charCodeAt(p)===8232?(m=Pm,p++):(m=e,L===0&&V(ym)),m===e&&(l.charCodeAt(p)===8233?(m=Sm,p++):(m=e,L===0&&V(Cm)))))),L--,m===e&&(y=e,L===0&&V(dm)),m}function df(){var m;return l.length>p?(m=l.charAt(p),p++):(m=e,L===0&&V(si)),m}function vP(){var m,y,x;if(m=p,y=[],x=Ac(),x!==e)for(;x!==e;)y.push(x),x=Ac();else y=e;return y!==e&&(te=m,y=Yh(y)),m=y,m}function Ac(){var m,y,x;return Em.test(l.charAt(p))?(m=l.charAt(p),p++):(m=e,L===0&&V(vm)),m===e&&(m=p,l.substr(p,2)===ec?(y=ec,p+=2):(y=e,L===0&&V(Am)),y!==e&&(te=m,y=Im()),m=y,m===e&&(m=p,l.charCodeAt(p)===92?(y=Aa,p++):(y=e,L===0&&V(Ia)),y!==e?(x=Bu(),x!==e?(te=m,y=Zh(),m=y):(p=m,m=e)):(p=m,m=e),m===e&&(m=p,l.charCodeAt(p)===92?(y=Aa,p++):(y=e,L===0&&V(Ia)),y!==e&&(te=m,y=xm()),m=y))),m}function Ic(){var m,y;return L++,m=gf(),m===e&&(m=mf(),m===e&&(m=ff())),L--,m===e&&(y=e,L===0&&V(wm)),m}function gf(){var m,y,x,I,G,k;if(L++,m=p,l.substr(p,2)===tc?(y=tc,p+=2):(y=e,L===0&&V(Om)),y!==e){for(x=[],I=p,G=p,L++,l.substr(p,2)===No?(k=No,p+=2):(k=e,L===0&&V(Au)),L--,k===e?G=void 0:(p=G,G=e),G!==e?(l.length>p?(k=l.charAt(p),p++):(k=e,L===0&&V(si)),k!==e?(te=I,G=rc(k),I=G):(p=I,I=e)):(p=I,I=e);I!==e;)x.push(I),I=p,G=p,L++,l.substr(p,2)===No?(k=No,p+=2):(k=e,L===0&&V(Au)),L--,k===e?G=void 0:(p=G,G=e),G!==e?(l.length>p?(k=l.charAt(p),p++):(k=e,L===0&&V(si)),k!==e?(te=I,G=rc(k),I=G):(p=I,I=e)):(p=I,I=e);x!==e?(l.substr(p,2)===No?(I=No,p+=2):(I=e,L===0&&V(Au)),I!==e?(te=m,y=Bm(x),m=y):(p=m,m=e)):(p=m,m=e)}else p=m,m=e;return L--,m===e&&(y=e,L===0&&V(Tm)),m}function mf(){var m,y,x,I,G,k;if(L++,m=p,l.substr(p,2)===ic?(y=ic,p+=2):(y=e,L===0&&V(Gm)),y!==e){for(x=[],I=p,G=p,L++,Do.test(l.charAt(p))?(k=l.charAt(p),p++):(k=e,L===0&&V(Fo)),L--,k===e?G=void 0:(p=G,G=e),G!==e?(l.length>p?(k=l.charAt(p),p++):(k=e,L===0&&V(si)),k!==e?(te=I,G=Ro(k),I=G):(p=I,I=e)):(p=I,I=e);I!==e;)x.push(I),I=p,G=p,L++,Do.test(l.charAt(p))?(k=l.charAt(p),p++):(k=e,L===0&&V(Fo)),L--,k===e?G=void 0:(p=G,G=e),G!==e?(l.length>p?(k=l.charAt(p),p++):(k=e,L===0&&V(si)),k!==e?(te=I,G=Ro(k),I=G):(p=I,I=e)):(p=I,I=e);x!==e?(Do.test(l.charAt(p))?(I=l.charAt(p),p++):(I=e,L===0&&V(Fo)),I===e&&(I=null),I!==e?(te=m,y=nc(x),m=y):(p=m,m=e)):(p=m,m=e)}else p=m,m=e;return L--,m===e&&(y=e,L===0&&V(Lm)),m}function ff(){var m,y,x,I,G,k;if(L++,m=p,l.charCodeAt(p)===35?(y=Nm,p++):(y=e,L===0&&V(Dm)),y!==e){for(x=[],I=p,G=p,L++,Do.test(l.charAt(p))?(k=l.charAt(p),p++):(k=e,L===0&&V(Fo)),L--,k===e?G=void 0:(p=G,G=e),G!==e?(l.length>p?(k=l.charAt(p),p++):(k=e,L===0&&V(si)),k!==e?(te=I,G=Ro(k),I=G):(p=I,I=e)):(p=I,I=e);I!==e;)x.push(I),I=p,G=p,L++,Do.test(l.charAt(p))?(k=l.charAt(p),p++):(k=e,L===0&&V(Fo)),L--,k===e?G=void 0:(p=G,G=e),G!==e?(l.length>p?(k=l.charAt(p),p++):(k=e,L===0&&V(si)),k!==e?(te=I,G=Ro(k),I=G):(p=I,I=e)):(p=I,I=e);x!==e?(Do.test(l.charAt(p))?(I=l.charAt(p),p++):(I=e,L===0&&V(Fo)),I===e&&(I=null),I!==e?(te=m,y=nc(x),m=y):(p=m,m=e)):(p=m,m=e)}else p=m,m=e;return L--,m===e&&(y=e,L===0&&V(Rm)),m}function De(){var m,y;for(L++,m=[],y=xc(),y===e&&(y=Ic());y!==e;)m.push(y),y=xc(),y===e&&(y=Ic());return L--,m===e&&(y=e,L===0&&V(Fm)),m}function Bu(){var m,y;if(m=[],oc.test(l.charAt(p))?(y=l.charAt(p),p++):(y=e,L===0&&V(sc)),y!==e)for(;y!==e;)m.push(y),oc.test(l.charAt(p))?(y=l.charAt(p),p++):(y=e,L===0&&V(sc));else m=e;return m}function xc(){var m,y;if(m=[],ac.test(l.charAt(p))?(y=l.charAt(p),p++):(y=e,L===0&&V(lc)),y===e&&(y=Bu()),y!==e)for(;y!==e;)m.push(y),ac.test(l.charAt(p))?(y=l.charAt(p),p++):(y=e,L===0&&V(lc)),y===e&&(y=Bu());else m=e;return m}function pf(){var m;return m=Cf(),m===e&&(m=bf(),m===e&&(m=Sf(),m===e&&(m=Pf(),m===e&&(m=yf(),m===e&&(m=Ef()))))),m}function bf(){var m;return Vm.test(l.charAt(p))?(m=l.charAt(p),p++):(m=e,L===0&&V(km)),m}function Pf(){var m;return Mm.test(l.charAt(p))?(m=l.charAt(p),p++):(m=e,L===0&&V(Wm)),m}function yf(){var m;return Hm.test(l.charAt(p))?(m=l.charAt(p),p++):(m=e,L===0&&V(zm)),m}function Sf(){var m;return qm.test(l.charAt(p))?(m=l.charAt(p),p++):(m=e,L===0&&V(Um)),m}function Cf(){var m;return jm.test(l.charAt(p))?(m=l.charAt(p),p++):(m=e,L===0&&V(Qm)),m}function Ef(){var m;return Xm.test(l.charAt(p))?(m=l.charAt(p),p++):(m=e,L===0&&V(Jm)),m}function vf(){var m;return $m.test(l.charAt(p))?(m=l.charAt(p),p++):(m=e,L===0&&V(Km)),m}if(wa=n(),wa!==e&&p===l.length)return wa;throw wa!==e&&p<l.length&&V(Zm()),cc(Iu,ai<l.length?l.charAt(ai):null,ai<l.length?vs(ai,ai+1):vs(ai,ai))}ng.exports={SyntaxError:xo,parse:pb}});var ag=Ri((zW,sg)=>{var bb=og();sg.exports=bb.parse});var gg=Ri((ZH,dg)=>{dg.exports={rgb2hsl:pa,rgb2hsv:uu,rgb2hwb:ba,rgb2cmyk:Pa,rgb2keyword:ya,rgb2xyz:Bh,rgb2lab:Lh,rgb2lch:Eb,hsl2rgb:hu,hsl2hsv:vb,hsl2hwb:Ab,hsl2cmyk:Ib,hsl2keyword:xb,hsv2rgb:cu,hsv2hsl:wb,hsv2hwb:Tb,hsv2cmyk:Ob,hsv2keyword:Bb,hwb2rgb:Sa,hwb2hsl:Lb,hwb2hsv:Gb,hwb2cmyk:Rb,hwb2keyword:Nb,cmyk2rgb:Ca,cmyk2hsl:Db,cmyk2hsv:Fb,cmyk2hwb:Vb,cmyk2keyword:kb,keyword2rgb:To,keyword2hsl:zb,keyword2hsv:qb,keyword2hwb:Ub,keyword2cmyk:jb,keyword2lab:Qb,keyword2xyz:Xb,xyz2rgb:lg,xyz2lab:ug,xyz2lch:Mb,lab2xyz:Gh,lab2rgb:hg,lab2lch:Rh,lch2lab:Nh,lch2xyz:Wb,lch2rgb:Hb};function pa(l){var t=l[0]/255,e=l[1]/255,i=l[2]/255,n=Math.min(t,e,i),o=Math.max(t,e,i),s=o-n,a,u,h;return o==n?a=0:t==o?a=(e-i)/s:e==o?a=2+(i-t)/s:i==o&&(a=4+(t-e)/s),a=Math.min(a*60,360),a<0&&(a+=360),h=(n+o)/2,o==n?u=0:h<=.5?u=s/(o+n):u=s/(2-o-n),[a,u*100,h*100]}function uu(l){var t=l[0],e=l[1],i=l[2],n=Math.min(t,e,i),o=Math.max(t,e,i),s=o-n,a,u,h;return o==0?u=0:u=s/o*1e3/10,o==n?a=0:t==o?a=(e-i)/s:e==o?a=2+(i-t)/s:i==o&&(a=4+(t-e)/s),a=Math.min(a*60,360),a<0&&(a+=360),h=o/255*1e3/10,[a,u,h]}function ba(l){var t=l[0],e=l[1],o=l[2],i=pa(l)[0],n=1/255*Math.min(t,Math.min(e,o)),o=1-1/255*Math.max(t,Math.max(e,o));return[i,n*100,o*100]}function Pa(l){var t=l[0]/255,e=l[1]/255,i=l[2]/255,n,o,s,a;return a=Math.min(1-t,1-e,1-i),n=(1-t-a)/(1-a)||0,o=(1-e-a)/(1-a)||0,s=(1-i-a)/(1-a)||0,[n*100,o*100,s*100,a*100]}function ya(l){return cg[JSON.stringify(l)]}function Bh(l){var t=l[0]/255,e=l[1]/255,i=l[2]/255;t=t>.04045?Math.pow((t+.055)/1.055,2.4):t/12.92,e=e>.04045?Math.pow((e+.055)/1.055,2.4):e/12.92,i=i>.04045?Math.pow((i+.055)/1.055,2.4):i/12.92;var n=t*.4124+e*.3576+i*.1805,o=t*.2126+e*.7152+i*.0722,s=t*.0193+e*.1192+i*.9505;return[n*100,o*100,s*100]}function Lh(l){var t=Bh(l),e=t[0],i=t[1],n=t[2],o,s,a;return e/=95.047,i/=100,n/=108.883,e=e>.008856?Math.pow(e,1/3):7.787*e+16/116,i=i>.008856?Math.pow(i,1/3):7.787*i+16/116,n=n>.008856?Math.pow(n,1/3):7.787*n+16/116,o=116*i-16,s=500*(e-i),a=200*(i-n),[o,s,a]}function Eb(l){return Rh(Lh(l))}function hu(l){var t=l[0]/360,e=l[1]/100,i=l[2]/100,n,o,s,a,u;if(e==0)return u=i*255,[u,u,u];i<.5?o=i*(1+e):o=i+e-i*e,n=2*i-o,a=[0,0,0];for(var h=0;h<3;h++)s=t+1/3*-(h-1),s<0&&s++,s>1&&s--,6*s<1?u=n+(o-n)*6*s:2*s<1?u=o:3*s<2?u=n+(o-n)*(2/3-s)*6:u=n,a[h]=u*255;return a}function vb(l){var t=l[0],e=l[1]/100,i=l[2]/100,n,o;return i===0?[0,0,0]:(i*=2,e*=i<=1?i:2-i,o=(i+e)/2,n=2*e/(i+e),[t,n*100,o*100])}function Ab(l){return ba(hu(l))}function Ib(l){return Pa(hu(l))}function xb(l){return ya(hu(l))}function cu(l){var t=l[0]/60,e=l[1]/100,u=l[2]/100,i=Math.floor(t)%6,n=t-Math.floor(t),o=255*u*(1-e),s=255*u*(1-e*n),a=255*u*(1-e*(1-n)),u=255*u;switch(i){case 0:return[u,a,o];case 1:return[s,u,o];case 2:return[o,u,a];case 3:return[o,s,u];case 4:return[a,o,u];case 5:return[u,o,s]}}function wb(l){var t=l[0],e=l[1]/100,i=l[2]/100,n,o;return o=(2-e)*i,n=e*i,n/=o<=1?o:2-o,n=n||0,o/=2,[t,n*100,o*100]}function Tb(l){return ba(cu(l))}function Ob(l){return Pa(cu(l))}function Bb(l){return ya(cu(l))}function Sa(l){var t=l[0]/360,e=l[1]/100,i=l[2]/100,n=e+i,o,s,a,u;switch(n>1&&(e/=n,i/=n),o=Math.floor(6*t),s=1-i,a=6*t-o,(o&1)!=0&&(a=1-a),u=e+a*(s-e),o){default:case 6:case 0:r=s,g=u,b=e;break;case 1:r=u,g=s,b=e;break;case 2:r=e,g=s,b=u;break;case 3:r=e,g=u,b=s;break;case 4:r=u,g=e,b=s;break;case 5:r=s,g=e,b=u;break}return[r*255,g*255,b*255]}function Lb(l){return pa(Sa(l))}function Gb(l){return uu(Sa(l))}function Rb(l){return Pa(Sa(l))}function Nb(l){return ya(Sa(l))}function Ca(l){var t=l[0]/100,e=l[1]/100,i=l[2]/100,n=l[3]/100,o,s,a;return o=1-Math.min(1,t*(1-n)+n),s=1-Math.min(1,e*(1-n)+n),a=1-Math.min(1,i*(1-n)+n),[o*255,s*255,a*255]}function Db(l){return pa(Ca(l))}function Fb(l){return uu(Ca(l))}function Vb(l){return ba(Ca(l))}function kb(l){return ya(Ca(l))}function lg(l){var t=l[0]/100,e=l[1]/100,i=l[2]/100,n,o,s;return n=t*3.2406+e*-1.5372+i*-.4986,o=t*-.9689+e*1.8758+i*.0415,s=t*.0557+e*-.204+i*1.057,n=n>.0031308?1.055*Math.pow(n,1/2.4)-.055:n=n*12.92,o=o>.0031308?1.055*Math.pow(o,1/2.4)-.055:o=o*12.92,s=s>.0031308?1.055*Math.pow(s,1/2.4)-.055:s=s*12.92,n=Math.min(Math.max(0,n),1),o=Math.min(Math.max(0,o),1),s=Math.min(Math.max(0,s),1),[n*255,o*255,s*255]}function ug(l){var t=l[0],e=l[1],i=l[2],n,o,s;return t/=95.047,e/=100,i/=108.883,t=t>.008856?Math.pow(t,1/3):7.787*t+16/116,e=e>.008856?Math.pow(e,1/3):7.787*e+16/116,i=i>.008856?Math.pow(i,1/3):7.787*i+16/116,n=116*e-16,o=500*(t-e),s=200*(e-i),[n,o,s]}function Mb(l){return Rh(ug(l))}function Gh(l){var t=l[0],e=l[1],i=l[2],n,o,s,a;return t<=8?(o=t*100/903.3,a=7.787*(o/100)+16/116):(o=100*Math.pow((t+16)/116,3),a=Math.pow(o/100,1/3)),n=n/95.047<=.008856?n=95.047*(e/500+a-16/116)/7.787:95.047*Math.pow(e/500+a,3),s=s/108.883<=.008859?s=108.883*(a-i/200-16/116)/7.787:108.883*Math.pow(a-i/200,3),[n,o,s]}function Rh(l){var t=l[0],e=l[1],i=l[2],n,o,s;return n=Math.atan2(i,e),o=n*360/2/Math.PI,o<0&&(o+=360),s=Math.sqrt(e*e+i*i),[t,s,o]}function hg(l){return lg(Gh(l))}function Nh(l){var t=l[0],e=l[1],i=l[2],n,o,s;return s=i/360*2*Math.PI,n=e*Math.cos(s),o=e*Math.sin(s),[t,n,o]}function Wb(l){return Gh(Nh(l))}function Hb(l){return hg(Nh(l))}function To(l){return Oh[l]}function zb(l){return pa(To(l))}function qb(l){return uu(To(l))}function Ub(l){return ba(To(l))}function jb(l){return Pa(To(l))}function Qb(l){return Lh(To(l))}function Xb(l){return Bh(To(l))}var Oh={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},cg={};for(Th in Oh)cg[JSON.stringify(Oh[Th])]=Th;var Th});var pg=Ri((_H,fg)=>{var Dh=gg(),Oo=function(){return new Ea};for(Ss in Dh)Oo[Ss+"Raw"]=function(l){return function(t){return typeof t=="number"&&(t=Array.prototype.slice.call(arguments)),Dh[l](t)}}(Ss),Fh=/(\w+)2(\w+)/.exec(Ss),du=Fh[1],mg=Fh[2],Oo[du]=Oo[du]||{},Oo[du][mg]=Oo[Ss]=function(l){return function(t){typeof t=="number"&&(t=Array.prototype.slice.call(arguments));var e=Dh[l](t);if(typeof e=="string"||e===void 0)return e;for(var i=0;i<e.length;i++)e[i]=Math.round(e[i]);return e}}(Ss);var Fh,du,mg,Ss,Ea=function(){this.convs={}};Ea.prototype.routeSpace=function(l,t){var e=t[0];return e===void 0?this.getValues(l):(typeof e=="number"&&(e=Array.prototype.slice.call(t)),this.setValues(l,e))};Ea.prototype.setValues=function(l,t){return this.space=l,this.convs={},this.convs[l]=t,this};Ea.prototype.getValues=function(l){var t=this.convs[l];if(!t){var e=this.space,i=this.convs[e];t=Oo[e][l](i),this.convs[l]=t}return t};["rgb","hsl","hsv","cmyk","keyword"].forEach(function(l){Ea.prototype[l]=function(t){return this.routeSpace(l,arguments)}});fg.exports=Oo});var Pg=Ri((e9,bg)=>{var Vh=pg();bg.exports=function(l){var t,e,i,n;if(t=/^((?:rgb|hs[lv]|cmyk|xyz|lab)a?)\s*\(([^\)]*)\)/.exec(l)){var o=t[1],s=o.replace(/a$/,""),a=s==="cmyk"?4:3;e=Vh[s],i=t[2].replace(/^\s+|\s+$/g,"").split(/\s*,\s*/).map(function(h,c){return/%$/.test(h)&&c===a?parseFloat(h)/100:(/%$/.test(h),parseFloat(h))}),o===s&&i.push(1),n=i[a]===void 0?1:i[a],i=i.slice(0,a),e[s]=function(){return i}}else if(/^#[A-Fa-f0-9]+$/.test(l)){var s=l.replace(/^#/,""),a=s.length;e=Vh.rgb,i=s.split(a===3?/(.)/:/(..)/),i=i.filter(Boolean).map(function(f){return parseInt(a===3?f+f:f,16)}),n=1,e.rgb=function(){return i},i[0]||(i[0]=0),i[1]||(i[1]=0),i[2]||(i[2]=0)}else e=Vh.keyword,e.keyword=function(){return l},i=l,n=1;var u={rgb:void 0,hsl:void 0,hsv:void 0,cmyk:void 0,keyword:void 0,hex:void 0};try{u.rgb=e.rgb(i)}catch{}try{u.hsl=e.hsl(i)}catch{}try{u.hsv=e.hsv(i)}catch{}try{u.cmyk=e.cmyk(i)}catch{}try{u.keyword=e.keyword(i)}catch{}return u.rgb&&(u.hex="#"+u.rgb.map(function(h){var c=h.toString(16);return c.length===1?"0"+c:c}).join("")),u.rgb&&(u.rgba=u.rgb.concat(n)),u.hsl&&(u.hsla=u.hsl.concat(n)),u.hsv&&(u.hsva=u.hsv.concat(n)),u.cmyk&&(u.cmyka=u.cmyk.concat(n)),u}});var Ni=class{bind(t){this.entity&&this.entity.setAttr(t,this)}constructor(t,e){this.entity=t,this.bind(e)}};var Ae=class{};Ae.GeomObjectIndex=0,Ae.DrawingObjectIndex=1,Ae.AlgorithmDataIndex=2,Ae.ViewerIndex=3;var ie=class extends Ni{constructor(e){super(e,Ae.GeomObjectIndex)}static getGeom(e){return e.getAttr(Ae.GeomObjectIndex)}get parent(){let e=this.entity.parent;return e?ie.getGeom(e):null}rebind(e){this.entity=e,this.bind(Ae.GeomObjectIndex)}*getAncestors(){let e=this.parent;for(;e!=null;)yield e,e=e.parent}};var Gu=class{static solve(t,e,i,n,o,s){let a=t*o-n*e;if(!(Math.abs(a)<Gu.eps))return{x:(i*o-s*e)/a,y:(t*s-n*i)/a}}},Tr=Gu;Tr.eps=1e-8;var Oa=class{},C=Oa;C.distanceEpsilonPrecision=6,C.mult=Math.pow(10,6),C.defaultLeafBoxesOffset=.5,C.lineSegmentThreshold=.05,C.intersectionEpsilon=1e-4,C.distanceEpsilon=Math.pow(10,-Oa.distanceEpsilonPrecision),C.squareOfDistanceEpsilon=Math.pow(10,-Oa.distanceEpsilonPrecision*2),C.tolerance=1e-8;function Oc(l,t){return(l?1:0)-(t?1:0)}function ce(l,t){let e=l-t;return e<0?-1:e===0?0:1}function Vo(l,t){let e=ce(l.y,t.y);return e||ce(l.x,t.x)}function Q(l,t){let e=l-t;return-C.distanceEpsilon<=e&&e<=C.distanceEpsilon}function Ba(l,t){return As(l,t)>0}function As(l,t){let e=l-t;return e<=-C.distanceEpsilon?-1:e>=C.distanceEpsilon?1:0}function pe(l,t){return l.sub(t).length}var d=class{static RoundPoint(t){return new d(d.RoundDouble(t.x),d.RoundDouble(t.y))}static RoundDouble(t){return Math.round(t*C.mult)/C.mult}toJSON(){return{x:this.x,y:this.y}}static fromJSON(t){return new d(t.x,t.y)}static ProjectionToLine(t,e,i){let n=e.sub(t),o=n.length;if(o<C.distanceEpsilon)return t;n=n.div(o);let s=i.sub(t).dot(n);return t.add(n.mul(s))}static RayIntersectsRayInteriors(t,e,i,n){let o=d.lineLineIntersection(t,t.add(e),i,i.add(n));if(!!o&&o.sub(t).dot(e.div(e.l1))>C.distanceEpsilon&&o.sub(i).dot(n.div(n.l1))>C.distanceEpsilon)return o}static IntervalIntersectsRay(t,e,i,n){let o=d.lineLineIntersection(t,e,i,i.add(n));if(!o)return;let s=t.sub(o),a=o.sub(e);if(!(s.dot(a)<=0)&&!(o.sub(i).dot(n)<0)&&s.dot(s)>C.squareOfDistanceEpsilon&&a.dot(a)>=C.squareOfDistanceEpsilon)return o}static PointToTheLeftOfLineOrOnLine(t,e,i){return d.signedDoubledTriangleArea(t,e,i)>=0}static PointToTheLeftOfLine(t,e,i){return d.signedDoubledTriangleArea(t,e,i)>0}static PointIsInsideCone(t,e,i,n){return d.PointToTheRightOfLineOrOnLine(t,e,i)&&d.PointToTheLeftOfLineOrOnLine(t,e,n)}static PointToTheRightOfLineOrOnLine(t,e,i){return d.signedDoubledTriangleArea(e,i,t)<=0}static PointToTheRightOfLine(t,e,i){return d.signedDoubledTriangleArea(e,i,t)<0}static closeIntersections(t,e){return d.close(t,e,C.intersectionEpsilon)}get l1(){return Math.abs(this.x_)+Math.abs(this.y_)}dot(t){return this.x*t.x+this.y*t.y}get x(){return this.x_}get y(){return this.y_}compareTo(t){let e=ce(this.x,t.x);return e!==0?e:ce(this.y,t.y)}toString(){return"("+this.x+","+this.y+")"}static close(t,e,i){return t.sub(e).length<=i}static closeSquare(t,e,i){let n=e.sub(t);return n.dot(n)<=i}static closeDistEps(t,e,i=C.distanceEpsilon){return t.sub(e).length<=i}normalize(){let t=this.length;return new d(this.x/t,this.y/t)}get length(){return Math.sqrt(this.x*this.x+this.y*this.y)}get lengthSquared(){return this.x*this.x+this.y*this.y}constructor(t,e){this.x_=t,this.y_=e}static middle(t,e){return t.add(e).div(2)}scale(t,e){return new d(this.x*t,this.y*e)}add(t){return new d(this.x+t.x,this.y+t.y)}sub(t){return new d(this.x-t.x,this.y-t.y)}mul(t){return new d(this.x*t,this.y*t)}div(t){return new d(this.x/t,this.y/t)}equal(t){return t.x===this.x&&t.y===this.y}neg(){return new d(-this.x,-this.y)}static lineLineIntersection(t,e,i,n){let o=e.sub(t),s=i.sub(n),a=i.sub(t),u=Tr.solve(o.x,s.x,a.x,o.y,s.y,a.y);if(u!==void 0)return t.add(o.mul(u.x))}static segSegIntersection(t,e,i,n){let o=e.sub(t),s=i.sub(n),a=i.sub(t),u=C.tolerance,h=Tr.solve(o.x,s.x,a.x,o.y,s.y,a.y);if(h!==void 0&&h.x>-u&&h.x<1+u&&h.y>-u&&h.y<1+u)return t.add(o.mul(h.x))}static parallelWithinEpsilon(t,e,i){let n=t.length,o=e.length;return n<i||o<i?!0:(t=t.div(n),e=e.div(o),Math.abs(-t.x*e.y+t.y*e.x)<i)}static crossProduct(t,e){return t.x*e.y-t.y*e.x}static dot(t,e){return t.x*e.x+t.y*e.y}static add(t,e){return t.add(e)}rotate90Ccw(){return new d(-this.y,this.x)}rotate90Cw(){return new d(this.y,-this.x)}clone(){return new d(this.x,this.y)}rotate(t){let e=Math.cos(t),i=Math.sin(t);return new d(e*this.x-i*this.y,i*this.x+e*this.y)}static mkPoint(t,e,i,n){return e.mul(t).add(n.mul(i))}static convSum(t,e,i){return e.add(i.sub(e).mul(t))}static anglePCP(t,e,i){return d.angle(t.sub(e),i.sub(e))}static angle(t,e){let i=t.x,n=t.y,o=e.x,s=e.y,a=i*s-n*o,u=i*o+n*s;if(Math.abs(u)<C.tolerance)return Math.abs(a)<C.tolerance?0:a<-C.tolerance?3*Math.PI/2:Math.PI/2;if(Math.abs(a)<C.tolerance)return u<-C.tolerance?Math.PI:0;let h=Math.atan2(a,u);return a>=-C.tolerance?h:Math.PI*2+h}static signedDoubledTriangleArea(t,e,i){return(e.x-t.x)*(i.y-t.y)-(i.x-t.x)*(e.y-t.y)}static getTriangleOrientation(t,e,i){let n=d.signedDoubledTriangleArea(t,e,i);return n>C.distanceEpsilon?1:n<-C.distanceEpsilon?0:2}static getTriangleOrientationWithIntersectionEpsilon(t,e,i){let n=d.signedDoubledTriangleArea(t,e,i);return n>C.intersectionEpsilon?1:n<-C.intersectionEpsilon?0:2}static ClosestPointAtLineSegment(t,e,i){let n=i.sub(e),o=t.sub(e),s=n.dot(o),a=n.dot(n);return s<=0+C.tolerance?e:a<=s+C.tolerance?i:e.add(n.mul(s/a))}static pointToTheLeftOfLineOrOnLine(t,e,i){return d.signedDoubledTriangleArea(t,e,i)>=0}static pointToTheLeftOfLine(t,e,i){return d.signedDoubledTriangleArea(t,e,i)>0}static pointToTheRightOfLineOrOnLine(t,e,i){return d.signedDoubledTriangleArea(e,i,t)<=0}static pointToTheRightOfLine(t,e,i){return d.signedDoubledTriangleArea(e,i,t)<0}static canProject(t,e,i){let n=i.sub(e);return!(t.sub(e).dot(n)<0||t.sub(i).dot(n)>0)}static distToLineSegment(t,e,i){let n=i.sub(e),o=t.sub(e),s,a;if((s=n.dot(o))<=C.tolerance)return{par:0,dist:o.length};if((a=n.dot(n))<=s+C.tolerance)return{par:1,dist:t.sub(i).length};let u=s/a;return{par:u,dist:e.add(n.mul(u)).length}}};var it=class{constructor(){this._next=null;this.prev=null}get point(){return this._point}set point(t){this._point=t}get next(){return this._next}set next(t){this._next=t}get nextOnPolyline(){return this.polyline.next(this)}get prevOnPolyline(){return this.polyline.prev(this)}getNext(){return this.next}setNext(t){this.next=t,this.polyline!=null&&this.polyline.setInitIsRequired()}getPrev(){return this.prev}setPrev(t){this.prev=t,this.polyline!=null&&this.polyline.setInitIsRequired()}static mkFromPoint(t){let e=new it;return e.point=t,e}};var ae=class{contains(t){let e=t.sub(this.corner),i=C.distanceEpsilon,n=e.dot(this.bRot);if(n>this.abRot+i||n<-i)return!1;let o=e.dot(this.aRot);return o<=this.baRot+i&&o>=-i}get area(){return Math.abs(this.a.x*this.b.y-this.a.y*this.b.x)}vertex(t){switch(t){case 0:return this.corner;case 1:return this.aPlusCorner;case 2:return this.otherCorner;case 3:return this.bPlusCorner;default:return}}static parallelogramOfTwo(t,e){let i=new ae,n=t.corner,o={minx:n.x,maxx:n.x,miny:n.y,maxy:n.y};return ae.pumpMinMax(o,t.aPlusCorner),ae.pumpMinMax(o,t.otherCorner),ae.pumpMinMax(o,t.bPlusCorner),ae.pumpMinMax(o,e.corner),ae.pumpMinMax(o,e.aPlusCorner),ae.pumpMinMax(o,e.otherCorner),ae.pumpMinMax(o,e.bPlusCorner),i.corner=new d(o.minx,o.miny),i.a=new d(0,o.maxy-o.miny),i.b=new d(o.maxx-o.minx,0),i.aPlusCorner=i.a.add(i.corner),i.otherCorner=i.b.add(i.aPlusCorner),i.bPlusCorner=i.b.add(i.corner),i.aRot=new d(-i.a.y,i.a.x),i.aRot.length>.5&&(i.aRot=i.aRot.normalize()),i.bRot=new d(-i.b.y,i.b.x),i.bRot.length>.5&&(i.bRot=i.bRot.normalize()),i.abRot=i.a.dot(i.bRot),i.baRot=i.b.dot(i.aRot),i.abRot<0&&(i.abRot=-i.abRot,i.bRot=i.bRot.neg()),i.baRot<0&&(i.baRot=-i.baRot,i.aRot=i.aRot.neg()),i.isSeg=i.a.sub(i.b).length<C.distanceEpsilon,i}static pumpMinMax(t,e){e.x<t.minx?t.minx=e.x:e.x>t.maxx&&(t.maxx=e.x),e.y<t.miny?t.miny=e.y:e.y>t.maxy&&(t.maxy=e.y)}static intersect(t,e){return!(ae.separByA(t,e)||ae.separByA(e,t)||ae.separByB(t,e)||ae.separByB(e,t))===!1?!1:!(t.isSeg&&e.isSeg)||!d.parallelWithinEpsilon(t.otherCorner.sub(t.corner),e.otherCorner.sub(e.corner),1e-5)?!0:ae.ParallelSegsIntersect(e,t)}static ParallelSegsIntersect(t,e){let i=t.corner,n=t.otherCorner,o=e.corner,s=e.otherCorner,a=n.sub(i),u=0,h=a.dot(a),c=o.sub(i).dot(a),f=s.sub(i).dot(a);if(c>f){let P=c;c=f,f=P}return!(f<u-C.distanceEpsilon||c>h+C.distanceEpsilon)}static separByB(t,e){let i=C.distanceEpsilon,n=e.vertex(0).sub(t.corner).dot(t.bRot),o=[1,2,3];if(n>t.abRot+i){for(let s of o)if(e.vertex(s).sub(t.corner).dot(t.bRot)<=t.abRot+i)return!1;return!0}else if(n<-i){for(let s of o)if(e.vertex(s).sub(t.corner).dot(t.bRot)>=-i)return!1;return!0}return!1}static separByA(t,e){let i=C.distanceEpsilon,n=e.corner.sub(t.corner),o=d.dot(n,t.aRot);return o>t.baRot+i?(n=e.aPlusCorner.sub(t.corner),!(d.dot(n,t.aRot)<=t.baRot+i||(n=e.bPlusCorner.sub(t.corner),d.dot(n,t.aRot)<=t.baRot+i)||(n=e.otherCorner.sub(t.corner),d.dot(n,t.aRot)<=t.baRot+i))):o<-i?(n=e.aPlusCorner.sub(t.corner),!(d.dot(n,t.aRot)>=-i||(n=e.bPlusCorner.sub(t.corner),d.dot(n,t.aRot)>=-i)||(n=e.otherCorner.sub(t.corner),d.dot(n,t.aRot)>=-i))):!1}static parallelogramByCornerSideSide(t,e,i){let n=new ae;return n.corner=t,n.a=e,n.b=i,n.aRot=new d(-e.y,e.x),n.aRot.length>.5&&(n.aRot=n.aRot.normalize()),n.bRot=new d(-i.y,i.x),n.bRot.length>.5&&(n.bRot=n.bRot.normalize()),n.abRot=n.bRot.dot(e),n.baRot=i.dot(n.aRot),n.abRot<0&&(n.abRot=-n.abRot,n.bRot=n.bRot.neg()),n.baRot<0&&(n.baRot=-n.baRot,n.aRot=n.aRot.neg()),n.isSeg=e.sub(i).length<C.distanceEpsilon,n.aPlusCorner=e.add(t),n.otherCorner=i.add(n.aPlusCorner),n.bPlusCorner=i.add(t),n}static getParallelogramOfAGroup(t){let e=0,i=0,n=0,o=0,s=!0;for(let a of t){let u=Bf(a);for(let h of u){let c=h.x,f=h.y;s?(s=!1,e=i=c,n=o=f):(c<e?e=c:c>i&&(i=c),f<n?n=f:f>o&&(o=f))}}return ae.parallelogramByCornerSideSide(new d(e,n),new d(0,o-n),new d(i-e,0))}};function*Bf(l){yield l.corner,yield l.aPlusCorner,yield l.otherCorner,yield l.bPlusCorner}var w=class{constructor(t,e,i,n){this.parStart=0;this.parEnd=1;this.start=new d(t,e),this.end=new d(i,n)}static fromJSON(t){return w.mkPP(d.fromJSON(t.start),d.fromJSON(t.end))}toJSON(){return{start:this.start.toJSON(),end:this.end.toJSON()}}offsetCurve(t,e){return null}trim(t,e){if(t=Math.max(this.parStart,t),e=Math.min(this.parEnd,e),t>e)throw"wrong params in trimming";let i=this.value(t),n=this.value(e);return d.close(i,n,C.distanceEpsilon)?null:w.mkPP(i,n)}value(t){return this.start.add(this.end.sub(this.start).mul(t))}trimWithWrap(t,e){return null}pNodeOverICurve(){let t=this.end.sub(this.start).mul(.5);return{parallelogram:ae.parallelogramByCornerSideSide(this.start,t,t),seg:this,leafBoxesOffset:0,node:{low:0,high:1,chord:this}}}normal(){let t=this.start.sub(this.end);return t=t.div(t.length),new d(-t.y,t.x)}static mkPP(t,e){return new w(t.x,t.y,e.x,e.y)}static mkLinePXY(t,e,i){return new w(t.x,t.y,e,i)}derivative(t){return this.end.sub(this.start)}secondDerivative(t){return new d(0,0)}thirdDerivative(t){return new d(0,0)}reverse(){return w.mkPP(this.end,this.start)}translate(t){this.start=this.start.add(t),this.end=this.end.add(t)}scaleFromOrigin(t,e){return w.mkPP(this.start.scale(t,e),this.end.scale(t,e))}getParameterAtLength(t){let e=this.end.sub(this.start).length;if(e<C.tolerance)return 0;let i=t/e;return i>1?1:i<0?0:i}transform(t){return w.mkPP(t.multiplyPoint(this.start),t.multiplyPoint(this.end))}closestParameterWithinBounds(t,e,i){let n=this.closestParameter(t);return n<e&&(n=e),n>i&&(n=i),n}lengthPartial(t,e){return this.value(e).sub(this.value(t)).length}get length(){return this.start.sub(this.end).length}get boundingBox(){return D.mkPP(this.start,this.end)}clone(){return w.mkPP(this.start.clone(),this.end.clone())}static closestParameterOnLineSegment(t,e,i){let n=i.sub(e),o=t.sub(e),s=n.dot(o);if(s<=0+C.tolerance)return 0;let a=n.dot(n);return a<=s+C.tolerance?1:s/a}closestParameter(t){return w.closestParameterOnLineSegment(t,this.start,this.end)}leftDerivative(t){return this.derivative(t)}rightDerivative(t){return this.derivative(t)}static IntersectPPPP(t,e,i,n){let o=d.lineLineIntersection(t,e,i,n);if(o!=null&&ko(o,t,e)&&ko(o,i,n))return o}curvature(t){return 0}curvatureDerivative(t){return 0}curvatureSecondDerivative(t){return 0}static minDistBetweenLineSegments(t,e,i,n){let o=e.sub(t),s=n.sub(i),a=t.sub(i),u=d.crossProduct(o,s),h=o.dot(o),c=o.dot(s),f=s.dot(s),P=o.dot(a),v=s.dot(a),A,O,M=Math.abs(u),z=M,$=M;M<C.tolerance?(A=0,z=1,O=v,$=f):(A=d.crossProduct(s,a),O=d.crossProduct(o,a),u<0&&(A=-A,O=-O),A<0?(A=0,O=v,$=f):A>z&&(A=z=1,O=v+c,$=f)),O<0?(O=0,-P<0?A=0:-P>h?A=z:(A=-P,z=h)):O>$&&(O=$=1,-P+c<0?A=0:-P+c>h?A=z:(A=-P+c,z=h));let N=Math.abs(A)<C.tolerance?0:A/z,q=Math.abs(O)<C.tolerance?0:O/$;return{parab:N,parcd:q,dist:a.add(o.mul(N).sub(s.mul(q))).length}}};function ko(l,t,e){return l.x>=Math.min(t.x,e.x)-C.distanceEpsilon&&l.y>=Math.min(t.y,e.y)-C.distanceEpsilon&&l.x<=Math.max(t.x,e.x)+C.distanceEpsilon&&l.y<=Math.max(t.y,e.y)+C.distanceEpsilon}function La(l,t,e,i){let n=d.getTriangleOrientation(l,t,e),o=d.getTriangleOrientation(l,t,i),s=d.getTriangleOrientation(e,i,l),a=d.getTriangleOrientation(e,i,t);return!!(n!=o&&s!=a||n==2&&ko(e,l,t)||o==2&&ko(i,l,t)||s==2&&ko(l,e,i)||a==2&&ko(t,e,i))}function Lf(l,t,e,i,n){return{parallelogram:e,seg:i,leafBoxesOffset:n,node:{low:l,high:t,chord:null}}}var Ve=class{static distToSegm(t,e,i){let n=i.sub(e);if(n.length<C.intersectionEpsilon)return t.sub(e.add(i).div(2)).length;let o=new d(-n.y,n.x);return o=o.mul(1/o.length),Math.abs(t.sub(e).dot(o))}static createParallelogramOnSubSeg(t,e,i){let n=i.derivative(t),o=i.derivative(e),s=new d(-o.y,o.x),a=i.value(t),u=i.value(e),c=u.sub(a).dot(s),f=n.dot(s),P=Math.abs(c)<C.distanceEpsilon;if(!P&&Math.abs(f)<C.distanceEpsilon)return;let v=P?0:c/f;return n=n.mul(v),ae.parallelogramByCornerSideSide(a,n,u.sub(a).sub(n))}static createParallelogramNodeForCurveSeg(t,e,i,n){if(t===i.parStart&&e===i.parEnd&&d.close(i.start,i.end,C.distanceEpsilon))return Ve.createNodeWithSegmentSplit(t,e,i,n);let s=i.value(t),a=i.value(e),u=a.sub(s),h=i.value((t+e)/2);if(Ve.distToSegm(h,s,a)<=C.intersectionEpsilon&&u.dot(u)<C.lineSegmentThreshold*C.lineSegmentThreshold&&e-t<C.lineSegmentThreshold){let c=w.mkPP(s,a),f=c.pNodeOverICurve();f.seg=i;let P=f.node;return P.low=t,P.high=e,P.chord=c,f}if(Ve.WithinEpsilon(i,t,e,n)){let c=Ve.createParallelogramOnSubSeg(t,e,i);if(c!==void 0)return Lf(t,e,c,i,n)}return Ve.createNodeWithSegmentSplit(t,e,i,n)}static WithinEpsilon(t,e,i,n){let s=(i-e)/3,a=t.value(e),u=t.value(i);return Ve.distToSegm(t.value(e+s),a,u)>n?!1:Ve.distToSegm(t.value(e+s*(3-1)),a,u)<=n}static createParallelogramNodeForCurveSegDefaultOffset(t){return Ve.createParallelogramNodeForCurveSeg(t.parStart,t.parEnd,t,C.defaultLeafBoxesOffset)}static createNodeWithSegmentSplit(t,e,i,n){let o={parallelogram:null,seg:i,leafBoxesOffset:1,node:{children:[]}},s=o.node;return s.children.push(Ve.createParallelogramNodeForCurveSeg(t,.5*(t+e),i,n)),s.children.push(Ve.createParallelogramNodeForCurveSeg(.5*(t+e),e,i,n)),o.parallelogram=ae.parallelogramOfTwo(s.children[0].parallelogram,s.children[1].parallelogram),o}};var Or=class{constructor(t,e,i,n,o){this.par0=t,this.par1=e,this.x=i,this.seg0=n,this.seg1=o}};var on=class{static closestPoint(t,e,i,n,o){let u=i,h=0,c=0,f,P=!1;do{let v=t.value(u),A=t.derivative(u),O=t.secondDerivative(u),M=A.dot(A)+v.sub(e).dot(O);if(Math.abs(M)<C.tolerance)return u;f=v.sub(e).dot(A.div(M)),u-=f,u>o+C.tolerance?(u=o,c++):u<n-C.tolerance&&(u=n,c++),h++}while(Math.abs(f)>C.tolerance&&!(P=h>=5||c>=5));return P&&t.value(i).sub(e).length<C.distanceEpsilon&&(u=i),u}};var ee=class{isFullEllipse(){return this.parEnd===Math.PI*2&&this.parStart===0}static fromJSON(t){return new ee(t.parStart,t.parEnd,d.fromJSON(t.axis0),d.fromJSON(t.axis1),d.fromJSON(t.center))}toJSON(){return{parStart:this.parStart,parEnd:this.parEnd,axis0:this.aAxis.toJSON(),axis1:this.bAxis.toJSON(),center:this.center.toJSON()}}offsetCurve(t,e){let i=e.sub(this.center),n=d.angle(this.aAxis,i);if(this.aAxis.mul(Math.cos(n)).add(this.bAxis.mul(Math.sin(n))).length<i.length){let s=this.aAxis.length,a=this.bAxis.length;return ee.mkEllipsePPP(this.aAxis.normalize().mul(s+t),this.bAxis.normalize().mul(a+t),this.center)}{let s=this.aAxis.length,a=this.bAxis.length;return ee.mkEllipsePPP(this.aAxis.normalize().mul(s-t),this.bAxis.normalize().mul(a-t),this.center)}}reverse(){return null}static mkEllipsePPP(t,e,i){return new ee(0,Math.PI*2,t,e,i)}constructor(t,e,i,n,o){for(this.parStart=t,this.parEnd=e,this.aAxis=i,this.bAxis=n,this.center=o,this.pNode=null,this.setBoundingBox();this.parStart<0;)this.parStart+=Math.PI*2,this.parEnd+=Math.PI*2}get start(){return this.value(this.parStart)}get end(){return this.value(this.parEnd)}trim(t,e){return new ee(Math.max(t,this.parStart),Math.min(e,this.parEnd),this.aAxis,this.bAxis,this.center)}trimWithWrap(t,e){return null}get boundingBox(){return this.box}value(t){return this.center.add(d.mkPoint(Math.cos(t),this.aAxis,Math.sin(t),this.bAxis))}derivative(t){return d.mkPoint(-Math.sin(t),this.aAxis,Math.cos(t),this.bAxis)}secondDerivative(t){return d.mkPoint(-Math.cos(t),this.aAxis,-Math.sin(t),this.bAxis)}thirdDerivative(t){return d.mkPoint(Math.sin(t),this.aAxis,-Math.cos(t),this.bAxis)}pNodeOverICurve(){return this.pNode!=null?this.pNode:this.pNode=Ve.createParallelogramNodeForCurveSegDefaultOffset(this)}setBoundingBox(){if(Q(this.parStart,0)&&Q(this.parEnd,Math.PI*2))this.box=this.fullBox();else{this.box=D.mkPP(this.start,this.end);let t;for(let e=Math.ceil(this.parStart/(Math.PI/2));(t=e*Math.PI/2)<this.parEnd;e++)t>this.parStart&&this.box.add(this.value(t))}}static mkEllipse(t,e,i,n,o,s){return new ee(t,e,i,n,new d(o,s))}static mkFullEllipsePPP(t,e,i){return new ee(0,Math.PI*2,t,e,i)}static mkFullEllipseNNP(t,e,i){return new ee(0,Math.PI*2,new d(t,0),new d(0,e),i)}static mkCircle(t,e){return ee.mkFullEllipseNNP(t,t,e)}translate(t){this.center=this.center.add(t),this.box.center=this.box.center.add(t),this.pNode=null}scaleFromOrigin(t,e){return new ee(this.parStart,this.parEnd,this.aAxis.mul(t),this.bAxis.mul(e),this.center.scale(t,e))}getParameterAtLength(t){let i=this.parStart,n=this.parEnd,o=t+.001,s=t-.001;for(;n-i>C.distanceEpsilon;){let a=.5*(n+i),u=this.lengthPartial(this.parStart,a);if(u>o)n=a;else if(u<s)i=a;else return a}return(n+i)/2}transform(t){if(t!=null){let e=t.multiplyPoint(this.aAxis).sub(t.offset()),i=t.multiplyPoint(this.bAxis).sub(t.offset());return new ee(this.parStart,this.parEnd,e,i,t.multiplyPoint(this.center))}return this.clone()}closestParameterWithinBounds(t,e,i){let o=(i-e)/9,s=e,a=Number.MAX_VALUE;for(let h=0;h<=8;h++){let c=e+h*o,f=t.sub(this.value(c)),P=f.dot(f);P<a&&(a=P,s=c)}s===0&&i===Math.PI*2&&(e=-Math.PI);let u=on.closestPoint(this,t,s,e,i);return u<0&&(u+=2*Math.PI),u}lengthPartial(t,e){return E.lengthWithInterpolationAndThreshold(this.trim(t,e),C.lineSegmentThreshold/100)}get length(){return(this.aAxis.length+this.bAxis.length)*Math.abs(this.parEnd-this.parStart)/2}clone(){return new ee(this.parStart,this.parEnd,this.aAxis.clone(),this.bAxis.clone(),this.center.clone())}closestParameter(t){let e=0,i=8,n=(this.parEnd-this.parStart)/(i+1),o=this.parStart,s=Number.MAX_VALUE;for(let h=0;h<=i;h++){let c=this.parStart+h*n,f=t.sub(this.value(c)),P=f.dot(f);P<s&&(s=P,o=c)}let a=!1;o===0&&this.parEnd===Math.PI*2&&(a=!0,e=this.parStart,this.parStart=-Math.PI);let u=on.closestPoint(this,t,o,this.parStart,this.parEnd);return u<0&&(u+=2*Math.PI),a&&(this.parStart=e),u}leftDerivative(t){return this.derivative(t)}rightDerivative(t){return this.derivative(t)}curvature(t){throw"NotImplementedException()"}curvatureDerivative(t){throw"NotImplementedException();"}curvatureSecondDerivative(t){throw"NotImplementedException()"}orientedCounterclockwise(){return d.crossProduct(this.aAxis,this.bAxis)>0}fullBox(){let t=this.aAxis.add(this.bAxis);return D.mkPP(this.center.add(t),this.center.sub(t))}isArc(){return Math.abs(this.aAxis.dot(this.bAxis))<C.tolerance&&Math.abs(this.aAxis.length-this.bAxis.length)<C.tolerance&&d.closeDistEps(this.aAxis.rotate90Ccw(),this.bAxis)}};var Ga=class{initValues(){this.a=this.curveA.value(this.si),this.b=this.curveB.value(this.ti),this.a_b=this.a.sub(this.b),this.ad=this.curveA.derivative(this.si),this.add=this.curveA.secondDerivative(this.si),this.bd=this.curveB.derivative(this.ti),this.bdd=this.curveB.secondDerivative(this.ti)}constructor(t,e,i,n,o,s,a,u){this.curveA=t,this.curveB=e,this.aMin=i,this.bMin=o,this.aMax=n,this.bMax=s,this.aGuess=a,this.bGuess=u,this.si=a,this.ti=u}Fs(){return this.a_b.dot(this.ad)}Fss(){return this.a_b.dot(this.add)+this.ad.dot(this.ad)}Fst(){return-this.bd.dot(this.ad)}Ftt(){return-this.a_b.dot(this.bdd)+this.bd.dot(this.bd)}Ft(){return-this.a_b.dot(this.bd)}delta(t,e,i,n){return t*n-i*e}solve(){let t=0,e=10,i=0,n=100,o=!1;if(this.initValues(),this.curveA instanceof w&&this.curveB instanceof w){let a=this.curveB.derivative(0);a=a.div(a.length);let u=this.curveA.normal(),h=Math.abs(u.dot(a));if(Math.abs(h)<C.distanceEpsilon||this.delta(this.Fss(),this.Fst(),this.Fst(),this.Ftt())<C.tolerance){this.success=!0,this.parallelLineSegLineSegMinDist();return}}let s;do{let a=this.delta(this.Fss(),this.Fst(),this.Fst(),this.Ftt());if(Math.abs(a)<C.tolerance){this.success=!1,o=!0;break}s={s:this.delta(-this.Fs(),this.Fst(),-this.Ft(),this.Ftt())/a,t:this.delta(this.Fss(),-this.Fs(),this.Fst(),-this.Ft())/a};let u=this.si+s.s,h=this.ti+s.t,c;u>this.aMax+C.distanceEpsilon||u<this.aMin-C.distanceEpsilon||h>this.bMax+C.distanceEpsilon||h<this.bMin-C.distanceEpsilon?(t++,this.chopDsDt(s),this.si+=s.s,this.ti+=s.t,c=!0):(c=!1,this.si=u,this.ti=h,this.si>this.aMax?this.si=this.aMax:this.si<this.aMin&&(this.si=this.aMin),this.ti>this.bMax?this.ti=this.bMax:this.ti<this.bMin&&(this.ti=this.bMin)),this.initValues(),i++,o=t>=e||i>=n||s.s===0&&s.t===0&&c}while((Math.abs(s.s)>=C.tolerance||Math.abs(s.t)>=C.tolerance)&&!o);if(o){let a=this.curveA.value(this.aGuess).sub(this.curveB.value(this.bGuess));if(a.dot(a)<C.distanceEpsilon*C.distanceEpsilon){this.aSolution=this.aGuess,this.bSolution=this.bGuess,this.aPoint=this.curveA.value(this.aGuess),this.bPoint=this.curveB.value(this.bGuess),this.success=!0;return}}this.aSolution=this.si,this.bSolution=this.ti,this.aPoint=this.a,this.bPoint=this.b,this.success=!o}chopDsDt(t){if(t.s!==0&&t.t!==0){let e=1;this.si+t.s>this.aMax?e=(this.aMax-this.si)/t.s:this.si+t.s<this.aMin&&(e=(this.aMin-this.si)/t.s);let i=1;this.ti+t.t>this.bMax?i=(this.bMax-this.ti)/t.t:this.ti+t.t<this.bMin&&(i=(this.bMin-this.ti)/t.t);let n=Math.min(e,i);t.s*=n,t.t*=n}else t.s===0?this.ti+t.t>this.bMax?t.t=this.bMax-this.ti:this.ti+t.t<this.bMin&&(t.t=this.bMin-this.ti):this.si+t.s>this.aMax?t.s=this.aMax-this.si:this.si+t.s<this.aMin&&(t.s=this.aMin-this.si)}parallelLineSegLineSegMinDist(){let t=this.curveA,e=this.curveB,i=t.start,n=t.end,o=e.start,s=e.end,a=n.sub(i),u=a.length,h=0,c,f,P;if(u>C.distanceEpsilon){a=a.div(u),c=a.dot(n.sub(i)),f=a.dot(o.sub(i)),P=a.dot(s.sub(i));let v=!1;if(f>P){v=!0;let A=f;f=P,P=A}if(P<h)this.aSolution=0,this.bSolution=v?0:1;else if(f>c)this.aSolution=1,this.bSolution=v?1:0;else{let A=Math.min(c,P);this.aSolution=A/(c-h),this.bSolution=(A-f)/(P-f),v&&(this.bSolution=1-this.bSolution)}}else{let v=s.sub(o),A=v.length;if(A>C.distanceEpsilon)if(v=v.div(A),h=0,c=v.dot(s.sub(o)),f=v.dot(i.sub(o)),f<h)this.bSolution=0,this.aSolution=1;else if(f>c)this.bSolution=1,this.aSolution=0;else{let O=Math.min(c,f);this.bSolution=O/(c-h),this.aSolution=0}else this.aSolution=0,this.bSolution=0}this.aPoint=this.curveA.value(this.aSolution),this.bPoint=this.curveB.value(this.bSolution)}};var be=class{constructor(t,e,i,n){this.b=new Array(4);this.parStart=0;this.parEnd=1;this.b[0]=t,this.b[1]=e,this.b[2]=i,this.b[3]=n,this.c=this.b[1].sub(this.b[0]).mul(3),this.e=this.b[2].sub(this.b[1]).mul(3).sub(this.c),this.l=this.b[3].sub(this.b[0]).sub(this.c).sub(this.e)}toJSON(){return{b:this.b.map(t=>t.toJSON())}}static fromJSON(t){return be.mkBezier(t.b.map(d.fromJSON))}leftDerivative(t){return this.derivative(t)}rightDerivative(t){return this.derivative(t)}B(t){return this.b[t]}pNodeOverICurve(){return this.pBoxNode!=null?this.pBoxNode:this.pBoxNode=Ve.createParallelogramNodeForCurveSegDefaultOffset(this)}value(t){let e=t*t,i=e*t;return this.l.mul(i).add(this.e.mul(e).add(this.c.mul(t)).add(this.b[0]))}static adjustParamTo01(t){return t>1?1:t<0?0:t}trim(t,e){if(t=be.adjustParamTo01(t),e=be.adjustParamTo01(e),t>e)return this.trim(e,t);if(t>1-C.tolerance)return new be(this.b[3],this.b[3],this.b[3],this.b[3]);let i=new Array(3),n=new Array(2),o=this.casteljau(t,i,n),s=new be(o,n[1],i[2],this.b[3]),a=s.casteljau((e-t)/(1-t),i,n);return new be(s.b[0],i[0],n[0],a)}trimWithWrap(t,e){throw"NotImplementedException()"}casteljau(t,e,i){let n=1-t;for(let o=0;o<3;o++)e[o]=d.mkPoint(n,this.b[o],t,this.b[o+1]);for(let o=0;o<2;o++)i[o]=d.mkPoint(n,e[o],t,e[o+1]);return d.mkPoint(n,i[0],t,i[1])}derivative(t){return this.l.mul(3*t*t).add(this.e.mul(2*t)).add(this.c)}secondDerivative(t){return d.mkPoint(6*t,this.l,2,this.e)}thirdDerivative(t){return this.l.mul(6)}get start(){return this.b[0]}get end(){return this.b[3]}reverse(){return new be(this.b[3],this.b[2],this.b[1],this.b[0])}translate(t){this.b[0]=this.b[0].add(t),this.b[1]=this.b[1].add(t),this.b[2]=this.b[2].add(t),this.b[3]=this.b[3].add(t),this.c=this.b[1].sub(this.b[0]).mul(3),this.e=this.b[2].sub(this.b[1]).mul(3).sub(this.c),this.l=this.b[3].sub(this.b[0]).sub(this.c).sub(this.e),this.bbox&&(this.bbox=D.translate(this.bbox,t)),this.pBoxNode=null}scaleFromOrigin(t,e){return new be(this.b[0].scale(t,e),this.b[1].scale(t,e),this.b[2].scale(t,e),this.b[3].scale(t,e))}offsetCurve(t,e){return null}lengthPartial(t,e){return this.trim(t,e).length}get length(){return be.lengthOnControlPolygon(this.b[0],this.b[1],this.b[2],this.b[3])}static lengthOnControlPolygon(t,e,i,n){let o=n.sub(t).length,s=e.sub(t).length+i.sub(e).length+n.sub(i).length;if(s-o>C.lineSegmentThreshold){let a=d.middle(t,e),u=d.middle(e,i),h=d.middle(i,n),c=d.middle(a,u),f=d.middle(h,u),P=d.middle(c,f);return be.lengthOnControlPolygon(t,a,c,P)+be.lengthOnControlPolygon(P,f,h,n)}return(s+o)/2}get boundingBox(){return this.bbox?this.bbox:this.bbox=D.mkOnPoints(this.b)}transform(t){return new be(t.multiplyPoint(this.b[0]),t.multiplyPoint(this.b[1]),t.multiplyPoint(this.b[2]),t.multiplyPoint(this.b[3]))}closestParameterWithinBounds(t,e,i){let n=(i-e)/8,o=0,s=Number.MAX_VALUE;for(let a=0;a<9;a++){let u=t.sub(this.value(a*n+e)),h=u.dot(u);h<s&&(s=h,o=a*n+e)}return on.closestPoint(this,t,o,e,i)}clone(){return new be(this.b[0],this.b[1],this.b[2],this.b[3])}static mkBezier(t){return new be(t[0],t[1],t[2],t[3])}curvature(t){let e=this.G(t);return this.F(t)/e}F(t){return this.Xp(t)*this.Ypp(t)-this.Yp(t)*this.Xpp(t)}G(t){let e=this.Xp(t),i=this.Yp(t),n=e*e+i*i;return Math.sqrt(n*n*n)}Xp(t){return 3*this.l.x*t*t+2*this.e.x*t+this.c.x}Ypp(t){return 6*this.l.y*t+2*this.e.y}Yp(t){return 3*this.l.y*t*t+2*this.e.y*t+this.c.y}Xpp(t){return 6*this.l.x*t+2*this.e.x}Xppp(t){return 6*this.l.x}Yppp(t){return 6*this.l.y}curvatureDerivative(t){let e=this.G(t);return(this.Fp(t)*e-this.Gp(t)*this.F(t))/(e*e)}Fp(t){return this.Xp(t)*this.Yppp(t)-this.Yp(t)*this.Xppp(t)}Fpp(t){return this.Xpp(t)*this.Yppp(t)-this.Ypp(t)*this.Xppp(t)}closestParameter(t){let i=0,n=Number.MAX_VALUE;for(let o=0;o<9;o++){let s=t.sub(this.value(o*.125)),a=s.dot(s);a<n&&(n=a,i=o*.125)}return on.closestPoint(this,t,i,0,1)}curvatureSecondDerivative(t){let e=this.G(t);return(this.Qp(t)*e-2*this.Q(t)*this.Gp(t))/(e*e*e)}Q(t){return this.Fp(t)*this.G(t)-this.Gp(t)*this.F(t)}Qp(t){return this.Fpp(t)*this.G(t)-this.Gpp(t)*this.F(t)}Gpp(t){let e=this.Xp(t),i=this.Yp(t),n=this.Xpp(t),o=this.Ypp(t),s=this.Xppp(t),a=this.Yppp(t),u=Math.sqrt(e*e+i*i),h=e*n+i*o;return 3*(h*h/u+u*(n*n+e*s+o*o+i*a))}Gp(t){let e=this.Xp(t),i=this.Yp(t),n=this.Xpp(t),o=this.Ypp(t);return 3*Math.sqrt(e*e+i*i)*(e*n+i*o)}getParameterAtLength(t){let e=0,i=1;for(;i-e>C.tolerance;){let n=(i+e)/2,o=this.evaluateError(t,n);if(o>0)i=n;else if(o<0)e=n;else return n}return(e+i)/2}evaluateError(t,e){let i=1-e,n=d.mkPoint(i,this.b[0],e,this.b[1]),o=d.mkPoint(i,this.b[1],e,this.b[2]),s=d.mkPoint(i,this.b[2],e,this.b[3]),a=d.mkPoint(i,n,e,o),u=d.mkPoint(i,o,e,s),h=d.mkPoint(i,a,e,u),c=be.lengthOnControlPolygon(this.b[0],n,a,h);return c>t+C.distanceEpsilon?1:c<t-C.distanceEpsilon?-1:0}};function Gf(l){return l.seg.value(l.par)}function Rf(l){return l.seg.derivative(l.par)}function Nf(l){return l.seg.secondDerivative(l.par)}function Df(l){return l.seg.thirdDerivative(l.par)}function Ff(l){if(l instanceof ee)return{tag:"ellipse",segData:l.toJSON()};if(l instanceof w)return{tag:"lineSegment",segData:l.toJSON()};if(l instanceof be)return{tag:"bezier",segData:l.toJSON()};throw new Error("not implemented")}var E=class{static fromJSON(t){let e=new E;for(let i of t.segs)switch(i.tag){case"bezier":e.addSegment(be.fromJSON(i.segData));break;case"ellipse":e.addSegment(ee.fromJSON(i.segData));break;case"lineSegment":e.addSegment(w.fromJSON(i.segData));break;default:throw new Error("not implemented")}return e}toJSON(){return{segs:this.segs.map(t=>Ff(t))}}static CurvesIntersect(t,e){return t===e||E.intersectionOne(t,e,!1)!=null}static lengthWithInterpolationAndThreshold(t,e){throw new Error("not implemented")}static lengthWithInterpolation(t){throw"not implemented"}get parStart(){return 0}get parEnd(){return this.parEnd_}lengthPartial(t,e){let i={start:t,end:e};this.adjustStartEndEndParametersToDomain(i);let n=this.getSegIndexParam(t),o=this.getSegIndexParam(e);if(n.segIndex<o.segIndex){let s=this.segs[n.segIndex],a=s.lengthPartial(n.par,s.parEnd);for(let u=n.segIndex+1;u<o.segIndex;u++)a+=this.segs[u].length;return s=this.segs[o.segIndex],a+s.lengthPartial(s.parStart,o.par)}else throw new Error("not implemented.")}reverse(){let t=new E;for(let e=this.segs.length-1;e>=0;e--)t.addSegment(this.segs[e].reverse());return t}constructor(){this.segs=[],this.parEnd_=0}mkCurveWithSegs(t){this.segs=t;for(let e of t)this.parEnd_+=E.paramSpan(e)}get start(){return this.segs[0].start}get end(){return this.segs[this.segs.length-1].end}scaleFromOrigin(t,e){let i=new E;for(let n of this.segs)i.addSegment(n.scaleFromOrigin(t,e));return i}trim(t,e){let i={start:t,end:e};this.adjustStartEndEndParametersToDomain(i);let n=this.getSegIndexParam(i.start),o=this.getSegIndexParam(i.end);if(n.segIndex===o.segIndex)return this.segs[n.segIndex].trim(n.par,o.par);let s=new E;n.par<this.segs[n.segIndex].parEnd&&(s=s.addSegment(this.segs[n.segIndex].trim(n.par,this.segs[n.segIndex].parEnd)));for(let a=n.segIndex+1;a<o.segIndex;a++)s=s.addSegment(this.segs[a]);return this.segs[o.segIndex].parStart<o.par&&(s=s.addSegment(this.segs[o.segIndex].trim(this.segs[o.segIndex].parStart,o.par))),s}translate(t){for(let e of this.segs)e.translate(t);this.boundingBox_&&(this.boundingBox_=D.translate(this.boundingBox_,t)),this.pBNode=null}adjustStartEndEndParametersToDomain(t){if(t.start>t.end){let e=t.start;t.start=t.end,t.end=e}t.start<this.parStart&&(t.start=this.parStart),t.end>this.parEnd&&(t.end=this.parEnd)}trimWithWrap(t,e){if(t<e)return this.trim(t,e);let i=new E;return i.addSegment(this.trim(t,this.parEnd)),i.addSegment(this.trim(this.parStart,e)),i}addSegs(t){for(let e of t)this.addSegment(e);return this}addSegment(t){if(t==null)return this;if(this.boundingBox_=null,!(t instanceof E))this.segs.push(t),this.parEnd_+=E.paramSpan(t);else for(let e of t.segs)this.segs.push(e),this.parEnd_+=E.paramSpan(e);return this}pNodeOverICurve(){if(this.pBNode!=null)return this.pBNode;let t=[],e=[];for(let i of this.segs){let n=i.pNodeOverICurve();t.push(n.parallelogram),e.push(n)}return this.pBNode={parallelogram:ae.getParallelogramOfAGroup(t),seg:this,leafBoxesOffset:C.defaultLeafBoxesOffset,node:{children:e}},this.pBNode}static intersectionOne(t,e,i){let n=E.curveCurveXWithParallelogramNodesOne(t.pNodeOverICurve(),e.pNodeOverICurve());return i&&n!=null&&(n=E.liftIntersectionToCurves(t,e,n)),n}static getAllIntersections(t,e,i){return t instanceof w?E.getAllIntersectionsOfLineAndICurve(t,e,i):E.getAllIntersectionsInternal(t,e,i)}static getAllIntersectionsInternal(t,e,i){let n=[];if(E.curveCurveXWithParallelogramNodes(t.pNodeOverICurve(),e.pNodeOverICurve(),n),i)for(let o=0;o<n.length;o++)n[o]=E.liftIntersectionToCurves(t,e,n[o]);return n}static getAllIntersectionsOfLineAndICurve(t,e,i){return e instanceof j?E.getAllIntersectionsOfLineAndPolyline(t,e):e instanceof E?E.getAllIntersectionsOfLineAndCurve(t,e,i):e instanceof ee&&e.isArc()?E.getAllIntersectionsOfLineAndArc(t,e):E.getAllIntersectionsInternal(t,e,i)}static getAllIntersectionsOfLineAndCurve(t,e,i){let n=[],o=t.pNodeOverICurve(),s=e.pNodeOverICurve();if(ae.intersect(o.parallelogram,s.parallelogram)===!1)return n;let a=0;for(let u of e.segs){let h=E.getAllIntersections(t,u,!1);if(i){for(let c of h)c.par1+=a-u.parStart,c.seg1=e;a+=u.parEnd-u.parStart}for(let c of h)E.alreadyInside(n,c)||n.push(c)}return n}static closeIntersections(t,e){return d.close(t.x,e.x,C.intersectionEpsilon)}static closeIntersectionPoints(t,e){return d.close(t,e,C.intersectionEpsilon)}static alreadyInside(t,e){for(let i=0;i<t.length;i++){let n=t[i];if(E.closeIntersections(n,e))return!0}return!1}static getAllIntersectionsOfLineAndArc(t,e){let i=t.end.sub(t.start),n=[],o=i.length;if(o<C.distanceEpsilon){let f=t.start.sub(e.center);if(Q(f.length,e.aAxis.length)){let P=d.angle(e.aAxis,f);e.parStart-C.tolerance<=P&&(P=Math.max(P,e.parStart),P<=e.parEnd+C.tolerance&&(P=Math.min(e.parEnd,P),n.push(new Or(0,P,t.start,t,e))))}return n}let s=i.rotate90Ccw().div(o),a=t.start.sub(e.center).dot(s),u=e.center.add(s.mul(a)),h=e.aAxis.length,c=Math.abs(a);if(h<c-C.distanceEpsilon)return n;if(i=s.rotate90Cw(),Q(h,c))E.tryToAddPointToLineCircleCrossing(t,e,n,u,o,i);else{let f=Math.sqrt(h*h-a*a),P=i.mul(f);E.tryToAddPointToLineCircleCrossing(t,e,n,u.add(P),o,i),E.tryToAddPointToLineCircleCrossing(t,e,n,u.sub(P),o,i)}return n}static tryToAddPointToLineCircleCrossing(t,e,i,n,o,s){let u=n.sub(t.start).dot(s);if(u<-C.distanceEpsilon||(u=Math.max(u,0),u>o+C.distanceEpsilon))return;u=Math.min(u,o),u/=o;let h=d.angle(e.aAxis,n.sub(e.center));e.parStart-C.tolerance<=h&&(h=Math.max(h,e.parStart),h<=e.parEnd+C.tolerance&&(h=Math.min(e.parEnd,h),i.push(new Or(u,h,n,t,e))))}static getAllIntersectionsOfLineAndPolyline(t,e){let i=[],n=0,o=e.startPoint;for(;o!=null&&o.getNext()!=null;o=o.getNext()){let s=E.crossTwoLineSegs(t.start,t.end,o.point,o.getNext().point,0,1,0,1);s&&(E.adjustSolution(t.start,t.end,o.point,o.getNext().point,s),E.oldIntersection(i,s.x)||i.push(new Or(s.aSol,n+s.bSol,s.x,t,e))),n++}if(e.closed){let s=E.crossTwoLineSegs(t.start,t.end,o.point,e.start,0,1,0,1);s&&(E.adjustSolution(t.start,t.end,o.point,e.start,s),E.oldIntersection(i,s.x)||i.push(new Or(s.aSol,n+s.bSol,s.x,t,e)))}return i}static adjustSolution(t,e,i,n,o){E.closeIntersectionPoints(o.x,t)?(o.x=t,o.aSol=0):E.closeIntersectionPoints(o.x,e)&&(o.x=e,o.aSol=1),E.closeIntersectionPoints(o.x,i)?(o.x=i,o.bSol=Math.floor(o.bSol)):E.closeIntersectionPoints(o.x,n)&&(o.x=n,o.bSol=Math.ceil(o.bSol))}static curveCurveXWithParallelogramNodesOne(t,e){if(!ae.intersect(t.parallelogram,e.parallelogram))return null;let i=t.node,n=e.node,o=i.hasOwnProperty("children"),s=n.hasOwnProperty("children");if(o&&s)for(let a of i.children)for(let u of n.children){let h=E.curveCurveXWithParallelogramNodesOne(a,u);if(h!=null)return h}else if(s)for(let a of n.children){let u=E.curveCurveXWithParallelogramNodesOne(t,a);if(u!=null)return u}else if(o)for(let a of i.children){let u=E.curveCurveXWithParallelogramNodesOne(a,e);if(u!=null)return u}else return E.crossOverIntervalsOne(t,e);return null}static curveCurveXWithParallelogramNodes(t,e,i){if(!ae.intersect(t.parallelogram,e.parallelogram))return;let n=t.node.hasOwnProperty("children"),o=e.node.hasOwnProperty("children");if(n&&o)for(let s of t.node.children)for(let a of e.node.children)E.curveCurveXWithParallelogramNodes(s,a,i);else if(o)for(let s of e.node.children)E.curveCurveXWithParallelogramNodes(t,s,i);else if(n)for(let s of t.node.children)E.curveCurveXWithParallelogramNodes(s,e,i);else i=E.crossOverLeaves(t,e,i)}static crossOverIntervalsOne(t,e){let i=t.node,n=e.node,o=(i.high-i.low)/2,s=(n.high-n.low)/2;for(let a=1;a<2;a++){let u=a*o+i.low;for(let h=1;h<2;h++){let c=h*s+n.low,f;if(i.chord==null&&n.chord==null?f=E.crossWithinIntervalsWithGuess(t.seg,e.seg,i.low,i.high,n.low,n.high,u,c):i.chord!=null&&n.chord==null?f=E.crossWithinIntervalsWithGuess(i.chord,e.seg,0,1,n.low,n.high,.5*a,c):i.chord==null?(f=E.crossWithinIntervalsWithGuess(t.seg,n.chord,i.low,i.high,0,1,u,.5*h),f&&(f.bSol=n.low+f.bSol*(n.high-n.low))):(f=E.crossWithinIntervalsWithGuess(i.chord,n.chord,0,1,0,1,.5*a,.5*h),f&&(f.aSol=i.low+f.aSol*(i.high-i.low),f.bSol=n.low+f.bSol*(n.high-n.low))),f)return E.createIntersectionOne(t,e,f.aSol,f.bSol,f.x)}}return E.goDeeperOne(t,e)}static crossOverLeaves(t,e,i){let n=t.node,o=e.node,s=!1,a=(n.high-n.low)/2+n.low,u=(o.high-o.low)/2+o.low,h;return n.chord==null&&o.chord==null?h=E.crossWithinIntervalsWithGuess(t.seg,e.seg,n.low,n.high,o.low,o.high,a,u):n.chord!=null&&o.chord==null?(h=E.crossWithinIntervalsWithGuess(n.chord,e.seg,0,1,o.low,o.high,.5,u),h&&(h.aSol=n.low+h.aSol*(n.high-n.low))):n.chord==null?(h=E.crossWithinIntervalsWithGuess(t.seg,o.chord,n.low,n.high,0,1,a,.5),h&&(h.bSol=o.low+h.bSol*(o.high-o.low))):(h=E.crossWithinIntervalsWithGuess(n.chord,o.chord,0,1,0,1,.5,.5),h&&(h.bSol=o.low+h.bSol*(o.high-o.low),h.aSol=n.low+h.aSol*(n.high-n.low))),h&&(E.addIntersection(t,e,i,h),s=!0),s||E.goDeeper(i,t,e),i}static addIntersection(t,e,i,n){let o=t.node;E.closeIntersectionPoints(n.x,t.seg.value(o.low))?(n.x=t.seg.value(o.low),n.aSol=o.low):E.closeIntersectionPoints(n.x,t.seg.value(o.high))&&(n.x=t.seg.value(o.high),n.aSol=o.high);let s=e.node;if(E.closeIntersectionPoints(n.x,e.seg.value(s.low))?(n.x=e.seg.value(s.low),n.bSol=s.low):E.closeIntersectionPoints(n.x,e.seg.value(s.high))&&(n.x=e.seg.value(s.high),n.bSol=s.high),!E.oldIntersection(i,n.x)){let u=new Or(n.aSol,n.bSol,n.x,t.seg,e.seg);i.push(u)}}static oldIntersection(t,e){for(let i of t)if(e.sub(i.x).length<C.distanceEpsilon*100)return!0;return!1}static createIntersectionOne(t,e,i,n,o){let s=t.node,a=e.node;return E.closeIntersectionPoints(o,t.seg.value(s.low))?(o=t.seg.value(s.low),i=s.low):E.closeIntersectionPoints(o,t.seg.value(s.high))&&(o=t.seg.value(s.high),i=s.high),E.closeIntersectionPoints(o,e.seg.value(a.low))?(o=e.seg.value(a.low),n=a.low):E.closeIntersectionPoints(o,e.seg.value(a.high))&&(o=e.seg.value(a.high),n=a.high),new Or(i,n,o,t.seg,e.seg)}static liftIntersectionToCurves_(t,e,i,n,o,s,a){let u=t instanceof E?E.liftParameterToCurve(t,i-s.parStart,s):i,h=e instanceof E?E.liftParameterToCurve(e,n-a.parStart,a):n;return new Or(u,h,o,t,e)}static DropIntersectionToSegs(t){let e,i;if(t.seg0 instanceof E){let s=t.seg0.getSegParam(t.par0);e=s.seg,i=s.par}else i=t.par0,e=t.seg0;let n,o;if(t.seg1 instanceof E){let s=t.seg1.getSegParam(t.par1);o=s.par,n=s.seg}else o=t.par1,n=t.seg1;return new Or(i,o,t.x,e,n)}static liftIntersectionToCurves(t,e,i){return E.liftIntersectionToCurves_(t,e,i.par0,i.par1,i.x,i.seg0,i.seg1)}static liftParameterToCurve(t,e,i){if(t===i)return e;if(!t.hasOwnProperty("segs"))return;let n=t,o=0;for(let s of n.segs){if(s===i)return e+o;o+=E.paramSpan(s)}throw"bug in liftParameterToCurve"}static paramSpan(t){return t.parEnd-t.parStart}static goDeeperOne(t,e){let i=t.node,n=e.node;if(t.leafBoxesOffset>C.distanceEpsilon&&e.leafBoxesOffset>C.distanceEpsilon){let a=Ve.createParallelogramNodeForCurveSeg(i.low,i.high,t.seg,t.leafBoxesOffset/2),u=Ve.createParallelogramNodeForCurveSeg(n.low,n.high,e.seg,e.leafBoxesOffset/2);return E.curveCurveXWithParallelogramNodesOne(a,u)}if(t.leafBoxesOffset>C.distanceEpsilon){let a=Ve.createParallelogramNodeForCurveSeg(i.low,i.high,t.seg,t.leafBoxesOffset/2);return E.curveCurveXWithParallelogramNodesOne(a,e)}if(e.leafBoxesOffset>C.distanceEpsilon){let a=Ve.createParallelogramNodeForCurveSeg(n.low,n.high,e.seg,e.leafBoxesOffset/2);return E.curveCurveXWithParallelogramNodesOne(t,a)}let o=t.seg.value(i.low),s=t.seg.value(i.high);if(!d.closeDistEps(o,s)){let a=e.seg.value(n.low),u=e.seg.value(n.high);if(!d.closeDistEps(a,u)){let h=t.seg instanceof w?t.seg:w.mkPP(o,s),c=e.seg instanceof w?e.seg:w.mkPP(a,u),f=E.crossWithinIntervalsWithGuess(h,c,0,1,0,1,.5,.5);if(f)return E.adjustParameters(t,h,e,c,f),E.createIntersectionOne(t,e,f.aSol,f.bSol,f.x)}}return null}static goDeeper(t,e,i){let n=e.node,o=i.node,s=e.leafBoxesOffset>C.distanceEpsilon,a=i.leafBoxesOffset>C.distanceEpsilon;if(s&&a){let u=Ve.createParallelogramNodeForCurveSeg(n.low,n.high,e.seg,e.leafBoxesOffset/2),h=Ve.createParallelogramNodeForCurveSeg(o.low,o.high,i.seg,i.leafBoxesOffset/2);E.curveCurveXWithParallelogramNodes(u,h,t)}else if(s){let u=Ve.createParallelogramNodeForCurveSeg(n.low,n.high,e.seg,e.leafBoxesOffset/2);E.curveCurveXWithParallelogramNodes(u,i,t)}else if(a){let u=Ve.createParallelogramNodeForCurveSeg(o.low,o.high,i.seg,i.leafBoxesOffset/2);E.curveCurveXWithParallelogramNodes(e,u,t)}else{let u=e.seg.value(n.low),h=e.seg.value(n.high);if(!d.closeDistEps(u,h)){let c=i.seg.value(o.low),f=i.seg.value(o.high);if(!d.closeDistEps(c,f)){let P=e.seg instanceof w?e.seg:w.mkPP(u,h),v=i.seg instanceof w?i.seg:w.mkPP(c,f),A=E.crossWithinIntervalsWithGuess(P,v,0,1,0,1,.5,.5);A&&(E.adjustParameters(e,P,i,v,A),E.addIntersection(e,i,t,A))}}}}static adjustParameters(t,e,i,n,o){if(e!==t.seg&&!(t.seg instanceof j))o.aSol=t.seg.closestParameter(o.x);else{let s=t.node;o.aSol=s.low+o.aSol*(s.high-s.low)}if(n!==i.seg&&!(i.seg instanceof j))o.bSol=i.seg.closestParameter(o.x);else{let s=i.node;o.bSol=s.low+o.bSol*(s.high-s.low)}}getSegParam(t){let e=this.parStart;for(let n of this.segs){let o=e+n.parEnd-n.parStart;if(t>=e&&t<=o)return{par:t-e+n.parStart,seg:n};e=o}let i=this.segs[this.segs.length-1];return{seg:i,par:i.parEnd}}getSegIndexParam(t){let e=0,i=this.segs.length;for(let o=0;o<i;o++){let s=this.segs[o],a=e+s.parEnd-s.parStart;if(t>=e&&t<=a)return{segIndex:o,par:t-e+s.parStart};e=a}let n=this.segs[i-1];return{segIndex:i-1,par:n.parEnd}}value(t){return Gf(this.getSegParam(t))}derivative(t){return Rf(this.getSegParam(t))}secondDerivative(t){return Nf(this.getSegParam(t))}thirdDerivative(t){return Df(this.getSegParam(t))}static crossWithinIntervalsWithGuess(t,e,i,n,o,s,a,u){if(t instanceof w&&e instanceof w){let f=E.crossTwoLineSegs(t.start,t.end,e.start,e.end,i,n,o,s);if(f!==void 0)return f}let h=E.minDistWithinIntervals(t,e,i,n,o,s,a,u);if(h==null)return;let c=h.aX.sub(h.bX);return c.dot(c)>=C.distanceEpsilon?void 0:{aSol:h.aSol,bSol:h.bSol,x:d.middle(h.aX,h.bX)}}static crossTwoLineSegs(t,e,i,n,o,s,a,u){let h=e.sub(t),c=i.sub(n),f=i.sub(t),P=Tr.solve(h.x,c.x,f.x,h.y,c.y,f.y);if(P==null)return;let v=P.x,A=P.y,O=t.add(h.mul(v));if(!(v<o-C.tolerance)&&(v=Math.max(v,o),!(v>s+C.tolerance)&&(v=Math.min(v,s),!(A<a-C.tolerance)&&(A=Math.max(A,a),!(A>u+C.tolerance)))))return A=Math.min(A,u),{aSol:v,bSol:A,x:O}}static PointRelativeToCurveLocation(t,e){if(!e.boundingBox.contains(t))return 0;let i=2*e.boundingBox.diagonal,n=Math.PI/180,o=0;for(let s=13;s<360;s+=13){let a=new d(Math.cos(s*n),Math.sin(s*n)),u=w.mkPP(t,t.add(a.mul(i))),h=this.getAllIntersectionsOfLineAndICurve(u,e,!0);if(E.AllIntersectionsAreGood(h,e)){for(let f of h)if(d.closeDistEps(f.x,t))return 1;if(h.length%2===1?o++:o--,o>=2)return 2;if(o<=-2)return 0}}return 1}static AllIntersectionsAreGood(t,e){let i=e.hasOwnProperty("segs"),n=null;if(i||e instanceof j&&(n=e.toCurve()),n){for(let o of t)if(!E.RealCut(E.DropIntersectionToSegs(o),n,!1))return!1}return!0}static RealCut(t,e,i){let n=t.seg0,o=t.seg1,s=t.par0,a=t.par1,u=t.x,h=n.derivative(s).normalize(),c=o.derivative(a).normalize().rotate(Math.PI/2);if(d.closeDistEps(u,o.end)){let P=null;for(let O=0;O<e.segs.length-1;O++)if(e.segs[O]===o){P=e.segs[O+1];break}if(P==null)return!1;let v=h.rotate(Math.PI/2);return!(v.dot(o.derivative(o.parEnd))*v.dot(P.derivative(P.parStart))<C.tolerance)}if(d.closeDistEps(u,o.start)){let P=null;for(let O=e.segs.length-1;O>0;O--)if(e.segs[O]===o){P=e.segs[O-1];break}if(P==null)return!1;let v=h.rotate(Math.PI/2);return!(v.dot(o.derivative(o.parStart))*v.dot(P.derivative(P.parEnd))<C.tolerance)}let f=h.dot(c);return i?f>C.distanceEpsilon:Math.abs(f)>C.distanceEpsilon}static realCutWithClosedCurve(t,e,i){let n=t.seg0,o=t.seg1,s=t.par0,a=t.par1,u=t.x,h=n.derivative(s).normalize(),c=o.derivative(a).normalize().rotate(Math.PI/2);if(d.closeDistEps(u,o.end)){let P=null;for(let O=0;O<e.segs.length;O++)if(e.segs[O]===o){P=e.segs[(O+1)%e.segs.length];break}if(P==null)throw new Error;let v=h.rotate(Math.PI/2);return!(v.dot(o.derivative(o.parEnd))*v.dot(P.derivative(P.parStart))<C.tolerance)}if(d.closeDistEps(u,o.start)){let P=null;for(let O=0;O<e.segs.length;O++)if(e.segs[O]===o){P=e.segs[O>0?O-1:e.segs.length-1];break}let v=h.rotate(Math.PI/2);return!(v.dot(o.derivative(o.parStart))*v.dot(P.derivative(P.parEnd))<C.tolerance)}let f=h.dot(c);return i?f>C.distanceEpsilon:Math.abs(f)>C.distanceEpsilon}static minDistWithinIntervals(t,e,i,n,o,s,a,u){let h=new Ga(t,e,i,n,o,s,a,u);return h.solve(),h.success?{aSol:h.aSolution,bSol:h.bSolution,aX:h.aPoint,bX:h.bPoint}:void 0}offsetCurve(t,e){throw new Error("Method not implemented.")}get boundingBox(){if(this.boundingBox_)return this.boundingBox_;if(this.segs.length===0)this.boundingBox_=D.mkEmpty();else{let t=this.segs[0].boundingBox.clone();for(let e=1;e<this.segs.length;e++)t.addRecSelf(this.segs[e].boundingBox);return this.boundingBox_=t}}clone(){let t=new E;for(let e of this.segs)t.addSegment(e.clone());return this.boundingBox_!=null&&(t.boundingBox_=this.boundingBox_.clone()),t}getParameterAtLength(t){let e=0;for(let i of this.segs){let n=i.length;if(n>=t)return e+i.getParameterAtLength(t);t-=n,e+=i.parEnd-i.parStart}return this.parEnd}get length(){let t=0;for(let e of this.segs)t+=e.length;return t}transform(t){let e=new E;for(let i of this.segs)e.addSegment(i.transform(t));return this.boundingBox_&&(e.boundingBox_=this.boundingBox_.transform(t)),e}closestParameterWithinBounds(t,e,i){let n=0,o=Number.MAX_VALUE,s=0;for(let a of this.segs){if(s>i)break;let u=E.paramSpan(a);if(s+u>=e){let c=Math.max(a.parStart,a.parStart+(e-s)),f=Math.min(a.parEnd,a.parStart+(i-s)),P=a.closestParameterWithinBounds(t,c,f),v=t.sub(a.value(P)),A=v.dot(v);A<o&&(n=s+P-a.parStart,o=A)}s+=u}return n}closestParameter(t){let e=0,i=Number.MAX_VALUE,n=0;for(let o of this.segs){let s=o.closestParameter(t),a=t.sub(o.value(s)),u=a.dot(a);if(u<i){if(e=n+s-o.parStart,u===0)break;i=u}n+=E.paramSpan(o)}return e}static addLineSegment(t,e,i){return t.addSegment(w.mkPP(e,i))}static addLineSegmentCNNP(t,e,i,n){return E.addLineSegment(t,new d(e,i),n)}static addLineSegmentCNNNN(t,e,i,n,o){E.addLineSegment(t,new d(e,i),new d(n,o))}static continueWithLineSegmentNN(t,e,i){E.addLineSegment(t,t.end,new d(e,i))}static continueWithLineSegmentP(t,e){E.addLineSegment(t,t.end,e)}static closeCurve(t){return E.continueWithLineSegmentP(t,t.start),t}leftDerivative(t){let e=this.tryToGetLeftSegment(t);return e!=null?e.derivative(e.parEnd):this.derivative(t)}rightDerivative(t){let e=this.tryToGetRightSegment(t);return e!=null?e.derivative(e.parStart):this.derivative(t)}tryToGetLeftSegment(t){if(Math.abs(t-this.parStart)<C.tolerance)return this.start.equal(this.end)?this.segs[this.segs.length-1]:null;for(let e of this.segs)if(t-=E.paramSpan(e),Math.abs(t)<C.tolerance)return e;return null}tryToGetRightSegment(t){if(Math.abs(t-this.parEnd)<C.tolerance)return this.start===this.end?this.segs[0]:null;for(let e of this.segs){if(Math.abs(t)<C.tolerance)return e;t-=E.paramSpan(e)}return null}static ClosestPoint(t,e){return t.value(t.closestParameter(e))}static CurveIsInsideOther(t,e){if(!e.boundingBox.containsRect(t.boundingBox))return!1;let i=E.getAllIntersections(t,e,!0);if(i.length===0)return E.NonIntersectingCurveIsInsideOther(t,e);if(i.length===1)return t.start.equal(i[0].x)?E.PointRelativeToCurveLocation(t.value((t.parStart+t.parEnd)/2),e)==2:E.PointRelativeToCurveLocation(t.start,e)===2;for(let n of E.PointsBetweenIntersections(t,i))if(E.PointRelativeToCurveLocation(n,e)===0)return!1;return!0}static*PointsBetweenIntersections(t,e){e.sort((a,u)=>a.par0-u.par0);for(let a=0;a<e.length-1;a++)yield t.value((e[a].par0+e[a+1].par0)/2);let i=e[e.length-1].par0,n=e[0].par0,o=t.parEnd-i+(n-t.parStart),s=i+o/2;s>t.parEnd&&(s=t.parStart+(s-t.parEnd)),yield t.value(s)}static NonIntersectingCurveIsInsideOther(t,e){for(let i=t.parStart;i<t.parEnd;i+=.5){let n=E.PointRelativeToCurveLocation(t.value(i),e);if(n!==1)return n===2}return E.PointRelativeToCurveLocation(t.end,e)!==0}static ClosedCurveInteriorsIntersect(t,e){if(!e.boundingBox.intersects(t.boundingBox))return!1;let i=E.getAllIntersections(t,e,!0);if(i.length===0)return E.NonIntersectingCurveIsInsideOther(t,e)||E.NonIntersectingCurveIsInsideOther(e,t);if(i.length===1)return t.start.equal(i[0].x)?E.PointRelativeToCurveLocation(t.value((t.parStart+t.parEnd)/2),e)===2||!e.start.equal(i[0].x)?E.PointRelativeToCurveLocation(e.start,t)===2:E.PointRelativeToCurveLocation(e.value((e.parStart+e.parEnd)/2),t)===2:E.PointRelativeToCurveLocation(t.start,e)===2;for(let n of E.PointsBetweenIntersections(t,i))if(E.PointRelativeToCurveLocation(n,e)===2)return!0;return!0}curvature(t){let e=this.getSegParam(t);return e.seg.curvature(e.par)}curvatureDerivative(t){throw new Error("Not implemente")}curvatureSecondDerivative(t){throw new Error("Not implemented")}static createBezierSeg(t,e,i,n,o){let s=d.mkPoint(t,i.point,1-t,n.point),a=d.mkPoint(e,o.point,1-e,n.point),u=n.point.mul(2/3);return new be(s,s.div(3).add(u),u.add(a.div(3)),a)}static createBezierSegN(t,e,i,n){let o=i.mul(n);return new be(t,t.add(o),e.add(o),e)}static findCorner(t){let e=t.next;if(e.next==null)return;let i=e.next;if(i!=null)return{b:e,c:i}}static trimEdgeSplineWithNodeBoundaries(t,e,i,n){let o=i.parStart,s=i.parEnd;t!=null&&(o=E.findNewStart(i,o,t,n)),e!=null&&(s=E.findNewEnd(i,e,n,s));let a=Math.min(o,s),u=Math.max(o,s);return a<u?i.trim(a,u):i}static findNewEnd(t,e,i,n){let o=E.getAllIntersections(t,e,!0);if(o.length===0)return n=t.parEnd,n;if(i){n=t.parEnd;for(let s of o)s.par0<n&&(n=s.par0)}else{n=t.parStart;for(let s of o)s.par0>n&&(n=s.par0)}return n}static findNewStart(t,e,i,n){let o=E.getAllIntersections(t,i,!0);if(o.length===0){e=t.parStart;return}if(n){e=t.parStart;for(let s of o)s.par0>e&&(e=s.par0)}else{e=t.parEnd;for(let s of o)s.par0<e&&(e=s.par0)}return e}static polylineAroundClosedCurve(t){if(t instanceof ee)return E.refineEllipse(t);if(t instanceof j)return t;if(t instanceof E&&E.allSegsAreLines(t)){let e=new j;for(let i of t.segs)e.addPoint(i.start);if(e.closed=!0,!e.isClockwise())return e.reverse()}return t.boundingBox.perimeter()}static allSegsAreLines(t){for(let e of t.segs)if(!(e instanceof w))return!1;return!0}static refineEllipse(t){let e=t.boundingBox.perimeter(),i=Math.PI/4,n=t.boundingBox.width,o=t.boundingBox.height,s=Math.sqrt(n*n+o*o),a=[];for(let h=0;h<4;h++){let c=i+h*Math.PI/2,f=t.value(c),P=t.derivative(c).normalize().mul(s),v=w.mkPP(f.sub(P),f.add(P));for(let A of E.getAllIntersections(e,v,!0))a.push(A)}a.sort((h,c)=>h.par0<c.par0?-1:h.par0>c.par0?1:0);let u=new j;return a.forEach(h=>u.addPoint(h.x)),u.closed=!0,u}static polyFromBox(t){let e=new j;return e.addPoint(t.leftTop),e.addPoint(t.rightTop),e.addPoint(t.rightBottom),e.addPoint(t.leftBottom),e.closed=!0,e}};var j=class{constructor(){this.initIsRequired=!0;this.isClosed_=!1}toJSON(){return{points:Array.from(this).map(t=>t.toJSON())}}static fromJSON(t){return j.mkFromPoints(t.points.map(e=>d.fromJSON(e)))}RemoveStartPoint(){let t=this.startPoint.next;t.prev=null,this.startPoint=t,this.setInitIsRequired()}RemoveEndPoint(){let t=this.endPoint.prev;t.next=null,this.endPoint=t,this.setInitIsRequired()}setInitIsRequired(){this.initIsRequired=!0}addPointXY(t,e){this.addPoint(new d(t,e))}isClockwise(){return d.getTriangleOrientation(this.startPoint.point,this.startPoint.next.point,this.startPoint.next.next.point)==0}addPoint(t){let e=new it;e.polyline=this,e.point=t.clone(),this.endPoint!=null?(this.endPoint.next=e,e.prev=this.endPoint,this.endPoint=e):this.startPoint=this.endPoint=e,this.setInitIsRequired()}PrependPoint(t){let e=it.mkFromPoint(t);e.polyline=this,this.startPoint!=null?d.closeDistEps(t,this.startPoint.point)||(this.startPoint.prev=e,e.next=this.startPoint,this.startPoint=e):(this.endPoint=e,this.startPoint=e),this.setInitIsRequired()}*[Symbol.iterator](){for(let t=this.startPoint;t!=null;t=t.next)yield t.point}*polylinePoints(){for(let t=this.startPoint;t!=null;t=t.next)yield t}*skip(t){for(let e=this.startPoint;e!=null;e=e.next)t>0?t--:yield e}static parallelogramOfLineSeg(t,e){let i=e.sub(t).div(2);return ae.parallelogramByCornerSideSide(t,i,i)}static mkFromPoints(t){let e=new j;for(let i of t)e.addPoint(i);return e}static mkClosedFromPoints(t){let e=j.mkFromPoints(t);return e.closed=!0,e}calculatePbNode(){let t=[],e=[],i=this.startPoint,n=0;for(;i.next!=null;){let o=j.parallelogramOfLineSeg(i.point,i.next.point);t.push(o),e.push({parallelogram:o,seg:this,leafBoxesOffset:0,node:{low:n,high:n+1,chord:w.mkPP(i.point,i.next.point)}}),i=i.next,n++}if(this.isClosed_){let o=j.parallelogramOfLineSeg(this.endPoint.point,this.startPoint.point);t.push(o),e.push({parallelogram:o,seg:this,leafBoxesOffset:0,node:{low:n,high:n+1,chord:w.mkPP(this.endPoint.point,this.startPoint.point)}})}this.pBNode={parallelogram:ae.getParallelogramOfAGroup(t),seg:this,leafBoxesOffset:0,node:{children:e}}}init(){this.bBox=D.rectangleOnPoint(this.startPoint.point);for(let t of this.skip(1))this.bBox.add(t.point);this.updateCount(),this.calculatePbNode(),this.initIsRequired=!1}updateCount(){this.count_=0;for(let t=this.startPoint;t!=null;t=t.next)this.count_++}get count(){return this.initIsRequired&&this.init(),this.count_}get closed(){return this.isClosed_}set closed(t){this.isClosed_=t}value(t){this.initIsRequired&&this.init();let e=this.getAdjustedParamAndStartEndPoints(t);return d.convSum(e.t,e.a,e.b)}getAdjustedParamAndStartEndPoints(t){let e=this.startPoint;for(;e.next!=null;){if(t<=1)return{a:e.point,b:e.next.point,t};e=e.next,t-=1}if(this.closed&&t<=1)return{a:this.endPoint.point,b:this.startPoint.point,t};throw new Error("out of the parameter domain")}derivative(t){let e=this.getAdjustedParamAndStartEndPoints(t);return e.b.sub(e.a)}secondDerivative(t){return new d(0,0)}thirdDerivative(t){return new d(0,0)}pNodeOverICurve(){return this.initIsRequired&&this.init(),this.pBNode}get boundingBox(){return this.initIsRequired&&this.init(),this.bBox}get parStart(){return 0}get parEnd(){return this.initIsRequired&&this.init(),this.closed?this.count_:this.count_-1}static polylineFromCurve(t){let e=new j;e.addPoint(t.start);for(let i of t.segs)e.addPoint(i.end);return e.closed=t.start===t.end,e}trim(t,e){let i=this.toCurve();return i=i.trim(t,e),i instanceof E?j.polylineFromCurve(i):j.mkFromPoints([i.start,i.end])}trimWithWrap(t,e){throw new Error("Method not implemented.")}translate(t){let e=this.startPoint;do{if(e.point=e.point.add(t),e===this.endPoint)break;e=e.getNext()}while(!0);this.setInitIsRequired()}scaleFromOrigin(t,e){throw new Error("Method not implemented.")}get start(){return this.startPoint.point}get end(){return this.endPoint.point}reverse(){let t=new j;t.closed=this.closed;let e=this.endPoint;do{if(t.addPoint(e.point),e===this.startPoint)break;e=e.getPrev()}while(!0);return t}offsetCurve(t,e){throw new Error("Method not implemented.")}lengthPartial(t,e){throw new Error("Method not implemented.")}get length(){throw new Error("Method not implemented.")}getParameterAtLength(t){throw new Error("Method not implemented.")}transform(t){let e=new j;for(let i of this.polylinePoints())e.addPoint(t.multiplyPoint(i.point));return e.closed=this.closed,e}closestParameterWithinBounds(t,e,i){throw new Error("Method not implemented.")}closestParameter(t){let e=0,i=Number.MAX_VALUE,n=0,o=this.startPoint;for(;o.next!=null;){let s=w.mkPP(o.point,o.next.point),a=s.closestParameter(t),u=s.value(a).sub(t),h=u.dot(u);h<i&&(i=h,e=a+n),o=o.next,n++}if(this.closed){let s=w.mkPP(this.endPoint.point,this.startPoint.point),a=s.closestParameter(t),u=s.value(a).sub(t);u.dot(u)<i&&(e=a+n)}return e}clone(){let t=new j;t.closed=this.closed;let e=this.startPoint;do{if(t.addPoint(e.point),e===this.endPoint)break;e=e.getNext()}while(!0);return t}leftDerivative(t){throw new Error("Method not implemented.")}rightDerivative(t){throw new Error("Method not implemented.")}curvature(t){throw new Error("Method not implemented.")}curvatureDerivative(t){throw new Error("Method not implemented.")}curvatureSecondDerivative(t){throw new Error("Method not implemented.")}next(t){var e;return(e=t.next)!=null?e:this.closed?this.startPoint:null}prev(t){var e;return(e=t.prev)!=null?e:this.closed?this.endPoint:null}toCurve(){let t=new E;E.addLineSegment(t,this.startPoint.point,this.startPoint.next.point);let e=this.startPoint.next;for(;(e=e.next)!=null;)E.continueWithLineSegmentP(t,e.point);return this.closed&&E.continueWithLineSegmentP(t,this.startPoint.point),t}RemoveCollinearVertices(){for(let t=this.startPoint.next;t.next!=null;t=t.next)d.getTriangleOrientation(t.prev.point,t.point,t.next.point)===2&&(t.prev.next=t.next,t.next.prev=t.prev);return this.setInitIsRequired(),this}};var nt=class{pad(t){this.width+=t*2}constructor(t,e=t){this.width=t,this.height=e}},D=class{transform(t){return D.mkPP(t.multiplyPoint(this.leftTop),t.multiplyPoint(this.rightBottom))}translate(t){return D.mkSizeCenter(this.size,this.center.add(t))}equal(t){return this.left_===t.left&&this.right_===t.right&&this.top_===t.top&&this.bottom_===t.bottom}equalEps(t){return Q(this.left_,t.left)&&Q(this.right_,t.right)&&Q(this.top_,t.top)&&Q(this.bottom_,t.bottom)}static mkSizeCenter(t,e){let i=t.width/2,n=t.height/2;return new D({left:e.x-i,right:e.x+i,bottom:e.y-n,top:e.y+n})}constructor(t){this.left_=t.left,this.right_=t.right,this.top_=t.top,this.bottom=t.bottom}add_rect(t){return this.addRec(t)}contains_point(t){return this.contains(t)}contains_rect(t){return this.containsRect(t)}intersection_rect(t){return this.intersection(t)}intersects_rect(t){return this.intersects(t)}unite(t){return D.rectangleOfTwo(this,t)}contains_point_radius(t,e){return this.containsWithPadding(t,e)}intersects(t){return this.intersectsOnX(t)&&this.intersectsOnY(t)}intersection(t){if(!this.intersects(t)){let s=D.mkEmpty();return s.setToEmpty(),s}let e=Math.max(this.left,t.left),i=Math.min(this.right,t.right),n=Math.max(this.bottom,t.bottom),o=Math.min(this.top,t.top);return new D({left:e,bottom:n,right:i,top:o})}get center(){return this.leftTop.add(this.rightBottom).mul(.5)}set center(t){let e=this.leftTop.add(this.rightBottom).mul(.5),i=t.sub(e);this.leftTop=this.leftTop.add(i),this.rightBottom=this.rightBottom.add(i)}intersectsOnY(t){return!(t.bottom_>this.top_+C.distanceEpsilon||t.top_<this.bottom_-C.distanceEpsilon)}intersectsOnX(t){return!(t.left>this.right_+C.distanceEpsilon||t.right<this.left_-C.distanceEpsilon)}static mkEmpty(){return new D({left:0,right:-1,bottom:0,top:-1})}get left(){return this.left_}set left(t){this.left_=t,this.onUpdated()}get right(){return this.right_}set right(t){this.right_=t,this.onUpdated()}get top(){return this.top_}set top(t){this.top_=t,this.onUpdated()}get bottom(){return this.bottom_}set bottom(t){this.bottom_=t,this.onUpdated()}get leftBottom(){return new d(this.left_,this.bottom_)}set leftBottom(t){this.left_=t.x,this.bottom=t.y}get rightTop(){return new d(this.right_,this.top_)}set rightTop(t){this.right_=t.x,this.top_=t.y}get leftTop(){return new d(this.left_,this.top_)}set leftTop(t){this.left_=t.x,this.top_=t.y}get rightBottom(){return new d(this.right_,this.bottom_)}set rightBottom(t){this.right_=t.x,this.bottom=t.y}onUpdated(){}static mkPP(t,e){let i=new D({left:t.x,right:t.x,top:t.y,bottom:t.y});return i.add(e),i}static rectangleOnPoint(t){return new D({left:t.x,right:t.x,top:t.y,bottom:t.y})}static mkLeftBottomSize(t,e,i){let n=t+i.width,o=e+i.height;return new D({left:t,right:n,top:o,bottom:e})}static getRectangleOnCoords(t,e,i,n){let o=new D({left:t,bottom:e,right:t,top:e});return o.add(new d(i,n)),o}static mkOnPoints(t){let e=D.mkEmpty();for(let i of t)e.add(i);return e}static mkOnRectangles(t){let e=D.mkEmpty();for(let i of t)e.addRecSelf(i);return e}get width(){return this.right_-this.left_}set width(t){let e=t/2,i=(this.left_+this.right_)/2;this.left_=i-e,this.right_=i+e}isEmpty(){return this.right<this.left}setToEmpty(){this.left=0,this.right=-1}get height(){return this.top_-this.bottom_}set height(t){let e=t/2,i=(this.top_+this.bottom_)/2;this.top_=i+e,this.bottom=i-e}static rectangleOfTwo(t,e){let i=new D({left:t.left_,right:t.right_,top:t.top_,bottom:t.bottom_});return i.addRecSelf(e),i}containsWithPadding(t,e){return this.left_-e-C.distanceEpsilon<=t.x&&t.x<=this.right_+e+C.distanceEpsilon&&this.bottom_-e-C.distanceEpsilon<=t.y&&t.y<=this.top_+e+C.distanceEpsilon}get area(){return(this.right_-this.left_)*(this.top_-this.bottom_)}add(t){this.isEmpty()?(this.left_=this.right_=t.x,this.top_=this.bottom=t.y):(this.left_>t.x&&(this.left_=t.x),this.top_<t.y&&(this.top_=t.y),this.right_<t.x&&(this.right_=t.x),this.bottom_>t.y&&(this.bottom=t.y))}addRecSelf(t){this.add(t.leftTop),this.add(t.rightBottom)}addRec(t){let e=this.clone();return e.add(t.leftTop),e.add(t.rightBottom),e}static translate(t,e){let i=t.clone();return i.center=t.center.add(e),i}static transform(t,e){return D.mkPP(e.multiplyPoint(t.leftTop),e.multiplyPoint(t.rightBottom))}contains(t){return this.containsWithPadding(t,0)}containsRect(t){return this.contains(t.leftTop)&&this.contains(t.rightBottom)}containsRectWithPadding(t,e){return this.containsWithPadding(t.leftTop,e)&&this.containsWithPadding(t.rightBottom,e)}get diagonal(){return Math.sqrt(this.width*this.width+this.height*this.height)}padWidth(t){this.left-=t,this.right+=t}padHeight(t){this.top+=t,this.bottom-=t}pad(t){t<-this.width/2&&(t=-this.width/2),t<-this.height/2&&(t=-this.height/2),this.padWidth(t),this.padHeight(t)}padEverywhere(t){this.left-=t.left,this.right+=t.right,this.bottom-=t.bottom,this.top+=t.top}static intersect(t,e){return t.intersects(e)?D.mkPP(new d(Math.max(t.left,e.left),Math.max(t.bottom,e.bottom)),new d(Math.min(t.right,e.right),Math.min(t.top,e.top))):D.mkEmpty()}perimeter(){let t=new j;return t.addPoint(this.leftTop),t.addPoint(this.rightTop),t.addPoint(this.rightBottom),t.addPoint(this.leftBottom),t.closed=!0,t}scaleAroundCenter(t){this.width=this.width*t,this.height=this.height*t}clone(){return new D({left:this.left,right:this.right,top:this.top,bottom:this.bottom})}get size(){return new nt(this.width,this.height)}set size(t){this.width=t.width,this.height=t.height}static creatRectangleWithSize(t,e){let i=t.width/2,n=e.x-i,o=e.x+i,s=t.height/2,a=e.y-s,u=e.y+s;return new D({left:n,right:o,top:u,bottom:a})}addPointWithSize(t,e){let i=t.width/2,n=t.height/2;this.add(new d(e.x-i,e.y-n)),this.add(new d(e.x+i,e.y-n)),this.add(new d(e.x-i,e.y+n)),this.add(new d(e.x+i,e.y+n))}};var ye=class{constructor(){this.previouisBezierCoefficient=.5;this.nextBezierCoefficient=.5;this.previousTangentCoefficient=1/3;this.nextTangentCoefficient=1/3}static mkSiteP(t){let e=new ye;return e.point=t,e}static mkSiteSP(t,e){let i=new ye;return i.point=e,i.prev=t,t.next=i,i}static mkSiteSPS(t,e,i){let n=new ye;return n.prev=t,n.point=e,n.next=i,t.next=n,i.prev=n,n}get turn(){return this.next==null||this.prev==null?0:d.getTriangleOrientation(this.prev.point,this.point,this.next.point)}clone(){let t=new ye;return t.previouisBezierCoefficient=this.previouisBezierCoefficient,t.point=this.point,t}};var Ge=class{static mkFromPoints(t){let e=null,i=null;for(let n of t)if(i==null)i=ye.mkSiteP(n),e=new Ge(i);else{let o=ye.mkSiteP(n);o.prev=i,i.next=o,i=o}return e}clone(){let t=this.headSite,e=null,i,n=null;for(;t!=null;)i=t.clone(),i.prev=e,e!=null?e.next=i:n=i,t=t.next,e=i;return new Ge(n)}constructor(t){this.headSite=t}get lastSite(){let t=this.headSite;for(;t.next!=null;)t=t.next;return t}*[Symbol.iterator](){let t=this.headSite;for(;t!=null;)yield t.point,t=t.next}createCurve(){let t=new E,e=this.headSite,i;do{let n=E.findCorner(e);if(n==null)break;let o=Ge.createBezierSegOnSite(n.b);t.segs.length===0?d.closeDistEps(e.point,o.start)||E.addLineSegment(t,e.point,o.start):d.closeDistEps(t.end,o.start)||E.continueWithLineSegmentP(t,o.start),t.addSegment(o),e=n.b}while(!0);return t.segs.length===0?d.closeDistEps(e.point,e.next.point)?t.segs.push(new be(e.point,e.point.add(new d(5,5)),e.point.add(new d(-5,5)),i.point)):E.addLineSegment(t,e.point,e.next.point):d.closeDistEps(t.end,e.next.point)||E.continueWithLineSegmentP(t,e.next.point),t}static createBezierSegOnSite(t){let e=t.previouisBezierCoefficient,i=t.nextBezierCoefficient,n=t.prev,o=t.next,s=n.point.mul(e).add(t.point.mul(1-e)),a=o.point.mul(i).add(t.point.mul(1-i)),u=s.mul(t.previousTangentCoefficient).add(t.point.mul(1-t.previousTangentCoefficient)),h=a.mul(t.nextTangentCoefficient).add(t.point.mul(1-t.nextTangentCoefficient));return be.mkBezier([s,u,h,a])}};var Qe=class{get Elements(){return this.elements}getElem(t,e){return this.elements[t][e]}setElem(t,e,i){this.elements[t][e]=i}static Divide(t,e){return t.multiply(e.inverse())}isIdentity(){return Q(this.elements[0][0],1)&&Q(this.elements[0][1],0)&&Q(this.elements[0][2],0)&&Q(this.elements[1][0],0)&&Q(this.elements[1][1],1)&&Q(this.elements[1][2],0)}offset(){return new d(this.getElem(0,2),this.getElem(1,2))}static getIdentity(){return new Qe(1,0,0,0,1,0)}constructor(t,e,i,n,o,s){this.elements=[[t,e,i],[n,o,s]]}static rotation(t){let e=Math.cos(t),i=Math.sin(t);return new Qe(e,-i,0,i,e,0)}static scaleAroundCenterTransformation(t,e,i){let n=1-t,o=1-e;return new Qe(t,0,n*i.x,0,e,o*i.y)}multiplyPoint(t){return new d(this.getElem(0,0)*t.x+this.getElem(0,1)*t.y+this.getElem(0,2),this.getElem(1,0)*t.x+this.getElem(1,1)*t.y+this.getElem(1,2))}multiply(t){return t!=null?new Qe(this.getElem(0,0)*t.getElem(0,0)+this.getElem(0,1)*t.getElem(1,0),this.getElem(0,0)*t.getElem(0,1)+this.getElem(0,1)*t.getElem(1,1),this.getElem(0,0)*t.getElem(0,2)+this.getElem(0,1)*t.getElem(1,2)+this.getElem(0,2),this.getElem(1,0)*t.getElem(0,0)+this.getElem(1,1)*t.getElem(1,0),this.getElem(1,0)*t.getElem(0,1)+this.getElem(1,1)*t.getElem(1,1),this.getElem(1,0)*t.getElem(0,2)+this.getElem(1,1)*t.getElem(1,2)+this.getElem(1,2)):null}inverse(){let t=this.getElem(0,0)*this.getElem(1,1)-this.getElem(1,0)*this.getElem(0,1),e=this.getElem(1,1)/t,i=-this.getElem(0,1)/t,n=-this.getElem(1,0)/t,o=this.getElem(0,0)/t,s=-e*this.getElem(0,2)-i*this.getElem(1,2),a=-n*this.getElem(0,2)-o*this.getElem(1,2);return new Qe(e,i,s,n,o,a)}};var ci=class{static mkEllipse(t,e,i){return ee.mkFullEllipseNNP(t,e,i)}static createParallelogram(t,e,i){let n=e/2,o=t/2,s=i.x,a=i.y,u=80*Math.PI/180,h=n/Math.tan(u);return j.mkClosedFromPoints([new d(-o-h+s,-n+a),new d(o+s,-n+a),new d(o+s+h,n+a),new d(-o+s,n+a)])}static createHexagon(t,e,i){let n=e/2,o=t/2,s=i.x,a=i.y;return j.mkClosedFromPoints([new d(-o+s,-n+a),new d(o+s,-n+a),new d(o+(n+s),0+a),new d(o+s,n+a),new d(-o+s,n+a),new d(-(o-n)+s,0+a)])}static createOctagon(t,e,i){let n=t/2,o=e/2,s=new Array(8);s[0]=new d(n+ci.octagonPad*n,o-o*ci.octagonPad),s[3]=new d(s[0].x*-1,s[0].y),s[4]=new d(s[3].x,s[3].y*-1),s[7]=new d(s[0].x,s[0].y*-1),s[1]=new d(n-n*ci.octagonPad,o+o*ci.octagonPad),s[2]=new d(s[1].x*-1,s[1].y),s[6]=new d(s[1].x,s[1].y*-1),s[5]=new d(s[2].x,s[2].y*-1);for(let a=0;a<8;a++)s[a]=s[a].add(i);return j.mkClosedFromPoints(s)}static createInvertedHouse(t,e,i){let n=ci.createHouse(t,e,i);return ci.rotateCurveAroundCenterByDegree(n,i,180)}static createHouse(t,e,i){let n=t/2,o=e/2,s=i.x,a=i.y,u=new E;return E.addLineSegmentCNNNN(u,s-n,a-o,s+n,a-o),E.continueWithLineSegmentNN(u,s+n,a+o),E.continueWithLineSegmentNN(u,s,a+2*o),E.continueWithLineSegmentNN(u,s-n,a+o),E.closeCurve(u)}static mkDiamond(t,e,i){let n=t,o=e,s=i.x,a=i.y,u=new E,h=[new d(s,a-o),new d(s+n,a),new d(s,a+o),new d(s-n,a)];return u.addSegs([w.mkPP(h[0],h[1]),w.mkPP(h[1],h[2]),w.mkPP(h[2],h[3]),w.mkPP(h[3],h[0])]),u}static rotateCurveAroundCenterByDegree(t,e,i){return ci.rotateCurveAroundCenterByRadian(t,e,i*Math.PI/180)}static rotateCurveAroundCenterByRadian(t,e,i){let n=Math.cos(i),o=Math.sin(i),s=new Qe(1,0,e.x,0,1,e.y).multiply(new Qe(n,-o,0,o,n,0)).multiply(new Qe(1,0,-e.x,0,1,-e.y));return t.transform(s)}static mkCircle(t,e){return ee.mkCircle(t,e)}static createRectangle(t,e,i){let n=t/2,o=e/2,s=i.x,a=i.y,u=new E,h=[new d(s-n,a-o),new d(s+n,a-o),new d(s+n,a+o),new d(s-n,a+o)];return u.addSegs([w.mkPP(h[0],h[1]),w.mkPP(h[1],h[2]),w.mkPP(h[2],h[3]),w.mkPP(h[3],h[0])]),u}static isRoundedRect(t){if(!(t instanceof E))return;let e=t.segs;if(e.length!==8&&e.length!==4)return;let i=e.length===8,n,o;for(let s=0;s<4;s++){let a=i?2*s+1:s;if(s===0){if(!(e[a]instanceof ee))return;let u=e[a];n=u.aAxis.length,o=u.bAxis.length}else{if(!(e[a]instanceof ee))return;let u=e[a];if(n!==u.aAxis.length||o!==u.bAxis.length)return}}return{radX:n,radY:o}}static mkRectangleWithRoundedCorners(t,e,i,n,o=new d(0,0)){if(i===0||n===0)return ci.createRectangle(t,e,o);let s=new E,a=t/2;i>a/2&&(i=a/2);let u=e/2;n>u/2&&(n=u/2);let h=o.x,c=o.y,f=a-i,P=u-n,v=c+u,A=c-u,O=h-a,M=h+a,z=new d(i,0),$=new d(0,n);return f>0&&s.addSegment(w.mkPP(new d(h-f,A),new d(h+f,A))),s.addSegment(ee.mkEllipse(1.5*Math.PI,2*Math.PI,z,$,h+f,c-P)),P>0&&s.addSegment(w.mkPP(new d(M,c-P),new d(M,c+P))),s.addSegment(ee.mkEllipse(0,.5*Math.PI,z,$,h+f,c+P)),f>0&&s.addSegment(w.mkPP(new d(h+f,v),new d(h-f,v))),s.addSegment(ee.mkEllipse(.5*Math.PI,Math.PI,z,$,h-f,c+P)),P>0&&s.addSegment(w.mkPP(new d(O,c+P),new d(O,c-P))),s.addSegment(ee.mkEllipse(Math.PI,1.5*Math.PI,z,$,h-f,c-P)),s}},me=ci;me.octagonPad=1/4;function Br(l){return l.parEnd-l.parStart}function Ra(l){switch(l.type){case"ellipse":return ee.fromJSON(l.data);case"curve":return E.fromJSON(l.data);case"lineSegment":return w.fromJSON(l.data);case"bezier":return be.fromJSON(l.data);case"polyline":return j.fromJSON(l.data)}}function Vf(l){if(l instanceof ee)return"ellipse";if(l instanceof E)return"curve";if(l instanceof w)return"lineSegment";if(l instanceof be)return"bezier";if(l instanceof j)return"polyline";throw new Error("not implemented")}function Na(l){return{type:Vf(l),data:l.toJSON()}}var Zt=class{static get DifferenceEpsilon(){return Zt.differenceEpsilon}static EqualPP(t,e){return Zt.Equal(t.x,e.x)&&Zt.Equal(t.y,e.y)}static Equal(t,e){return Zt.Compare(t,e)===0}static Compare(t,e){let i=0;return t+Zt.DifferenceEpsilon<e?i=-1:e+Zt.DifferenceEpsilon<t&&(i=1),i}static ComparePP(t,e){let i=Zt.Compare(t.x,e.x);return i===0&&(i=Zt.Compare(t.y,e.y)),i}static LessOrEqual(t,e){let i=Zt.Compare(t,e);return i<0||i===0}static Less(t,e){return Zt.Compare(t,e)<0}static GetDirections(t,e){return F.DirectionFromPointToPoint(t,e)}static IsPureDirection(t,e){return F.IsPureDirection(Zt.GetDirections(t,e))}static IsPureDirectionD(t){return F.IsPureDirection(t)}static IsPureLower(t,e){let i=Zt.GetDirections(t,e);return 2===i||1===i}static GetPureDirectionVV(t,e){return Zt.GetDirections(t.point,e.point)}},B=Zt;B.differenceEpsilon=C.distanceEpsilon/2;var F=class{constructor(t){this.Dir=t}get Right(){return new F(F.RotateRight(this.Dir))}static RotateRight(t){switch(t){case 1:return 2;case 2:return 4;case 4:return 8;case 8:return 1;default:throw new Error}}static RotateLeft(t){switch(t){case 1:return 8;case 8:return 4;case 4:return 2;case 2:return 1;default:throw new Error}}static ToIndex(t){switch(t){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new Error}}static VectorDirection(t){let e=0;return t.x>B.DifferenceEpsilon?e=2:t.x<-B.DifferenceEpsilon&&(e=8),t.y>B.DifferenceEpsilon?e=e|1:t.y<-B.DifferenceEpsilon&&(e=e|4),e}static VectorDirectionPP(t,e){let i=0,n=e.x-t.x,o=e.y-t.y;return n>B.DifferenceEpsilon?i=2:-n>B.DifferenceEpsilon&&(i=8),o>B.DifferenceEpsilon?i|=1:-o>B.DifferenceEpsilon&&(i|=4),i}static DirectionFromPointToPoint(t,e){return F.VectorDirectionPP(t,e)}static OppositeDir(t){switch(t){case 1:return 4;case 8:return 2;case 4:return 1;case 2:return 8;default:return 0}}static IsPureDirection(t){switch(t){case 1:return!0;case 2:return!0;case 4:return!0;case 8:return!0;default:return!1}}static IsPureDirectionPP(t,e){return F.IsPureDirection(F.DirectionFromPointToPoint(t,e))}static DirectionsAreParallel(t,e){return t===e||t===F.OppositeDir(e)}ToPoint(){let t=0,e=0;return(this.Dir&2)===2&&t++,(this.Dir&1)===1&&e++,(this.Dir&8)===8&&t--,(this.Dir&4)===4&&e--,new d(t,e)}static toPoint(t){return new F(t).ToPoint()}static negate(t){return new F(F.OppositeDir(t.Dir))}};var Lr=class extends ie{constructor(e,i){super(e);this._isPositioned=!1;i&&(this.boundingBox=D.mkPP(new d(0,0),new d(i.width,i.height)))}clone(){let e=new Lr(null,null);return e.isPositioned=this.isPositioned,e._boundingBox=this._boundingBox.clone(),e.attachmentSegmentEnd=this.attachmentSegmentEnd,e.attachmentSegmentStart=this.attachmentSegmentStart,e}get isPositioned(){return this._isPositioned}set isPositioned(e){this._isPositioned=e}get boundingBox(){return this._boundingBox}set boundingBox(e){this._boundingBox=e}setBoundingBox(e){this.isPositioned=!0,this._boundingBox=e}get width(){return this.boundingBox.width}set width(e){this.boundingBox.width=e}get height(){return this.boundingBox.height}set height(e){this.boundingBox.height=e}get center(){return this.boundingBox.center}set center(e){this.boundingBox.center=e}translate(e){this.isPositioned&&(this.center=this.center.add(e))}transform(e){this.isPositioned&&(this.center=e.multiplyPoint(this.center))}positionCenter(e){this.boundingBox.center=e,this.isPositioned=!0}};var Re=class extends ie{constructor(e){super(e);this.lineWidth=1}static getGeom(e){return ie.getGeom(e)}clone(){let e=new Re(null);return this.smoothedPolyline&&(e.smoothedPolyline=this.smoothedPolyline.clone()),e.curve=this.curve.clone(),this.sourceArrowhead!=null&&(e.sourceArrowhead=this.sourceArrowhead.clone()),this.targetArrowhead!=null&&(e.targetArrowhead=this.targetArrowhead.clone()),e}get label(){return this.edge!=null&&this.edge.label!=null?ie.getGeom(this.edge.label):null}set label(e){this.edge.label.setAttr(Ae.GeomObjectIndex,e)}RaiseLayoutChangeEvent(e){this.edge.raiseEvents(e)}requireRouting(){this.curve=null,this.smoothedPolyline=null}translate(e){if(!(e.x===0&&e.y===0)){if(this.curve!=null&&this.curve.translate(e),this.smoothedPolyline!=null)for(let i=this.smoothedPolyline.headSite,n=this.smoothedPolyline.headSite;i!=null;i=i.next,n=n.next)i.point=n.point.add(e);if(this.sourceArrowhead!=null&&this.sourceArrowhead.tipPosition&&(this.sourceArrowhead.tipPosition=this.sourceArrowhead.tipPosition.add(e)),this.targetArrowhead!=null&&this.targetArrowhead.tipPosition&&(this.targetArrowhead.tipPosition=this.targetArrowhead.tipPosition.add(e)),this.edge.label){let i=Lr.getGeom(this.edge.label);i&&i.translate(e)}}}GetMaxArrowheadLength(){let e=0;return this.sourceArrowhead!=null&&(e=this.sourceArrowhead.length),this.targetArrowhead!=null&&this.targetArrowhead.length>e?this.targetArrowhead.length:e}transform(e){if(this.curve!=null){if(this.curve=this.curve.transform(e),this.smoothedPolyline!=null)for(let i=this.smoothedPolyline.headSite,n=this.smoothedPolyline.headSite;i!=null;i=i.next,n=n.next)i.point=e.multiplyPoint(i.point);this.sourceArrowhead!=null&&(this.sourceArrowhead.tipPosition=e.multiplyPoint(this.sourceArrowhead.tipPosition)),this.targetArrowhead!=null&&(this.targetArrowhead.tipPosition=e.multiplyPoint(this.targetArrowhead.tipPosition))}}get edge(){return this.entity}get source(){return ie.getGeom(this.edge.source)}*sourceArrowheadPoints(e){if(this.sourceArrowhead==null)return;yield this.sourceArrowhead.tipPosition;let i=this.sourceArrowhead.tipPosition.sub(this.curve.start);i=i.rotate90Cw().mul(Math.tan(e*.5*(Math.PI/180))),yield i.add(this.curve.start),yield this.curve.start.sub(i)}*targetArrowheadPoints(e){if(this.targetArrowhead==null)return;yield this.targetArrowhead.tipPosition;let i=this.targetArrowhead.tipPosition.sub(this.curve.end);i=i.rotate90Cw().mul(Math.tan(e*.5*(Math.PI/180))),yield i.add(this.curve.end),yield this.curve.end.sub(i)}get boundingBox(){let e=D.mkEmpty();if(this.smoothedPolyline!=null)for(let n of this.smoothedPolyline)e.add(n);this.curve!=null&&e.addRecSelf(this.curve.boundingBox);for(let n of this.sourceArrowheadPoints(25))e.add(n);for(let n of this.targetArrowheadPoints(25))e.add(n);this.label&&e.addRecSelf(this.label.boundingBox);let i=this.lineWidth;return e.left-=i,e.top+=i,e.right+=i,e.bottom-=i,e}isInterGraphEdge(){return this.edge.isInterGraphEdge()}get target(){return ie.getGeom(this.edge.target)}toString(){return this.source.toString()+"->"+this.target}static RouteSelfEdge(e,i,n){let o=e.boundingBox.width,s=e.boundingBox.height,a=e.boundingBox.center,u=new d(a.x-o/4,a.y),h=new d(a.x-o/4,a.y-s/2-i),c=new d(a.x+o/4,a.y-s/2-i),f=new d(a.x+o/4,a.y);return n.smoothedPolyline=Ge.mkFromPoints([u,h,c,f]),n.smoothedPolyline.createCurve()}underCollapsedGraph(){return this.source.underCollapsedGraph()||this.target.underCollapsedGraph()}EdgeToAncestor(){return this.edge.EdgeToAncestor()}};var Is=he(Gr(),1);function Mf(l,t,e,i,n,o){for(let a=0;a<l.length;a++){if(a===t||a===e)continue;let u=o.box0.add_rect(l[a].irect),h=u.area-o.box0.area,c=o.box1.add_rect(l[a].irect),f=c.area-o.box1.area;i.length*2<n.length?(i.push(l[a]),o.box0=u):n.length*2<i.length?(n.push(l[a]),o.box1=c):h<f?(i.push(l[a]),o.box0=u):f<h?(n.push(l[a]),o.box1=c):o.box0.area<o.box1.area?(i.push(l[a]),o.box0=u):(n.push(l[a]),o.box1=c)}}function Oe(l){if(l.length===0)return null;if(l.length===1)return l[0];let t={b0:l[0].irect,seed0:1},e=Wf(l,t),i=[],n=[];i.push(l[t.seed0]),n.push(l[e]);let o={box0:l[t.seed0].irect,box1:l[e].irect};Mf(l,t.seed0,e,i,n,o);let s=Gc(l.length);return s.irect=o.box0.add_rect(o.box1),s.Left=Oe(i),s.Right=Oe(n),s}function Lc(l,t){return l.add_rect(t).area}function Wf(l,t){let e=Lc(t.b0,l[t.seed0].irect);for(let n=2;n<l.length;n++){let o=Lc(t.b0,l[n].irect);o>e&&(t.seed0=n,e=o)}let i;for(let n=0;n<l.length;n++)if(n!==t.seed0){i=n;break}e=l[t.seed0].irect.add_rect(l[i].irect).area;for(let n=0;n<l.length;n++){if(n===t.seed0)continue;let o=l[t.seed0].irect.add_rect(l[n].irect).area;o>e&&(i=n,e=o)}return i}function Di(l,t){if(l==null||t==null)return null;let e=Array.from(l).map(i=>Fe(i,t(i)));return Oe(e)}function Gc(l){let t=new Jn;return t.Count=l,t}function Fe(l,t){let e=new Jn;return e.UserData=l,e.irect=t,e.Count=1,e}function Vu(l,t,e){return l.irect.intersects_rect(e)?t(l.UserData)===0?l.Left!=null?Vu(l.Left,t,e)===0&&Vu(l.Right,t,e)===0?0:1:0:1:0}var Jn=class{toString(){return this.IsLeaf?this.Count.toString()+" "+this.UserData:this.Count.toString()}get IsLeaf(){return this.left==null}get Left(){return this.left}set Left(t){this.left!=null&&this.left.Parent===this&&(this.left.Parent=null),this.left=t,this.left!=null&&(this.left.Parent=this)}get Right(){return this.right}set Right(t){this.right!=null&&this.right.Parent===this&&(this.right.Parent=null),this.right=t,this.right!=null&&(this.right.Parent=this)}get IsLeftChild(){return this===this.Parent.Left}FirstIntersectedNode(t){var e;return t.intersects_rect(this.irect)?this.IsLeaf?this:(e=this.Left.FirstIntersectedNode(t))!=null?e:this.Right.FirstIntersectedNode(t):null}FirstHitNodeWithPredicate(t,e){var i;return this.irect.contains_point(t)?this.IsLeaf?e(t,this.UserData)===1?this:null:(i=this.Left.FirstHitNodeWithPredicate(t,e))!=null?i:this.Right.FirstHitNodeWithPredicate(t,e):null}FirstHitByRectWithPredicate(t,e){var i;return this.irect.intersects_rect(t)?this.IsLeaf?e(this.UserData)===1?this:null:(i=this.Left.FirstHitByRectWithPredicate(t,e))!=null?i:this.Right.FirstHitByRectWithPredicate(t,e):null}FirstHitNode(t){var e;return this.irect.contains_point(t)?this.IsLeaf?this:(e=this.Left.FirstHitNode(t))!=null?e:this.Right.FirstHitNode(t):null}*AllHitItems(t,e=null){let i=new Is.Stack;for(i.push(this);i.size>0;){let n=i.pop();n.irect.intersects_rect(t)&&(n.IsLeaf?(e==null||e(n.UserData))&&(yield n.UserData):(i.push(n.left),i.push(n.right)))}}*AllHitItems_(t){let e=new Is.Stack;for(e.push(this);e.size>0;){let i=e.pop();i.irect.contains_point(t)&&(i.IsLeaf?yield i.UserData:(e.push(i.left),e.push(i.right)))}}VisitTree(t,e){Vu(this,t,e)}Clone(){let t=Gc(this.Count);return t.UserData=this.UserData,t.irect=this.irect,this.Left!=null&&(t.Left=this.Left.Clone()),this.Right!=null&&(t.Right=this.Right.Clone()),t}*GetNodeItemsIntersectingRectangle(t){for(let e of this.GetLeafRectangleNodesIntersectingRectangle(t))yield e.UserData}*GetLeafRectangleNodesIntersectingRectangle(t){let e=new Is.Stack;for(e.push(this);e.size>0;){let i=e.pop();i.irect.intersects_rect(t)&&(i.IsLeaf?yield i:(e.push(i.left),e.push(i.right)))}}*GetAllLeaves(){for(let t of this.GetAllLeafNodes())yield t.UserData}*GetAllLeafNodes(){for(let t of this.EnumRectangleNodes(!0))yield t}*EnumRectangleNodes(t){let e=new Is.Stack;for(e.push(this);e.size>0;){let i=e.pop();(i.IsLeaf||!t)&&(yield i),i.IsLeaf||(e.push(i.left),e.push(i.right))}}TraverseHierarchy(t,e){e(t),t.Left!=null&&this.TraverseHierarchy(t.Left,e),t.Right!=null&&this.TraverseHierarchy(t.Right,e)}};var ke=class{constructor(t,e){Vo(t,e)<0?(this._first=t,this._second=e):(this._first=e,this._second=t)}get first(){return this._first}get second(){return this._second}get Length(){return pe(this._first,this._second)}CompareTo(t){let e=Vo(this._first,t._first);return e!==0?e:Vo(this._second,t._second)}static equal(t,e){return t._first.equal(e._first)&&t._second.equal(e._second)}toString(){return this._first+(" "+this._second)}};var Se=class{constructor(){this.size_=0;this.mapOfSets=new Map}delete(t){return this.deletexy(t.x,t.y)}clear(){this.mapOfSets.clear(),this.size_=0}get size(){return this.size_}static mk(t){let e=new Se;for(let i of t)e.add(i);return e}addxy(t,e){let i=this.mapOfSets.get(t);i==null&&this.mapOfSets.set(t,i=new Set),i.has(e)||this.size_++,i.add(e)}add(t){return this.addxy(t.x,t.y),this}deletexy(t,e){let i=this.mapOfSets.get(t);return i!=null&&i.delete(e)?(this.size_--,!0):!1}hasxy(t,e){return this.mapOfSets.has(t)&&this.mapOfSets.get(t).has(e)}has(t){return this.hasxy(t.x,t.y)}forEach(t,e){for(let i of this)t(i,i,e)}*entries(){for(let t of this)yield[t,t]}keys(){return this.values()}*values(){for(let t of this.mapOfSets)for(let e of t[1])yield new d(t[0],e)}[(Symbol.toStringTag,Symbol.iterator)](){return this.values()}};function Fi(l,t){let e=new Set;for(let i of l)t.has(i)||e.add(i);return e}function Rc(l,t){let e=new Se;for(let i of l)t.has(i)||e.add(i);return e}function Ur(l,t){let e=new Set(l);for(let i of t)e.add(i);return e}function di(l,t){for(let e of t)l.push(e)}function jr(l,t){let e=new Set;if(l.size<t.size)for(let i of l)t.has(i)&&e.add(i);else for(let i of t)l.has(i)&&e.add(i);return e}function Nc(l){if(l.length===0)return new Set;let t=l[0];for(let e=1;e<l.length;e++)t=jr(t,l[e]);return t}function sn(l,t){for(let e of t)l.add(e)}function $n(l,t){if(l.size!==t.size)return!1;for(let e of l)if(!t.has(e))return!1;return!0}function gi(l,t){let e=[];for(let i of l)for(let n of t(i))e.push(n);return e}function Kn(l,t,e){let i=l.get(t);i||(i=new Set,l.set(t,i)),i.add(e)}function Yn(l,t,e){let i=l.get(t);i||(i=new Array,l.set(t,i)),i.push(e)}function ku(l,t,e){let i=l.get(t);i||(i=new Set,l.set(t,i)),i.add(e)}function Dc(l,t,e){ku(l,new ke(t[0],t[1]),e)}function Hf(l,t,e){let i=l.get(t);i&&i.delete(e)}function Mu(l,t,e){Hf(l,new ke(t[0],t[1]),e)}var zu=he(Qr(),1);var le=class{static assert(t,e=null){if(!t)throw e!=null?(console.log(e),new Error(e)):new Error("condition does not hold")}};var Vi=class{constructor(){this.attrs=[];this._parent=null}addEvent(t){this.events.push(t)}removeEvent(t){let e=this.events.indexOf(t);e>=0&&(this.events=this.events.splice(e,1))}raiseEvents(t){this.events.forEach(e=>e(t))}clearAttr(){this.attrs=[]}setAttr(t,e){this.attrs[t]=e}getAttr(t){return this.attrs[t]}get parent(){return this._parent}set parent(t){this._parent=t}*getAncestors(){let t=this.parent;for(;t!=null;)yield t,t=t.parent}isDescendantOf(t){for(let e of this.getAncestors())if(e===t)return!0;return!1}};var sr=class extends Vi{constructor(e,i){super();this.source=e,this.target=i,e!==i?(e.outEdges.add(this),i.inEdges.add(this)):e.selfEdges.add(this)}add(){this.source!==this.target?(this.source.outEdges.add(this),this.target.inEdges.add(this)):this.source.selfEdges.add(this)}remove(){this.source!==this.target?(this.source.outEdges.delete(this),this.target.inEdges.delete(this)):this.source.selfEdges.delete(this)}toString(){return"("+this.source.toString()+"->"+this.target.toString()+")"}isInterGraphEdge(){return this.source.parent!==this.target.parent}EdgeToAncestor(){return this.source instanceof de&&this.target.isDescendantOf(this.source)?1:this.target instanceof de&&this.source.isDescendantOf(this.target)?2:0}};var Rr=class extends Vi{constructor(e){super();this.inEdges=new Set;this.outEdges=new Set;this.selfEdges=new Set;this.id=e}removeOutEdge(e){this.outEdges.delete(e)}removeInEdge(e){this.inEdges.delete(e)}get id(){return this._id}set id(e){this._id=e}toString(){return this.id}*_edges(){for(let e of this.inEdges)yield e;for(let e of this.outEdges)yield e;for(let e of this.selfEdges)yield e}get edges(){return this._edges()}get outDegree(){return this.outEdges.size}get inDegree(){return this.inEdges.size}get selfDegree(){return this.selfEdges.size}get degree(){return this.outDegree+this.inDegree+this.selfDegree}};var Fa=class{constructor(){this.nodeMap=new Map}remove(t){this.nodeMap.delete(t.id)}get size(){return this.nodeMap.size}*nodes_(){for(let t of this.nodeMap.values())yield t}*graphs_(){for(let t of this.nodes_())t instanceof de&&(yield t)}findShallow(t){return this.nodeMap.get(t)}get nodesShallow(){return this.nodes_()}get graphs(){return this.graphs_()}*_edges(){for(let t of this.nodeMap.values()){for(let e of t.outEdges)yield e;for(let e of t.selfEdges)yield e}}interGraphEdges(){throw new Error("not implemented")}get nodeShallowCount(){return this.nodeMap.size}get edgeCount(){let t=0;for(let e of this.nodeMap.values())t+=e.outDegree+e.selfDegree;return t}get edges(){return this._edges()}addNode(t){this.nodeMap.set(t.id,t)}nodeIsConsistent(t){for(let e of t.outEdges)if(e.source!==t||e.source===e.target)return!1;for(let e of t.inEdges)if(e.target!==t||e.source===e.target)return!1;for(let e of t.selfEdges)if(e.target!==e.source||e.source!==t)return!1;return!0}isConsistent(){for(let t of this.nodeMap.values())if(!this.nodeIsConsistent(t))return!1;return!0}};var de=class extends Rr{constructor(e="__graph__"){super(e);this.nodeCollection=new Fa}remove(e){this.nodeCollection.remove(e)}removeSubgraph(){let e=this.parent;e&&e.removeNode(this);for(let i of this.outGoingEdges())i.attachedAtSource?i.node.removeOutEdge(i.edge):i.node.removeInEdge(i.edge)}*outGoingEdges(){for(let e of this.outEdges){let i=e.target;this.isAncestor(i)||(yield{edge:e,node:i,attachedAtSource:!1})}for(let e of this.inEdges){let i=e.source;this.isAncestor(i)||(yield{edge:e,node:i,attachedAtSource:!0})}for(let e of this.nodesBreadthFirst){for(let i of e.outEdges){let n=i.target;n!==this&&(this.isAncestor(n)||(yield{edge:i,node:n,attachedAtSource:!1}))}for(let i of e.inEdges){let n=i.source;n!==this&&(this.isAncestor(n)||(yield{edge:i,node:n,attachedAtSource:!0}))}}}isAncestor(e){for(let i of e.getAncestors())if(i===this)return!0;return!1}*getClusteredConnectedComponents(){let e=new Set,i=new zu.Queue;for(let n of this.nodesBreadthFirst){if(e.has(n))continue;e.add(n),i.enqueue(n);let o=new Set;do{let s=i.dequeue();s.parent===this&&o.add(s);for(let a of this.reachableFrom(s))e.has(a)||(e.add(a),i.enqueue(a))}while(i.length>0);yield Array.from(o)}}*reachableFrom(e){for(let i of e.outEdges)yield i.target;for(let i of e.inEdges)yield i.source;e instanceof de&&(yield*e.shallowNodes),e.parent!=this&&(yield e.parent)}hasSomeAttrOnIndex(e){for(let i of this.nodesBreadthFirst)if(i.getAttr(e))return!0;for(let i of this.deepEdges)if(i.getAttr(e))return!0;return!1}*graphs(){for(let e of this.nodeCollection.graphs)yield e}noEmptySubgraphs(){for(let e of this.subgraphsBreadthFirst())if(e.shallowNodeCount===0)return!1;return!0}hasSubgraphs(){for(let e of this.shallowNodes)if(e instanceof de)return!0;return!1}*subgraphsBreadthFirst(){for(let e of this.nodesBreadthFirst)e instanceof de&&(yield e)}isEmpty(){return this.shallowNodeCount===0}setEdge(e,i){let n=this.nodeCollection.findShallow(e);if(n==null)return;let o=this.nodeCollection.findShallow(i);if(o!=null)return new sr(n,o)}get shallowNodes(){return this.nodeCollection.nodesShallow}get nodesBreadthFirst(){return this.nodesBreadthFirst_()}*nodesBreadthFirst_(){for(let e of this.nodeCollection.nodesShallow)yield e,e instanceof de&&(yield*e.nodesBreadthFirst)}findNodeRecursive(e){let i=this.nodeCollection.findShallow(e);if(i)return i;for(let n of this.shallowNodes)if(n instanceof de){let o=n.findNodeRecursive(e);if(o)return o}return null}findNode(e){return this.nodeCollection.findShallow(e)}get shallowEdges(){return this.nodeCollection.edges}get deepEdges(){return this.deepEdgesIt()}*deepEdgesIt(){for(let e of this.nodesBreadthFirst){for(let i of e.outEdges)yield i;for(let i of e.selfEdges)yield i;for(let i of e.inEdges)this.isAncestor(i.source)||(yield i)}}isConsistent(){return this.parent?this.parent.isConsistent():this.eachNodeIdIsUnique()&&this.nodeCollection.isConsistent()}nodeIsConsistent(e){return this.nodeCollection.nodeIsConsistent(e)}removeNode(e){for(let i of e.outEdges)i.target.inEdges.delete(i);for(let i of e.inEdges)i.source.outEdges.delete(i);this.nodeCollection.remove(e);for(let i of this.subgraphsBreadthFirst())i.removeNode(e)}addNode(e){return le.assert(this.findNodeRecursive(e.id)==null),e.parent=this,this.nodeCollection.addNode(e),e}get shallowNodeCount(){return this.nodeCollection.nodeShallowCount}get nodeCountDeep(){let e=this.nodeCollection.size;for(let i of this.shallowNodes)i instanceof de&&(e+=i.nodeCountDeep);return e}get edgeCount(){return this.nodeCollection.edgeCount}liftNode(e){for(;e!=null&&e.parent!==this;)e=e.parent;return e}get deepEdgesCount(){let e=0;for(let i of this.nodesBreadthFirst)e+=i.outDegree+i.selfDegree;return e}eachNodeIdIsUnique(){let e=new Set;for(let i of this.nodesBreadthFirst){if(e.has(i.id))return!1;e.add(i.id)}return!0}*allElements(){for(let e of this.allSuccessorsWidthFirst()){yield e;for(let i of e.selfEdges)yield i;for(let i of e.outEdges)yield i;for(let i of e.inEdges)this.isAncestor(i.source)||(yield i)}yield*this.edges}*allSuccessorsWidthFirst(){for(let e of this.shallowNodes)yield e;for(let e of this.shallowNodes)e instanceof de&&(yield*e.allSuccessorsWidthFirst())}*allSuccessorsDepthFirst(){for(let e of this.shallowNodes)e instanceof de&&(yield*e.allSuccessorsDepthFirst()),yield e}};function*Fc(l){let t=new Set,e=new zu.Queue;for(let o of l.shallowNodes){if(t.has(o))continue;let s=new Array;for(n(o,e,t);e.length>0;){let a=e.dequeue();s.push(a);for(let u of i(a))n(u,e,t)}yield s}function*i(o){for(let s of o.outEdges)yield s.target;for(let s of o.inEdges)yield s.source}function n(o,s,a){a.has(o)||(s.enqueue(o),a.add(o))}}function qu(l,t){t.parent&&t.parent.remove(t),l.addNode(t)}function ws(l,t){return t.has(l.source)&&t.has(l.target)}var Zn=class extends ie{constructor(){super(...arguments);this.padding=1}clone(){let e=new Zn(null);return this.boundaryCurve&&(e.boundaryCurve=this.boundaryCurve.clone()),e}translate(e){e.x===0&&e.y===0||this.boundaryCurve.translate(e)}toJSON(){return{boundaryCurve:this.boundaryCurve,padding:this.padding}}get node(){return this.entity}get boundaryCurve(){return this._boundaryCurve}set boundaryCurve(e){e!=null&&e.boundingBox&&(e.boundingBox.height<Zn.minHeight||e.boundingBox.width<Zn.minWidth)&&(e=me.mkCircle(Zn.minWidth,e.boundingBox.center)),this._boundaryCurve=e}get id(){return this.node.id}toString(){return this.id}static mkNode(e,i){let n=new Zn(i);return n.boundaryCurve=e,n}get center(){return this.boundaryCurve.boundingBox.center}set center(e){let i=e.sub(this.center);this.boundaryCurve.translate(i)}fitBoundaryCurveToTarget(e){if(this.boundaryCurve!=null){let i=me.isRoundedRect(this.boundaryCurve);if(i==null){let n=e.width/this.boundaryCurve.boundingBox.width,o=e.height/this.boundaryCurve.boundingBox.height;this.boundaryCurve=this.boundaryCurve.scaleFromOrigin(n,o),this.boundaryCurve.translate(e.center.sub(this.boundaryCurve.boundingBox.center))}else this.boundaryCurve=me.mkRectangleWithRoundedCorners(e.width,e.height,i.radX,i.radY,e.center)}}static getGeom(e){return e.getAttr(Ae.GeomObjectIndex)}*inEdges(){for(let e of this.node.inEdges)yield ie.getGeom(e)}*outEdges(){for(let e of this.node.outEdges)yield ie.getGeom(e)}*selfEdges(){for(let e of this.node.selfEdges)yield ie.getGeom(e)}get boundingBoxWithPadding(){let e=this.boundingBox.clone();return e.pad(this.padding),e}get boundingBox(){return this.boundaryCurve?this.boundaryCurve.boundingBox:null}set boundingBox(e){!this.boundaryCurve||(Math.abs(e.width-this.width)<1e-4&&Math.abs(e.height-this.height)<1e-4?this.center=e.center:this.fitBoundaryCurveToTarget(e))}get width(){return this.boundaryCurve.boundingBox.width}get height(){return this.boundaryCurve.boundingBox.height}transform(e){this.boundaryCurve!=null&&(this.boundaryCurve=this.boundaryCurve.transform(e))}underCollapsedGraph(){let e=this.node.parent;if(e==null)return!1;let i=ie.getGeom(e);return i==null?!1:i.isCollapsed?!0:i.underCollapsedGraph()}*getAncestors(){for(let e of this.node.getAncestors())yield ie.getGeom(e)}},Ke=Zn;Ke.minHeight=2,Ke.minWidth=3;var _=class{ProgressStep(){}constructor(t){this.cancelToken=t}};var Uu=class{},an=Uu;an.GoldenRatio=(1+Math.sqrt(5))/2,an.GoldenRatioRemainder=2-Uu.GoldenRatio;var ln=class extends _{constructor(e,i){super(null);this.desiredAspectRatio=1.2;this.bestPacking=null;this.cachedCosts=new Map;this.rectangles=e,this.desiredAspectRatio=i}get PackedWidth(){return this.bestPacking!=null?this.bestPacking.PackedWidth:0}get PackedHeight(){return this.bestPacking!=null?this.bestPacking.PackedHeight:0}Pack(e,i,n){let o=ln.GetGoldenSectionStep(e,i),s=Math.max(n/10,(i-e)/ln.MaxSteps);i+=s,this.bestPackingCost=Number.MAX_VALUE,this.rectangles.length===1?this.PackLimit(e):this.rectangles.length===2?(this.PackLimit(e),this.PackLimit(i)):this.rectangles.length>2&&ln.GoldenSectionSearch(u=>this.PackLimit(u),e,o,i,s);let a=this.bestPacking.getRects();for(let u=0;u<this.rectangles.length;u++)this.rectangles[u]=a[u]}PackLimit(e){let i=this.cachedCosts.get(e);if(i==null){let n=this.createPacking(this.rectangles,e);n.run(),this.cachedCosts.set(e,i=Math.abs(n.PackedAspectRatio-this.desiredAspectRatio)),i<this.bestPackingCost&&(this.bestPackingCost=i,this.bestPacking=n)}return i}static GoldenSectionSearch(e,i,n,o,s){if(Math.abs(i-o)<s)return e(i)<e(o)?i:o;let a=ln.GetGoldenSectionStep(n,o),u=e(n),h=e(a),c=()=>ln.GoldenSectionSearch(e,a,n,i,s),f=()=>ln.GoldenSectionSearch(e,n,a,o,s);if(h<u)return f();if(h>u)return c();let P=f(),v=c();return e(v)<e(P)?v:P}static GetGoldenSectionStep(e,i){return e<i?e+an.GoldenRatioRemainder*(i-e):e-an.GoldenRatioRemainder*(e-i)}},Ts=ln;Ts.MaxSteps=1e3;var Vc=he(Gr(),1);var Va=class extends _{get PackedWidth(){return this.packedWidth}set PackedWidth(e){this.packedWidth=e}get PackedHeight(){return this.packedHeight}set PackedHeight(e){this.packedHeight=e}get PackedAspectRatio(){return this.PackedWidth/this.PackedHeight}getRects(){let e=[];for(let[i,n]of this.rectsToCenters)i.center=n,e.push(i);return e}};var un=class extends Va{constructor(e,i,n=!1){super(null);this.rectsToCenters=new Map,this.rectanglesByDescendingHeight=n?e:un.SortRectangles(e),this.wrapWidth=i}static SortRectangles(e){return e.sort((i,n)=>n.height-i.height),e}run(){this.Pack()}Pack(){this.PackedWidth=0,this.PackedHeight=0;let e=new Vc.Stack,i=!1,n=0,o=0,s=0,a=this.rectanglesByDescendingHeight;for(let u=0;i||u<a.length;){let h=a[u],c=e.length>0?e.top:null;if(c==null||c.right+h.width<=this.wrapWidth&&n+h.height<=c.top){let P=new d(c?c.right:0,n).add(new d(h.width/2,h.height/2));h.center=P,this.rectsToCenters.set(h,P),o=Math.max(o,h.right),s=Math.max(s,h.top),e.push(h),i=!1}else n=c.top,e.pop(),i=!0;i||u++}this.PackedWidth=o,this.PackedHeight=s}};var _n=class extends Ts{constructor(t,e){super(un.SortRectangles(t),e),this.createPacking=(i,n)=>new un(i,n,!0)}run(){let t=Number.MAX_VALUE,e=0,i=0;for(let n of this.rectangles){let o=n.width;i+=o,t=Math.min(t,o),e=Math.max(e,o)}this.Pack(e,i,t)}};function ki(l){return new mi(Oe(l.map(([t,e])=>Fe(e,t))))}function qf(l,t){l.UserData=t.UserData,l.Left=t.Left,l.Right=t.Right,l.Count--,l.irect=t.irect}function kc(l){for(let t=l.Parent;t!=null;t=t.Parent)t.Count--,t.irect=t.Left.irect.add_rect(t.Right.irect)}function Uf(l,t){let e=new Array;for(let n of l.GetAllLeafNodes())n!==t&&e.push(n);let i=Oe(e);l.Count=i.Count,l.Left=i.Left,l.Right=i.Right,l.irect=i.Left.irect.add_rect(i.Right.irect)}function jf(l){for(let t=l.Parent;t!=null;t=t.Parent)if(!Mc(t))return t;return null}function Mc(l){return 2*l.Left.Count>=l.Right.Count&&2*l.Right.Count>=l.Left.Count}function ju(l,t,e,i){return l.irect.intersects_rect(t)?l.IsLeaf?i(l.UserData)?--e.bound!==0:!0:ju(l.Left,t,e,i)&&ju(l.Right,t,e,i):!0}var mi=class{clear(){this.RootNode=null}NumberOfIntersectedIsLessThanBound(t,e,i){return ju(this._rootNode,t,{bound:e},i)}get RootNode(){return this._rootNode}set RootNode(t){this._rootNode=t}constructor(t){this._rootNode=t}*GetAllLeaves(){if(this._rootNode!=null&&this.Count>0)for(let t of this._rootNode.GetAllLeaves())yield t}get Count(){return this._rootNode==null?0:this._rootNode.Count}Add(t,e){this.AddNode(Fe(e,t))}AddNode(t){this._rootNode==null?this._rootNode=t:this.Count<=2?this._rootNode=Oe(Array.from(this._rootNode.GetAllLeafNodes()).concat([t])):this.AddNodeToTreeRecursive(t,this._rootNode)}Rebuild(){this._rootNode=Oe(Array.from(this._rootNode.GetAllLeafNodes()))}AddNodeToTreeRecursive(t,e){if(e.IsLeaf)e.Left=Fe(e.UserData,e.irect),e.Right=t,e.Count=2;else{e.Count++;let i,n;if(2*e.Left.Count<e.Right.Count)this.AddNodeToTreeRecursive(t,e.Left),e.Left.irect=e.Left.irect.add_rect(t.irect);else if(2*e.Right.Count<e.Left.Count)this.AddNodeToTreeRecursive(t,e.Right),e.Right.irect=e.Right.irect.add_rect(t.irect);else{i=e.Left.irect.add_rect(t.irect);let o=i.area-e.Left.irect.area;n=e.Right.irect.add_rect(t.irect);let s=n.area-e.Right.irect.area;o<s?(this.AddNodeToTreeRecursive(t,e.Left),e.Left.irect=i):o>s?(this.AddNodeToTreeRecursive(t,e.Right),e.Right.irect=n):i.area<n.area?(this.AddNodeToTreeRecursive(t,e.Left),e.Left.irect=i):(this.AddNodeToTreeRecursive(t,e.Right),e.Right.irect=n)}}e.irect=e.Left.irect.add_rect(e.Right.irect)}GetAllIntersecting(t){return this._rootNode==null||this.Count===0?[]:Array.from(this._rootNode.GetNodeItemsIntersectingRectangle(t))}OneIntersecting(t){if(this._rootNode==null||this.Count===0)return;let e=this._rootNode.FirstIntersectedNode(t);if(e!=null)return{intersectedLeaf:e.UserData}}GetAllLeavesIntersectingRectangle(t){return this._rootNode==null||this.Count===0?[]:this._rootNode.GetLeafRectangleNodesIntersectingRectangle(t)}IsIntersecting(t){if(this._rootNode==null||this.Count===0)return!1;for(let e of this._rootNode.GetNodeItemsIntersectingRectangle(t))return!0;return!1}Contains(t,e){if(this._rootNode==null)return!1;for(let i of this._rootNode.GetLeafRectangleNodesIntersectingRectangle(t))if(i.UserData===e)return!0;return!1}Remove(t,e){if(this._rootNode==null)return;let i;for(let n of this._rootNode.GetLeafRectangleNodesIntersectingRectangle(t))n.UserData===e&&(i=n);if(i!=null)return this.RootNode.Count===1?this.RootNode=null:this.RemoveLeaf(i),i.UserData}RemoveLeaf(t){let e=jf(t);if(e!=null)Uf(e,t),kc(e);else{let i=t.Parent;i==null?this._rootNode=new Jn:(qf(i,t.IsLeftChild?i.Right:i.Left),kc(i))}}UnbalancedNode(t){for(let e=t.Parent;e!=null;e=e.Parent)if(!Mc(e))return e;return null}};var ka=class extends D{constructor(e){super(e);this.radX=e.radX,this.radY=e.radY,this.roundedRect_=me.mkRectangleWithRoundedCorners(this.width,this.height,e.radX,e.radY,this.center)}onUpdated(){this.isEmpty||(this.roundedRect_=me.mkRectangleWithRoundedCorners(this.width,this.height,this.radX,this.radY,this.center))}isOk(){return this.isEmpty()?!0:this.roundedRect_.boundingBox.equalEps(this)}setRect(e){this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.isEmpty()||(this.roundedRect_=me.mkRectangleWithRoundedCorners(e.width,e.height,this.radX,this.radY,this.center))}};function Ma(l,t){let e=t.map(o=>[o,o.boundingBox]),i=e.map(o=>o[1]),n=new _n(i,1.5);n.run();for(let[o,s]of e){let a=s.leftBottom.sub(o.boundingBox.leftBottom);o.translate(a)}l.boundingBox=new D({left:0,bottom:0,right:n.PackedWidth,top:n.PackedHeight})}var ne=class extends Ke{constructor(e){super(e);this.margins={left:10,top:10,bottom:10,right:10};this.radX=10;this.radY=10;this.rrect=new ka({left:0,right:-1,top:20,bottom:0,radX:this.radX,radY:this.radY})}isAncestor(e){return this.graph.isAncestor(e.node)}deepTranslate(e){for(let i of this.nodesBreadthFirst){i instanceof ne?i.boundingBox=i.boundingBox.translate(e):i.translate(e);for(let n of i.selfEdges())n.translate(e);for(let n of i.outEdges())this.graph.isAncestor(n.target.node)&&n.translate(e)}this.boundingBox=this.boundingBox.translate(e)}clone(){let e=new ne(null);return e.boundingBox=this.boundingBox.clone(),e.layoutSettings=this.layoutSettings,e.margins=this.margins,e.radX=this.radX,e.radY=this.radY,e}calculateBoundsFromChildren(){let e=D.mkEmpty();for(let i of this.shallowNodes)e.addRecSelf(i.boundingBoxWithPadding);return e.padEverywhere(this.margins),e}*allSuccessorsWidthFirst(){for(let e of this.graph.allSuccessorsWidthFirst())yield Ke.getGeom(e)}static getGeom(e){return ie.getGeom(e)}edgeCurveOrArrowheadsIntersectRect(e,i){for(let s of e.sourceArrowheadPoints(25))if(i.contains(s))return!0;for(let s of e.targetArrowheadPoints(25))if(i.contains(s))return!0;let n=e.curve,o=i.perimeter();return E.intersectionOne(n,o,!1)!=null||E.PointRelativeToCurveLocation(n.start,o)===2}isEmpty(){return this.graph.isEmpty()}setSettingsRecursively(e){this.layoutSettings=e;for(let i of this.nodesBreadthFirst){let n=i;n.layoutSettings=e}}get layoutSettings(){return this._layoutSettings}set layoutSettings(e){this._layoutSettings=e}get labelSize(){return this._labelSize}set labelSize(e){this._labelSize=e}get boundingBox(){return this.rrect?this.rrect.clone():null}set boundingBox(e){e?this.rrect.setRect(e):this.rrect.roundedRect_=null}transform(e){if(!e.isIdentity()){for(let i of this.shallowNodes)i.transform(e);for(let i of this.shallowEdges)i.transform(e),i.label&&i.label.transform(e);this.boundingBox=this.rrect==null||this.rrect.isEmpty()?this.pumpTheBoxToTheGraphWithMargins():this.boundingBox.transform(e)}}translate(e){e.x===0&&e.y===0||this.deepTranslate(e)}get nodesBreadthFirst(){return this.nodesBreadthFirstIter()}*nodesBreadthFirstIter(){for(let e of this.graph.nodesBreadthFirst)yield ie.getGeom(e)}setEdge(e,i){let n=this.graph.setEdge(e,i);return new Re(n)}getPumpedGraphWithMarginsBox(){let e={b:D.mkEmpty()};return Wa(this,e),e.b.padEverywhere(this.margins),e.b}pumpTheBoxToTheGraphWithMargins(){return this.boundingBox=this.getPumpedGraphWithMarginsBox()}get center(){return this.boundingBox||this.boundingBox.isEmpty?this.boundingBox.center:new d(0,0)}set center(e){let i=e.sub(this.center),n=new Qe(1,0,i.x,0,1,i.y);this.transform(n)}get left(){return this.boundingBox.left}get right(){return this.boundingBox.right}get top(){return this.boundingBox.top}get bottom(){return this.boundingBox.bottom}CheckClusterConsistency(){throw new Error("Method not implemented.")}get edgeCount(){return this.graph.edgeCount}get boundaryCurve(){return this.rrect.roundedRect_}set boundaryCurve(e){throw new Error}get shallowNodes(){return this.shallowNodes_()}*shallowNodes_(){for(let e of this.graph.shallowNodes)yield ie.getGeom(e)}get deepEdges(){return this.deepEdgesIt()}*deepEdgesIt(){for(let e of this.graph.deepEdges)yield ie.getGeom(e)}get shallowEdges(){return this.shallowEdgesIt()}*shallowEdgesIt(){for(let e of this.graph.shallowEdges)yield ie.getGeom(e)}static mk(e,i=new nt(0,0)){let n=new ne(new de(e));return n.labelSize=i,n}get Clusters(){return this.subgraphs()}*subgraphs(){for(let e of this.graph.subgraphsBreadthFirst())yield ie.getGeom(e)}static mkWithGraphAndLabel(e,i){let n=new ne(e);return n.labelSize=i,n}get deepNodeCount(){let e=0;for(let i of this.graph.nodesBreadthFirst)e++;return e}get subgraphsDepthFirst(){return this.getSubgraphsDepthFirst()}*getSubgraphsDepthFirst(){for(let e of this.graph.allSuccessorsDepthFirst())e instanceof de&&(yield ne.getGeom(e))}get uniformMargins(){return Math.max(this.margins.left,this.margins.right,this.margins.right,this.margins.bottom)}set uniformMargins(e){this.margins.left=this.margins.right=this.margins.right=this.margins.bottom=e}get height(){return this.boundingBox.height}get width(){return this.boundingBox.width}get shallowNodeCount(){return this.graph.shallowNodeCount}get graph(){return this.entity}liftNode(e){let i=this.graph.liftNode(e.node);return i?ie.getGeom(i):null}findNode(e){let i=this.graph.findNode(e);return i?ie.getGeom(i):null}addNode(e){return this.graph.addNode(e.node),e}addLabelToGraphBB(e){this.labelSize&&(e.top+=this.labelSize.height+2,e.width<this.labelSize.width&&(e.width=this.labelSize.width))}};function Wa(l,t){for(let i of l.shallowEdges){if(!e(i))continue;let n=i.curve.boundingBox;if(t.b.addRecSelf(n),i.edge.label!=null){let o=ie.getGeom(i.edge.label);o&&t.b.addRecSelf(o.boundingBox)}}for(let i of l.shallowNodes)"shallowEdges"in i&&Wa(i,t),!(i.underCollapsedGraph()||!i.boundingBox)&&t.b.addRecSelf(i.boundingBox);l instanceof ne&&l.addLabelToGraphBB(t.b);function e(i){if(i==null||i.curve==null||i.underCollapsedGraph())return!1;if(l instanceof ne){let n=l.entity;return n.isAncestor(i.source.entity)&&n.isAncestor(i.target.entity)}else return!0}}var Z=class{constructor(t,e){this.x=t,this.y=e}get source(){return this.x}get target(){return this.y}isDiagonal(){return this.x===this.y}};var ar=class{isEmpty(){if(this.arrayOfMaps.length===0)return!0;for(let t of this.arrayOfMaps)if(t.size>0)return!1;return!0}set(t,e,i){this.arrayOfMaps[t].set(e,i)}setPair(t,e){this.set(t.x,t.y,e)}delete(t,e){t<0||t>=this.arrayOfMaps.length||this.arrayOfMaps[t].delete(e)}has(t,e){return t<0||t>=this.arrayOfMaps.length?!1:this.arrayOfMaps[t].has(e)}get(t,e){return t<0||t>=this.arrayOfMaps.length?null:this.arrayOfMaps[t].get(e)}getI(t){return this.get(t.x,t.y)}constructor(t){this.arrayOfMaps=new Array(t);for(let e=0;e<t;e++)this.arrayOfMaps[e]=new Map}*keys(){for(let t=0;t<this.arrayOfMaps.length;t++){let e=this.arrayOfMaps[t];for(let i of e)yield new Z(t,i[0])}}*keyValues(){for(let t=0;t<this.arrayOfMaps.length;t++){let e=this.arrayOfMaps[t];for(let i of e)yield[new Z(t,i[0]),i[1]]}}*values(){for(let t=0;t<this.arrayOfMaps.length;t++){let e=this.arrayOfMaps[t];for(let i of e)yield i[1]}}};var qe=class{constructor(){this.size_=0;this.mapOfMaps=new Map}deleteP(t){return this.delete(t.x,t.y)}clear(){this.mapOfMaps.clear(),this.size_=0}get size(){return this.size_}setxy(t,e,i){let n=this.mapOfMaps.get(t);n==null&&this.mapOfMaps.set(t,n=new Map),n.has(e)||this.size_++,n.set(e,i)}set(t,e){this.setxy(t.x,t.y,e)}delete(t,e){let i=this.mapOfMaps.get(t);return i!=null?(i.delete(e)&&this.size_--,!0):!1}hasxy(t,e){let i=this.mapOfMaps.get(t);return i!=null&&i.has(e)}has(t){return this.hasxy(t.x,t.y)}getxy(t,e){let i=this.mapOfMaps.get(t);if(i!=null)return i.get(e)}get(t){return this.getxy(t.x,t.y)}*keys(){for(let t of this.mapOfMaps)for(let e of t[1])yield new d(t[0],e[0])}*[Symbol.iterator](){for(let t of this.mapOfMaps)for(let e of t[1])yield[new d(t[0],e[0]),e[1]]}*values(){for(let t of this.mapOfMaps)for(let e of t[1])yield e[1]}};var Nr=class{constructor(){this.size_=0;this.mapOfMaps=new qe}clear(){this.mapOfMaps.clear(),this.size_=0}get size(){return this.size_}set(t,e){let i=t._first,n=t._second,o=this.mapOfMaps.get(i);o==null&&this.mapOfMaps.set(i,o=new qe),o.has(n)||this.size_++,o.set(n,e)}delete(t){let e=t._first,i=t._second,n=this.mapOfMaps.get(e);n!=null&&n.deleteP(i)&&this.size_--}has(t){let e=this.mapOfMaps.get(t._first);return e!=null&&e.has(t._second)}getPP(t,e){return this.get(new ke(t,e))}get(t){let e=this.mapOfMaps.get(t._first);if(e!=null)return e.get(t._second)}*keys(){for(let t of this.mapOfMaps)for(let e of t[1])yield new ke(t[0],e[0])}*[Symbol.iterator](){for(let[t,e]of this.mapOfMaps)for(let[i,n]of e)yield[new ke(t,i),n]}*values(){for(let t of this.mapOfMaps)for(let e of t[1])yield e[1]}};var Qu=he(Qr(),1),Xr=class{constructor(t=null){this.parents=new Set;this.children=new Set;this.ports=new Set;this.BoundaryCurve=t}get Parents(){return Array.from(this.parents.values())}get Children(){return Array.from(this.children.values())}get BoundaryCurve(){return this.boundaryCurve}set BoundaryCurve(t){this.boundaryCurve=t}get BoundingBox(){return this.BoundaryCurve.boundingBox}get Ports(){return this.ports}static mkShape(){return new Xr(null)}get IsGroup(){return this.children.size>0}*Descendants(){let t=new Qu.Queue;for(let e of this.Children)t.enqueue(e);for(;t.length>0;){let e=t.dequeue();yield e;for(let i of e.Children)t.enqueue(i)}}*Ancestors(){let t=new Qu.Queue;for(let e of this.Parents)t.enqueue(e);for(;t.length>0;){let e=t.dequeue();yield e;for(let i of e.Parents)t.enqueue(i)}}AddParent(t){this.parents.add(t),t.children.add(this)}AddChild(t){t.parents.add(this),this.children.add(t)}RemoveChild(t){this.children.delete(t),t.parents.delete(this)}RemoveParent(t){this.parents.delete(t),t.children.delete(this)}ToString(){return this.UserData?this.UserData.toString():"null"}};var Mi=class{};var dt=class extends Mi{constructor(e,i){super();this.curve=this.curve,this.location=i.clone()}get Location(){return this.location}set Location(e){this.location=e}Translate(e){this.location=this.location.add(e)}get Curve(){return this.curve}set Curve(e){this.curve=e}};var Rt=class extends dt{constructor(e,i,n){super(null,i().add(n));this.LocationOffset=n,this.CurveDelegate=e,this.CenterDelegate=i}static mk(e,i){return new Rt(e,i,new d(0,0))}get CenterDelegate(){return this.centerDelegate}set CenterDelegate(e){this.centerDelegate=e}get CurveDelegate(){return this.curveDelegate}set CurveDelegate(e){this.curveDelegate=e}get LocationOffset(){return this.locationOffset}set LocationOffset(e){this.locationOffset=e}get Location(){return this.CenterDelegate().add(this.LocationOffset)}get Curve(){return this.CurveDelegate()}};var Wo=class{constructor(t,e,i,n,o){this.color=t,e!==void 0&&(this.item=e),i!==void 0&&(this.parent=i),n!==void 0&&(this.left=n),o!==void 0&&(this.right=o)}toString(){return this.item.toString()}};var Me=class{[Symbol.iterator](){return this.allNodes()}constructor(t){this.comparer=t,this.count=0,this.root=this.nil=new Wo(1)}clear(){this.root=this.nil=new Wo(1)}toNull(t){return t!==this.nil?t:null}isEmpty(){return this.root===this.nil}getComparer(){return this.comparer}getRoot(){return this.root}find(t,e=this.root){let i;for(;e!==this.nil&&(i=this.comparer(t,e.item))!==0;)e=i<0?e.left:e.right;return this.toNull(e)}findFirst(t,e=this.root){if(e===this.nil)return null;let i=null;for(;e!==this.nil;)e=t(e.item)?(i=e).left:e.right;return i}findLast(t,e=this.root){if(e===this.nil)return null;let i=null;for(;e!==this.nil;)e=t(e.item)?(i=e).right:e.left;return i}treeMinimum(t=this.root){for(;t.left!==this.nil;)t=t.left;return this.toNull(t)}treeMaximum(t=this.root){for(;t.right!==this.nil;)t=t.right;return this.toNull(t)}next(t){if(t.right!==this.nil)return this.treeMinimum(t.right);let e=t.parent;for(;e!==this.nil&&t===e.right;)t=e,e=e.parent;return this.toNull(e)}previous(t){if(t.left!==this.nil)return this.treeMaximum(t.left);let e=t.parent;for(;e!==this.nil&&t===e.left;)t=e,e=e.parent;return this.toNull(e)}leftRotate(t){let e=t.right;t.right=e.left,e.left!==this.nil&&(e.left.parent=t),e.parent=t.parent,t.parent===this.nil?this.root=e:t===t.parent.left?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}rightRotate(t){let e=t.left;t.left=e.right,e.right!==this.nil&&(e.right.parent=t),e.parent=t.parent,t.parent===this.nil?this.root=e:t===t.parent.right?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}deleteFixup(t){for(;t!==this.root&&t.color===1;)if(t===t.parent.left){let e=t.parent.right;e.color===0&&(e.color=1,t.parent.color=0,this.leftRotate(t.parent),e=t.parent.right),e.left.color===1&&e.right.color===1?(e.color=0,t=t.parent):(e.right.color===1&&(e.left.color=1,e.color=0,this.rightRotate(e),e=t.parent.right),e.color=t.parent.color,t.parent.color=1,e.right.color=1,this.leftRotate(t.parent),t=this.root)}else{let e=t.parent.left;e.color===0&&(e.color=1,t.parent.color=0,this.rightRotate(t.parent),e=t.parent.left),e.right.color===1&&e.left.color===1?(e.color=0,t=t.parent):(e.left.color===1&&(e.right.color=1,e.color=0,this.leftRotate(e),e=t.parent.left),e.color=t.parent.color,t.parent.color=1,e.left.color=1,this.rightRotate(t.parent),t=this.root)}t.color=1}deleteSubTree(t){let e;if(t.left===this.nil||t.right===this.nil)e=t;else for(e=t.right;e.left!==this.nil;)e=e.left;let i=e.left!==this.nil?e.left:e.right;return i.parent=e.parent,e.parent===this.nil?this.root=i:e===e.parent.left?e.parent.left=i:e.parent.right=i,e!==t&&(t.item=e.item),e.color===1&&this.deleteFixup(i),this.toNull(t)}deleteNodeInternal(t){this.count--,this.deleteSubTree(t)}remove(t){let e=this.find(t);return e!=null?(this.count--,this.deleteSubTree(e)):null}insert(t){let e=this.treeInsert(t);return this.insertPrivate(e),this.toNull(e)}treeInsert(t){let e=this.nil,i=this.root,n=0;for(;i!==this.nil;)e=i,n=this.comparer(t,i.item),i=n<0?i.left:i.right;let o=new Wo(1,t,e,this.nil,this.nil);return e===this.nil?this.root=o:n<0?e.left=o:e.right=o,this.toNull(o)}insertPrivate(t){for(this.count++,t.color=0;t!==this.root&&t.parent.color===0;)if(t.parent===t.parent.parent.left){let e=t.parent.parent.right;e.color===0?(t.parent.color=1,e.color=1,t.parent.parent.color=0,t=t.parent.parent):(t===t.parent.right&&(t=t.parent,this.leftRotate(t)),t.parent.color=1,t.parent.parent.color=0,this.rightRotate(t.parent.parent))}else{let e=t.parent.parent.left;e.color===0?(t.parent.color=1,e.color=1,t.parent.parent.color=0,t=t.parent.parent):(t===t.parent.left&&(t=t.parent,this.rightRotate(t)),t.parent.color=1,t.parent.parent.color=0,this.leftRotate(t.parent.parent))}this.root.color=1}*allNodes(){if(this.isEmpty())return;let t=this.treeMinimum();for(;t!=null;)yield t.item,t=this.next(t)}toString(){let t="{",e=0;for(let i of this.allNodes())t+=i.toString(),e!==this.count-1&&(t+=`
`),e++;return t+"}"}};var hn=class{constructor(t){this.heapSize=0;this.A=[],this.compare=t}*[Symbol.iterator](){for(let t=1;t<=this.heapSize;t++)yield this.A[t]}Enqueue(t){let e=this.heapSize+1;this.A[e]=t,this.heapSize++;let i=e>>1,n,o;for(;e>1&&this.Less(n=this.A[e],o=this.A[i]);)this.A[i]=n,this.A[e]=o,e=i,i=e>>1}Dequeue(){if(this.heapSize<1)throw new Error;let t=this.A[1],e=this.A[this.heapSize];return this.heapSize--,this.ChangeMinimum(e),t}ChangeMinimum(t){this.A[1]=t;let e=1,i=2,n=!1;for(;i<this.heapSize&&!n;){n=!0;let o=this.A[i],s=this.A[i+1];this.compare(o,s)<0?this.compare(o,t)<0&&(this.A[e]=o,this.A[i]=t,n=!1,e=i,i=e<<1):this.compare(s,t)<0&&(this.A[e]=s,this.A[i+1]=t,n=!1,e=i+1,i=e<<1)}if(i===this.heapSize){let o=this.A[i];this.compare(o,t)<0&&(this.A[e]=o,this.A[i]=t)}}get Count(){return this.heapSize}Less(t,e){return this.compare(t,e)<0}GetMinimum(){return this.A[1]}};var ot=class{};var lr=class extends ot{constructor(e){super();this.Vertex=e}get Site(){return this.Vertex.point}get Polyline(){return this.Vertex.polyline}};var Ha=class extends lr{constructor(t){super(t)}};var za=class{constructor(t){this.lineSweeper=t}Compare(t,e){switch(d.getTriangleOrientation(e.Start,e.End,this.x)){case 2:return 0;case 0:return 1;default:return-1}}SetOperand(t){this.x=this.IntersectionOfSideAndSweepLine(t)}IntersectionOfSideAndSweepLine(t){let e=t.Direction.dot(this.lineSweeper.SweepDirection),i=(this.lineSweeper.Z-t.Start.dot(this.lineSweeper.SweepDirection))/e;return t.Start.add(t.Direction.mul(i))}};var qa=class extends ot{constructor(e){super();this.site=e}get Site(){return this.site}};var Ho=class{constructor(t,e){this.PreviousZ=Number.NEGATIVE_INFINITY;this.z=Number.NEGATIVE_INFINITY;this.Obstacles=t!=null?t:[],this.SweepDirection=e,this.DirectionPerp=e.rotate(-Math.PI/2),this.EventQueue=new hn((i,n)=>this.Compare(i,n)),this.ObstacleSideComparer=new za(this),this.LeftObstacleSideTree=new Me((i,n)=>this.ObstacleSideComparer.Compare(i,n)),this.RightObstacleSideTree=new Me((i,n)=>this.ObstacleSideComparer.Compare(i,n))}get EventQueue(){return this.eventQueue}set EventQueue(t){this.eventQueue=t}get DirectionPerp(){return this.directionPerp}set DirectionPerp(t){this.directionPerp=t}get Z(){return this.z}set Z(t){t>this.z+C.tolerance&&(this.PreviousZ=this.z),this.z=t}GetZS(t){return this.SweepDirection.dot(t.Site)}GetZP(t){return this.SweepDirection.dot(t)}SegmentIsNotHorizontal(t,e){return Math.abs(t.sub(e).dot(this.SweepDirection))>C.distanceEpsilon}RemoveLeftSide(t){this.ObstacleSideComparer.SetOperand(t),this.LeftObstacleSideTree.remove(t)}RemoveRightSide(t){this.ObstacleSideComparer.SetOperand(t),this.RightObstacleSideTree.remove(t)}InsertLeftSide(t){this.ObstacleSideComparer.SetOperand(t),this.LeftObstacleSideTree.insert(t)}InsertRightSide(t){this.ObstacleSideComparer.SetOperand(t),this.RightObstacleSideTree.insert(t)}FindFirstObstacleSideToTheLeftOfPoint(t){let e=this.RightObstacleSideTree.findLast(i=>d.pointToTheRightOfLineOrOnLine(t,i.Start,i.End));return e==null?null:e.item}FindFirstObstacleSideToToTheRightOfPoint(t){let e=this.LeftObstacleSideTree.findFirst(i=>!d.pointToTheRightOfLineOrOnLine(t,i.Start,i.End));return e==null?null:e.item}EnqueueEvent(t){this.eventQueue.Enqueue(t)}InitQueueOfEvents(){for(let t of this.Obstacles)this.EnqueueLowestPointsOnObstacles(t);if(this.Ports!=null)for(let t of this.Ports.values())this.EnqueueEvent(new qa(t))}EnqueueLowestPointsOnObstacles(t){let e=this.GetLowestPoint(t);this.EnqueueEvent(new Ha(e))}GetLowestPoint(t){let e=t.startPoint,i=t.startPoint.next;for(;i!=null;i=i.next)this.Less(i.point,e.point)&&(e=i);return e}Compare(t,e){let i=t.Site,n=e.Site;return this.ComparePoints(i,n)}Less(t,e){return this.ComparePoints(t,e)<0}ComparePoints(t,e){let i=this.SweepDirection.dot(t),n=this.SweepDirection.dot(e);return i<n?-1:i>n?1:(i=this.directionPerp.dot(t),n=this.directionPerp.dot(e),i<n?-1:i>n?1:0)}};var Wc=he(gt(),1),qo=class{constructor(t,e,i=1){this.LengthMultiplier=1;this.Source=t,this.Target=e,this.Weight=i}static closeuv(t,e){return d.closeDistEps(t.point,qo.u,.1)&&d.closeDistEps(e.point,qo.v,.1)}get SourcePoint(){return this.Source.point}get TargetPoint(){return this.Target.point}get Length(){return this.SourcePoint.sub(this.TargetPoint).length*this.LengthMultiplier}toString(){return Wc.String.Format("{0}->{1} ({2})",this.Source,this.Target,this.Weight)}ReversedClone(){return new qo(this.Target,this.Source)}Clone(){return new qo(this.Source,this.Target)}},_t=qo;_t.u=new d(545.833,840.458),_t.v=new d(606.1667261889578,786.2917261889578),_t.DefaultWeight=1;var mt=class extends _t{static constructorVV(t,e){return new mt(t,e,0)}constructor(t,e,i=0){super(t,e,i)}};var fi=class{constructor(t){this._inEdges=new Array;this._outEdges=new Me((e,i)=>this.Compare(e,i)),this.point=t}get InEdges(){return this._inEdges}get OutEdges(){return this._outEdges}get Degree(){return this._inEdges.length+this.OutEdges.count}InEdgesLength(){return this._inEdges.length}addInEdge(t){this._inEdges.push(t)}get IsTerminal(){return this._isTerminal}set IsTerminal(t){this._isTerminal=t}get IsShortestPathTerminal(){return this._isShortestPathTerminal}set IsShortestPathTerminal(t){this._isShortestPathTerminal=t}toString(){return this.point.toString()}RemoveOutEdge(t){this.OutEdges.remove(t)}RemoveInEdge(t){let e=this._inEdges.indexOf(t);if(e===-1)return;let i=this._inEdges.length-1;e!==i&&(this._inEdges[e]=this._inEdges[i]),this._inEdges.pop()}static FindFirst(t,e){return fi.FindFirst_t(t.root,t,e)}static FindFirst_t(t,e,i){if(t===e.nil)return null;let n=null;for(;t!==e.nil;)t=t.item.TargetPoint.compareTo(i)>=0?(n=t).left:t.right;return n}get(t){let e=fi.FindFirst(this.OutEdges,t.point);return e!=null&&e.item.Target===t||(e=fi.FindFirst(t.OutEdges,this.point),e!=null&&e.item.Target===this)?e.item:null}Compare(t,e){return t.TargetPoint.compareTo(e.TargetPoint)}ClearEdges(){this._outEdges.clear(),this._inEdges=[]}};var Ie=class{constructor(){this.activeVertices=new Set;this.VertexFactory=t=>new fi(t);this.pointToVertexMap=new qe}*edges_(){for(let t of this.pointToVertexMap.values())for(let e of t.OutEdges)yield e}get Edges(){return this.edges_()}ClearPrevEdgesTable(){for(let t of this.activeVertices)t.prevEdge=null;this.activeVertices.clear()}ShrinkLengthOfPrevEdge(t,e){t.prevEdge.LengthMultiplier=e}PreviosVertex(t){let e=t.prevEdge;return e?e.Source===t?e.Target:e.Source:null}SetPreviousEdge(t,e){this.activeVertices.add(t),t.prevEdge=e}AddHole(t){let e=t.startPoint;for(;e!==t.endPoint;)this.AddEdgePlPl(e,e.next),e=e.next;this.AddEdgePlPl(t.endPoint,t.startPoint)}static*OrientHolesClockwise(t){for(let e of t)for(let i=e.startPoint;;i=i.next){let n=d.getTriangleOrientation(i.point,i.next.point,i.next.next.point);if(n!==2){yield n===0?e:e.reverse();break}}}AddVertexP(t){let e=this.pointToVertexMap.get(t);if(e)return e;let i=this.VertexFactory(t);return this.pointToVertexMap.set(t,i),i}AddVertexV(t){this.pointToVertexMap.set(t.point,t)}ContainsVertex(t){return this.pointToVertexMap.has(t)}static AddEdgeVV(t,e){let i;if(i=t.get(e))return i;if(t===e)throw new Error("Self-edges are not allowed");let n=new _t(t,e);return t.OutEdges.insert(n),e.InEdges.push(n),n}AddEdgePlPl(t,e){this.AddEdgePP(t.point,e.point)}static AddEdge(t){t.Source.OutEdges.insert(t),t.Target.addInEdge(t)}AddEdgeF(t,e,i){let n=this.FindVertex(t),o=null;if(n!=null&&(o=this.FindVertex(e),o!=null)){let a=n.get(o);if(a)return a}n==null?(n=this.AddVertexP(t),o=this.AddVertexP(e)):o==null&&(o=this.AddVertexP(e));let s=i(n,o);return n.OutEdges.insert(s),o.addInEdge(s),s}AddEdgePP(t,e){return this.AddEdgeF(t,e,(i,n)=>new _t(i,n))}FindVertex(t){return this.pointToVertexMap.get(t)}Vertices(){return this.pointToVertexMap.values()}RemoveVertex(t){for(let e of t.OutEdges)e.Target.RemoveInEdge(e);for(let e of t.InEdges)e.Source.RemoveOutEdge(e);this.pointToVertexMap.deleteP(t.point)}FindEdgePP(t,e){let i=this.FindVertex(t);if(i==null)return null;let n=this.FindVertex(e);return n==null?null:i.get(n)}static RemoveEdge(t){t.Source.RemoveOutEdge(t),t.Target.RemoveInEdge(t)}ClearEdges(){for(let t of this.Vertices())t.ClearEdges()}};var dn=class{constructor(){this.Removed=!1}};var pi=class extends dn{constructor(e,i,n){super();this.start=e,this.EndVertex=i,this.ConeSide=n}get Start(){return this.start}get End(){return this.EndVertex.point}get Direction(){return this.End.sub(this.Start)}toString(){return"BrokenConeSide: "+(this.Start+(","+this.End))}};var Uo=class{get Removed(){return this.removed}set Removed(t){this.removed=t}constructor(t,e){this.apex=t,this.coneSweeper=e}get Apex(){return this.apex}set Apex(t){this.apex=t}get RightSideDirection(){return this.coneSweeper.ConeRightSideDirection}get LeftSideDirection(){return this.coneSweeper.ConeLeftSideDirection}get RightSide(){return this.rightSide}set RightSide(t){this.rightSide=t,this.rightSide.Cone=this}get LeftSide(){return this.leftSide}set LeftSide(t){this.leftSide=t,this.leftSide.Cone=this}};var Os=class extends ot{constructor(e,i){super();this.site=e,this.coneToClose=i}get ConeToClose(){return this.coneToClose}get Site(){return this.site}toString(){return"ConeClosureEvent "+this.site}};var ur=class extends dn{constructor(t){super(),this.Cone=t}get Start(){return this.Cone.Apex}get Direction(){return this.Cone.LeftSideDirection}toString(){return"ConeLeftSide "+this.Start+(" "+this.Direction)}};var Jr=class extends dn{constructor(t){super(),this.Cone=t}get Start(){return this.Cone.Apex}get Direction(){return this.Cone.RightSideDirection}toString(){return"ConeRightSide "+this.Start+" "+this.Direction}};var eo=class{SetOperand(t){this.x=this.IntersectionOfSegmentAndSweepLine(t)}constructor(t){this.coneSweeper=t}Compare(t,e){let i=t instanceof pi,n=e instanceof pi;return i?n?this.CompareBrokenSides(t,e):this.CompareObstacleSideAndConeSide(e):n?this.CompareConeSideAndObstacleSide(t,e):eo.CompareNotIntersectingSegs(t,e)}static CompareNotIntersectingSegs(t,e){switch(d.getTriangleOrientation(t.Start,e.Start,e.Start.add(e.Direction))){case 1:return-1;case 0:return 1;default:return 0}}CompareObstacleSideAndConeSide(t){let e=d.getTriangleOrientation(this.x,t.Start,t.Start.add(t.Direction));return e===1?-1:e===0?1:t instanceof ur?-1:1}CompareConeSideAndObstacleSide(t,e){let i=d.getTriangleOrientation(this.x,e.start,e.End);return i===1?-1:i===0||t instanceof ur?1:-1}IntersectionOfSegmentAndSweepLine(t){let e=t.Direction.dot(this.coneSweeper.SweepDirection),i=(this.coneSweeper.Z-t.Start.dot(this.coneSweeper.SweepDirection))/e;return t.Start.add(t.Direction.mul(i))}CompareBrokenSides(t,e){return t.EndVertex===e.EndVertex?eo.CompareNotIntersectingSegs(t.ConeSide,e.ConeSide):d.getTriangleOrientation(this.x,e.start,e.EndVertex.point)===1?-1:1}};var gn=class extends ot{constructor(e,i,n){super();this.coneLeftSide=e,this.intersectionPoint=i,this.endVertex=n}get EndVertex(){return this.endVertex}get Site(){return this.intersectionPoint}toString(){return"LeftIntersectionEvent "+this.intersectionPoint}};var mn=class{get Direction(){return this.End.sub(this.Start)}toString(){return this.Start+" "+this.End}};var fn=class extends mn{constructor(e){super();this.Init(e)}Init(e){this.StartVertex=e}get Polyline(){return this.StartVertex.polyline}get Start(){return this.StartVertex.point}get End(){return this.EndVertex.point}};var bi=class extends fn{constructor(e){super(e);this.end=e.nextOnPolyline.point}get End(){return this.end}get EndVertex(){return this.StartVertex.nextOnPolyline}};var $r=class extends lr{constructor(t){super(t)}};var Bs=class extends ot{constructor(e,i,n){super();this.coneRightSide=e,this.intersectionPoint=i,this.endVertex=n}get EndVertex(){return this.endVertex}set EndVertex(e){this.endVertex=e}get Site(){return this.intersectionPoint}toString(){return"RightIntersectionEvent "+this.intersectionPoint}};var Pi=class extends fn{constructor(e){super(e);this.end=e.prevOnPolyline.point}get End(){return this.end}get EndVertex(){return this.StartVertex.prevOnPolyline}};var Kr=class extends lr{constructor(t){super(t)}};var st=class extends Ho{constructor(e,i,n,o,s,a,u){super(e,i);this.visibilityGraph=s,this.ConeRightSideDirection=n,this.ConeLeftSideDirection=o,this.coneSideComparer=new eo(this),this.leftConeSides=new Me((h,c)=>this.coneSideComparer.Compare(h,c)),this.rightConeSides=new Me((h,c)=>this.coneSideComparer.Compare(h,c)),this.Ports=a,this.BorderPolyline=u,this.PortEdgesCreator=(h,c)=>new mt(h,c,0)}static Sweep(e,i,n,o,s,a){new st(e,i,i.rotate(-n/2),i.rotate(n/2),o,s,a).Calculate()}Calculate(){for(this.InitQueueOfEvents();this.EventQueue.Count>0;)this.ProcessEvent(this.EventQueue.Dequeue());this.BorderPolyline!=null&&this.CloseRemainingCones(),this.CreatePortEdges()}CreatePortEdges(){if(this.portEdgesGraph!=null)for(let e of this.portEdgesGraph.Edges)this.visibilityGraph.AddEdgeF(e.SourcePoint,e.TargetPoint,this.PortEdgesCreator)}CloseRemainingCones(){if(this.leftConeSides.count===0)return;let e=this.BorderPolyline.startPoint,i=this.leftConeSides.count;do{let n=this.leftConeSides.treeMinimum().item.Cone;e=this.FindPolylineSideIntersectingConeRightSide(e,n),e=this.GetPolylinePointInsideOfConeAndRemoveCones(e,n),i--}while(this.leftConeSides.count>0&&i>0)}GetPolylinePointInsideOfConeAndRemoveCones(e,i){let n=e.nextOnPolyline,o=st.FindInsidePoint(e.point,n.point,i);return d.closeDistEps(o,e.point)?(this.AddEdgeAndRemoveCone(i,e.point),this.AddEdgesAndRemoveRemainingConesByPoint(e.point)):d.closeDistEps(o,n.point)?(this.AddEdgeAndRemoveCone(i,n.point),this.AddEdgesAndRemoveRemainingConesByPoint(n.point),e=n):(e=st.InsertPointIntoPolylineAfter(this.BorderPolyline,e,o),this.AddEdgeAndRemoveCone(i,e.point),this.AddEdgesAndRemoveRemainingConesByPoint(e.point)),e}static FindInsidePoint(e,i,n){return st.FindInsidePointBool(e,i,n.Apex,n.Apex.add(n.LeftSideDirection),n.Apex.add(n.RightSideDirection))}static FindInsidePointBool(e,i,n,o,s){if(d.closeDistEps(e,i)||d.PointIsInsideCone(e,n,o,s))return e;if(d.PointIsInsideCone(i,n,o,s))return i;let a=d.middle(e,i);return d.pointToTheLeftOfLine(a,n,o)?st.FindInsidePointBool(a,i,n,o,s):st.FindInsidePointBool(e,a,n,o,s)}AddEdgesAndRemoveRemainingConesByPoint(e){let i=new Array;for(let n of this.leftConeSides)if(d.PointToTheRightOfLineOrOnLine(e,n.Start,n.Start.add(n.Direction)))i.push(n.Cone);else break;for(let n of i)this.AddEdgeAndRemoveCone(n,e)}FindPolylineSideIntersectingConeRightSide(e,i){let n=e,o=i.Apex,s=i.Apex.add(this.ConeRightSideDirection),a=st.GetSign(e,o,s);for(;;){let u=e.nextOnPolyline,h=st.GetSign(u,o,s);if(h-a>0)return e;if(e=u,a=h,e===n)throw new Error("cannod decide if the polyline intersects the cone!")}}static GetSign(e,i,n){let o=d.signedDoubledTriangleArea(i,n,e.point);return o<0?1:o>0?-1:0}AddEdgeAndRemoveCone(e,i){this.Ports!=null&&this.Ports.has(e.Apex)?this.CreatePortEdge(e,i):this.visibilityGraph.AddEdgePP(e.Apex,i),this.RemoveCone(e)}CreatePortEdge(e,i){this.portEdgesGraph==null&&(this.portEdgesGraph=new Ie);let n=this.portEdgesGraph.FindVertex(e.Apex),o=n!=null?Array.from(n.InEdges).concat(Array.from(n.OutEdges.allNodes())):null;if(o)for(let s of o){let a=(s.Target===n?s.Source:s.Target).point;Ie.RemoveEdge(s),this.portEdgesGraph.AddEdgePP(a,i)}this.portEdgesGraph.AddEdgePP(e.Apex,i)}static InsertPointIntoPolylineAfter(e,i,n){let o;return i.next!=null?(o=it.mkFromPoint(n),o.prev=i,o.next=i.next,i.next.prev=o,i.next=o):(o=it.mkFromPoint(n),o.prev=i,i.next=o,e.endPoint=o),o.polyline=e,e.setInitIsRequired(),o}ProcessEvent(e){e instanceof lr?this.ProcessVertexEvent(e):e instanceof Bs?this.ProcessRightIntersectionEvent(e):e instanceof gn?this.ProcessLeftIntersectionEvent(e):(e instanceof Os?e.ConeToClose.Removed||this.RemoveCone(e.ConeToClose):this.ProcessPortObstacleEvent(e),this.Z=this.GetZS(e))}ProcessPortObstacleEvent(e){this.Z=this.GetZS(e),this.GoOverConesSeeingVertexEvent(e),this.CreateConeOnVertex(e)}ProcessLeftIntersectionEvent(e){if(e.coneLeftSide.Removed===!1)if(Math.abs(e.EndVertex.point.sub(e.Site).dot(this.SweepDirection))<C.distanceEpsilon)this.RemoveCone(e.coneLeftSide.Cone);else{this.RemoveSegFromLeftTree(e.coneLeftSide),this.Z=this.GetZP(e.Site);let i=new pi(e.Site,e.EndVertex,e.coneLeftSide);this.InsertToTree(this.leftConeSides,i),e.coneLeftSide.Cone.LeftSide=i,this.LookForIntersectionOfObstacleSideAndLeftConeSide(e.Site,e.EndVertex),this.TryCreateConeClosureForLeftSide(i)}else this.Z=this.GetZP(e.Site)}TryCreateConeClosureForLeftSide(e){if(e.Cone.RightSide instanceof Jr){let i=e.Cone.RightSide;d.getTriangleOrientation(i.Start,i.Start.add(i.Direction),e.EndVertex.point)==0&&this.CreateConeClosureEvent(e,i)}}CreateConeClosureEvent(e,i){let n=d.RayIntersectsRayInteriors(e.start,e.Direction,i.Start,i.Direction);if(n){let o=new Os(n,e.Cone);this.EnqueueEvent(o)}}ProcessRightIntersectionEvent(e){if(e.coneRightSide.Removed)this.Z=this.GetZP(e.Site);else{this.RemoveSegFromRightTree(e.coneRightSide),this.Z=this.GetZP(e.Site);let i=new pi(e.Site,e.EndVertex,e.coneRightSide);this.InsertToTree(this.rightConeSides,i),e.coneRightSide.Cone.RightSide=i,this.LookForIntersectionOfObstacleSideAndRightConeSide(e.Site,e.EndVertex),this.TryCreateConeClosureForRightSide(i)}}TryCreateConeClosureForRightSide(e){if(e.Cone.LeftSide instanceof ur){let i=e.Cone.LeftSide;d.getTriangleOrientation(i.Start,i.Start.add(i.Direction),e.EndVertex.point)==1&&this.CreateConeClosureEvent(e,i)}}RemoveConesClosedBySegment(e,i){this.CloseConesCoveredBySegment(e,i,this.GetZP(e)>this.GetZP(i)?this.leftConeSides:this.rightConeSides)}CloseConesCoveredBySegment(e,i,n){let o=n.findFirst(u=>d.getTriangleOrientation(u.Start,u.Start.add(u.Direction),e)===1);if(o==null||!d.IntervalIntersectsRay(e,i,o.item.Start,o.item.Direction))return;let a=new Array;do a.push(o.item.Cone),o=n.next(o);while(o!=null&&d.IntervalIntersectsRay(e,i,o.item.Start,o.item.Direction)!==void 0);for(let u of a)this.RemoveCone(u)}ProcessVertexEvent(e){this.Z=this.GetZS(e),this.GoOverConesSeeingVertexEvent(e),this.AddConeAndEnqueueEvents(e)}static Diamond(e){return me.mkDiamond(2,2,e)}AddConeAndEnqueueEvents(e){if(e instanceof $r){let i=e.Vertex.nextOnPolyline;this.CloseConesAddConeAtLeftVertex(e,i)}else if(e instanceof Kr){let i=e.Vertex.prevOnPolyline;this.CloseConesAddConeAtRightVertex(e,i)}else this.CloseConesAddConeAtLeftVertex(e,e.Vertex.nextOnPolyline),this.CloseConesAddConeAtRightVertex(e,e.Vertex.prevOnPolyline)}CloseConesAddConeAtRightVertex(e,i){let n=e.Vertex.nextOnPolyline.point;this.directionPerp.dot(e.Site.sub(n))>C.distanceEpsilon&&this.RemoveConesClosedBySegment(n,e.Vertex.point),this.directionPerp.dot(i.point.sub(e.Site))>C.distanceEpsilon&&this.RemoveConesClosedBySegment(e.Site,i.point);let o=e.Site,s=o.add(this.ConeLeftSideDirection),a=o.add(this.ConeRightSideDirection),u=i.point;this.GetZP(o.sub(n))>C.distanceEpsilon&&this.RemoveRightSide(new Pi(e.Vertex.nextOnPolyline)),this.GetZP(o.sub(i.point))>C.distanceEpsilon&&this.RemoveLeftSide(new bi(i)),this.GetZP(u)+C.distanceEpsilon<this.GetZS(e)&&this.CreateConeOnVertex(e),d.PointToTheRightOfLineOrOnLine(u,o,s)?d.PointToTheLeftOfLineOrOnLine(u,o,a)?this.CaseToTheLeftOfLineOrOnLineConeRp(e,i):(this.GetZP(u.sub(o))>C.distanceEpsilon&&(this.LookForIntersectionOfObstacleSideAndLeftConeSide(e.Site,i),this.InsertRightSide(new Pi(e.Vertex))),this.EnqueueRightVertexEvent(new Kr(i))):(this.CreateConeOnVertex(e),d.PointToTheLeftOfLineOrOnLine(u.add(this.DirectionPerp),u,o)&&this.EnqueueRightVertexEvent(new Kr(i)))}CaseToTheLeftOfLineOrOnLineConeRp(e,i){this.EnqueueRightVertexEvent(new Kr(i));let n=new Uo(e.Vertex.point,this),o=new pi(n.Apex,i,new ur(n));n.LeftSide=o,n.RightSide=new Jr(n);let s=this.InsertToTree(this.rightConeSides,n.RightSide);this.LookForIntersectionWithConeRightSide(s);let a=this.InsertToTree(this.leftConeSides,n.LeftSide);this.FixConeLeftSideIntersections(o,a),this.GetZP(i.point.sub(e.Site))>C.distanceEpsilon&&this.InsertRightSide(new Pi(e.Vertex))}LookForIntersectionOfObstacleSideAndRightConeSide(e,i){let n=this.GetLastNodeToTheLeftOfPointInRightSegmentTree(e);if(n!=null&&n.item instanceof Jr){let o=d.IntervalIntersectsRay(e,i.point,n.item.Start,this.ConeRightSideDirection);o&&this.SegmentIsNotHorizontal(o,i.point)&&this.EnqueueEvent(this.CreateRightIntersectionEvent(n.item,o,i))}}CreateRightIntersectionEvent(e,i,n){return new Bs(e,i,n)}GetLastNodeToTheLeftOfPointInRightSegmentTree(e){return this.rightConeSides.findLast(i=>st.PointIsToTheRightOfSegment(e,i))}LookForIntersectionOfObstacleSideAndLeftConeSide(e,i){let n=this.GetFirstNodeToTheRightOfPoint(e);if(n==null||!(n.item instanceof ur))return;let o=n.item,s=d.IntervalIntersectsRay(e,i.point,o.Start,this.ConeLeftSideDirection);s&&this.EnqueueEvent(new gn(o,s,i))}GetFirstNodeToTheRightOfPoint(e){return this.leftConeSides.findFirst(i=>st.PointIsToTheLeftOfSegment(e,i))}static PointIsToTheLeftOfSegment(e,i){return d.getTriangleOrientation(i.Start,i.Start.add(i.Direction),e)===1}static PointIsToTheRightOfSegment(e,i){return d.getTriangleOrientation(i.Start,i.Start.add(i.Direction),e)===0}FixConeLeftSideIntersections(e,i){do i=this.leftConeSides.next(i);while(i!=null&&d.PointToTheRightOfLineOrOnLine(e.Start,i.item.Start,i.item.Start.add(i.item.Direction)));if(i!=null&&i.item instanceof ur){let n=i.item,o=d.IntervalIntersectsRay(e.start,e.End,n.Start,n.Direction);o&&this.EnqueueEvent(new gn(n,o,e.EndVertex))}}InsertToTree(e,i){return this.coneSideComparer.SetOperand(i),e.insert(i)}CloseConesAddConeAtLeftVertex(e,i){let n=e.Vertex.prevOnPolyline.point;e.Site.sub(n).dot(this.directionPerp)<-C.distanceEpsilon&&this.RemoveConesClosedBySegment(e.Site,n),i.point.sub(e.Site).dot(this.directionPerp)<-C.distanceEpsilon&&this.RemoveConesClosedBySegment(i.point,e.Site);let o=e.Site,s=o.add(this.ConeLeftSideDirection),a=o.add(this.ConeRightSideDirection),u=i.point;this.GetZP(o.sub(n))>C.distanceEpsilon&&this.RemoveLeftSide(new bi(e.Vertex.prevOnPolyline));let h=this.GetZP(u)-this.Z;h<-C.distanceEpsilon&&this.RemoveRightSide(new Pi(i));let c=u.sub(e.Site);if(h<-C.distanceEpsilon||Q(h,0)&&this.GetZP(c)>0&&c.dot(this.directionPerp)>-C.distanceEpsilon)this.CreateConeOnVertex(e);else if(!d.PointToTheLeftOfLineOrOnLine(u,o,a))this.CreateConeOnVertex(e),this.EnqueueEvent(new $r(i));else if(d.PointToTheLeftOfLineOrOnLine(u,o,s))this.EnqueueEvent(new $r(i)),this.GetZP(c)>C.distanceEpsilon&&(this.LookForIntersectionOfObstacleSideAndRightConeSide(e.Site,i),this.InsertLeftSide(new bi(e.Vertex)));else{this.EnqueueEvent(new $r(i));let f=new Uo(e.Vertex.point,this),P=new pi(e.Vertex.point,i,new Jr(f));f.RightSide=P,f.LeftSide=new ur(f),this.LookForIntersectionWithConeLeftSide(this.InsertToTree(this.leftConeSides,f.LeftSide));let v=this.InsertToTree(this.rightConeSides,P);this.FixConeRightSideIntersections(P,v),this.GetZP(c)>C.distanceEpsilon&&this.InsertLeftSide(new bi(e.Vertex))}}RemoveCone(e){e.Removed=!0,this.RemoveSegFromLeftTree(e.LeftSide),this.RemoveSegFromRightTree(e.RightSide)}RemoveSegFromRightTree(e){this.coneSideComparer.SetOperand(e);let i=this.rightConeSides.remove(e);if(e.Removed=!0,i==null){let n=this.Z;this.Z=Math.max(this.GetZP(e.Start),this.Z-.01),this.coneSideComparer.SetOperand(e),i=this.rightConeSides.remove(e),this.Z=n}}RemoveSegFromLeftTree(e){if(e.Removed=!0,this.coneSideComparer.SetOperand(e),this.leftConeSides.remove(e)==null){let n=this.Z;this.Z=Math.max(this.GetZP(e.Start),this.Z-.01),this.coneSideComparer.SetOperand(e),this.leftConeSides.remove(e),this.Z=n}}FixConeRightSideIntersections(e,i){do i=this.rightConeSides.previous(i);while(i!=null&&d.PointToTheLeftOfLineOrOnLine(e.start,i.item.Start,i.item.Start.add(i.item.Direction)));if(i!=null){let n;if(i.item instanceof Jr){let o=i.item;(n=d.IntervalIntersectsRay(e.start,e.End,o.Start,o.Direction))&&this.EnqueueEvent(this.CreateRightIntersectionEvent(o,n,e.EndVertex))}}}CreateConeOnVertex(e){let i=new Uo(e.Site,this);i.LeftSide=new ur(i),i.RightSide=new Jr(i);let n=this.InsertToTree(this.leftConeSides,i.LeftSide),o=this.InsertToTree(this.rightConeSides,i.RightSide);this.LookForIntersectionWithConeRightSide(o),this.LookForIntersectionWithConeLeftSide(n)}LookForIntersectionWithConeLeftSide(e){if(e.item instanceof ur){let i=e.item,n=this.FindFirstObstacleSideToTheLeftOfPoint(i.Start);n!=null&&this.TryIntersectionOfConeLeftSideAndObstacleSide(i,n)}else{let i=e.item;e=this.leftConeSides.next(e),e!=null&&e.item instanceof ur&&this.TryIntersectionOfConeLeftSideAndObstacleConeSide(e.item,i)}}LookForIntersectionWithConeRightSide(e){if(e.item instanceof Jr){let i=e.item,n=this.FindFirstObstacleSideToToTheRightOfPoint(i.Start);n!=null&&this.TryIntersectionOfConeRightSideAndObstacleSide(i,n)}else{let i=e.item;e=this.rightConeSides.previous(e),e!=null&&e.item instanceof Jr&&this.TryIntersectionOfConeRightSideAndObstacleConeSide(e.item,i)}}TryIntersectionOfConeRightSideAndObstacleConeSide(e,i){let n=d.IntervalIntersectsRay(i.start,i.End,e.Start,e.Direction);n&&this.EnqueueEvent(this.CreateRightIntersectionEvent(e,n,i.EndVertex))}TryIntersectionOfConeRightSideAndObstacleSide(e,i){let n=d.IntervalIntersectsRay(i.Start,i.End,e.Start,e.Direction);n&&this.EnqueueEvent(this.CreateRightIntersectionEvent(e,n,i.EndVertex))}TryIntersectionOfConeLeftSideAndObstacleConeSide(e,i){let n=d.IntervalIntersectsRay(i.start,i.End,e.Start,e.Direction);n&&this.EnqueueEvent(new gn(e,n,i.EndVertex))}TryIntersectionOfConeLeftSideAndObstacleSide(e,i){let n=d.IntervalIntersectsRay(i.Start,i.End,e.Start,e.Direction);n&&this.EnqueueEvent(new gn(e,n,i.EndVertex))}ExtendSegmentToZ(e){let i=e.Direction.dot(this.SweepDirection),n=(this.Z+40-e.Start.dot(this.SweepDirection))/i;return w.mkPP(e.Start,e.Start.add(e.Direction.mul(n)))}GoOverConesSeeingVertexEvent(e){let i=this.FindFirstSegmentInTheRightTreeNotToTheLeftOfVertex(e);if(i==null)return;let o=i.item.Cone,s=o.LeftSide;if(st.VertexIsToTheLeftOfSegment(e,s))return;let a=[o];if(this.coneSideComparer.SetOperand(s),i=this.leftConeSides.find(s),i==null){let u=this.Z;this.Z=Math.max(this.GetZP(s.Start),this.PreviousZ),this.coneSideComparer.SetOperand(s),i=this.leftConeSides.find(s),this.Z=u}if(!(i==null&&(i=this.GetRbNodeEmergency(s),i==null))){for(i=this.leftConeSides.next(i);i!=null&&!st.VertexIsToTheLeftOfSegment(e,i.item);)a.push(i.item.Cone),i=this.leftConeSides.next(i);for(let u of a)this.AddEdgeAndRemoveCone(u,e.Site)}}GetRbNodeEmergency(e){if(this.leftConeSides.count===0)return null;for(let i=this.leftConeSides.treeMinimum();i!=null;i=this.leftConeSides.next(i))if(i.item===e)return i;return null}static VertexIsToTheLeftOfSegment(e,i){return d.getTriangleOrientation(i.Start,i.Start.add(i.Direction),e.Site)===1}static VertexIsToTheRightOfSegment(e,i){return d.getTriangleOrientation(i.Start,i.Start.add(i.Direction),e.Site)===0}FindFirstSegmentInTheRightTreeNotToTheLeftOfVertex(e){return this.rightConeSides.findFirst(i=>!st.VertexIsToTheRightOfSegment(e,i))}EnqueueRightVertexEvent(e){this.GetZP(e.Site.sub(e.Vertex.prevOnPolyline.point))>C.tolerance||this.EnqueueEvent(e)}invariant(){for(let e of this.leftConeSides)if(e.Removed)return!1;for(let e of this.rightConeSides)if(e.Removed)return!1;return!0}};var yi=class extends _{constructor(e,i){super(null);this.coneAngle=Math.PI/6;this.ports=new Se;this._obstacles=Array.from(Ie.OrientHolesClockwise(e)),this._visibilityGraph=i}static mk(e,i,n,o,s){let a=new yi(e,i);return a.Ports=o,a.BorderPolyline=s,a.ConeAngle=n,a}get ConeAngle(){return this.coneAngle}set ConeAngle(e){this.coneAngle=e}get Ports(){return this.ports}set Ports(e){this.ports=e}get BorderPolyline(){return this.borderPolyline}set BorderPolyline(e){this.borderPolyline=e}get Bidirectional(){return this._bidirectional}set Bidirectional(e){this._bidirectional=e}static GetTotalSteps(e){return Math.floor((2*Math.PI-e/2)/e)+1}run(){let e=2*Math.PI-this.coneAngle/2;if(this.Bidirectional)this.HandleBideractionalCase();else{let i;for(let n=0;(i=this.coneAngle*n)<=e;n++)super.ProgressStep(),this.AddDirection(new d(Math.cos(i),Math.sin(i)),this.BorderPolyline,this._visibilityGraph)}}HandleBideractionalCase(){let e=Math.PI/this.coneAngle;for(let i=0;i<e;i++){let n=i*this.coneAngle,o=new Ie;this.AddDirection(new d(Math.cos(n),Math.sin(n)),this.BorderPolyline,o);let s=new Ie;this.AddDirection(new d(Math.cos(n)*-1,Math.sin(n)*-1),this.BorderPolyline,s),this.AddIntersectionOfBothDirectionSweepsToTheResult(o,s)}}AddIntersectionOfBothDirectionSweepsToTheResult(e,i){for(let n of e.Edges)i.FindEdgePP(n.SourcePoint,n.TargetPoint)!=null&&this._visibilityGraph.AddEdgePP(n.SourcePoint,n.TargetPoint)}AddDirection(e,i,n){st.Sweep(this._obstacles,e,this.coneAngle,n,this.Ports,i)}};var Ze=class extends Mi{constructor(e){super();this.adjustmentAngle=Math.PI/10;this.hookSize=9;this.curve=e,this.location=this.curve().start}mk(e,i){let n=new Ze(e);return n.HookSize=i,n}get Location(){return this.location}get Curve(){return this.curve()}SetLocation(e){this.location=e}get AdjustmentAngle(){return this.adjustmentAngle}set AdjustmentAngle(e){this.adjustmentAngle=e}get HookSize(){return this.hookSize}set HookSize(e){this.hookSize=e}};var St=class extends Rt{constructor(e,i,n=new d(0,0)){super(e,i,n)}get LoosePolyline(){return this.loosePolyline}set LoosePolyline(e){this.loosePolyline=e}static mk(e,i){return new St(e,i)}};var Ct=class extends Mi{get Location(){return this.curve.value(this.parameter)}set Location(e){throw new Error("Method should not be called.")}static mk(e,i){let n=new Ct;return n.curve=e,n.parameter=i,n}get Parameter(){return this.parameter}set Parameter(e){this.parameter=e}get Curve(){return this.curve}set Curve(e){this.curve=e}};var Yr=class{constructor(){this.capacityOverflowCoefficient=Yr.DefaultCapacityOverflowCoefficientMultiplier;this.RotateBundles=!1;this.MaxHubRadius=50;this.MinHubRadius=.1;this.CreateUnderlyingPolyline=!1;this.pathLengthImportance=Yr.DefaultPathLengthImportance;this.inkImportance=Yr.DefaultInkImportance;this.edgeSeparation=Yr.DefaultEdgeSeparation;this._edgeWidthShrinkCoeff=1;this.useCubicBezierSegmentsInsideOfHubs=!1;this.angleThreshold=Math.PI/180*45;this.hubRepulsionImportance=100;this.bundleRepulsionImportance=100;this.minimalRatioOfGoodCdtEdges=.9;this.highestQuality=!0;this.KeepOverlaps=!1;this.StopAfterShortestPaths=!1}toJSON(){let t={};return this.capacityOverflowCoefficient!=Yr.DefaultCapacityOverflowCoefficientMultiplier&&(t.capacityOverflowCoefficient=this.capacityOverflowCoefficient),this.RotateBundles&&(t.RotateBundles=this.RotateBundles),this.MaxHubRadius!=50&&(t.MaxHubRadius=this.MaxHubRadius),this.MinHubRadius!=.1&&(t.MinHubRadius=this.MinHubRadius),this.CreateUnderlyingPolyline&&(t.CreateUnderlyingPolyline=this.CreateUnderlyingPolyline),this.pathLengthImportance!=Yr.DefaultPathLengthImportance&&(t.pathLengthImportance=this.pathLengthImportance),this.inkImportance!=Yr.DefaultInkImportance&&(t.inkImportance=this.inkImportance),this.edgeSeparation!=Yr.DefaultEdgeSeparation&&(t.edgeSeparation=this.edgeSeparation),this._edgeWidthShrinkCoeff!=1&&(t._edgeWidthShrinkCoeff=this._edgeWidthShrinkCoeff),this.useCubicBezierSegmentsInsideOfHubs&&(t.useCubicBezierSegmentsInsideOfHubs=this.useCubicBezierSegmentsInsideOfHubs),this.angleThreshold!=Math.PI/180*45&&(t.angleThreshold=this.angleThreshold),this.hubRepulsionImportance!=100&&(t.hubRepulsionImportance=this.hubRepulsionImportance),this.bundleRepulsionImportance!=100&&(t.bundleRepulsionImportance=this.bundleRepulsionImportance),this.minimalRatioOfGoodCdtEdges!=.9&&(t.minimalRatioOfGoodCdtEdges=this.minimalRatioOfGoodCdtEdges),this.highestQuality||(t.highestQuality=this.highestQuality),this.KeepOverlaps&&(t.KeepOverlaps=this.KeepOverlaps),this.StopAfterShortestPaths&&(t.StopAfterShortestPaths=this.StopAfterShortestPaths),t}static createFromJSON(t){let e=new Yr;return t.capacityOverflowCoefficient&&(e.capacityOverflowCoefficient=t.capacityOverflowCoefficient),t.RotateBundles&&(e.RotateBundles=t.RotateBundles),t.MaxHubRadius&&(e.MaxHubRadius=t.MaxHubRadius),t.MinHubRadius&&(e.MinHubRadius=t.MinHubRadius),t.CreateUnderlyingPolyline&&(e.CreateUnderlyingPolyline=t.CreateUnderlyingPolyline),t.pathLengthImportance&&(e.pathLengthImportance=t.pathLengthImportance),t.inkImportance&&(e.inkImportance=t.inkImportance),t.edgeSeparation&&(e.edgeSeparation=t.edgeSeparation),t._edgeWidthShrinkCoeff&&(e._edgeWidthShrinkCoeff=t._edgeWidthShrinkCoeff),t.useCubicBezierSegmentsInsideOfHubs&&(e.useCubicBezierSegmentsInsideOfHubs=t.useCubicBezierSegmentsInsideOfHubs),t.angleThreshold&&(e.angleThreshold=t.angleThreshold),t.hubRepulsionImportance&&(e.hubRepulsionImportance=t.hubRepulsionImportance),t.bundleRepulsionImportance&&(e.bundleRepulsionImportance=t.bundleRepulsionImportance),t.minimalRatioOfGoodCdtEdges&&(e.minimalRatioOfGoodCdtEdges=t.minimalRatioOfGoodCdtEdges),t.highestQuality&&(e.HighestQuality=t.highestQuality),t.KeepOverlaps&&(e.KeepOverlaps=t.KeepOverlaps),t.StopAfterShortestPaths&&(e.StopAfterShortestPaths=t.StopAfterShortestPaths),e}get CapacityOverflowCoefficient(){return this.capacityOverflowCoefficient}set CapacityOverflowCoefficient(t){this.capacityOverflowCoefficient=t}get PathLengthImportance(){return this.pathLengthImportance}set PathLengthImportance(t){this.pathLengthImportance=t}get InkImportance(){return this.inkImportance}set InkImportance(t){this.inkImportance=t}get EdgeSeparation(){return this.edgeSeparation}set EdgeSeparation(t){this.edgeSeparation=t}get edgeWidthShrinkCoeff(){return this._edgeWidthShrinkCoeff}set edgeWidthShrinkCoeff(t){this._edgeWidthShrinkCoeff=t}ActualEdgeWidth(t,e=this.edgeWidthShrinkCoeff){return e*(this.edgeSeparation+t.lineWidth)}get UseCubicBezierSegmentsInsideOfHubs(){return this.useCubicBezierSegmentsInsideOfHubs}set UseCubicBezierSegmentsInsideOfHubs(t){this.useCubicBezierSegmentsInsideOfHubs=t}get AngleThreshold(){return this.angleThreshold}set AngleThreshold(t){this.angleThreshold=t}get HubRepulsionImportance(){return this.hubRepulsionImportance}set HubRepulsionImportance(t){this.hubRepulsionImportance=t}get BundleRepulsionImportance(){return this.bundleRepulsionImportance}set BundleRepulsionImportance(t){this.bundleRepulsionImportance=t}get MinimalRatioOfGoodCdtEdges(){return this.minimalRatioOfGoodCdtEdges}set MinimalRatioOfGoodCdtEdges(t){this.minimalRatioOfGoodCdtEdges=t}get HighestQuality(){return this.highestQuality}set HighestQuality(t){this.highestQuality=t}},Dr=Yr;Dr.DefaultCapacityOverflowCoefficientMultiplier=1e3,Dr.DefaultPathLengthImportance=500,Dr.DefaultInkImportance=.01,Dr.DefaultEdgeSeparation=.5;var pn=class extends Xr{constructor(e){super(null);this.node=e}get BoundaryCurve(){return this.node.boundaryCurve}set BoundaryCurve(e){if(e)throw new Error("Cannot set BoundaryCurve directly for RelativeShape")}};var hr=class{static GetShapes(t,e){let i=new Map;for(let n of t)hr.ProcessAncestorDescendantCouple(n.target,n.source,i),hr.InsertEdgePortsToShapes(i,n);for(let n of e)hr.ProcessAncestorDescendantCouple(n.source,n.target,i),hr.InsertEdgePortsToShapes(i,n);return hr.BindShapes(i),Array.from(i.values())}static InsertEdgePortsToShapes(t,e){t.get(e.target).Ports.add(e.targetPort),t.get(e.source).Ports.add(e.sourcePort)}static BindShapes(t){for(let[e,i]of t){if(!(e instanceof ne))continue;let n=e;for(let o of Xu(n)){let s=t.get(o);s&&i.AddChild(s)}}}static ProcessAncestorDescendantCouple(t,e,i){let n=ja(e);do{for(let o of Xu(n))hr.CreateShapeIfNeeeded(o,i);if(n===t)break;n=ja(n)}while(!0);hr.CreateShapeIfNeeeded(n,i)}static CreateShapeIfNeeeded(t,e){e.has(t)||e.set(t,new pn(t))}static NumberOfActiveNodesIsUnderThreshold(t,e,i){let n=new Set;for(let o of t)if(hr.SetOfActiveNodesIsLargerThanThreshold(o.target,o.source,n,i))return!1;for(let o of e)if(hr.SetOfActiveNodesIsLargerThanThreshold(o.source,o.target,n,i))return!1;return!0}static SetOfActiveNodesIsLargerThanThreshold(t,e,i,n){let o=ja(e);for(;;){for(let s of Xu(o))if(i.add(s),i.size>n)return!0;if(o===t)break;o=ja(o)}return i.add(o),i.size>n}};function ja(l){let t=l.node.parent;return ie.getGeom(t)}function*Xu(l){for(let t of l.graph.shallowNodes)yield ie.getGeom(t)}var zt=class{constructor(t){this.stamp=0;this.SetPivotAndAllocateHullPointsArray(t)}SetPivotAndAllocateHullPointsArray(t){this.pivot=new d(0,Number.MAX_SAFE_INTEGER);let e=-1,i=0;for(let n of t)n.y<this.pivot.y?(this.pivot=n,e=i):n.y===this.pivot.y&&n.x>this.pivot.x&&(this.pivot=n,e=i),i++;if(i>=1){this.hullPoints=new Array(i-1),i=0;for(let n of t)i!==e?this.hullPoints[i++]={point:n,deleted:!1,stamp:this.stamp++}:e=-1}}get StackTopPoint(){return this.stack.point}get StackSecondPoint(){return this.stack.next.point}static*CalculateConvexHull(t){let e=new zt(t);for(let i of e.Calculate())yield i}*Calculate(){if(this.pivot.y!==Number.MAX_SAFE_INTEGER){if(this.hullPoints.length===0){yield this.pivot;return}this.SortAllPointsWithoutPivot(),this.Scan();for(let t of this.EnumerateStack())yield t}}*EnumerateStack(){let t=this.stack;for(;t!=null;)yield t.point,t=t.next}Scan(){let t=0;for(;this.hullPoints[t].deleted;)t++;for(this.stack={point:this.pivot,next:null},this.Push(t++),t<this.hullPoints.length&&(this.hullPoints[t].deleted?t++:this.Push(t++));t<this.hullPoints.length;)this.hullPoints[t].deleted?t++:this.LeftTurn(t)?this.Push(t++):this.Pop();for(;this.StackHasMoreThanTwoPoints()&&!this.LeftTurnToPivot();)this.Pop()}LeftTurnToPivot(){return d.getTriangleOrientation(this.StackSecondPoint,this.StackTopPoint,this.pivot)===1}StackHasMoreThanTwoPoints(){return this.stack.next!=null&&this.stack.next.next!=null}Pop(){this.stack=this.stack.next}LeftTurn(t){if(this.stack.next==null)return!0;let e=d.getTriangleOrientationWithIntersectionEpsilon(this.StackSecondPoint,this.StackTopPoint,this.hullPoints[t].point);return e===1?!0:e===0?!1:this.BackSwitchOverPivot(this.hullPoints[t].point)}BackSwitchOverPivot(t){return this.stack.next.next!=null?!1:this.StackTopPoint.x>this.pivot.x+C.distanceEpsilon&&t.x<this.pivot.x-C.distanceEpsilon}Push(t){this.stack={point:this.hullPoints[t].point,next:this.stack}}SortAllPointsWithoutPivot(){this.hullPoints.sort(Xf(this.pivot))}static createConvexHullAsClosedPolyline(t){return j.mkClosedFromPoints(Array.from(zt.CalculateConvexHull(t)))}};function Xf(l){return(t,e)=>{if(t===e)return 0;if(t==null)return-1;if(e==null)return 1;switch(d.getTriangleOrientationWithIntersectionEpsilon(l,t.point,e.point)){case 1:return-1;case 0:return 1;case 2:let i=t.point.x-l.x,n=e.point.x-l.x;if(i>C.distanceEpsilon&&n<-C.distanceEpsilon)return-1;if(i<-C.distanceEpsilon&&n>C.distanceEpsilon)return 1;let o=t.point.sub(l),s=e.point.sub(l),a=o.l1-s.l1;return a<0?(t.deleted=!0,-1):a>0?(e.deleted=!0,1):(t.stamp>e.stamp?t.deleted=!0:e.deleted=!0,0)}throw new Error}}function Et(l,t,e){!l.irect.intersects_rect(t.irect)||(l.Left==null?t.Left==null?e(l.UserData,t.UserData):(Et(l,t.Left,e),Et(l,t.Right,e)):t.Left!=null?(Et(l.Left,t.Left,e),Et(l.Left,t.Right,e),Et(l.Right,t.Left,e),Et(l.Right,t.Right,e)):(Et(l.Left,t,e),Et(l.Right,t,e)))}function tt(l,t,e){!l.irect.intersects_rect(t.irect)||(l===t?$f(l,e):l.Left==null?t.Left==null?e(l.UserData,t.UserData):(tt(l,t.Left,e),tt(l,t.Right,e)):t.Left!=null?(tt(l.Left,t.Left,e),tt(l.Left,t.Right,e),tt(l.Right,t.Left,e),tt(l.Right,t.Right,e)):(tt(l.Left,t,e),tt(l.Right,t,e)))}function yr(l,t,e){if(!l.irect.intersects_rect(t.irect))return!1;if(l===t)return Jf(l,e);if(l.Left==null){if(t.Left==null)return e(l.UserData,t.UserData);if(yr(l,t.Left,e)||yr(l,t.Right,e))return!0}else if(t.Left!=null){if(yr(l.Left,t.Left,e)||yr(l.Left,t.Right,e)||yr(l.Right,t.Left,e)||yr(l.Right,t.Right,e))return!0}else if(yr(l.Left,t,e)||yr(l.Right,t,e))return!0;return!1}function Jf(l,t){return l.Left==null?!1:yr(l.Left,l.Left,t)||yr(l.Left,l.Right,t)||yr(l.Right,l.Right,t)}function $f(l,t){l.Left!=null&&(tt(l.Left,l.Left,t),tt(l.Left,l.Right,t),tt(l.Right,l.Right,t))}var Hc=BigInt("6364136223846793005"),Ju=(BigInt(1)<<BigInt(32))-BigInt(1),Wi=(BigInt(1)<<BigInt(64))-BigInt(1),bn=class{constructor(t,e){this._state=BigInt(0),this._inc=(BigInt(e)<<BigInt(1)|BigInt(1))&Wi,this._random_b(),this._state=this._state+BigInt(t)&Wi,this._random_b()}_random_b(){let t=this._state;this._state=t*Hc+this._inc&Wi;let e=(t>>BigInt(18)^t)>>BigInt(27),i=t>>BigInt(59),n=i^BigInt(31);return(e>>i|e<<n)&Ju}_advance(t){t&=Wi;let e=BigInt(1),i=Hc,n=BigInt(0),o=this._inc;for(;t>0;)t&BigInt(1)&&(e=e*i&Wi,n=n*i+o&Wi),o=(i+BigInt(1))*o&Wi,i=i*i&Wi,t>>=BigInt(1);this._state=e*this._state+n&Wi}randint(t){if(t>Ju)throw new TypeError(`Bound too large: ${t}`);if(t<=0)throw new TypeError(`Empty sample space for r: 0 \u2264 r < ${t}`);let e=BigInt(t),i=(Ju^e)%e;for(;;){let n=this._random_b();if(n>=i)return Number(n%e)}}random(){return Number(this._random_b())/Math.pow(2,32)}};var to;function Pn(l){return to==null&&(to=new bn(0,0)),to.randint(l)}function yn(l){to=new bn(l,0)}function Si(){return to==null&&(to=new bn(0,0)),to.random()}var qc=he(Qr(),1);function*Zr(l){let t=new Array(l.nodeCount).fill(!1),e=new qc.Queue;for(let i=0;i<l.nodeCount;i++)if(!t[i]){let n=new Array;for(zc(i,e,t);e.length>0;){let o=e.dequeue();n.push(o);for(let s of Kf(l,o))zc(s,e,t)}yield n}}function*Kf(l,t){for(let e of l.outEdges[t])yield e.target;for(let e of l.inEdges[t])yield e.source}function zc(l,t,e){e[l]===!1&&(t.enqueue(l),e[l]=!0)}var Uc=he(Qr(),1);function jo(l){let t=new ft;return t.SetEdges(l,ft.vertexCount(l)),t}function Qa(l){let t=new ft;return t.SetEdges(l,ft.vertexCount(l)),t}function vt(l,t){let e=new ft;return e.SetEdges(l,t),e}var ft=class{constructor(){this.nodeCount=0}*incidentEdges(t){for(let e of this.outEdges[t])yield e;for(let e of this.inEdges[t])yield e}static deleteFromArray(t,e){let i=t.indexOf(e,0);i>-1&&t.splice(i,1)}removeEdge(t){ft.deleteFromArray(this.edges,t),t.source!==t.target?(ft.deleteFromArray(this.outEdges[t.source],t),ft.deleteFromArray(this.inEdges[t.target],t)):ft.deleteFromArray(this.selfEdges[t.source],t)}static vertexCount(t){let e=0;for(let i of t)i.source>=e&&(e=i.source),i.target>=e&&(e=i.target);return++e}SetEdges(t,e){this.edges=t,this.nodeCount=e;let i=new Array(this.nodeCount).fill(0),n=new Array(this.nodeCount).fill(0),o=new Array(this.nodeCount).fill(0);this.outEdges=new Array(this.nodeCount),this.inEdges=new Array(this.nodeCount),this.selfEdges=new Array(this.nodeCount);for(let s of this.edges)s.source!==s.target?(i[s.source]++,n[s.target]++):o[s.source]++;for(let s=0;s<this.nodeCount;s++)this.outEdges[s]=new Array(i[s]),i[s]=0,this.inEdges[s]=new Array(n[s]),n[s]=0,this.selfEdges[s]=new Array(o[s]),o[s]=0;for(let s of this.edges){let a=s.source,u=s.target;a!==u?(this.outEdges[a][i[a]++]=s,this.inEdges[u][n[u]++]=s):this.selfEdges[a][o[a]++]=s}}inEdgesCount(t){return this.inEdges[t].length}outEdgesCount(t){return this.outEdges[t].length}selfEdgesCount(t){return this.selfEdges[t].length}addEdge(t){this.edges.push(t),t.source!==t.target?(this.outEdges[t.source].push(t),this.inEdges[t.target].push(t)):this.selfEdges[t.source].push(t)}*nodesOfConnectedGraph(){if(this.edges.length===0)return;let t=new Set,e=new Uc.Queue,i=this.edges[0].source;for(ft.enqueue(t,e,i),yield i;e.length>0;){i=e.dequeue();for(let n of this.outEdges[i]){let o=n.target;t.has(o)||(ft.enqueue(t,e,o),yield o)}for(let n of this.inEdges[i]){let o=n.source;t.has(o)||(ft.enqueue(t,e,o),yield o)}}}*pred(t){for(let e of this.inEdges[t])yield e.source}*succ(t){for(let e of this.outEdges[t])yield e.target}static enqueue(t,e,i){e.enqueue(i),t.add(i)}};var ro=class{get Sequence(){return this.f}set Sequence(t){this.f=t}get Length(){return this.length}set Length(t){this.length=t}constructor(t,e){this.f=t,this.length=e}FindMinimum(){let t=0,e=this.length-1,i=t+Math.floor((e-t)/2),n=this.f(i);if(n>=this.f(0)&&n>=this.f(this.length-1))return this.f(0)<this.f(this.length-1)?0:this.length-1;for(;e-t>1;)switch(i=t+Math.floor((e-t)/2),this.BehaviourAtIndex(i)){case 1:t=i;break;case 0:e=i;break;case 2:return i}return t===e||this.f(t)<=this.f(e)?t:e}BehaviourAtIndex(t){let e=this.f(t);if(t===0){let o=this.f(1);return o===e?2:o>e?0:1}if(t===this.length-1){let o=this.f(this.length-2);return o===e?2:o>e?1:0}let i=e-this.f(t-1),n=this.f(t+1)-e;return i*n<=0?2:i>0?0:1}FindMaximum(){let t=0,e=this.length-1,i=t+Math.floor((e-t)/2),n=this.f(i);if(n<=this.f(0)&&n<=this.f(this.length-1))return this.f(0)>this.f(this.length-1)?0:this.length-1;for(;e-t>1;)switch(i=t+Math.floor((e-t)/2),this.BehaviourAtIndex(i)){case 1:e=i;break;case 0:t=i;break;case 2:return i}return t===e||this.f(t)>=this.f(e)?t:e}};var Xa=class{toArray(){let t=[];for(let e=0;e<this.length;e++)t.push(this.f(e));return t}constructor(t,e){this.f=t,this.length=e}GetAdjustedSequenceForMinimum(){let t=this.f(0),i=(this.f(this.length-1)-t)/(this.length-1);return n=>Math.min(this.f(n),t+i*n)}GetAdjustedSequenceForMaximum(){let t=this.f(0),i=(this.f(this.length-1)-t)/(this.length-1);return n=>Math.max(this.f(n),t+i*n)}FindMinimum(){return this.f(0)===this.f(this.length-1)?new ro(this.f,this.length).FindMinimum():new ro(this.GetAdjustedSequenceForMinimum(),this.length).FindMinimum()}FindMaximum(){return this.f(0)===this.f(this.length-1)?new ro(this.f,this.length).FindMaximum():new ro(this.GetAdjustedSequenceForMaximum(),this.length).FindMaximum()}};var Sn=class{constructor(t,e){this.P=t,this.Q=e}LeftFromLineOnP(t,e,i){let n=this.P.pnt(t);return this.upperBranchOnP?d.pointToTheLeftOfLineOrOnLine(i,n,e):d.pointToTheRightOfLineOrOnLine(i,n,e)}LeftFromLineOnQ(t,e,i){let n=this.Q.pnt(t);return this.lowerBranchOnQ?d.pointToTheLeftOfLineOrOnLine(i,n,e):d.pointToTheRightOfLineOrOnLine(i,n,e)}PrevOnP(t){return this.upperBranchOnP?this.P.Prev(t):this.P.Next(t)}PrevOnQ(t){return this.lowerBranchOnQ?this.Q.Prev(t):this.Q.Next(t)}NextOnP(t){return this.upperBranchOnP?this.P.Next(t):this.P.Prev(t)}NextOnQ(t){return this.lowerBranchOnQ?this.Q.Next(t):this.Q.Prev(t)}MedianOnP(t,e){return this.upperBranchOnP?this.P.Median(t,e):this.P.Median(e,t)}MedianOnQ(t,e){return this.lowerBranchOnQ?this.Q.Median(t,e):this.Q.Median(e,t)}ModuleP(t,e){return this.upperBranchOnP?this.P.Module(e-t):this.P.Module(t-e)}ModuleQ(t,e){return this.lowerBranchOnQ?this.Q.Module(e-t):this.Q.Module(t-e)}TangentBetweenBranches(t,e,i,n){for(;e!==t||n!==i;){let o=e!==t?this.MedianOnP(t,e):t,s=n!==i?this.MedianOnQ(i,n):i,a=this.P.pnt(o),u=this.Q.pnt(s),h=!0;this.ModuleP(t,e)>1?this.LeftFromLineOnP(this.NextOnP(o),a,u)?t=o:this.LeftFromLineOnP(this.PrevOnP(o),a,u)?e=o:h=!1:e!==t?this.LeftFromLineOnP(e,this.P.pnt(t),u)?t=e:this.LeftFromLineOnP(t,this.P.pnt(e),u)?e=t:h=!1:h=!1;let c=!0;this.ModuleQ(i,n)>1?this.LeftFromLineOnQ(this.NextOnQ(s),u,a)?i=s:this.LeftFromLineOnQ(this.PrevOnQ(s),u,a)?n=s:c=!1:n!==i?this.LeftFromLineOnQ(n,this.Q.pnt(i),a)?i=n:this.LeftFromLineOnQ(i,this.Q.pnt(n),a)?n=i:c=!1:c=!1,!h&&!c&&(t=o,e=o,i=s,n=s)}return[t,n]}FindDividingBisector(t){let e={pClosest:void 0,qClosest:void 0,p1:void 0,p2:void 0,q1:void 0,q2:void 0};this.FindClosestFeatures(e),t.bisectorPivot=d.middle(e.pClosest,e.qClosest),t.bisectorRay=e.pClosest.sub(e.qClosest).rotate(Math.PI/2),t.p1=e.p1,t.p2=e.p2,t.q1=e.q1,t.q2=e.q2}FindClosestPoints(){let t={q2:void 0,p1:void 0,p2:void 0,q1:void 0,pClosest:void 0,qClosest:void 0};return this.FindClosestFeatures(t),{pClosest:t.pClosest,qClosest:t.qClosest}}FindClosestFeatures(t){let e={leftTangentPoint:void 0,rightTangentPoint:void 0};this.P.GetTangentPoints(e,this.Q.pp(0).point),t.p2=e.leftTangentPoint,t.p1=e.rightTangentPoint,t.p2===t.p1&&(t.p2+=this.P.count),this.Q.GetTangentPoints(e,this.P.pp(0).point),t.q1=e.leftTangentPoint,t.q2=e.rightTangentPoint,t.q2===t.q1&&(t.q2+=this.Q.count),this.FindClosestPoints_(t)}FindClosestPoints_(t){for(;this.ChunksAreLong(t.p2,t.p1,t.q2,t.q1);)this.ShrinkChunks(t);t.p1===t.p2?(t.pClosest=this.P.pp(t.p2).point,t.q1===t.q2?t.qClosest=this.Q.pp(t.q1).point:(t.qClosest=d.ClosestPointAtLineSegment(t.pClosest,this.Q.pp(t.q1).point,this.Q.pp(t.q2).point),d.closeDistEps(t.qClosest,this.Q.pnt(t.q1))?t.q2=t.q1:d.closeDistEps(t.qClosest,this.Q.pnt(t.q2))&&(t.q1=t.q2))):(t.qClosest=this.Q.pp(t.q1).point,t.pClosest=d.ClosestPointAtLineSegment(t.qClosest,this.P.pp(t.p1).point,this.P.pp(t.p2).point),d.closeDistEps(t.pClosest,this.P.pnt(t.p1))?t.p2=t.p1:d.closeDistEps(t.qClosest,this.P.pnt(t.p2))&&(t.p1=t.p2))}ChunksAreLong(t,e,i,n){let o=this.P.Module(t-e)+1;if(o>2)return!0;let s=this.Q.Module(n-i)+1;return s>2||o===2&&s===2}ShrinkChunks(t){let e=t.p1===t.p2?t.p1:this.P.Median(t.p1,t.p2),i=t.q1===t.q2?t.q1:this.Q.Median(t.q2,t.q1),n=this.P.pp(e).point,o=this.Q.pp(i).point,s={a1:void 0,a2:void 0,b1:void 0,b2:void 0};if(this.GetAnglesAtTheMedian(e,i,n,o,s),!this.InternalCut(t,e,i,s.a1,s.a2,s.b1,s.b2)&&!Sn.OneOfChunksContainsOnlyOneVertex(t,e,i,s.a1,s.b1)&&!this.OnlyOneChunkContainsExactlyTwoVertices(t,{mp:e,mq:i},s)){if(t.p2===this.P.Next(t.p1)&&t.q1===this.Q.Next(t.q2)){let a=w.minDistBetweenLineSegments(this.P.pnt(t.p1),this.P.pnt(t.p2),this.Q.pnt(t.q1),this.Q.pnt(t.q2));a.parab===0?t.p2=t.p1:a.parab===1?t.p1=t.p2:a.parcd===0?t.q2=t.q1:a.parcd===1&&(t.q1=t.q2);return}s.a1<=Math.PI&&s.a2<=Math.PI&&s.b1<=Math.PI&&s.b2<=Math.PI?s.a1+s.b1>Math.PI?s.a1>=Math.PI/2?t.p1=e:t.q1=i:s.a2>=Math.PI/2?t.p2=e:t.q2=i:s.a1>Math.PI?t.p1=e:s.a2>Math.PI?t.p2=e:s.b1>Math.PI?t.q1=i:t.q2=i}}InternalCut(t,e,i,n,o,s,a){let u=!1;if(n>=Math.PI&&o>=Math.PI){let h=this.P.pp(e).point,c=this.Q.pp(i).point,f=this.P.pp(this.P.Next(e)).point,P=d.getTriangleOrientation(h,c,this.Q.pp(0).point),v=d.getTriangleOrientation(h,c,f);P===v?t.p1=this.P.Next(e):t.p2=this.P.Prev(e),u=!0}if(s>=Math.PI&&a>=Math.PI){let h=this.P.pp(e).point,c=this.Q.pp(i).point,f=this.Q.pp(this.Q.Next(i)).point,P=d.getTriangleOrientation(h,c,this.P.pp(0).point),v=d.getTriangleOrientation(h,c,f);P===v?t.q2=this.Q.Next(i):t.q1=this.Q.Prev(i),u=!0}return u}GetAnglesAtTheMedian(t,e,i,n,o){o.a1=d.anglePCP(n,i,this.P.pnt(this.P.Prev(t))),o.a2=d.anglePCP(this.P.pnt(this.P.Next(t)),i,n),o.b1=d.anglePCP(this.Q.pnt(this.Q.Next(e)),n,i),o.b2=d.anglePCP(i,n,this.Q.pnt(this.Q.Prev(e)))}OnlyOneChunkContainsExactlyTwoVertices(t,e,i){let n=t.p2===this.P.Next(t.p1),o=t.q1===this.Q.Next(t.q2);return n&&!o?(this.ProcessShortSide(t,e.mp,e.mq,i.a1,i.b1,i.a2,i.b2),!0):o&&!n?(this.SwapEverything(t,e,i),this.ProcessShortSide(t,e.mp,e.mq,i.a1,i.b1,i.a2,i.b2),this.SwapEverything(t,e,i),!0):!1}SwapEverything(t,e,i){this.SwapPq();let n=t.p2;t.p2=t.q1,t.q1=n,n=t.q2,t.q2=t.p1,t.p1=n,n=e.mq,e.mq=e.mp,e.mp=n,n=i.a2,i.a2=i.b1,i.b1=n,n=i.b2,i.b2=i.a1,i.a1=n}ProcessShortSide(t,e,i,n,o,s,a){e===t.p2?this.ProcessSide(t,i,n,o,a):s<=Math.PI?s+a>=Math.PI?s>=Math.PI/2?t.p2=t.p1:t.q2=i:o>=Math.PI/2?t.q1=i:s<a&&(d.canProject(this.Q.pnt(i),this.P.pp(t.p1).point,this.P.pp(t.p2).point)?t.q1=i:t.p1=t.p2):n+o<=Math.PI?t.p1=t.p2:t.p2=t.p1}SwapPq(){let t=this.P;this.P=this.Q,this.Q=t}ProcessSide(t,e,i,n,o){let s=this.Q.pnt(e);i<=Math.PI?i+n>=Math.PI?i>=Math.PI/2?t.p1=t.p2:t.q1=e:o>=Math.PI/2?t.q2=e:i<o&&(d.canProject(s,this.P.pp(t.p1).point,this.P.pp(t.p2).point)?t.q2=e:t.p2=t.p1):(t.p2=t.p1,n>=Math.PI?t.q1=e:o>=Math.PI&&(t.q2=e))}static OneOfChunksContainsOnlyOneVertex(t,e,i,n,o){return t.p1===t.p2?(o>=Math.PI/2?t.q1=i:t.q2=i,!0):t.q1===t.q2?(n>=Math.PI/2?t.p1=e:t.p2=e,!0):!1}CalculateLeftTangents(){let t={bisectorPivot:null,bisectorRay:null,p1:0,p2:0,q1:0,q2:0};this.FindDividingBisector(t);let e=this.P.FindTheFurthestVertexFromBisector(t.p1,t.p2,t.bisectorPivot,t.bisectorRay),i=this.Q.FindTheFurthestVertexFromBisector(t.q2,t.q1,t.bisectorPivot,t.bisectorRay);this.upperBranchOnP=!1,this.lowerBranchOnQ=!0,this.leftPLeftQ=this.TangentBetweenBranches(e,t.p1,i,t.q1),this.lowerBranchOnQ=!1,this.leftPRightQ=this.TangentBetweenBranches(e,t.p1,i,t.q2)}CalculateRightTangents(){let t={bisectorPivot:null,bisectorRay:null,p1:0,p2:0,q1:0,q2:0};this.FindDividingBisector(t);let e=this.P.FindTheFurthestVertexFromBisector(t.p1,t.p2,t.bisectorPivot,t.bisectorRay),i=this.Q.FindTheFurthestVertexFromBisector(t.q2,t.q1,t.bisectorPivot,t.bisectorRay);this.upperBranchOnP=!0,this.lowerBranchOnQ=!0,this.rightPLeftQ=this.TangentBetweenBranches(e,t.p2,i,t.q1),this.lowerBranchOnQ=!1,this.rightPRightQ=this.TangentBetweenBranches(e,t.p2,i,t.q2)}};var at=class{static mkFromPoints(t){return new at(j.mkClosedFromPoints(t))}get Polyline(){return this.polyline}constructor(t){this.polyline=t,this.points=new Array;for(let e=this.polyline.startPoint;e;e=e.next)this.points.push(e)}Next(t){return this.Module(t+1)}Prev(t){return this.Module(t-1)}get count(){return this.Polyline.count}Module(t){return t<0?t+this.count:t<this.count?t:t-this.count}pp(t){return this.points[this.Module(t)]}pnt(t){return this.pp(t).point}toString(){return this.polyline.toString()}Median(t,e){return e>t?Math.floor((e+t)/2):this.Module(e+Math.floor((this.count+t)/2))}FindTheFurthestVertexFromBisector(t,e,i,n){let o=n.rotate(Math.PI/2);this.polyline.startPoint.point.sub(i).dot(o)<0&&(o=o.mul(-1)),t===e&&(e=this.Next(t));do{let s=this.Median(e,t),a=this.pnt(s);this.pnt(this.Next(s)).sub(a).dot(o)>=0?e=this.Next(s):this.pnt(this.Prev(s)).sub(a).dot(o)>=0?t=this.Prev(s):e=s,t=s}while(t!==e);return t}static TestPolygonDist(t,e){let i=Number.MAX_SAFE_INTEGER;for(let n=0;n<t.count;n++)for(let o=0;o<e.count;o++){let s=w.minDistBetweenLineSegments(t.pnt(n),t.pnt(n+1),e.pnt(o),e.pnt(o+1));i=Math.min(i,s.dist)}return i}static Distance(t,e){let n=new Sn(t,e).FindClosestPoints();return{p:n.pClosest,q:n.qClosest,dist:n.pClosest.sub(n.qClosest).length}}static DistanceOnly(t,e){return at.Distance(t,e).dist}static PolygonIsLegalDebug(t){let e=t.Polyline;for(let i=e.startPoint;i.next!=null&&i.next.next!=null;i=i.next)if(d.getTriangleOrientation(i.point,i.next.point,i.next.next.point)===2)return!1;return!0}static DistancePoint(t,e){let i=Number.MAX_VALUE;for(let n=0;n<t.count;n++){let o=d.distToLineSegment(e,t.points[n].point,t.points[(n+1)%t.count].point).dist;i=Math.min(i,o)}return i}GetTangentPoints(t,e){let i=new Xa(this.GetSequenceDelegate(e),this.count);t.leftTangentPoint=i.FindMaximum(),t.rightTangentPoint=i.FindMinimum()}GetSequenceDelegate(t){let e=this.pnt(0);return i=>{let n=d.anglePCP(e,t,this.pnt(i));return n<Math.PI?n:n-2*Math.PI}}};var ue=class{constructor(t,e,i,n){this.randomizationShift=.01;this.TightObstacles=new Set;this.Obstacles=t,this.TightPadding=e,this.LoosePadding=i,this.IgnoreTightPadding=n}ObstaclesIntersectLine(t,e){return this.ObstaclesIntersectICurve(w.mkPP(t,e))}static PadCorner(t,e,i,n,o){let s=ue.GetPaddedCorner(e,i,n,o);return s.numberOfPoints===-1?!1:(t.addPoint(s.a),s.numberOfPoints===2&&t.addPoint(s.b),!0)}static CurveIsClockwise(t,e){return d.getTriangleOrientation(e,t.start,t.start.add(t.derivative(t.parStart)))==0}static PaddedPolylineBoundaryOfNode(t,e,i=!1){return ue.CreatePaddedPolyline(E.polylineAroundClosedCurve(t),e,i)}static LoosePolylineWithFewCorners(t,e,i){return e<C.distanceEpsilon?t:ue.CreateLoosePolylineOnBisectors(t,e,i)}static CreateLoosePolylineOnBisectors(t,e,i){let n=Array.from(ue.BisectorPoints(t,e));i&&s();let o=zt.CalculateConvexHull(n);return j.mkClosedFromPoints(o);function s(){for(let a=0;a<n.length;a++){let u=n[a];n[a]=new d(u.x+(2*Si()-1)*i,u.y+(2*Si()-1)*i)}}}static CreateRectNodeOfPolyline(t){return Fe(t,t.boundingBox)}CreateLooseObstacles(){this.tightPolylinesToLooseDistances=new Map,this.LooseObstacles=new Array;for(let t of this.TightObstacles){let e=ue.FindMaxPaddingForTightPolyline(this.RootOfTightHierarchy,t,this.LoosePadding);this.tightPolylinesToLooseDistances.set(t,e),this.LooseObstacles.push(ue.LoosePolylineWithFewCorners(t,e,this.randomizationShift))}this.RootOfLooseHierarchy=ue.CalculateHierarchy(this.LooseObstacles)}CreateTightObstacles(){this.RootOfTightHierarchy=this.CreateTightObstacles_(),this.OverlapsDetected=this.TightObstacles.size<this.Obstacles.length}Calculate(){this.IgnoreTightPadding?this.CreateTightObstaclesIgnoringTightPadding():this.CreateTightObstacles(),this.IsEmpty()||this.CreateLooseObstacles()}IsEmpty(){return this.TightObstacles==null||this.TightObstacles.size===0}ObstaclesIntersectICurve(t){let e=t.boundingBox;return ue.CurveIntersectsRectangleNode(t,e,this.RootOfTightHierarchy)}static CurveIntersectsRectangleNode(t,e,i){if(!i.irect.intersects(e))return!1;if(i.UserData!=null){let n=i.UserData;return E.intersectionOne(n,t,!1)!=null||ue.PointIsInside(n.start,t)}return ue.CurveIntersectsRectangleNode(t,e,i.Left)||ue.CurveIntersectsRectangleNode(t,e,i.Right)}static PointIsInside(t,e){return E.PointRelativeToCurveLocation(t,e)===2}CreateTightObstaclesIgnoringTightPadding(){let t=this.Obstacles.map(n=>E.polylineAroundClosedCurve(n)),e=ue.CalculateHierarchy(t),i=ue.GetOverlappedPairSet(e);if(this.TightObstacles=new Set,i.size===0){for(let n of t){let o=ue.FindMaxPaddingForTightPolyline(e,n,this.TightPadding);this.TightObstacles.add(ue.LoosePolylineWithFewCorners(n,o,this.randomizationShift))}this.RootOfTightHierarchy=ue.CalculateHierarchy(Array.from(this.TightObstacles))}else{for(let n of t)this.TightObstacles.add(ue.CreatePaddedPolyline(n,this.TightPadding));if(!this.IsEmpty())for(this.RootOfTightHierarchy=ue.CalculateHierarchy(Array.from(this.TightObstacles)),this.OverlapsDetected=!1;ue.GetOverlappedPairSet(this.RootOfTightHierarchy).size>0;)this.RootOfTightHierarchy=ue.ReplaceTightObstaclesWithConvexHulls(this.TightObstacles,Array.from(i)),this.OverlapsDetected=!0}}CreateTightObstacles_(){if(this.Obstacles.length===0)return null;for(let t of this.Obstacles)ue.CalculateTightPolyline(this.TightObstacles,this.TightPadding,t);return ue.RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(this.TightObstacles)}static CalculateTightPolyline(t,e,i){let n=ue.PaddedPolylineBoundaryOfNode(i,e);t.add(n)}static CalculateHierarchy(t){let e=t.map(i=>ue.CreateRectNodeOfPolyline(i));return Oe(e)}static RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(t){let e=ue.CalculateHierarchy(Array.from(t)),i;for(;(i=ue.GetOverlappedPairSet(e)).size>0;)e=ue.ReplaceTightObstaclesWithConvexHulls(t,Array.from(i));return e}static MapToInt(t){let e=new Map;for(let i=0;i<t.length;i++)e.set(t[i],i);return e}static ReplaceTightObstaclesWithConvexHulls(t,e){let i=new Set;for(let u of e)i.add(u[0]),i.add(u[1]);let n=Array.from(i),o=ue.MapToInt(n),s=Qa(Array.from(e).map(u=>new Z(o.get(u[0]),o.get(u[1])))),a=Zr(s);for(let u of a){let h=u.map(P=>n[P]),c=gi(h,P=>P),f=zt.createConvexHullAsClosedPolyline(c);for(let P of h)t.delete(P);t.add(f)}return ue.CalculateHierarchy(Array.from(t))}static OneCurveLiesInsideOfOther(t,e){return E.PointRelativeToCurveLocation(t.start,e)!==0||E.PointRelativeToCurveLocation(e.start,t)!==0}static PolylinesIntersect(t,e){return E.CurvesIntersect(t,e)||ue.OneCurveLiesInsideOfOther(t,e)}static GetOverlappedPairSet(t){let e=new Set;return tt(t,t,(i,n)=>{ue.PolylinesIntersect(i,n)&&e.add([i,n])}),e}static*BisectorPoints(t,e){for(let i=t.startPoint;i!=null;i=i.next){let n={skip:!1},o=ue.GetStickingVertexOnBisector(i,e,n);n.skip||(yield o)}}static GetStickingVertexOnBisector(t,e,i){let n=t.polyline.prev(t).point,o=t.point,s=t.polyline.next(t).point,a=o.sub(n).normalize().add(o.sub(s).normalize()),u=a.length;return u<C.tolerance?i.skip=!0:(i.skip=!1,a=a.div(u)),a.mul(e).add(o)}static FindMaxPaddingForTightPolyline(t,e,i){let n=i,o=new at(e),s=e.boundingBox.clone();s.pad(2*i);for(let a of Array.from(t.GetNodeItemsIntersectingRectangle(s)).filter(u=>u!==e)){let u=at.Distance(o,new at(a)).dist;n=Math.min(n,u/ue.LooseDistCoefficient)}return n}static GetPaddedCorner(t,e,i,n){let o=t.point,s=e.point,a=i.point;if(d.getTriangleOrientation(o,s,a)===1)return{a:void 0,b:void 0,numberOfPoints:-1};let u=s.sub(o).rotate(Math.PI/2).normalize();if(ue.CornerIsNotTooSharp(o,s,a)){u=u.mul(n);let A=a.sub(s).normalize().mul(n).rotate(Math.PI/2),O=d.lineLineIntersection(o.add(u),s.add(u),s.add(A),a.add(A));return{a:O,b:O,numberOfPoints:1}}let h=s.sub(o).normalize().add(s.sub(a).normalize());if(h.length<C.intersectionEpsilon){let A=s.add(u.mul(n));return{a:A,b:A,numberOfPoints:1}}let c=h.normalize().mul(n),f=c.rotate(Math.PI/2),P=(n-c.dot(u))/f.dot(u),v=f.mul(P);return{a:c.add(v).add(s),b:c.sub(v).add(s),numberOfPoints:2}}static CornerIsNotTooSharp(t,e,i){let n=t.sub(e).rotate(Math.PI/4).add(e);return d.getTriangleOrientation(e,n,i)===1}static CreatePaddedPolyline(t,e,i=!1){let n=new j,o=i?Yf(t):t;if(!ue.PadCorner(n,o.endPoint.prev,o.endPoint,o.startPoint,e))return ue.CreatePaddedPolyline(j.mkClosedFromPoints(Array.from(zt.CalculateConvexHull(o))),e);if(!ue.PadCorner(n,o.endPoint,o.startPoint,o.startPoint.next,e))return ue.CreatePaddedPolyline(j.mkClosedFromPoints(Array.from(zt.CalculateConvexHull(o))),e);for(let s=o.startPoint;s.next.next!=null;s=s.next)if(!ue.PadCorner(n,s,s.next,s.next.next,e))return ue.CreatePaddedPolyline(j.mkClosedFromPoints(Array.from(zt.CalculateConvexHull(o))),e);return n.closed=!0,n}},lt=ue;lt.LooseDistCoefficient=2.1;function Yf(l){let t=new j,e=.01;for(let i=l.startPoint;i;i=i.next){let n=i.point.x+e*Si(),o=i.point.y+e*Si();t.addPointXY(n,o)}return t.closed=l.closed,t}var Qo=class{get TightPolyline(){return this.tightPoly}set TightPolyline(t){this.tightPoly=t}static mk(t,e,i){let n=new Qo;return n.TightPolyline=t,n.LooseShape=e,n.Distance=i,n}toString(){return(this.TightPolyline==null?"null":this.TightPolyline.toString().substring(0,5))+","+(this.LooseShape==null?"null":this.LooseShape.toString().substring(0,5))}};var Xo=class{constructor(t,e,i,n){this.loosePolylinesToNodes=new Map;this.MainShape=t,this.TightPadding=e,this.LoosePadding=i,this.ShapesToTightLooseCouples=n}Calculate(t){yn(3),this.MainShape.Children.length!==0&&(this.CreateTightObstacles(),this.CreateTigthLooseCouples(t),this.OverlapsDetected&&this.FillTheMapOfShapeToTightLooseCouples())}FillTheMapOfShapeToTightLooseCouples(){let t=Oe(this.MainShape.Children.map(e=>Fe(e,e.BoundingBox)));Et(t,this.coupleHierarchy,this.TryMapShapeToTightLooseCouple.bind(this))}TryMapShapeToTightLooseCouple(t,e){Xo.ShapeIsInsideOfPoly(t,e.TightPolyline)&&this.ShapesToTightLooseCouples.set(t,e)}static ShapeIsInsideOfPoly(t,e){return E.PointRelativeToCurveLocation(t.BoundaryCurve.start,e)===2}CreateTigthLooseCouples(t){let e=new Array;for(let i of this.tightHierarchy.GetAllLeaves()){let n=lt.FindMaxPaddingForTightPolyline(this.tightHierarchy,i,this.LoosePadding),o=lt.LoosePolylineWithFewCorners(i,n,t),s=new Xr(o),a=Qo.mk(i,s,n);this.ShapesToTightLooseCouples.set(this.tightToShape.get(i),a),e.push(a)}this.coupleHierarchy=Oe(e.map(i=>Fe(i,i.TightPolyline.boundingBox)))}CreateTightObstacles(){this.tightToShape=new Map;let t=new Set(this.MainShape.Children.map(this.InitialTightPolyline.bind(this))),e=t.size;this.tightHierarchy=lt.RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(t),this.OverlapsDetected=e>t.size}InitialTightPolyline(t){let e=lt.PaddedPolylineBoundaryOfNode(t.BoundaryCurve,this.TightPadding),i=gi(this.LoosePolylinesUnderShape(t),o=>o).filter(o=>E.PointRelativeToCurveLocation(o,e)===0);if(i.length==0)return this.tightToShape&&this.tightToShape.set(e,t),e;let n=Array.from(e).concat(i);return e=j.mkClosedFromPoints(zt.CalculateConvexHull(n)),this.tightToShape&&this.tightToShape.set(e,t),e}LoosePolylinesUnderShape(t){return t.Children.map(e=>this.ShapesToTightLooseCouples.get(e).LooseShape.BoundaryCurve)}};var jc=he(gt(),1);var Ja=class{constructor(t,e,i){this.indexToA=t,this.priority=e,this.v=i}};var At=class{constructor(t=ce){this.heapSize=0;this.compare=t,this.cache=new Map,this.A=[]}get count(){return this.heapSize}ContainsElement(t){return this.cache.has(t)}SwapWithParent(t){let e=this.A[t>>1];this.PutAtI(t>>1,this.A[t]),this.PutAtI(t,e)}Enqueue(t,e){let i=++this.heapSize,n=new Ja(i,e,t);for(this.cache.set(t,n),this.A[i]=n;i>1&&this.compare(this.A[i>>1].priority,e)>0;)this.SwapWithParent(i),i>>=1}IsEmpty(){return this.heapSize===0}PutAtI(t,e){this.A[t]=e,e.indexToA=t}Dequeue(){if(this.heapSize===0)throw new Error("dequeue on an empty queue");let t=this.A[1].v;return this.MoveQueueOneStepForward(t),t}DequeueAndGetPriority(t){if(this.heapSize===0)throw new Error("dequeue on an empty queue");let e=this.A[1].v;return t.priority=this.A[1].priority,this.MoveQueueOneStepForward(e),e}MoveQueueOneStepForward(t){this.cache.delete(t),this.PutAtI(1,this.A[this.heapSize]);let e=1;for(;;){let i=e,n=e<<1;n<=this.heapSize&&this.compare(this.A[n].priority,this.A[e].priority)<0&&(i=n);let o=n+1;if(o<=this.heapSize&&this.compare(this.A[o].priority,this.A[i].priority)<0&&(i=o),i!==e)this.SwapWithParent(i);else break;e=i}this.heapSize--}DecreasePriority(t,e){let i=this.cache.get(t);if(!i)return;i.priority=e;let n=i.indexToA;for(;n>1&&this.compare(this.A[n].priority,this.A[n>>1].priority)<0;){this.SwapWithParent(n);n>>=1}}*GetEnumerator(){for(let t=1;t<=this.heapSize;t++)yield this.A[t].v}Peek(t){if(this.count===0){t.priority=0;return}return t.priority=this.A[1].priority,this.A[1].v}toString(){let t=new jc.StringBuilder;for(let e of this.A)t.Append(e+",");return t.ToString()}};var Hi=class{constructor(t,e,i){this.upperBound=Number.POSITIVE_INFINITY;this._visGraph=i,this._visGraph.ClearPrevEdgesTable();for(let n of i.Vertices())n.Distance=Number.POSITIVE_INFINITY;this.source=t,this.targets=new Set(e),this.source.Distance=0}GetPath(){let t=new At(ce);for(this.source.Distance=0,t.Enqueue(this.source,0);!t.IsEmpty()&&(this.current=t.Dequeue(),!this.targets.has(this.current));){for(let e of this.current.OutEdges)this.PassableOutEdge(e)&&this.ProcessNeighbor(t,e,e.Target);for(let e of this.current.InEdges)this.PassableInEdge(e)&&this.ProcessNeighbor(t,e,e.Source)}return this._visGraph.PreviosVertex(this.current)==null?null:this.CalculatePath()}PassableOutEdge(t){return t.Source===this.source||this.targets.has(t.Target)||!Hi.IsForbidden(t)}PassableInEdge(t){return this.targets.has(t.Source)||t.Target===this.source||!Hi.IsForbidden(t)}static IsForbidden(t){return t.IsPassable!=null&&!t.IsPassable()||t instanceof mt}ProcessNeighbor(t,e,i){let n=e.Length,o=this.current.Distance+n;o>=this.upperBound||(this.targets.has(i)&&(this.upperBound=o,this.closestTarget=i),i!==this.source&&this._visGraph.PreviosVertex(i)==null?(i.Distance=o,this._visGraph.SetPreviousEdge(i,e),t.Enqueue(i,o)):o<i.Distance&&(i.Distance=o,this._visGraph.SetPreviousEdge(i,e),t.DecreasePriority(i,o)))}CalculatePath(){if(this.closestTarget==null)return null;let t=new Array,e=this.closestTarget;do t.push(e),e=this._visGraph.PreviosVertex(e);while(e!==this.source);return t.push(this.source),t.reverse()}};var io=class{constructor(t,e,i){this._lengthMultiplier=1;this._lengthMultiplierForAStar=1;this._visGraph=t,this._source=e,this._target=i,this._source.Distance=0}get LengthMultiplier(){return this._lengthMultiplier}set LengthMultiplier(t){this._lengthMultiplier=t}get LengthMultiplierForAStar(){return this._lengthMultiplierForAStar}set LengthMultiplierForAStar(t){this._lengthMultiplierForAStar=t}GetPath(t){let e=new At(ce);for(this._source.Distance=0,this._target.Distance=Number.POSITIVE_INFINITY,e.Enqueue(this._source,this.H(this._source));!e.IsEmpty();){let i={priority:0},n=e.DequeueAndGetPriority(i);if(i.priority>=this._target.Distance)break;for(let o of n.OutEdges)if(this.PassableOutEdge(o)){let s=o.Target;this.ProcessNeighbor(e,n,o,s)}for(let o of n.InEdges)if(this.PassableInEdge(o)){let s=o.Source;this.ProcessNeighbor(e,n,o,s)}}return this._visGraph.PreviosVertex(this._target)==null?null:this.CalculatePath(t)}PassableOutEdge(t){return t.Source===this._source||t.Target===this._target||!io.IsForbidden(t)}PassableInEdge(t){return t.Source===this._target||t.Target===this._source||!io.IsForbidden(t)}static IsForbidden(t){return t.IsPassable!=null&&!t.IsPassable()||t instanceof mt}ProcessNeighborN(t,e,i,n,o){let s=i.Length+o,a=e.Distance+s;n!==this._source&&this._visGraph.PreviosVertex(n)==null?(n.Distance=a,this._visGraph.SetPreviousEdge(n,i),n!==this._target&&t.Enqueue(n,this.H(n))):n!==this._source&&a<n.Distance&&(n.Distance=a,this._visGraph.SetPreviousEdge(n,i),n!==this._target&&t.DecreasePriority(n,this.H(n)))}ProcessNeighbor(t,e,i,n){let o=i.Length,s=e.Distance+o;n!==this._source&&this._visGraph.PreviosVertex(n)==null?(n.Distance=s,this._visGraph.SetPreviousEdge(n,i),n!==this._target&&t.Enqueue(n,this.H(n))):n!==this._source&&s<n.Distance&&(n.Distance=s,this._visGraph.SetPreviousEdge(n,i),n!==this._target&&t.DecreasePriority(n,this.H(n)))}H(t){return t.Distance+t.point.sub(this._target.point).length*this.LengthMultiplierForAStar}CalculatePath(t){let e=new Array,i=this._target;do e.push(i),t&&this._visGraph.ShrinkLengthOfPrevEdge(i,this.LengthMultiplier),i=this._visGraph.PreviosVertex(i);while(i!==this._source);return e.push(this._source),e.reverse()}};var Qc=he(gt(),1),Ls=class{toString(){return Qc.String.Format("{0},{1}",this.Start,this.End)}get Start(){return this.leftTangent.End.point}get End(){return this.rightTangent.End.point}constructor(t,e){this.LeftTangent=t,this.RightTangent=e}get LeftTangent(){return this.leftTangent}set LeftTangent(t){this.leftTangent=t}get RightTangent(){return this.rightTangent}set RightTangent(t){this.rightTangent=t}get RbNode(){return this.rbNode}set RbNode(t){this.rbNode=t}};var Xc=he(gt(),1),Gs=class{get Comp(){return this.comp}set Comp(t){this.comp=t}get IsHigh(){return!this.IsLow}get IsLow(){return this.lowTangent}set IsLow(t){this.lowTangent=t}get SeparatingPolygons(){return this.separatingPolygons}set SeparatingPolygons(t){this.separatingPolygons=t}get Diagonal(){return this.diagonal}set Diagonal(t){this.diagonal=t}get Start(){return this.start}set Start(t){this.start=t}get End(){return this.end}set End(t){this.end=t}constructor(t,e){this.start=t,this.End=e}toString(){return Xc.String.Format("{0},{1}",this.Start,this.End)}};var Rs=class{get PointOnTangentAndInsertedDiagonal(){return this.pointOnTheRay}set PointOnTangentAndInsertedDiagonal(t){this.pointOnTheRay=t}Compare(t,e){if(t.Start.equal(e.Start))return 0;switch(d.getTriangleOrientation(this.PointOnTangentAndInsertedDiagonal,e.Start,e.End)){case 1:return-1;default:return 1}}static BelongsToTheDiagonal(t,e,i){return d.closeDistEps(t,d.ClosestPointAtLineSegment(t,e,i))}static IntersectDiagonalWithRay(t,e,i){let n=e.sub(t),o=i.Start,s=i.End,a=Tr.solve(s.x-o.x,n.x*-1,t.x-o.x,s.y-o.y,n.y*-1,t.y-o.y);return t.add(n.mul(a.y))}};var Ci=class{constructor(t){this.pivot=t}IComparer(t,e){if(t===e)return 0;if(t==null)return-1;if(e==null)return 1;let i=t.Start.point.sub(this.pivot),n=e.Start.point.sub(this.pivot);return Ci.CompareVectorsByAngleToXAxis(i,n)}static CompareVectorsByAngleToXAxis(t,e){return t.y>=0?e.y<0?-1:Ci.CompareVectorsPointingToTheSameYHalfPlane(t,e):e.y>=0?1:Ci.CompareVectorsPointingToTheSameYHalfPlane(t,e)}static CompareVectorsPointingToTheSameYHalfPlane(t,e){let i=t.x*e.y-t.y*e.x;if(i>C.tolerance)return-1;if(i<-C.tolerance)return 1;if(t.x>=0){if(e.x<0)return-1}else if(e.x>=0)return 1;let n=Math.abs(t.x)-Math.abs(e.x);return n<0?-1:n>0?1:(n=Math.abs(t.y)-Math.abs(e.y),n<0?-1:n>0?1:0)}};var _r=class extends _{constructor(e,i,n){super(null);this.polygons=[];this.activeDiagonalComparer=new Rs;this.polygons=e,this.visibilityGraph=n,this.addedPolygons=i}run(){this.useLeftPTangents=!0,this.CalculateAndAddEdges(),this.useLeftPTangents=!1,this.CalculateAndAddEdges()}CalculateAndAddEdges(){for(let e of this.addedPolygons)this.CalculateVisibleTangentsFromPolygon(e);this.ProgressStep()}CalculateVisibleTangentsFromPolygon(e){this.currentPolygon=e,this.AllocateDataStructures(),this.OrganizeTangents(),this.InitActiveDiagonals(),this.Sweep()}AllocateDataStructures(){this.tangents=new Array,this.diagonals=new Array,this.activeDiagonalTree=new Me(this.activeDiagonalComparer.Compare.bind(this.activeDiagonalComparer))}Sweep(){if(!(this.tangents.length<2))for(let e=1;e<this.tangents.length;e++){let i=this.tangents[e];i.Diagonal!=null?(i.Diagonal.RbNode===this.activeDiagonalTree.treeMinimum()&&this.AddVisibleEdge(i),i.IsHigh&&this.RemoveDiagonalFromActiveNodes(i.Diagonal)):i.IsLow&&(this.activeDiagonalComparer.PointOnTangentAndInsertedDiagonal=i.End.point,this.InsertActiveDiagonal(new Ls(i,i.Comp)),i.Diagonal.RbNode===this.activeDiagonalTree.treeMinimum()&&this.AddVisibleEdge(i))}}AddVisibleEdge(e){Ie.AddEdgeVV(Jc(this.visibilityGraph,e.start),Jc(this.visibilityGraph,e.End))}InitActiveDiagonals(){if(this.tangents.length===0)return;let e=this.tangents[0],i=e.start.point,n=e.End.point;for(let o of this.diagonals)_r.RayIntersectDiagonal(i,n,o)&&(this.activeDiagonalComparer.PointOnTangentAndInsertedDiagonal=Rs.IntersectDiagonalWithRay(i,n,o),this.InsertActiveDiagonal(o));if(e.Diagonal.RbNode===this.activeDiagonalTree.treeMinimum()&&this.AddVisibleEdge(e),e.IsLow===!1){let o=e.Diagonal;this.RemoveDiagonalFromActiveNodes(o)}}RemoveDiagonalFromActiveNodes(e){let i=this.activeDiagonalTree.deleteSubTree(e.RbNode);i!=null&&i.item!=null&&(i.item.RbNode=i),e.LeftTangent.Diagonal=null,e.RightTangent.Diagonal=null}InsertActiveDiagonal(e){e.RbNode=this.activeDiagonalTree.insert(e),_r.MarkDiagonalAsActiveInTangents(e)}static MarkDiagonalAsActiveInTangents(e){e.LeftTangent.Diagonal=e,e.RightTangent.Diagonal=e}static RayIntersectDiagonal(e,i,n){let o=n.Start,s=n.End;return d.getTriangleOrientation(e,o,s)===1&&d.getTriangleOrientation(e,i,o)!==1&&d.getTriangleOrientation(e,i,s)!==0}static TangentComparison(e,i){return Ci.CompareVectorsByAngleToXAxis(e.End.point.sub(e.start.point),i.End.point.sub(i.start.point))}*AllObstacles(){for(let e of this.addedPolygons)yield e;if(this.polygons)for(let e of this.polygons)yield e}OrganizeTangents(){for(let e of this.AllObstacles())e!==this.currentPolygon&&this.ProcessPolygonQ(e);this.tangents.sort(_r.TangentComparison)}ProcessPolygonQ(e){let i=new Sn(this.currentPolygon,e);this.useLeftPTangents?i.CalculateLeftTangents():i.CalculateRightTangents();let n=this.useLeftPTangents?i.leftPLeftQ:i.rightPLeftQ,o=new Gs(this.currentPolygon.pp(n[0]),e.pp(n[1]));o.IsLow=!0,o.SeparatingPolygons=!this.useLeftPTangents,n=this.useLeftPTangents?i.leftPRightQ:i.rightPRightQ;let s=new Gs(this.currentPolygon.pp(n[0]),e.pp(n[1]));s.IsLow=!1,s.SeparatingPolygons=this.useLeftPTangents,o.Comp=s,s.Comp=o,this.tangents.push(o),this.tangents.push(s),this.diagonals.push(new Ls(o,s))}};function Jc(l,t){return l.FindVertex(t.point)}var Jo=class{get Pivot(){return this.pivot}set Pivot(t){this.pivot=t}get IntersectionOfTheRayAndInsertedEdge(){return this.pointOnTheRay}set IntersectionOfTheRayAndInsertedEdge(t){this.pointOnTheRay=t}Compare(t,e){switch(d.getTriangleOrientation(this.IntersectionOfTheRayAndInsertedEdge,e.point,e.nextOnPolyline.point)){case 1:return-1;default:return 1}}IntersectionPointBelongsToTheInsertedEdge(t){let e=t.point.sub(this.IntersectionOfTheRayAndInsertedEdge),i=t.nextOnPolyline.point.sub(this.IntersectionOfTheRayAndInsertedEdge);return Math.abs(e.x*i.y-i.x*e.y)<C.distanceEpsilon}IntersectEdgeWithRayPPP(t,e,i){let n=Tr.solve(e.x-t.x,-i.x,this.Pivot.x-t.x,e.y-t.y,-i.y,this.Pivot.y-t.y);if(!(-C.tolerance<=n.x&&n.x<=1+C.tolerance))throw new Error;if(!n)throw new Error;return this.Pivot.add(i.mul(n.y))}IntersectEdgeWithRay(t,e){return this.IntersectEdgeWithRayPPP(t.point,t.nextOnPolyline.point,e)}static constructorPP(t,e){let i=new Jo;return i.pivot=t,i.pointOnTheRay=e,i}};var $c=he(gt(),1),Cn=class{get Start(){return this.start}set Start(t){this.start=t}get End(){return this.end}set End(t){this.end=t}constructor(t,e){this.start=t,this.end=e}*Sides(){let t=this.start;for(;t!==this.end;){let e=t;yield e,t=e.nextOnPolyline}}MoveStartClockwise(){return this.Start!==this.End?(this.Start=this.Start.nextOnPolyline,!0):!1}toString(){return $c.String.Format("Stem({0},{1})",this.Start,this.End)}};var Fr=class{constructor(t,e,i,n){this.sideNodes=new Map;this.visibleBoundaries=new Map;this.sortedListOfPolypoints=new Array;this.holes=Array.from(t),this.visibilityGraph=e,this.q=i,this.qPolylinePoint=it.mkFromPoint(this.q),this.QVertex=this.visibilityGraph.AddVertexP(this.qPolylinePoint.point),this.visibilityKind=n;let o=new Ci(this.q);this.heapForSorting=new hn(o.IComparer.bind(o))}get QVertex(){return this.qV}set QVertex(t){this.qV=t}static CalculatePointVisibilityGraph(t,e,i,n){let o=e.FindVertex(i);if(o!=null)return o;let s=new Fr(t,e,i,n);return s.FillGraph(),s.QVertex}FillGraph(){this.ComputeHoleBoundariesPossiblyVisibleFromQ(),this.visibleBoundaries.size>0&&(this.SortSAndInitActiveSides(),this.Sweep())}SortSAndInitActiveSides(){this.InitHeapAndInsertActiveSides();for(let t=this.heapForSorting.GetMinimum();this.sortedListOfPolypoints.push(t.Start),t.MoveStartClockwise()?this.heapForSorting.ChangeMinimum(t):this.heapForSorting.Dequeue(),this.heapForSorting.Count!==0;t=this.heapForSorting.GetMinimum());}InitHeapAndInsertActiveSides(){for(let t of this.GetInitialVisibleBoundaryStemsAndInsertActiveSides())this.heapForSorting.Enqueue(t)}*GetInitialVisibleBoundaryStemsAndInsertActiveSides(){for(let[t,e]of this.visibleBoundaries){let i=!1;for(let n of e.Sides()){let o=n;if(o.point.y<this.q.y){if(n.nextOnPolyline.point.y>=this.q.y){let s=d.getTriangleOrientation(this.q,o.point,n.nextOnPolyline.point);if(s===1||s===2){i=!0,yield new Cn(e.Start,n),yield new Cn(n.nextOnPolyline,e.End),this.RegisterActiveSide(n);break}}}else{if(o.point.y>this.q.y)break;if(n.point.x>=this.q.x){i=!0,yield new Cn(n,e.End),n!==e.Start&&(yield new Cn(e.Start,t.prev(o))),this.RegisterActiveSide(n);break}}}i||(yield e)}}RegisterActiveSide(t){this.activeEdgeComparer.IntersectionOfTheRayAndInsertedEdge=this.activeEdgeComparer.IntersectEdgeWithRay(t,new d(1,0)),this.sideNodes.set(t,this.activeSidesTree.insert(t))}Sweep(){for(let t of this.sortedListOfPolypoints)this.SweepPolylinePoint(t)}SweepPolylinePoint(t){let e=Fr.GetIncomingSide(t),i=this.GetOutgoingSide(t);this.activeEdgeComparer.IntersectionOfTheRayAndInsertedEdge=t.point;let n;if(n=this.sideNodes.get(e)){if(n===this.activeSidesTree.treeMinimum()&&this.AddEdge(t),i!=null)n.item=i,this.sideNodes.set(i,n);else{let o=this.activeSidesTree.deleteSubTree(n);o!=null&&o.item!=null&&this.sideNodes.set(o.item,o)}this.sideNodes.delete(e)}else if(i!=null){let o;(o=this.sideNodes.get(i))||(o=this.activeSidesTree.insert(i),this.sideNodes.set(i,o),o===this.activeSidesTree.treeMinimum()&&this.AddEdge(t))}else throw new Error}AddEdge(t){(this.visibilityKind===0||this.visibilityKind===1&&Fr.LineTouchesPolygon(this.QVertex.point,t))&&this.visibilityGraph.AddEdgeF(this.QVertex.point,t.point,(e,i)=>new mt(e,i))}static LineTouchesPolygon(t,e){let i=e.polyline.prev(e).point,n=e.polyline.next(e).point,o=e.point;return d.signedDoubledTriangleArea(t,o,i)*d.signedDoubledTriangleArea(t,o,n)>=0}GetOutgoingSide(t){let e=this.visibleBoundaries.get(t.polyline);return t===e.End?null:t}static GetIncomingSide(t){return t.prevOnPolyline}ComputeHoleBoundariesPossiblyVisibleFromQ(){this.InitActiveEdgesAndActiveEdgesComparer();for(let t of this.holes)this.ComputeVisiblePartOfTheHole(t)}InitActiveEdgesAndActiveEdgesComparer(){this.activeEdgeComparer=new Jo,this.activeEdgeComparer.pivot=this.q,this.activeSidesTree=new Me(this.activeEdgeComparer.Compare.bind(this.activeEdgeComparer))}ComputeVisiblePartOfTheHole(t){let e,i=!0;for(e=t.startPoint;!this.HoleSideIsVisibleFromQ(t,e);e=t.next(e))i=!1;let n=t.next(e);if(i)for(;this.HoleSideIsVisibleFromQ(t,t.prev(e));)e=t.prev(e);for(;this.HoleSideIsVisibleFromQ(t,n);n=t.next(n));this.visibleBoundaries.set(t,new Cn(e,n))}HoleSideIsVisibleFromQ(t,e){return d.signedDoubledTriangleArea(this.q,e.point,t.next(e).point)>=-C.squareOfDistanceEpsilon}};var Ce=class extends _{constructor(){super(...arguments);this.IgnoreTightPadding=!0;this.activeRectangle=D.mkEmpty();this.activePolygons=new Array;this.alreadyAddedOrExcludedPolylines=new Set;this.UseEdgeLengthMultiplier=!1;this.UseInnerPolylingShortcutting=!0;this.UsePolylineEndShortcutting=!0;this.AllowedShootingStraightLines=!0;this.LookForRoundedVertices=!1}rerouteEdge(e){if(e.smoothedPolyline==null)return;let i=j.mkFromPoints(e.smoothedPolyline);this.pathOptimizer.run(i),e.curve=this.pathOptimizer.poly.toCurve()}static constructorANNN(e,i,n,o){return Ce.constructorANNNB(e,i,n,o,!1)}get Obstacles(){return this.obstacles_}set Obstacles(e){this.obstacles_=e}get EnteringAngleBound(){return this.enteringAngleBound_}set EnteringAngleBound(e){this.enteringAngleBound_=e}get SourceTightPolyline(){return this._sourceTightPolyline}set SourceTightPolyline(e){this._sourceTightPolyline=e}get TargetTightPolyline(){return this.targetTightPolyline}set TargetTightPolyline(e){this.targetTightPolyline=e}get TargetLoosePolyline(){return this.targetLoosePolyline}set TargetLoosePolyline(e){this.targetLoosePolyline=e}get VisibilityGraph(){return this.visibilityGraph}set VisibilityGraph(e){this.visibilityGraph=e}get SourcePort(){return this.sourcePort}set SourcePort(e){if(this.sourcePort=e,this.sourcePort!=null)if(this.SourceTightPolyline=Ce.GetFirstHitPolyline(this.sourcePort.Location,this.ObstacleCalculator.RootOfTightHierarchy),this.sourcePort instanceof dt)this.alreadyAddedOrExcludedPolylines.add(this.SourceLoosePolyline),this.StartPointOfEdgeRouting=this.SourcePort.Location;else{let i=this.sourcePort;this.StartPointOfEdgeRouting=this.TakeBoundaryPortOutsideOfItsLoosePolyline(i.Curve,i.Parameter,this.SourceLoosePolyline)}}get TargetPort(){return this.targetPort}set TargetPort(e){this.targetPort=e}get LoosePadding(){return this.loosePadding}set LoosePadding(e){this.loosePadding=e,this.ObstacleCalculator!=null&&(this.ObstacleCalculator.LoosePadding=e)}get OffsetForPolylineRelaxing(){return this.TightPadding*.75}get StartPointOfEdgeRouting(){return this.startPointOfRouting_}set StartPointOfEdgeRouting(e){this.startPointOfRouting_=e}ExtendVisibilityGraphToLocation(e){this.VisibilityGraph==null&&(this.VisibilityGraph=new Ie);let i=null;if(!this.activeRectangle.contains(e)){this.activeRectangle.isEmpty?this.activeRectangle=D.mkPP(this.SourcePort.Location,e):this.activeRectangle.add(e),i=this.GetAddedPolygonesAndMaybeExtendActiveRectangle();for(let n of i)this.VisibilityGraph.AddHole(n.Polyline)}i==null||i.length===0?(this.targetVV!=null&&this.VisibilityGraph.RemoveVertex(this.targetVV),this.CalculateEdgeTargetVisibilityGraph(e)):(this.RemovePointVisibilityGraphs(),new _r(i,this.activePolygons,this.VisibilityGraph).run(),di(this.activePolygons,i),this.CalculateEdgeTargetVisibilityGraph(e),this.CalculateSourcePortVisibilityGraph())}RemovePointVisibilityGraphs(){this.targetVV!=null&&this.VisibilityGraph.RemoveVertex(this.targetVV),this.sourceVV!=null&&this.VisibilityGraph.RemoveVertex(this.sourceVV)}CalculateEdgeTargetVisibilityGraph(e){this.targetVV=Fr.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()),this.VisibilityGraph,e,1)}CalculateSourcePortVisibilityGraph(){this.sourceVV=Fr.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()),this.VisibilityGraph,this.StartPointOfEdgeRouting,1)}TakeBoundaryPortOutsideOfItsLoosePolyline(e,i,n){let o=e.value(i),s=e.leftDerivative(i).normalize().add(e.rightDerivative(i).normalize()).normalize();d.getTriangleOrientation(Ce.PointInsideOfConvexCurve(e),o,o.add(s))==1&&(s=s.mul(-1)),s=s.rotate(Math.PI/2);let a=n.boundingBox.diagonal,u=w.mkPP(o,o.add(s.mul(a))),h=E.intersectionOne(u,n,!1).x,c=s.mul(h.sub(o).length/2);for(;;){u=w.mkPP(o,h.add(c));let f=!1;for(let P of Ce.IntersectionsOfLineAndRectangleNodeOverPolylineLR(u,this.ObstacleCalculator.RootOfLooseHierarchy))if(P.seg1!==n){c=c.div(1.5),f=!0;break}if(!f)break}return u.end}static PointInsideOfConvexCurve(e){return e.value(0).add(e.value(1.5)).div(2)}*GetActivePolylines(){for(let e of this.activePolygons)yield e.Polyline}GetAddedPolygonesAndMaybeExtendActiveRectangle(){let e=this.activeRectangle,i=new Array,n;do{n=!1;for(let o of this.ObstacleCalculator.RootOfLooseHierarchy.GetNodeItemsIntersectingRectangle(this.activeRectangle))this.alreadyAddedOrExcludedPolylines.has(o)||(e.addRec(o.boundingBox),i.push(new at(o)),this.alreadyAddedOrExcludedPolylines.add(o),n=!0);n&&(this.activeRectangle=e)}while(n);return i}PolylineSegmentIntersectsTightHierarchy(e,i){return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchyPPR(e,i,this.ObstacleCalculator.RootOfTightHierarchy)}PolylineIntersectsPolyRectangleNodeOfTightHierarchyPPR(e,i,n){return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(w.mkPP(e,i),n)}PolylineIntersectsPolyRectangleNodeOfTightHierarchy(e,i){if(!e.boundingBox.intersects(i.irect))return!1;if(i.UserData!=null){for(let n of E.getAllIntersections(e,i.UserData,!1))if(n.seg1!==this.SourceTightPolyline&&n.seg1!==this.TargetTightPolyline||(n.seg1===this.SourceTightPolyline&&this.SourcePort)instanceof Ct||(n.seg1===this.TargetTightPolyline&&this.TargetPort)instanceof Ct)return!0;return!1}return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(e,i.Left)||this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(e,i.Right)}static IntersectionsOfLineAndRectangleNodeOverPolylineLR(e,i){let n=new Array;return Ce.IntersectionsOfLineAndRectangleNodeOverPolyline(e,i,n),n}static IntersectionsOfLineAndRectangleNodeOverPolyline(e,i,n){if(i!=null&&!!e.boundingBox.intersects(i.irect)){if(i.UserData!=null){di(n,E.getAllIntersections(e,i.UserData,!0));return}Ce.IntersectionsOfLineAndRectangleNodeOverPolyline(e,i.Left,n),Ce.IntersectionsOfLineAndRectangleNodeOverPolyline(e,i.Right,n)}}LineCanBeAcceptedForRouting(e){let i=this.SourcePort instanceof dt,n=this.TargetPort instanceof dt;if(!i&&!this.targetIsInsideOfSourceTightPolyline&&!this.InsideOfTheAllowedConeOfBoundaryPort(e.end,this.SourcePort)||!n&&this.TargetPort!=null&&!this.sourceIsInsideOfTargetTightPolyline&&!this.InsideOfTheAllowedConeOfBoundaryPort(e.start,this.TargetPort))return!1;let o=Ce.IntersectionsOfLineAndRectangleNodeOverPolylineLR(e,this.ObstacleCalculator.RootOfTightHierarchy);for(let s of o)if(s.seg1!==this.SourceTightPolyline&&s.seg1!==this.targetTightPolyline)return!1;return!0}InsideOfTheAllowedConeOfBoundaryPort(e,i){let n=i.Curve,o=lt.CurveIsClockwise(n,Ce.PointInsideOfConvexCurve(n)),s=i.Location,a=this.GetPointOnTheRightBoundaryPortConeSide(s,n,o,i.Parameter),u=this.GetPointOnTheLeftBoundaryPortConeSide(s,n,o,i.Parameter);return d.getTriangleOrientation(s,a,e)!==0&&d.getTriangleOrientation(s,e,u)!==0}GetPointOnTheRightBoundaryPortConeSide(e,i,n,o){let s=n?i.rightDerivative(o):i.leftDerivative(o).neg();return e.add(s.rotate(this.EnteringAngleBound))}GetPointOnTheLeftBoundaryPortConeSide(e,i,n,o){let s=n?i.leftDerivative(o).neg():i.rightDerivative(o);return e.add(s.rotate(-this.EnteringAngleBound))}SmoothenCorners(e){let i=e.headSite,n={b:null,c:null};for(;n=E.findCorner(i);)i=this.SmoothOneCorner(i,n.c,n.b)}SmoothOneCorner(e,i,n){let a=.5,u,h,c;e.prev==null?(c=2,h=1):i.next==null?(c=1,h=2):c=h=1;do u=E.createBezierSeg(a*c,a*h,e,n,i),n.previouisBezierCoefficient=a*c,n.nextBezierCoefficient=a*h,a/=1.5;while(f()>this.loosePadding&&a>.01);return a*=1.5,a<.5&&a>.01&&(a=.5*(a+a*1.5),u=E.createBezierSeg(a*c,a*h,e,n,i),f()>this.loosePadding&&(n.previouisBezierCoefficient=a*c,n.nextBezierCoefficient=a*h)),n;function f(){let P=u.closestParameter(n.point);return n.point.sub(u.value(P)).length}}TryToRemoveInflectionsAndCollinearSegments(e){let i=!0,n={s:null};for(;i;)for(i=!1,n.s=e.headSite;n.s!=null&&n.s.next!=null;n.s=n.s.next)n.s.turn*n.s.next.turn<0&&(i=this.TryToRemoveInflectionEdge(n)||i)}TryToRemoveInflectionEdge(e){if(!this.ObstacleCalculator.ObstaclesIntersectLine(e.s.prev.point,e.s.next.point)){let i=e.s.prev,n=e.s.next;return i.next=n,n.prev=i,e.s=i,!0}if(!this.ObstacleCalculator.ObstaclesIntersectLine(e.s.prev.point,e.s.next.next.point)){let i=e.s.prev,n=e.s.next.next;return i.next=n,n.prev=i,e.s=i,!0}if(!this.ObstacleCalculator.ObstaclesIntersectLine(e.s.point,e.s.next.next.point)){let i=e.s.next.next;return e.s.next=i,i.prev=e.s,!0}return!1}GetShortestPolyline(e,i){this.CleanTheGraphForShortestPath();let o=new io(this.visibilityGraph,e,i).GetPath(this.UseEdgeLengthMultiplier);if(o==null)return null;let s=j.mkFromPoints(Array.from(o).map(a=>a.point)).RemoveCollinearVertices();return this.pathOptimizer&&(this.pathOptimizer.run(s),s=this.pathOptimizer.poly),s}CleanTheGraphForShortestPath(){this.visibilityGraph.ClearPrevEdgesTable()}get OverlapsDetected(){return this.ObstacleCalculator.OverlapsDetected}get TightHierarchy(){return this.ObstacleCalculator.RootOfTightHierarchy}set TightHierarchy(e){this.ObstacleCalculator.RootOfTightHierarchy=e}get LooseHierarchy(){return this.ObstacleCalculator.RootOfLooseHierarchy}set LooseHierarchy(e){this.ObstacleCalculator.RootOfLooseHierarchy=e}CalculateObstacles(){this.ObstacleCalculator=new lt(this.Obstacles,this.TightPadding,this.LoosePadding,this.IgnoreTightPadding),this.ObstacleCalculator.Calculate()}static constructorANNNB(e,i,n,o,s){let a=new Ce(null);return a.IgnoreTightPadding=s,a.EnteringAngleBound=80*(Math.PI/180),a.TightPadding=i,a.LoosePadding=n,o>0?(le.assert(o>Math.PI/180),le.assert(o<=90*(Math.PI/180)),a.UseSpanner=!0,a.ExpectedProgressSteps=yi.GetTotalSteps(o)):a.ExpectedProgressSteps=e.length,a.ConeSpannerAngle=o,a.Obstacles=e,a.CalculateObstacles(),a}RouteEdgeToLocation(e){this.TargetPort=new dt(null,e),this.TargetTightPolyline=null,this.TargetLoosePolyline=null;let i=new Re(null),n=w.mkPP(this.SourcePort.Location,e);return this.LineCanBeAcceptedForRouting(n)?(this._polyline=new j,this._polyline.addPoint(n.start),this._polyline.addPoint(n.end),i.smoothedPolyline=Ge.mkFromPoints(this._polyline),i.curve=i.smoothedPolyline.createCurve(),i):this.SourcePort instanceof Ct&&(n=w.mkPP(this.StartPointOfEdgeRouting,e),Ce.IntersectionsOfLineAndRectangleNodeOverPolylineLR(n,this.ObstacleCalculator.RootOfTightHierarchy).length==0)?(this._polyline=new j,this._polyline.addPoint(this.SourcePort.Location),this._polyline.addPoint(n.start),this._polyline.addPoint(n.end),i.smoothedPolyline=Ge.mkFromPoints(this._polyline),i.curve=i.smoothedPolyline.createCurve(),i):(this.ExtendVisibilityGraphToLocation(e),this._polyline=this.GetShortestPolyline(this.sourceVV,this.targetVV),this.SourcePort instanceof Ct&&this._polyline.PrependPoint(this.SourcePort.Location),i.smoothedPolyline=Ge.mkFromPoints(this._polyline),i.curve=i.smoothedPolyline.createCurve(),i)}RouteEdgeToPort(e,i,n,o){return this.ObstacleCalculator.IsEmpty()?this.sourcePort!=null&&this.targetPort!=null?(o.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(this.sourcePort.Location,this.targetPort.Location),w.mkPP(this.sourcePort.Location,this.targetPort.Location)):null:(this.TargetPort=e,this.TargetTightPolyline=Ce.GetFirstHitPolyline(e.Location,this.ObstacleCalculator.RootOfTightHierarchy),e instanceof Ct?this.RouteEdgeToBoundaryPort(i,n,o):this.RouteEdgeToFloatingPortOfNode(i,n,o))}SmoothedPolylineFromTwoPoints(e,i){return this._polyline=new j,this._polyline.addPoint(e),this._polyline.addPoint(i),Ge.mkFromPoints(this._polyline)}RouteEdgeToFloatingPortOfNode(e,i,n){return this.sourcePort instanceof dt?this.RouteFromFloatingPortToFloatingPort(e,i,n):this.RouteFromBoundaryPortToFloatingPort(e,i,n)}RouteFromBoundaryPortToFloatingPort(e,i,n){let o=this.SourcePort.Location,s=this.targetPort.Location,a=w.mkPP(o,s);if(this.LineCanBeAcceptedForRouting(a))return n.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(a.start,a.end),a;if(!this.targetIsInsideOfSourceTightPolyline){let h=this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.SourcePort.Curve,this.SourcePort.Parameter,this.SourceLoosePolyline);if(a=w.mkPP(h,s),this.LineAvoidsTightHierarchyLP(a,e))return n.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(a.start,a.end),a}this.ExtendVisibilityGraphToLocationOfTargetFloatingPort(e),this._polyline=this.GetShortestPolyline(this.sourceVV,this.targetVV);let u=this.SourceTightPolyline;return this.targetIsInsideOfSourceTightPolyline||(this.SourceTightPolyline=null),this.SourceTightPolyline=u,this._polyline.PrependPoint(o),this.SmoothCornersAndReturnCurve(i,n)}SmoothCornersAndReturnCurve(e,i){return i.smoothedPolyline=Ge.mkFromPoints(this._polyline),e&&this.SmoothenCorners(i.smoothedPolyline),i.smoothedPolyline.createCurve()}RouteFromFloatingPortToFloatingPort(e,i,n){return this.ExtendVisibilityGraphToLocationOfTargetFloatingPort(e),this._polyline=this.GetShortestPolyline(this.sourceVV,this.targetVV),this._polyline==null?null:(n.smoothedPolyline=Ge.mkFromPoints(this._polyline),this.SmoothCornersAndReturnCurve(i,n))}TryShortcutPolyPoint(e){return this.LineAvoidsTightHierarchyLPP(w.mkPP(e.point,e.next.next.point),this.SourceTightPolyline,this.targetTightPolyline)?(e.next=e.next.next,e.next.prev=e,!0):!1}ExtendVisibilityGraphToLocationOfTargetFloatingPort(e){this.VisibilityGraph==null&&(this.VisibilityGraph=new Ie);let i=null,n=this.targetPort.Location;if(!this.activeRectangle.contains(n)){this.activeRectangle.isEmpty?this.activeRectangle=D.mkPP(this.SourcePort.Location,n):this.activeRectangle.add(n),i=this.GetAddedPolygonesAndMaybeExtendActiveRectangle();for(let o of i)this.VisibilityGraph.AddHole(o.Polyline)}i==null?(this.targetVV!=null&&this.VisibilityGraph.RemoveVertex(this.targetVV),this.CalculateEdgeTargetVisibilityGraphForFloatingPort(n,e),this.sourceVV==null&&this.CalculateSourcePortVisibilityGraph()):(this.RemovePointVisibilityGraphs(),new _r(i,this.activePolygons,this.VisibilityGraph).run(),di(this.activePolygons,i),this.CalculateEdgeTargetVisibilityGraphForFloatingPort(n,e),this.CalculateSourcePortVisibilityGraph())}CalculateEdgeTargetVisibilityGraphForFloatingPort(e,i){this.UseSpanner?this.targetVV=this.AddTransientVisibilityEdgesForPort(e,i):this.targetVV=Fr.CalculatePointVisibilityGraph(this.GetActivePolylinesWithException(i),this.VisibilityGraph,e,1)}AddTransientVisibilityEdgesForPort(e,i){let n=this.GetVertex(e);if(n!=null)return n;if(n=this.visibilityGraph.AddVertexP(e),i!=null)for(let o of i)this.visibilityGraph.AddEdgeF(e,o,(s,a)=>new mt(s,a));else n=Fr.CalculatePointVisibilityGraph(this.GetActivePolylines(),this.VisibilityGraph,e,1);return n}GetVertex(e){let i=this.visibilityGraph.FindVertex(e);return i==null&&this.LookForRoundedVertices&&(i=this.visibilityGraph.FindVertex(d.RoundPoint(e))),i}*GetActivePolylinesWithException(e){for(let i of this.activePolygons)i.Polyline!==e&&(yield i.Polyline)}RouteEdgeToBoundaryPort(e,i,n){return this.TargetLoosePolyline=e,this.sourcePort instanceof dt?this.RouteFromFloatingPortToBoundaryPort(i,n):this.RouteFromBoundaryPortToBoundaryPort(i,n)}RouteFromBoundaryPortToBoundaryPort(e,i){let n=this.SourcePort.Location,o,s=this.targetPort.Location,a=w.mkPP(n,s);if(this.LineCanBeAcceptedForRouting(a))this._polyline=new j,this._polyline.addPoint(a.start),this._polyline.addPoint(a.end),i.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(a.start,a.end),o=Ge.mkFromPoints(this._polyline).createCurve();else{let u=this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.targetPort.Curve,this.targetPort.Parameter,this.TargetLoosePolyline);if(a=w.mkPP(n,u),this.InsideOfTheAllowedConeOfBoundaryPort(u,this.SourcePort)&&this.LineAvoidsTightHierarchyLP(a,this._sourceTightPolyline))this._polyline=new j,this._polyline.addPoint(a.start),this._polyline.addPoint(a.end),this._polyline.addPoint(s),o=this.SmoothCornersAndReturnCurve(e,i);else if(a=w.mkPP(this.StartPointOfEdgeRouting,s),this.InsideOfTheAllowedConeOfBoundaryPort(this.StartPointOfEdgeRouting,this.TargetPort)&&this.LineAvoidsTightHierarchy(a))this._polyline=new j,this._polyline.addPoint(n),this._polyline.addPoint(a.start),this._polyline.addPoint(a.end),o=this.SmoothCornersAndReturnCurve(e,i);else{let h;if(h=w.IntersectPPPP(n,this.StartPointOfEdgeRouting,s,u))this._polyline=new j,this._polyline.addPoint(n),this._polyline.addPoint(h),this._polyline.addPoint(s),o=this.SmoothCornersAndReturnCurve(e,i);else if(d.closeDistEps(this.StartPointOfEdgeRouting,u))this._polyline=new j,this._polyline.addPoint(n),this._polyline.addPoint(u),this._polyline.addPoint(s),o=this.SmoothCornersAndReturnCurve(e,i);else if(this.LineAvoidsTightHierarchy(w.mkPP(this.StartPointOfEdgeRouting,u)))this._polyline=new j,this._polyline.addPoint(n),this._polyline.addPoint(this.StartPointOfEdgeRouting),this._polyline.addPoint(u),this._polyline.addPoint(s),o=this.SmoothCornersAndReturnCurve(e,i);else{this.ExtendVisibilityGraphToTargetBoundaryPort(u),this._polyline=this.GetShortestPolyline(this.sourceVV,this.targetVV);let c={tmpTargetTight:null},f=this.HideSourceTargetTightsIfNeeded(c);this.RecoverSourceTargetTights(f,c.tmpTargetTight),this._polyline.PrependPoint(n),this._polyline.addPoint(s),o=this.SmoothCornersAndReturnCurve(e,i)}}}return o}RecoverSourceTargetTights(e,i){this.SourceTightPolyline=e,this.TargetTightPolyline=i}HideSourceTargetTightsIfNeeded(e){let i=this.SourceTightPolyline;return e.tmpTargetTight=this.TargetTightPolyline,this.TargetTightPolyline=null,this.SourceTightPolyline=null,i}LineAvoidsTightHierarchy(e){return Ce.IntersectionsOfLineAndRectangleNodeOverPolylineLR(e,this.ObstacleCalculator.RootOfTightHierarchy).length===0}RouteFromFloatingPortToBoundaryPort(e,i){let n=this.targetPort.Location,o;if(this.InsideOfTheAllowedConeOfBoundaryPort(this.sourcePort.Location,this.targetPort)&&(o=w.mkPP(this.SourcePort.Location,n),this.LineCanBeAcceptedForRouting(o)))return i.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(o.start,o.end),o;let s=this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.TargetPort.Curve,this.TargetPort.Parameter,this.TargetLoosePolyline);if(o=w.mkPP(this.SourcePort.Location,s),this.LineAvoidsTightHierarchyLP(o,this._sourceTightPolyline))return this._polyline=j.mkFromPoints([o.start,o.end,n]),i.smoothedPolyline=Ge.mkFromPoints(this._polyline),i.smoothedPolyline.createCurve();this.ExtendVisibilityGraphToTargetBoundaryPort(s),this._polyline=this.GetShortestPolyline(this.sourceVV,this.targetVV),this._polyline.addPoint(n);let a={smoothedPolyline:null};return this.SmoothCornersAndReturnCurve(e,a)}LineAvoidsTightHierarchyLP(e,i){let n=!0;for(let o of Ce.IntersectionsOfLineAndRectangleNodeOverPolylineLR(e,this.ObstacleCalculator.RootOfTightHierarchy))if(o.seg1!==i){n=!1;break}return n}LineAvoidsTightHierarchyLPP(e,i,n){let o=!0;for(let s of Ce.IntersectionsOfLineAndRectangleNodeOverPolylineLR(e,this.ObstacleCalculator.RootOfTightHierarchy))if(!(s.seg1===i||s.seg1===n)){o=!1;break}return o}LineAvoidsTightHierarchyPPPP(e,i,n,o){return this.LineAvoidsTightHierarchyLPP(w.mkPP(e,i),n,o)}ExtendVisibilityGraphToTargetBoundaryPort(e){let i=null;if(this.VisibilityGraph==null&&(this.VisibilityGraph=new Ie),!this.activeRectangle.contains(e)||!this.activeRectangle.containsRect(this.TargetLoosePolyline.boundingBox)){this.activeRectangle.isEmpty?(this.activeRectangle=this.TargetLoosePolyline.boundingBox.clone(),this.activeRectangle.add(this.SourcePort.Location),this.activeRectangle.add(this.StartPointOfEdgeRouting),this.activeRectangle.add(e)):(this.activeRectangle.add(e),this.activeRectangle.addRec(this.TargetLoosePolyline.boundingBox)),i=this.GetAddedPolygonesAndMaybeExtendActiveRectangle();for(let n of i)this.VisibilityGraph.AddHole(n.Polyline)}i==null?(this.targetVV!=null&&this.VisibilityGraph.RemoveVertex(this.targetVV),this.CalculateEdgeTargetVisibilityGraph(e)):(this.RemovePointVisibilityGraphs(),new _r(i,this.activePolygons,this.VisibilityGraph).run(),di(this.activePolygons,i),this.CalculateEdgeTargetVisibilityGraph(e),this.CalculateSourcePortVisibilityGraph())}GetHitLoosePolyline(e){return this.ObstacleCalculator.IsEmpty()||this.ObstacleCalculator.RootOfLooseHierarchy==null?null:Ce.GetFirstHitPolyline(e,this.ObstacleCalculator.RootOfLooseHierarchy)}static GetFirstHitPolyline(e,i){let n=Ce.GetFirstHitRectangleNode(e,i);return n?n.UserData:null}static GetFirstHitRectangleNode(e,i){return i==null?null:i.FirstHitNodeWithPredicate(e,(n,o)=>E.PointRelativeToCurveLocation(n,o)!==0?1:0)}Clean(){this.TargetPort=null,this.SourcePort=null,this.SourceTightPolyline=null,this.SourceLoosePolyline=null,this.TargetLoosePolyline=null,this.targetTightPolyline=null,this.VisibilityGraph=null,this.targetVV=null,this.sourceVV=null,this.activePolygons=[],this.alreadyAddedOrExcludedPolylines.clear(),this.activeRectangle.setToEmpty()}SetSourcePortAndSourceLoosePolyline(e,i){this.SourceLoosePolyline=i,this.sourcePort=e,this.sourcePort!=null&&(this.SourceTightPolyline=Ce.GetFirstHitPolyline(this.sourcePort.Location,this.ObstacleCalculator.RootOfTightHierarchy),this.sourcePort instanceof dt?(this.alreadyAddedOrExcludedPolylines.add(this.SourceLoosePolyline),this.StartPointOfEdgeRouting=this.SourcePort.Location):this.StartPointOfEdgeRouting=this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.SourcePort.Curve,this.sourcePort.Parameter,this.SourceLoosePolyline))}run(){this.CalculateWholeTangentVisibilityGraph()}CalculateWholeTangentVisibilityGraph(){this.VisibilityGraph=new Ie,this.CalculateWholeVisibilityGraphOnExistingGraph()}CalculateWholeVisibilityGraphOnExistingGraph(){this.activePolygons=Array.from(this.AllPolygons());for(let i of this.ObstacleCalculator.LooseObstacles)this.VisibilityGraph.AddHole(i);let e;this.UseSpanner?e=new yi(this.ObstacleCalculator.LooseObstacles,this.VisibilityGraph):e=new _r(new Array,this.activePolygons,this.visibilityGraph),e.run()}RouteSplineFromPortToPortWhenTheWholeGraphIsReady(e,i,n,o){let s=e instanceof dt&&i instanceof Ct||e instanceof Ze;if(s){let u=e;e=i,i=u}this.sourcePort=e,this.targetPort=i,this.FigureOutSourceTargetPolylinesAndActiveRectangle();let a=this.GetEdgeGeomByRouting(n,o);return a==null?null:(this.targetVV=null,this.sourceVV=null,s&&(a=a.reverse()),a)}GetEdgeGeomByRouting(e,i){this.sourceIsInsideOfTargetTightPolyline=this.TargetTightPolyline==null||E.PointRelativeToCurveLocation(this.sourcePort.Location,this.TargetTightPolyline)===2;let n;if(this.sourcePort instanceof Ct){let o=this.sourcePort;this.StartPointOfEdgeRouting=this.targetIsInsideOfSourceTightPolyline?o.Location:this.TakeBoundaryPortOutsideOfItsLoosePolyline(o.Curve,o.Parameter,this.SourceLoosePolyline),this.CalculateSourcePortVisibilityGraph();let s={smoothedPolyline:null};this.targetPort instanceof Ct?n=this.RouteFromBoundaryPortToBoundaryPort(e,s):n=this.RouteFromBoundaryPortToFloatingPort(this.targetLoosePolyline,e,s)}else this.targetPort instanceof dt?(this.ExtendVisibilityGraphFromFloatingSourcePort(),n=this.RouteFromFloatingPortToFloatingPort(this.targetLoosePolyline,e,i)):n=this.RouteFromFloatingPortToAnywherePort(this.targetPort.LoosePolyline,e,i,this.targetPort);return n}RouteFromFloatingPortToAnywherePort(e,i,n,o){return o.Curve.boundingBox.contains(this.sourcePort.Location)?(this.sourceVV=this.GetVertex(this.sourcePort.Location),this._polyline=this.GetShortestPolylineToMulitpleTargets(this.sourceVV,Array.from(this.Targets(e))),this._polyline==null?null:(this.FixLastPolylinePointForAnywherePort(o),o.HookSize>0&&this.BuildHook(o),this.SmoothCornersAndReturnCurve(i,n))):(n.smoothedPolyline=null,null)}BuildHook(e){let i=e.Curve,n=ee.mkFullEllipseNNP(e.HookSize,e.HookSize,this._polyline.end),o=E.getAllIntersections(i,n,!0);d.getTriangleOrientation(o[0].x,this._polyline.end,this._polyline.endPoint.prev.point)==1&&o.reverse();let s=this._polyline.end.sub(this._polyline.endPoint.prev.point).normalize(),a=i.derivative(o[0].par0).normalize(),u=a.dot(s);if(Math.abs(u)<.2)this.ExtendPolyline(a,o[0],s,e);else{let h=i.derivative(o[1].par0).normalize();h.dot(s)<u?this.ExtendPolyline(h,o[1],s,e):this.ExtendPolyline(a,o[0],s,e)}}ExtendPolyline(e,i,n,o){let s=e.rotate(Math.PI/2);s.dot(n)<0&&(s=s.neg());let a=i.x.add(s.mul(o.HookSize)),u;!(u=d.lineLineIntersection(a,a.add(e),this._polyline.end,this._polyline.end.add(n)))||(this._polyline.addPoint(u),this._polyline.addPoint(a),this._polyline.addPoint(i.x))}FixLastPolylinePointForAnywherePort(e){for(;;){let i=this.GetLastPointInsideOfCurveOnPolyline(e.Curve);i.next.next=null,this._polyline.endPoint=i.next;let n=i.next.point.sub(i.point);n=n.normalize().mul(e.Curve.boundingBox.diagonal);let o=n.rotate(e.AdjustmentAngle*-1),s=n.rotate(e.AdjustmentAngle),a=E.intersectionOne(e.Curve,w.mkPP(i.point,i.point.add(o)),!0),u=E.intersectionOne(e.Curve,w.mkPP(i.point,i.point.add(s)),!0);if(a==null||u==null)return;let h=Ce.GetTrimmedCurveForHookingUpAnywhere(e.Curve,i,a,u),c=h.value(h.closestParameter(i.point));if(!this.LineAvoidsTightHierarchyLPP(w.mkPP(i.point,c),this.SourceTightPolyline,null)){let f=E.intersectionOne(e.Curve,w.mkPP(i.point,i.next.point),!1);if(f==null)return;this._polyline.endPoint.point=f.x;break}if(this._polyline.endPoint.point=c,i.prev==null||!this.TryShortcutPolyPoint(i.prev))break}}static GetTrimmedCurveForHookingUpAnywhere(e,i,n,o){let s=d.getTriangleOrientation(o.x,n.x,i.point)===0,a=n.par0,u=o.par0,h,c,f;return s?a<u?e.trim(a,u):(c=e.trim(a,e.parEnd),h=e.trim(e.parStart,u),f=new E,f.addSegs([c,h])):u<a?e.trim(u,a):(c=e.trim(u,e.parEnd),h=e.trim(e.parStart,a),f=new E,f.addSegs([c,h]))}GetLastPointInsideOfCurveOnPolyline(e){for(let i=this._polyline.endPoint.prev;i!=null;i=i.prev)if(i.prev==null||E.PointRelativeToCurveLocation(i.point,e)===2)return i;throw new Error}GetShortestPolylineToMulitpleTargets(e,i){this.CleanTheGraphForShortestPath();let o=new Hi(e,i,this.VisibilityGraph).GetPath();if(o==null)return null;let s=new j;for(let a of o)s.addPoint(a.point);return s.RemoveCollinearVertices()}Targets(e){return Array.from(e).map(i=>this.visibilityGraph.FindVertex(i))}ExtendVisibilityGraphFromFloatingSourcePort(){let e=this.sourcePort;this.StartPointOfEdgeRouting=e.Location,this.UseSpanner?this.sourceVV=this.AddTransientVisibilityEdgesForPort(this.sourcePort.Location,this.SourceLoosePolyline):this.sourceVV=Fr.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()).filter(i=>i!==this.SourceLoosePolyline),this.VisibilityGraph,this.StartPointOfEdgeRouting,1)}FigureOutSourceTargetPolylinesAndActiveRectangle(){let e=this.sourcePort.Curve.value(this.sourcePort.Curve.parStart);this._sourceTightPolyline=Ce.GetFirstHitPolyline(e,this.ObstacleCalculator.RootOfTightHierarchy),this.SourceLoosePolyline=Ce.GetFirstHitPolyline(e,this.ObstacleCalculator.RootOfLooseHierarchy),e=this.targetPort.Curve.value(this.targetPort.Curve.parStart),this.targetTightPolyline=Ce.GetFirstHitPolyline(e,this.ObstacleCalculator.RootOfTightHierarchy),this.targetLoosePolyline=Ce.GetFirstHitPolyline(e,this.ObstacleCalculator.RootOfLooseHierarchy),this.activeRectangle=D.mkPP(new d(Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY),new d(Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY))}*AllPolygons(){for(let e of this.ObstacleCalculator.LooseObstacles)yield new at(e)}GetVisibilityGraph(){return this.VisibilityGraph}AddActivePolygons(e){di(this.activePolygons,e)}ClearActivePolygons(){this.activePolygons=[]}};var jd=he(Qr(),1);var Sr=class{constructor(){this.length=Sr.defaultArrowheadLength;this.width=0;this.length=Sr.defaultArrowheadLength}clone(){let t=new Sr;return t.length=this.length,t.width=this.width,t.tipPosition=this.tipPosition,t}static calculateArrowheads(t){if(t.sourceArrowhead==null&&t.targetArrowhead==null)return!0;let e=Sr.findTrimStartForArrowheadAtSource(t);if(e==null)return!1;let i=Sr.findTrimEndForArrowheadAtTarget(t);if(i==null||e>i-C.intersectionEpsilon||E.closeIntersectionPoints(t.curve.value(e),t.curve.value(i)))return!1;let n=t.curve.trim(e,i);return n==null?!1:(t.sourceArrowhead!=null&&(t.sourceArrowhead.tipPosition=t.curve.start),t.targetArrowhead!=null&&(t.targetArrowhead.tipPosition=t.curve.end),t.curve=n,!0)}static getIntersectionsWithArrowheadCircle(t,e,i){let n=ee.mkFullEllipseNNP(e,e,i);return E.getAllIntersections(n,t,!0)}static findTrimEndForArrowheadAtTarget(t){let e=C.distanceEpsilon*C.distanceEpsilon,i=t.curve.parEnd;if(t.targetArrowhead==null||t.targetArrowhead.length<=C.distanceEpsilon)return i;let n=t.curve,o=t.targetArrowhead.length,s,a,u=10;do{if(u--,u===0)return;a=Sr.getIntersectionsWithArrowheadCircle(n,o,n.end),i=a.length!==0?Math.max(...a.map(h=>h.par1)):n.parEnd,s=t.curve.value(i),o/=2}while(s.sub(n.start).lengthSquared<e||a.length===0);return i}static findTrimStartForArrowheadAtSource(t){if(t.sourceArrowhead==null||t.sourceArrowhead.length<=C.distanceEpsilon)return t.curve.parStart;let e=C.distanceEpsilon*C.distanceEpsilon,i=t.sourceArrowhead.length,n,o=t.curve,s,a=10,u;for(;--a>0;){if(s=Sr.getIntersectionsWithArrowheadCircle(o,i,o.start),s.length===0)return o.parStart;if(u=Math.min(...s.map(h=>h.par1)),n=s.filter(h=>h.par1===u)[0].x,n.sub(o.end).lengthSquared>=e)return u;i/=2}}static trimSplineAndCalculateArrowheads(t,e,i){return Sr.trimSplineAndCalculateArrowheadsII(t,t.source.boundaryCurve,t.target.boundaryCurve,e,i)}static trimSplineAndCalculateArrowheadsII(t,e,i,n,o){if(t.curve=E.trimEdgeSplineWithNodeBoundaries(e,i,n,o),t.curve==null)return!1;if((t.sourceArrowhead==null||t.sourceArrowhead.length<C.distanceEpsilon)&&(t.targetArrowhead==null||t.targetArrowhead.length<C.distanceEpsilon))return!0;let s=!1,a=t.sourceArrowhead!=null?t.sourceArrowhead.length:0,u=t.targetArrowhead!=null?t.targetArrowhead.length:0,h=t.curve.end.sub(t.curve.start).length;t.sourceArrowhead!=null&&(t.sourceArrowhead.length=Math.min(h,a)),t.targetArrowhead!=null&&(t.targetArrowhead.length=Math.min(h,u));let c=10;for(;(t.sourceArrowhead!=null&&t.sourceArrowhead.length>C.intersectionEpsilon||t.targetArrowhead!=null&&t.targetArrowhead.length>C.intersectionEpsilon)&&!s&&(s=Sr.calculateArrowheads(t),s||(t.sourceArrowhead!=null&&(t.sourceArrowhead.length*=.5),t.targetArrowhead!=null&&(t.targetArrowhead.length*=.5)),c--,c!==0););return s||(t.sourceArrowhead!=null&&(t.sourceArrowhead.tipPosition=n.start),t.targetArrowhead!=null&&(t.targetArrowhead.tipPosition=n.end)),t.sourceArrowhead!=null&&(t.sourceArrowhead.length=a),t.targetArrowhead!=null&&(t.targetArrowhead.length=u),s}static createBigEnoughSpline(t){let e=t.source.center,i=t.target.center,n=i.sub(e),o=n.length,s;o<.001?(s=new d(1,0),i=e.add(s.rotate(Math.PI/2))):s=n.rotate(Math.PI/2);let a=1;t.sourceArrowhead!=null&&(a+=t.sourceArrowhead.length),t.targetArrowhead!=null&&(a+=t.targetArrowhead.length),s=s.normalize().mul(1.5*a);for(let u=1;u<1e4;u=u*2){let h=E.createBezierSegN(e,i,s,u);if(Sr.trimSplineAndCalculateArrowheadsII(t,t.source.boundaryCurve,t.target.boundaryCurve,h,!1))return}Sr.createEdgeCurveWithNoTrimming(t,e,i)}static createEdgeCurveWithNoTrimming(t,e,i){let n=i.sub(e).normalize(),o=e,s=i,a=t.targetArrowhead;a!=null&&(a.tipPosition=i,s=i.sub(n.mul(a.length)));let u=t.sourceArrowhead;u!=null&&(u.tipPosition=e,o=e.add(n.mul(u.length))),t.curve=w.mkPP(o,s)}},We=Sr;We.defaultArrowheadLength=5;var It=class{static GetShapes(t,e=Array.from(t.shallowEdges)){let i=new Map;Kc(t,i);for(let n of e){let o=i.get(n.source);o&&n.sourcePort!=null&&o.Ports.add(n.sourcePort),o=i.get(n.target),o&&n.targetPort!=null&&o.Ports.add(n.targetPort)}return Array.from(i.values())}static CreateShapeWithCenterPort(t){let e=new pn(t),i=Rt.mk(()=>t.boundaryCurve,()=>t.center);e.Ports.add(i);for(let n of t.inEdges())It.FixPortAtTarget(i,n);for(let n of t.outEdges())It.FixPortAtSource(i,n);for(let n of t.selfEdges())It.FixPortAtSource(i,n),It.FixPortAtTarget(i,n);return e}static CreateShapeWithClusterBoundaryPort(t){let e=new pn(t),i=St.mk(()=>t.boundaryCurve,()=>t.center);e.Ports.add(i);let n;for(let o of t.inEdges())o.EdgeToAncestor()===2?(n==null&&(n=new Ze(()=>t.boundaryCurve)),o.targetPort=n):It.FixPortAtTarget(i,o);for(let o of t.outEdges())o.EdgeToAncestor()===1?(n==null&&(n=new Ze(()=>t.boundaryCurve)),o.sourcePort=n):It.FixPortAtSource(i,o);for(let o of t.selfEdges())It.FixPortAtSource(i,o),It.FixPortAtTarget(i,o);return e}static FixPortAtSource(t,e){e!=null&&e.sourcePort==null&&(e.sourcePort=t)}static FixPortAtTarget(t,e){e!=null&&e.targetPort==null&&(e.targetPort=t)}};function Kc(l,t){for(let e of l.shallowNodes)if(e instanceof ne){let i=It.CreateShapeWithClusterBoundaryPort(e);t.set(e,i);let n=e;if(!n.isCollapsed){Kc(n,t);for(let o of n.shallowNodes)i.AddChild(t.get(o))}}else t.set(e,It.CreateShapeWithCenterPort(e))}var Yc=he(Gr(),1);var $u=class{constructor(t,e){this.v=t,this.i=e}},cr=class{static getFeedbackSetWithConstraints(t,e){throw new Error("Method not implemented.")}static push(t,e,i,n){e[i]=1,t.push(new $u(i,n))}static getFeedbackSet(t){let e=new ar(t.nodeCount);if(t==null||t.nodeCount===0)return[];let i=new Array(t.nodeCount).fill(0);for(let n=0;n<t.nodeCount;n++){if(i[n]===2)continue;let o=new Yc.Stack,s=0;for(cr.push(o,i,n,s);o.size>0;){let a=o.pop();n=a.v,i[n]=2,s=a.i;let u=t.outEdges[n];for(;s<u.length;s++){let h=u[s];if(h.source===h.target)continue;let c=i[h.target];c===1?e.set(h.source,h.target,h):c===0&&(cr.push(o,i,n,s+1),n=h.target,i[h.target]=2,u=t.outEdges[n],s=-1)}}}return Array.from(e.values())}};var Cr=class{constructor(){this.isEmpty=!0}AddValue(t){this.isEmpty?(this.max=t,this.min=t,this.isEmpty=!1):t<this.min?this.min=t:t>this.max&&(this.max=t)}get length(){return this.max-this.min}static sign(t){return t>C.distanceEpsilon?1:t<-C.distanceEpsilon?-1:0}};var Ku=he(Gr(),1),ed=he(gt(),1);var Zc=he(gt(),1);var zi=class{SetActiveState(t,e){this.IsActive=t,this.VectorIndex=e,this.IsActive?(this.Left.ActiveConstraintCount++,this.Right.ActiveConstraintCount++):(this.Left.ActiveConstraintCount--,this.Right.ActiveConstraintCount--)}SetVectorIndex(t){this.VectorIndex=t}Reinitialize(){this.IsActive=!1,this.IsUnsatisfiable=!1,this.ClearDfDv()}UpdateGap(t){this.Gap=t}static constructorVVNB(t,e,i,n){let o=new zi(t);return o.Left=t,o.Right=e,o.Gap=i,o.IsEquality=n,o.Lagrangian=0,o.IsActive=!1,o}constructor(t){this.Right=t,this.Left=t}ToString(){return Zc.String.Format("  Cst: [{0}] [{1}] {2} {3:F5} vio {4:F5} Lm {5:F5}/{6:F5} {7}actv",this.Left,this.Right,this.IsEquality?"==":">=",this.Gap,this.Violation,this.Lagrangian,this.Lagrangian*2,this.IsActive?"+":this.IsUnsatisfiable?"!":"-")}get Violation(){return this.Left.ActualPos*this.Left.Scale+(this.Gap-this.Right.ActualPos*this.Right.Scale)}ClearDfDv(){this.Lagrangian=0}CompareTo(t){let e=this.Left.CompareTo(t.Left);return e===0&&(e=this.Right.CompareTo(t.Right)),e===0&&(e=ce(this.Gap,t.Gap)),e}};var _c=he(gt(),1),En=class{static constructorDCVV(t,e,i,n){let o=new En(e);return o.Set(t,e,i,n),o}constructor(t){this.ConstraintToEval=t,this.Depth=-1}Set(t,e,i,n){return this.Parent=t,this.ConstraintToEval=e,this.VariableToEval=i,this.VariableDoneEval=n,this.Depth=0,this.ChildrenHaveBeenPushed=!1,e.Lagrangian=0,this}get IsLeftToRight(){return this.VariableToEval===this.ConstraintToEval.Right}toString(){return _c.String.Format("{0} {1}{2} - {3}{4} ({5})","",this.IsLeftToRight?"":"*",this.ConstraintToEval.Left.Name,this.IsLeftToRight?"*":"",this.ConstraintToEval.Right.Name,this.Depth)}};var Yu=class{constructor(t,e){this.Constraint=t,this.IsForward=e}},no=class{constructor(t,e){this.Variables=new Array,t!=null&&this.AddVariable(t),this.allConstraints=e}toString(){return ed.String.Format("[Block: nvars = {0} refpos = {1:F5} scale = {2:F5}]",this.Variables.length,this.ReferencePos,this.Scale)}ComputeDfDv(t){this.allConstraints.DfDvStack=new Ku.Stack;let e=new zi(t);this.dfDvDummyParentNode=new En(e);let i=this.GetDfDvNode(this.dfDvDummyParentNode,e,t,null);for(this.allConstraints.DfDvStack.push(i);;){let n=this.allConstraints.DfDvStack.top,o=this.allConstraints.DfDvStack.length;if(!n.ChildrenHaveBeenPushed){n.ChildrenHaveBeenPushed=!0;for(let s of n.VariableToEval.LeftConstraints)if(s.IsActive&&s.Right!==n.VariableDoneEval){let a=this.GetDfDvNode(n,s,s.Right,n.VariableToEval);s.Right.ActiveConstraintCount===1?this.ProcessDfDvLeafNodeDirectly(a):this.PushDfDvNode(a)}for(let s of n.VariableToEval.RightConstraints)if(s.IsActive&&s.Left!==n.VariableDoneEval){let a=this.GetDfDvNode(n,s,s.Left,n.VariableToEval);s.Left.ActiveConstraintCount===1?this.ProcessDfDvLeafNodeDirectly(a):this.PushDfDvNode(a)}if(this.allConstraints.DfDvStack.length>o)continue}if(this.allConstraints.DfDvStack.pop(),this.ProcessDfDvLeafNode(n),n===i)break}}ProcessDfDvLeafNode(t){let e=t.VariableToEval.DfDv;t.IsLeftToRight?(t.ConstraintToEval.Lagrangian=t.ConstraintToEval.Lagrangian+e,t.Parent.ConstraintToEval.Lagrangian=t.Parent.ConstraintToEval.Lagrangian+t.ConstraintToEval.Lagrangian):(t.ConstraintToEval.Lagrangian=(t.ConstraintToEval.Lagrangian+e)*-1,t.Parent.ConstraintToEval.Lagrangian=t.Parent.ConstraintToEval.Lagrangian-t.ConstraintToEval.Lagrangian),this.CheckForConstraintPathTarget(t),this.Debug_CheckForViolatedActiveConstraint(t.ConstraintToEval),this.allConstraints.RecycleDfDvNode(t)}Debug_CheckForViolatedActiveConstraint(t){t.Violation>this.allConstraints.SolverParameters.GapTolerance}ProcessDfDvLeafNodeDirectly(t){this.ProcessDfDvLeafNode(t)}GetDfDvNode(t,e,i,n){let o=this.allConstraints.DfDvRecycleStack.size>0?this.allConstraints.DfDvRecycleStack.pop().Set(t,e,i,n):En.constructorDCVV(t,e,i,n);return o.Depth=o.Parent.Depth+1,this.allConstraints.MaxConstraintTreeDepth<o.Depth&&(this.allConstraints.MaxConstraintTreeDepth=o.Depth),o}PushDfDvNode(t){this.PushOnDfDvStack(t)}AddVariableAndPushDfDvNode(t,e){t.push(e.VariableToEval),this.PushOnDfDvStack(e)}PushOnDfDvStack(t){this.allConstraints.DfDvStack.push(t)}CheckForConstraintPathTarget(t){if(this.pathTargetVariable===t.VariableToEval){for(;t.Parent!==this.dfDvDummyParentNode;)this.constraintPath.push(new Yu(t.ConstraintToEval,t.IsLeftToRight)),t=t.Parent;this.pathTargetVariable=null}}Expand(t){this.constraintPath==null&&(this.constraintPath=new Array),this.constraintPath=[],this.pathTargetVariable=t.Right,this.ComputeDfDv(t.Left);let e=null;if(this.constraintPath.length>0){for(let s of this.constraintPath)s.IsForward&&(e==null||s.Constraint.Lagrangian<e.Lagrangian)&&(s.Constraint.IsEquality||(e=s.Constraint));e!=null&&this.allConstraints.DeactivateConstraint(e)}if(this.constraintPath=[],this.pathTargetVariable=null,e==null){t.IsUnsatisfiable=!0,this.allConstraints.NumberOfUnsatisfiableConstraints++;return}let i=new Array;this.GetConnectedVariables(i,t.Right,t.Left);let n=t.Violation,o=i.length;for(let s=0;s<o;s++)i[s].OffsetInBlock=i[s].OffsetInBlock+n;this.allConstraints.ActivateConstraint(t),t.ClearDfDv(),this.UpdateReferencePos()}Split(t){if(t&&this.UpdateReferencePos(),this.Variables.length<2)return null;let e=null;this.ComputeDfDv(this.Variables[0]);let i=this.allConstraints.SolverParameters.Advanced.MinSplitLagrangianThreshold,n=this.Variables.length;for(let o=0;o<n;o++)for(let s of this.Variables[o].LeftConstraints)s.IsActive&&!s.IsEquality&&s.Lagrangian<i&&(e=s,i=s.Lagrangian);return e==null?null:this.SplitOnConstraint(e)}SplitOnConstraint(t){this.allConstraints.DeactivateConstraint(t);let e=new no(null,this.allConstraints);return this.TransferConnectedVariables(e,t.Right,t.Left),e.Variables.length>0?(this.UpdateReferencePos(),e.UpdateReferencePos()):e=null,e}AddVariable(t){this.Variables.push(t),t.Block=this,this.Variables.length===1?(this.Scale=t.Scale,this.ReferencePos=t.ActualPos,this.sumAd=t.ActualPos*t.Weight,this.sumAb=0,this.sumA2=t.Weight,t.OffsetInBlock=0):this.AddVariableToBlockSums(t)}UpdateReferencePos(){this.Scale=this.Variables[0].Scale,this.sumAd=0,this.sumAb=0,this.sumA2=0;let t=this.Variables.length;for(let e=0;e<t;e++)this.AddVariableToBlockSums(this.Variables[e]);this.UpdateReferencePosFromSums()}AddVariableToBlockSums(t){let e=this.Scale/t.Scale,i=t.OffsetInBlock/t.Scale,n=e*t.Weight;this.sumAd+=n*t.DesiredPos,this.sumAb+=n*i,this.sumA2+=n*e}UpdateReferencePosFromSums(){if(!(Number.isFinite(this.sumAd)&&Number.isFinite(this.sumAb)&&Number.isFinite(this.sumA2)))throw new Error("infinite numbers");this.ReferencePos=(this.sumAd-this.sumAb)/this.sumA2,this.UpdateVariablePositions()}UpdateVariablePositions(){let t=this.Scale*this.ReferencePos,e=this.Variables.length;for(let i=0;i<e;i++){let n=this.Variables[i];n.ActualPos=(t+n.OffsetInBlock)/n.Scale}}GetConnectedVariables(t,e,i){this.RecurseGetConnectedVariables(t,e,i)}RecurseGetConnectedVariables(t,e,i){this.allConstraints.DfDvStack=new Ku.Stack;let n=new zi(e);for(this.dfDvDummyParentNode=new En(n),this.allConstraints.DfDvStack.push(this.GetDfDvNode(this.dfDvDummyParentNode,n,e,i)),t.push(e);this.allConstraints.DfDvStack.length>0;){let o=this.allConstraints.DfDvStack.top,s=this.allConstraints.DfDvStack.length;if(!o.ChildrenHaveBeenPushed){o.ChildrenHaveBeenPushed=!0;for(let a of o.VariableToEval.LeftConstraints)a.IsActive&&a.Right!==o.VariableDoneEval&&(a.Right.ActiveConstraintCount===1?t.push(a.Right):this.AddVariableAndPushDfDvNode(t,this.GetDfDvNode(o,a,a.Right,o.VariableToEval)));for(let a of o.VariableToEval.RightConstraints)a.IsActive&&a.Left!==o.VariableDoneEval&&(a.Left.ActiveConstraintCount===1?t.push(a.Left):this.AddVariableAndPushDfDvNode(t,this.GetDfDvNode(o,a,a.Left,o.VariableToEval)))}this.allConstraints.DfDvStack.length>s||this.allConstraints.RecycleDfDvNode(this.allConstraints.DfDvStack.pop())}}TransferConnectedVariables(t,e,i){this.GetConnectedVariables(t.Variables,e,i);let n=t.Variables.length;for(let s=0;s<n;s++)t.Variables[s].Block=t;let o=this.Variables.length-1;for(let s=this.Variables.length-1;s>=0;s--)this.Variables[s].Block===t&&(s<o&&(this.Variables[s]=this.Variables[o]),o--);if(this.Variables=this.Variables.slice(0,o+1),this.Variables.length===0){for(let s=0;s<n;s++){let a=t.Variables[s];this.Variables.push(a),a.Block=this}t.Variables=[]}}};var $a=class{get Count(){return this.Vector.length}item(t){return this.Vector[t]}constructor(){this.Vector=new Array}Add(t){t.VectorIndex=this.Vector.length,this.Vector.push(t)}Remove(t){let e=this.Vector[this.Vector.length-1];this.Vector[t.VectorIndex]=e,e.VectorIndex=t.VectorIndex,this.Vector.pop()}toString(){return this.Vector.toString()}};var Zu=he(Gr(),1),Ka=class{constructor(){this.nextConstraintIndex=0;this.DfDvStack=new Zu.Stack;this.DfDvRecycleStack=new Zu.Stack}get IsEmpty(){return this.Vector==null}Create(t){this.Vector=new Array(t),this.firstActiveConstraintIndex=t}Add(t){t.SetVectorIndex(this.nextConstraintIndex),this.Vector[this.nextConstraintIndex++]=t}ActivateConstraint(t){this.firstActiveConstraintIndex--,this.SwapConstraint(t)}DeactivateConstraint(t){this.SwapConstraint(t),this.firstActiveConstraintIndex++}SwapConstraint(t){let e=this.Vector[this.firstActiveConstraintIndex];e.SetVectorIndex(t.VectorIndex),this.Vector[t.VectorIndex]=e,this.Vector[this.firstActiveConstraintIndex]=t,t.SetActiveState(!t.IsActive,this.firstActiveConstraintIndex)}Reinitialize(){if(this.Vector!=null){for(let t of this.Vector)t.Reinitialize();this.firstActiveConstraintIndex=this.Vector.length}}RecycleDfDvNode(t){this.DfDvRecycleStack.length<1024&&this.DfDvRecycleStack.push(t)}toString(){return this.Vector.toString()}};var $o=class{constructor(){this.GapTolerance=1e-4,this.QpscConvergenceEpsilon=1e-5,this.QpscConvergenceQuotient=1e-6,this.OuterProjectIterationsLimit=-1,this.InnerProjectIterationsLimit=-1,this.TimeLimit=-1,this.Advanced=new Ns}Clone(){let t=this.MemberwiseClone();return t.Advanced=this.Advanced.Clone(),t}MemberwiseClone(){let t=new $o;return t.GapTolerance=this.GapTolerance,t.QpscConvergenceEpsilon=this.QpscConvergenceEpsilon,t.QpscConvergenceQuotient=this.QpscConvergenceQuotient,t.OuterProjectIterationsLimit=this.OuterProjectIterationsLimit,t.InnerProjectIterationsLimit=this.InnerProjectIterationsLimit,t.TimeLimit=this.TimeLimit,t}},Ns=class{constructor(){this.ForceQpsc=!1,this.ScaleInQpsc=!0,this.MinSplitLagrangianThreshold=-1e-7,this.UseViolationCache=!0,this.ViolationCacheMinBlocksDivisor=10,this.ViolationCacheMinBlocksCount=100}Clone(){let t=new Ns;return t.ForceQpsc=this.ForceQpsc,t.ScaleInQpsc=this.ScaleInQpsc,t.MinSplitLagrangianThreshold=this.MinSplitLagrangianThreshold,t.UseViolationCache=this.UseViolationCache,t.ViolationCacheMinBlocksDivisor=this.ViolationCacheMinBlocksDivisor,t.ViolationCacheMinBlocksCount=this.ViolationCacheMinBlocksCount,t}};var _u=class{constructor(t){this.Variable=t,this.OrigWeight=t.Weight,this.OrigScale=t.Scale,this.OrigDesiredPos=this.Variable.DesiredPos}},eh=class{constructor(t,e){this.Value=t,this.Column=e}},qt=class{constructor(t,e){this.newMatrixRow=new Array;this.previousFunctionValue=Number.MAX_VALUE;this.solverParameters=t,this.matrixQ=new Array(e).fill(0),this.vectorWiDi=new Array(e).fill(0),this.vectorQpscVars=new Array(e).fill(0),this.gradientVector=new Array(e).fill(0),this.vectorQg=new Array(e).fill(0),this.vectorPrevY=new Array(e).fill(0),this.vectorCurY=new Array(e).fill(0)}AddVariable(t){if(this.isFirstProjectCall=!0,this.vectorWiDi[t.Ordinal]=2*(t.Weight*t.DesiredPos)*-1,this.vectorPrevY[t.Ordinal]=t.Weight,t.Neighbors!=null)for(let e of t.Neighbors)this.vectorPrevY[t.Ordinal]=this.vectorPrevY[t.Ordinal]+e.Weight,this.vectorPrevY[e.Neighbor.Ordinal]=this.vectorPrevY[e.Neighbor.Ordinal]-e.Weight;for(let e=0;e<this.vectorPrevY.length;e++)this.vectorPrevY[e]!==0&&(this.newMatrixRow.push(new eh(this.vectorPrevY[e]*2,e)),this.vectorPrevY[e]=0);this.matrixQ[t.Ordinal]=Array.from(this.newMatrixRow),this.newMatrixRow=[],this.vectorQpscVars[t.Ordinal]=new _u(t),t.Weight=1}VariablesComplete(){for(let t of this.vectorQpscVars){let e=t.Variable;for(let i of this.matrixQ[e.Ordinal])i.Column===e.Ordinal&&(this.solverParameters.Advanced.ScaleInQpsc&&(e.Scale=1/Math.sqrt(Math.abs(i.Value)),Number.isFinite(e.Scale)||(e.Scale=1),e.Scale,this.vectorWiDi[e.Ordinal]=this.vectorWiDi[e.Ordinal]*e.Scale),this.vectorCurY[e.Ordinal]=e.ActualPos,e.DesiredPos=e.ActualPos)}if(!!this.solverParameters.Advanced.ScaleInQpsc)for(let t=0;t<this.matrixQ.length;t++){let e=this.matrixQ[t];for(let i=0;i<e.length;i++)e[i].Column===t?e[i].Value=1:e[i].Value=e[i].Value*(this.vectorQpscVars[t].Variable.Scale*this.vectorQpscVars[e[i].Column].Variable.Scale)}}PreProject(){if(this.isFirstProjectCall)for(let n of this.vectorQpscVars)this.vectorCurY[n.Variable.Ordinal]=n.Variable.ActualPos;if(this.MatrixVectorMultiply(this.vectorCurY,this.gradientVector),this.HasConverged())return!1;qt.VectorVectorAdd(this.gradientVector,this.vectorWiDi,this.gradientVector);let t=qt.VectorVectorMultiply(this.gradientVector,this.gradientVector),e=0;if(t!==0&&(this.MatrixVectorMultiply(this.gradientVector,this.vectorQg),e=qt.VectorVectorMultiply(this.vectorQg,this.gradientVector)),e===0)return!1;let i=t/e;qt.VectorCopy(this.vectorPrevY,this.vectorCurY),qt.VectorScaledVectorSubtract(this.vectorPrevY,i,this.gradientVector,this.vectorCurY);for(let n=0;n<this.vectorCurY.length;n++)this.vectorQpscVars[n].Variable.DesiredPos=this.vectorCurY[n];return!0}PostProject(){for(let i of this.vectorQpscVars)this.vectorCurY[i.Variable.Ordinal]=i.Variable.ActualPos;qt.VectorVectorSubtract(this.vectorPrevY,this.vectorCurY,this.vectorCurY);let t=qt.VectorVectorMultiply(this.gradientVector,this.vectorCurY),e=0;if(t!==0){this.MatrixVectorMultiply(this.vectorCurY,this.vectorQg);let i=qt.VectorVectorMultiply(this.vectorQg,this.vectorCurY);e=i===0?1:t/i,e>1?e=1:e<0&&(e=0)}return qt.VectorScaledVectorSubtract(this.vectorPrevY,e,this.vectorCurY,this.vectorCurY),this.isFirstProjectCall=!1,e>0}QpscComplete(){for(let t of this.vectorQpscVars)t.Variable.Weight=t.OrigWeight,t.Variable.DesiredPos=t.OrigDesiredPos,this.solverParameters.Advanced.ScaleInQpsc&&(t.Variable.ActualPos=t.Variable.ActualPos*t.Variable.Scale,t.Variable.Scale=t.OrigScale);return this.previousFunctionValue}HasConverged(){let t=this.GetFunctionValue(this.vectorCurY),e=!1;if(!this.isFirstProjectCall){let i=this.previousFunctionValue-t,n=0;if(i!==0){let o=this.previousFunctionValue!==0?this.previousFunctionValue:t;n=Math.abs(i/o)}(Math.abs(i)<this.solverParameters.QpscConvergenceEpsilon||Math.abs(n)<this.solverParameters.QpscConvergenceQuotient)&&(e=!0)}return this.previousFunctionValue=t,e}GetFunctionValue(t){return qt.VectorVectorMultiply(this.gradientVector,t)/2+qt.VectorVectorMultiply(this.vectorWiDi,t)}static VectorVectorMultiply(t,e){let i=0;for(let n=0;n<t.length;n++)i=i+t[n]*e[n];return i}MatrixVectorMultiply(t,e){let i=0;for(let n of this.matrixQ){let o=0;for(let s of n)o=o+s.Value*t[s.Column];e[i++]=o}}static VectorVectorAdd(t,e,i){for(let n=0;n<t.length;n++)i[n]=t[n]+e[n]}static VectorVectorSubtract(t,e,i){for(let n=0;n<t.length;n++)i[n]=t[n]-e[n]}static VectorScaledVectorSubtract(t,e,i,n){for(let o=0;o<t.length;o++)n[o]=t[o]-e*i[o]}static VectorCopy(t,e){for(let i=0;i<e.length;i++)t[i]=e[i]}};var oo=class{constructor(){this.NumberOfUnsatisfiableConstraints=0;this.OuterProjectIterations=0;this.InnerProjectIterationsTotal=0;this.MinInnerProjectIterations=0;this.MaxInnerProjectIterations=0;this.MaxConstraintTreeDepth=0;this.GoalFunctionValue=0;this.TimeLimitExceeded=!1;this.OuterProjectIterationsLimitExceeded=!1;this.InnerProjectIterationsLimitExceeded=!1}get ExecutionLimitExceeded(){return this.TimeLimitExceeded||this.OuterProjectIterationsLimitExceeded||this.InnerProjectIterationsLimitExceeded}Clone(){let t=new oo;return t.GoalFunctionValue=this.GoalFunctionValue,t.InnerProjectIterationsLimitExceeded=this.InnerProjectIterationsLimitExceeded,t.InnerProjectIterationsTotal=this.InnerProjectIterationsTotal,t.MaxConstraintTreeDepth=this.MaxConstraintTreeDepth,t.OuterProjectIterations=this.OuterProjectIterations,t.OuterProjectIterationsLimitExceeded=this.OuterProjectIterationsLimitExceeded,t.AlgorithmUsed=this.AlgorithmUsed,t.NumberOfUnsatisfiableConstraints=this.NumberOfUnsatisfiableConstraints,t.MaxInnerProjectIterations=this.MaxInnerProjectIterations,t}};var td=he(gt(),1);var th=class{constructor(t,e){this.Neighbor=t,this.Weight=e}},Ya=class{constructor(t,e,i,n,o){this.ActiveConstraintCount=0;if(n<=0)throw new Error("weight");if(o<=0)throw new Error("scale");let s=i*n;if(!Number.isFinite(s)||Number.isNaN(s))throw new Error("desiredPos");if(s=i*o,!Number.isFinite(s)||Number.isNaN(s))throw new Error("desiredPos");this.Ordinal=t,this.UserData=e,this.DesiredPos=i,this.Weight=n,this.Scale=o,this.OffsetInBlock=0,this.ActualPos=this.DesiredPos}get DfDv(){return 2*(this.Weight*(this.ActualPos-this.DesiredPos))/this.Scale}Reinitialize(){this.ActiveConstraintCount=0,this.OffsetInBlock=0,this.ActualPos=this.DesiredPos}AddNeighbor(t,e){this.Neighbors==null&&(this.Neighbors=new Array),this.Neighbors.push(new th(t,e))}toString(){return td.String.Format("{0} {1:F5} ({2:F5}) {3:F5} {4:F5}",this.Name,this.ActualPos,this.DesiredPos,this.Weight,this.Scale)}get Name(){return this.UserData==null?"-0-":this.UserData.toString()}SetConstraints(t,e){this.LeftConstraints=t,this.RightConstraints=e}CompareTo(t){return ce(this.Ordinal,t.Ordinal)}};var Za=class{get IsFull(){return this.numConstraints===Za.MaxConstraints}Clear(){this.LowViolation=0,this.numConstraints=0,this.constraints||(this.constraints=new Array(Za.MaxConstraints))}FilterBlock(t){this.LowViolation=Number.MAX_VALUE;let e=this.numConstraints>0;for(let i=this.numConstraints-1;i>=0;i--){let n=this.constraints[i];if(n.Left.Block===t||n.Right.Block===t||n.IsActive||n.IsUnsatisfiable)i<this.numConstraints-1&&(this.constraints[i]=this.constraints[this.numConstraints-1]),this.numConstraints--;else{let o=n.Left.ActualPos*n.Left.Scale+(n.Gap-n.Right.ActualPos*n.Right.Scale);o<this.LowViolation&&(this.LowViolation=o)}}return this.numConstraints===0&&(this.LowViolation=0),e}FindIfGreater(t){let e=null;for(let i=0;i<this.numConstraints;i++){let n=this.constraints[i],o=n.Left.ActualPos*n.Left.Scale+(n.Gap-n.Right.ActualPos*n.Right.Scale);o>t&&(t=o,e=n)}return e}Insert(t,e){let i=0,n=e,o=e;for(let s=0;s<this.numConstraints;s++){let a=this.constraints[s],u=a.Left.ActualPos*a.Left.Scale+(a.Gap-a.Right.ActualPos*a.Right.Scale);u<n?(o=n,i=s,n=u):u<o&&(o=u)}this.IsFull?(this.constraints[i]=t,this.LowViolation=o):(this.constraints[this.numConstraints++]=t,this.IsFull&&(this.LowViolation=n))}},Ds=Za;Ds.MaxConstraints=20;var _a=class{constructor(t,e){this.NumberOfLeftConstraints=0;this.Constraints=t,this.NumberOfLeftConstraints=e}},el=class{constructor(){this.allBlocks=new $a;this.allConstraints=new Ka;this.numberOfConstraints=0;this.numberOfVariables=0;this.equalityConstraints=new Array;this.loadedVariablesAndConstraintLists=new Map;this.emptyConstraintList=new Array(0);this.updatedConstraints=new Array;this.violationCache=new Ds;this.violationCacheMinBlockCutoff=0;this.nextVariableOrdinal=0;this.solverParams=new $o;this.solverSolution=new oo}get IsQpsc(){return this.hasNeighbourPairs||this.solverParams.Advanced.ForceQpsc}AddVariableAN(t,e){return this.AddVariableANNN(t,e,1,1)}AddVariableANN(t,e,i){return this.AddVariableANNN(t,e,i,1)}AddVariableANNN(t,e,i,n){if(!this.allConstraints.IsEmpty)throw new Error("Cannot add Variables or Constraints once Solve() has been called");let o=new Ya(this.nextVariableOrdinal++,t,e,i,n),s=new no(o,this.allConstraints);return o.Block=s,this.allBlocks.Add(s),this.numberOfVariables++,this.loadedVariablesAndConstraintLists.set(o,new _a(new Array,0)),o}UpdateVariables(){for(let t of this.allBlocks.Vector)t.UpdateReferencePos()}get Variables(){return gi(this.allBlocks.Vector,t=>t.Variables)}get VariableCount(){return this.numberOfVariables}*Constraints(){if(this.allConstraints.IsEmpty)for(let t of this.loadedVariablesAndConstraintLists.keys()){let e=this.loadedVariablesAndConstraintLists.get(t);if(e.Constraints!=null){let i=e.Constraints.length;for(let n=0;n<i;n++){let o=e.Constraints[n];if(t===o.Left)return yield,o}}}else for(let t of this.allConstraints.Vector)yield t}get ConstraintCount(){return this.numberOfConstraints}AddEqualityConstraint(t,e,i){return this.AddConstraintVVNB(t,e,i,!0)}AddConstraintVVNB(t,e,i,n){if(!this.allConstraints.IsEmpty)throw new Error("Cannot add Variables or Constraints once Solve() has been called");if(t===e)throw new Error("Cannot add a constraint between a variable and itself");let o=this.loadedVariablesAndConstraintLists.get(t),s=this.loadedVariablesAndConstraintLists.get(e),a=zi.constructorVVNB(t,e,i,n);return this.loadedVariablesAndConstraintLists.set(t,new _a(o.Constraints,o.NumberOfLeftConstraints+1)),o.Constraints.push(a),s.Constraints.push(a),this.numberOfConstraints++,n&&this.equalityConstraints.push(a),a}AddConstraint(t,e,i){return this.AddConstraintVVNB(t,e,i,!1)}SetConstraintUpdate(t,e){e!==t.Gap&&this.updatedConstraints.push([t,e])}AddNeighborPair(t,e,i){if(i<=0||Number.isNaN(i)||!Number.isFinite(i))throw new Error("relationshipWeight");if(t===e)throw new Error;t.AddNeighbor(e,i),e.AddNeighbor(t,i),this.hasNeighbourPairs=!0}Solve(){return this.SolvePar(null)}SolvePar(t){t&&(this.solverParams=t.Clone()),this.solverParams.OuterProjectIterationsLimit<0&&(this.solverParams.OuterProjectIterationsLimit=100*(Math.floor(Math.log2(this.numberOfVariables))+1)),this.solverParams.InnerProjectIterationsLimit<0&&(this.solverParams.InnerProjectIterationsLimit=this.numberOfConstraints*2+100*(Math.max(0,Math.floor(Math.log2(this.numberOfConstraints)))+1));let e=!this.allConstraints.IsEmpty;if(this.CheckForUpdatedConstraints(),this.solverSolution=new oo,this.solverSolution.MinInnerProjectIterations=Number.MAX_VALUE,this.allConstraints.MaxConstraintTreeDepth=0,this.allConstraints.SolverParameters=this.solverParams,this.numberOfConstraints===0){if(!this.IsQpsc)return this.solverSolution.Clone()}else e||this.SetupConstraints();return this.allConstraints.NumberOfUnsatisfiableConstraints=0,this.MergeEqualityConstraints(),this.IsQpsc?this.SolveQpsc():(this.SolveByStandaloneProject(),this.CalculateStandaloneProjectGoalFunctionValue()),this.solverSolution.MinInnerProjectIterations>this.solverSolution.MaxInnerProjectIterations&&(this.solverSolution.MinInnerProjectIterations=this.solverSolution.MaxInnerProjectIterations),this.solverSolution.NumberOfUnsatisfiableConstraints=this.allConstraints.NumberOfUnsatisfiableConstraints,this.solverSolution.MaxConstraintTreeDepth=this.allConstraints.MaxConstraintTreeDepth,this.solverSolution.Clone()}CheckForUpdatedConstraints(){if(this.updatedConstraints.length===0)return;let t=this.IsQpsc;for(let[e,i]of this.updatedConstraints){let n=e;if(n.UpdateGap(i),!t&&!n.IsEquality){this.SplitOnConstraintIfActive(n);continue}t=!0}this.updatedConstraints=[],t&&this.ReinitializeBlocks()}SplitOnConstraintIfActive(t){if(t.IsActive){let e=t.Left.Block.SplitOnConstraint(t);e!=null&&this.allBlocks.Add(e)}}SetupConstraints(){this.allConstraints.Create(this.numberOfConstraints);for(let t of this.loadedVariablesAndConstraintLists.keys()){let e=this.loadedVariablesAndConstraintLists.get(t),i=e.Constraints,n=0,o=0,s=0;i!=null&&(n=i.length,o=e.NumberOfLeftConstraints,s=n-o);let a=this.emptyConstraintList;o!==0&&(a=new Array(o));let u=this.emptyConstraintList;s!==0&&(u=new Array(s)),t.SetConstraints(a,u);let h=0,c=0;for(let f=0;f<n;f++){let P=i[f];t===P.Left?a[h++]=P:u[c++]=P}for(let f of t.LeftConstraints)this.allConstraints.Add(f)}this.loadedVariablesAndConstraintLists.clear(),this.violationCacheMinBlockCutoff=Number.MAX_VALUE,this.solverParams.Advanced.UseViolationCache&&this.solverParams.Advanced.ViolationCacheMinBlocksDivisor>0&&(this.violationCacheMinBlockCutoff=Math.min(this.allBlocks.Count/this.solverParams.Advanced.ViolationCacheMinBlocksDivisor,this.solverParams.Advanced.ViolationCacheMinBlocksCount))}SolveByStandaloneProject(){for(;;){if(!this.RunProject())return;if(!this.SplitBlocks())break}}RunProject(){return this.solverSolution.OuterProjectIterations++,this.Project(),!this.CheckForLimitsExceeded()}CheckForLimitsExceeded(){return this.solverParams.OuterProjectIterationsLimit>0&&this.solverSolution.OuterProjectIterations>=this.solverParams.OuterProjectIterationsLimit?(this.solverSolution.OuterProjectIterationsLimitExceeded=!0,!0):!!this.solverSolution.InnerProjectIterationsLimitExceeded}CalculateStandaloneProjectGoalFunctionValue(){this.solverSolution.GoalFunctionValue=0;let t=this.allBlocks.Count;for(let e=0;e<t;e++){let i=this.allBlocks.item(e),n=i.Variables.length;for(let o=0;o<n;o++){let s=i.Variables[o];this.solverSolution.GoalFunctionValue+=s.Weight*(s.ActualPos*s.ActualPos),this.solverSolution.GoalFunctionValue-=2*(s.Weight*(s.DesiredPos*s.ActualPos))}}}SolveQpsc(){if(this.solverSolution.AlgorithmUsed=this.solverParams.Advanced.ScaleInQpsc?1:2,!this.QpscMakeFeasible())return;let t=new qt(this.solverParams,this.numberOfVariables);for(let i of this.allBlocks.Vector)for(let n of i.Variables)t.AddVariable(n);t.VariablesComplete(),this.ReinitializeBlocks(),this.MergeEqualityConstraints();let e=!1;for(;!(!t.PreProject()&&!e||(e=this.SplitBlocks(),!this.RunProject())||!t.PostProject()&&!e););this.solverSolution.GoalFunctionValue=t.QpscComplete()}QpscMakeFeasible(){return this.RunProject()}ReinitializeBlocks(){let t=Array.from(this.allBlocks.Vector);this.allBlocks.Vector=[];for(let e of t)for(let i of e.Variables){i.Reinitialize();let n=new no(i,this.allConstraints);this.allBlocks.Add(n)}this.allConstraints.Reinitialize(),this.violationCache.Clear()}MergeEqualityConstraints(){for(let t of this.equalityConstraints){if(t.Left.Block===t.Right.Block){Math.abs(t.Violation)>this.solverParams.GapTolerance&&(t.IsUnsatisfiable=!0,this.allConstraints.NumberOfUnsatisfiableConstraints++);continue}this.MergeBlocks(t)}}Project(){if(this.numberOfConstraints===0)return!1;this.violationCache.Clear(),this.lastModifiedBlock=null;let t=this.allBlocks.Count>this.violationCacheMinBlockCutoff,e=1,i={maxViolation:0},n=this.GetMaxViolatedConstraint(i,t);if(!n)return!1;for(;n;){if(n.Left.Block===n.Right.Block?(n.Left.Block.Expand(n),n.IsUnsatisfiable&&this.violationCache.Clear(),this.lastModifiedBlock=n.Left.Block):this.lastModifiedBlock=this.MergeBlocks(n),this.solverParams.InnerProjectIterationsLimit>0&&e>=this.solverParams.InnerProjectIterationsLimit){this.solverSolution.InnerProjectIterationsLimitExceeded=!0;break}t=this.allBlocks.Count>this.violationCacheMinBlockCutoff,t||this.violationCache.Clear(),e++;let o={maxViolation:0};n=this.GetMaxViolatedConstraint(o,t)}return this.solverSolution.InnerProjectIterationsTotal=this.solverSolution.InnerProjectIterationsTotal+e,this.solverSolution.MaxInnerProjectIterations<e&&(this.solverSolution.MaxInnerProjectIterations=e),this.solverSolution.MinInnerProjectIterations>e&&(this.solverSolution.MinInnerProjectIterations=e),!0}MergeBlocks(t){let e=t.Left.Block,i=t.Right.Block,n=t.Left.OffsetInBlock+(t.Gap-t.Right.OffsetInBlock);i.Variables.length>e.Variables.length&&(e=t.Right.Block,i=t.Left.Block,n=-n);let o=i.Variables.length;for(let s=0;s<o;s++){let a=i.Variables[s];a.OffsetInBlock+=n,e.AddVariable(a)}return e.UpdateReferencePosFromSums(),this.allConstraints.ActivateConstraint(t),this.allBlocks.Remove(i),e}SplitBlocks(){let t=new Array,e=this.allBlocks.Count;for(let n=0;n<e;n++){let s=this.allBlocks.item(n).Split(this.IsQpsc);s!=null&&t.push(s)}let i=t.length;for(let n=0;n<i;n++){let o=t[n];this.allBlocks.Add(o)}return t.length!==0}GetMaxViolatedConstraint(t,e){t.maxViolation=this.solverParams.GapTolerance;let i=this.SearchViolationCache(t.maxViolation);return i!=null?i:this.SearchAllConstraints(t.maxViolation,e)}SearchViolationCache(t){let e=null;if(this.lastModifiedBlock==null)return;this.lastModifiedBlock.Variables.length<this.numberOfVariables+1&&this.violationCache.FilterBlock(this.lastModifiedBlock);let i=this.lastModifiedBlock.Variables.length;for(let o=0;o<i;o++){let s=this.lastModifiedBlock.Variables[o];for(let a of s.LeftConstraints)if(!a.IsActive&&!a.IsUnsatisfiable){let u=a.Left.ActualPos*a.Left.Scale+(a.Gap-a.Right.ActualPos*a.Right.Scale);Ba(u,t)&&(e!=null&&t>this.violationCache.LowViolation&&this.violationCache.Insert(e,t),t=a.Violation,e=a)}for(let a of s.RightConstraints)if(!a.IsActive&&!a.IsUnsatisfiable&&a.Left.Block!==this.lastModifiedBlock){let u=a.Left.ActualPos*a.Left.Scale+(a.Gap-a.Right.ActualPos*a.Right.Scale);Ba(u,t)&&(e!=null&&t>this.violationCache.LowViolation&&this.violationCache.Insert(e,t),t=u,e=a)}}let n=this.violationCache.FindIfGreater(t);return n!=null&&(e!=null&&t>this.violationCache.LowViolation&&this.violationCache.Insert(e,t),e=n),e}SearchAllConstraints(t,e){let i=null;this.violationCache.Clear();for(let n of this.allConstraints.Vector){if(n.IsActive)break;if(n.IsUnsatisfiable)continue;let o=n.Left.ActualPos*n.Left.Scale+(n.Gap-n.Right.ActualPos*n.Right.Scale),s=null,a=0;Ba(o,t)&&(t>this.violationCache.LowViolation&&(s=i,a=t),t=o,i=n),e&&(s==null&&n!==i&&(!this.violationCache.IsFull||o>this.violationCache.LowViolation)&&(s=n,a=o),s!=null&&a>this.violationCache.LowViolation&&this.violationCache.Insert(s,a))}return i}};var tl=class{constructor(){this.variables=new Map;this.fixedVars=new Map;this.FailToAdjustEpsilon=.001;this.InitSolver()}AddVariableWithIdealPositionNNN(t,e,i){this.variables.set(t,this.solver.AddVariableANN(t,e,i))}AddVariableWithIdealPositionNN(t,e){this.AddVariableWithIdealPositionNNN(t,e,1)}AddLeftRightSeparationConstraintNNNB(t,e,i,n){let o=this.GetVariable(t);if(o==null)return;let s=this.GetVariable(e);s!=null&&this.solver.AddConstraintVVNB(o,s,i,n)}AddLeftRightSeparationConstraintNNN(t,e,i){this.AddLeftRightSeparationConstraintNNNB(t,e,i,!1)}AddGoalTwoVariablesAreCloseNNN(t,e,i){let n=this.GetVariable(t);if(n==null)return;let o=this.GetVariable(e);o!=null&&this.solver.AddNeighborPair(n,o,i)}AddGoalTwoVariablesAreClose(t,e){this.AddGoalTwoVariablesAreCloseNNN(t,e,1)}GetVariable(t){return this.variables.get(t)}Solve(){this.SolveP(null)}SolveP(t){let e={executionLimitExceeded:!1};this.SolvePNS(t,e)}SolvePNS(t,e){let i;do{this.solution=null;let n=null;if(t!=null&&(n=t,n==null))throw new Error("parameters");this.solution=this.solver.SolvePar(n),e.executionLimitExceeded=this.solution.ExecutionLimitExceeded,i=this.AdjustConstraintsForMovedFixedVars()}while(i&&this.solution.ExecutionLimitExceeded===!1);return this.solution.ExecutionLimitExceeded===!1}AdjustConstraintsForMovedFixedVars(){let t=new Set;for(let[e,i]of this.fixedVars.entries())tl.Close(i,this.GetVariableResolvedPosition(e))||t.add(e);return t.size===0?!1:this.AdjustConstraintsForMovedFixedVarSet(t)}static Close(t,e){return Math.abs(t-e)<5e-4}AdjustConstraintsForMovedFixedVarSet(t){for(;t.size>0;){let e;for(let i of t){e=i;break}if(!this.AdjustSubtreeOfFixedVar(e,t))return!1}return!0}AdjustSubtreeOfFixedVar(t,e){let i={successInAdjusting:!1},n=this.AdjustConstraintsOfNeighborsOfFixedVariable(t,i);if(!i.successInAdjusting||n.length===0)return!1;for(let o of n)e.delete(o);return!0}AdjustConstraintsOfNeighborsOfFixedVariable(t,e){let i=this.variables.get(t).Block.Variables,n=new Cr,o=new Cr,s=1;for(let a of i)!this.fixedVars.has(a.UserData)||(n.AddValue(a.ActualPos),o.AddValue(a.DesiredPos),o.length>0&&(s=Math.max(s,n.length/o.length)));return s===1&&(s=2),e.successInAdjusting=this.FixActiveConstraints(i,s),i.map(a=>a.UserData)}FixActiveConstraints(t,e){let i=!1;for(let n of t)for(let o of n.LeftConstraints)o.IsActive&&(o.Gap>this.FailToAdjustEpsilon&&(i=!0),this.solver.SetConstraintUpdate(o,o.Gap/e));return i}GetVariableResolvedPosition(t){let e=this.GetVariable(t);return e==null?0:e.ActualPos}InitSolver(){this.solver=new el,this.variables.clear()}AddFixedVariable(t,e){this.AddVariableWithIdealPositionNNN(t,e,tl.FixedVarWeight),this.fixedVars.set(t,e)}ContainsVariable(t){return this.variables.has(t)}GetVariableIdealPosition(t){return this.variables.get(t).DesiredPos}get Solution(){return this.solution}},Fs=tl;Fs.FixedVarWeight=1e9;var rl=class{constructor(){this.lowBound=Number.NEGATIVE_INFINITY;this.upperBound=Number.POSITIVE_INFINITY}get Position(){return this.position}set Position(t){t<this.lowBound?this.position=this.lowBound:t>this.upperBound?this.position=this.upperBound:this.position=t}get LowBound(){return this.lowBound}set LowBound(t){this.lowBound=t}get UpperBound(){return this.upperBound}set UpperBound(t){this.upperBound=t}toString(){return this.lowBound+(" "+(this.Position+(" "+this.upperBound)))}};var il=class{constructor(t){this.idealPositions=new Map;this.varList=new Array;this.constraints=new Set;this.solverShell=new Fs;this.boundsToInt=new Map;this.varSepartion=t}SetLowBound(t,e){let i=this.Var(e);i.LowBound=Math.max(t,i.LowBound)}Var(t){return this.varList[t]}SetUpperBound(t,e){let i=this.Var(t);i.UpperBound=Math.min(e,i.UpperBound)}Solve(){this.SolveByRegularSolver()}SolveByRegularSolver(){this.CreateVariablesForBounds();for(let t=0;t<this.varList.length;t++){let e=this.varList[t];e.IsFixed?this.solverShell.AddFixedVariable(t,e.Position):(this.solverShell.AddVariableWithIdealPositionNN(t,this.idealPositions.get(t)),e.LowBound!==Number.NEGATIVE_INFINITY&&this.constraints.add(new Z(this.GetBoundId(e.LowBound),t)),e.UpperBound!==Number.POSITIVE_INFINITY&&this.constraints.add(new Z(t,this.GetBoundId(e.UpperBound))))}this.CreateGraphAndRemoveCycles();for(let t of this.graph.edges){let e=0;t.x<this.varList.length&&(e+=this.varList[t.x].Width),t.y<this.varList.length&&(e+=this.varList[t.y].Width),e/=2,this.solverShell.AddLeftRightSeparationConstraintNNN(t.x,t.y,this.varSepartion+e)}this.solverShell.Solve();for(let t=0;t<this.varList.length;t++)this.varList[t].Position=this.solverShell.GetVariableResolvedPosition(t)}GetBoundId(t){return this.boundsToInt.get(t)}CreateVariablesForBounds(){for(let t of this.varList)t.IsFixed||(t.LowBound!==Number.NEGATIVE_INFINITY&&this.RegisterBoundVar(t.LowBound),t.UpperBound!==Number.POSITIVE_INFINITY&&this.RegisterBoundVar(t.UpperBound))}RegisterBoundVar(t){if(!this.boundsToInt.has(t)){let e=this.varList.length+this.boundsToInt.size;this.boundsToInt.set(t,e),this.solverShell.AddFixedVariable(e,t)}}CreateGraphAndRemoveCycles(){this.graph=vt(Array.from(this.constraints),this.varList.length+this.boundsToInt.size);let t=cr.getFeedbackSet(this.graph);if(t!=null)for(let e of t)this.graph.removeEdge(e)}GetVariablePosition(t){return this.varList[t].Position}AddConstraint(t,e){this.constraints.add(new Z(t,e))}AddVariableNNNN(t,e,i,n){this.idealPositions.set(t,i),this.AddVariableNNBN(t,e,!1,n)}AddFixedVariable(t,e){this.AddVariableNNBN(t,e,!0,0)}AddVariableNNBN(t,e,i,n){let o=new rl;o.Position=e,o.IsFixed=i,o.Width=n,this.varList.push(o)}};var vn=class{clone(){let t=new vn;return t.transparency=this.transparency,t.width=this.width,t.color=this.color,t.icurve=this.icurve.clone(),t.label=this.label,t.dashArray=this.dashArray,t.drawPN=this.drawPN,t}static mkDebugCurveTWCILD(t,e,i,n,o,s,a=!1){let u=new vn;return u.transparency=t,u.width=e,u.color=i,u.icurve=n,u.label=o,u.dashArray=s,u.drawPN=a,u}static mkDebugCurveTWCI(t,e,i,n){return vn.mkDebugCurveTWCILD(t,e,i,n,null,null)}static mkDebugCurveWCI(t,e,i){return vn.mkDebugCurveTWCI(255,t,e,i)}static mkDebugCurveCI(t,e){return vn.mkDebugCurveWCI(1,t,e)}static mkDebugCurveI(t){return vn.mkDebugCurveCI("Black",t)}},oe=vn;oe.colors=["DeepSkyBlue","IndianRed","Orange","Gold","DarkRed","Plum","Red","Violet","Indigo","Yellow","OrangeRed","Tomato","Purple","SaddleBrown","Green","Navy","Aqua","Pink","Bisque","Black","BlanchedAlmond","Blue","BlueViolet","Brown","Lime","BurlyWood","Chocolate","Coral","CornflowerBlue","Cornsilk","Crimson","Cyan","CadetBlue","Chartreuse","DarkBlue","DarkCyan","DarkGoldenrod","DarkGray","DarkGreen","DarkKhaki","DarkMagenta","DarkOliveGreen","DarkOrange","DarkOrchid","DarkSalmon","DarkSeaGreen","DarkSlateBlue","DarkSlateGray","DarkTurquoise","DarkViolet","DeepPink","DimGray","DodgerBlue","Firebrick","FloralWhite","ForestGreen","Fuchsia","CodeAnalysis","Gainsboro","GhostWhite","Goldenrod","Gray","GreenYellow","Honeydew","HotPink","Ivory","Lavender","LavenderBlush","LawnGreen","LemonChiffon","LightBlue","LightCoral","LightCyan","LightGoldenrodYellow","LightGray","LightGreen","LightPink","LightSalmon","LightSeaGreen","LightSkyBlue","LightSlateGray","LightSteelBlue","LightYellow","LimeGreen","Linen","Magenta","Maroon","MediumAquamarine","MediumBlue","MediumOrchid","MediumPurple","MediumSeaGreen","MediumSlateBlue","MediumSpringGreen","MediumTurquoise","MediumVioletRed","MidnightBlue","MintCream","MistyRose","Moccasin","NavajoWhite","OldLace","Olive","OliveDrab","Orchid","PaleGoldenrod","PaleGreen","PaleTurquoise","PaleVioletRed","PapayaWhip","PeachPuff","Peru","PowderBlue","RosyBrown","RoyalBlue","Salmon","SandyBrown","SeaGreen","CodeAnalysis","SeaShell","Sienna","Silver","SkyBlue","SlateBlue","SlateGray","Snow","SpringGreen","SteelBlue","Tan","Teal","Thistle","Transparent","Turquoise","Aquamarine","Azure","Beige","Wheat","White","WhiteSmoke","YellowGreen","Khaki","AntiqueWhite"];var rd=he(Qr(),1);var nl=class extends _t{constructor(e,i){super(e,i);this.RightNeighbors=new Set;this.setOfLongestSegs=new Set;this.RightBound=Number.POSITIVE_INFINITY,this.LeftBound=Number.NEGATIVE_INFINITY,this.Direction=F.DirectionFromPointToPoint(e.point,i.point)}AddRightNeighbor(e){this.RightNeighbors.add(e)}get LongestNudgedSegments(){return this.setOfLongestSegs}AddLongestNudgedSegment(e){this.setOfLongestSegs.add(e)}BoundFromRight(e){e=Math.max(e,this.LeftBound),this.RightBound=Math.min(e,this.RightBound)}BoundFromLeft(e){e=Math.min(e,this.RightBound),this.LeftBound=Math.max(e,this.LeftBound)}};var er=class{constructor(t){this.Point=t}*GetEnumerator(){let t;for(t=this;t!=null;t=t.Next)yield t.Point}get X(){return this.Point.x}get Y(){return this.Point.y}InsertVerts(t,e,i){for(e--;t<e;e--)this.SetNewNext(i[e])}InsertVertsInReverse(t,e,i){for(t++;t<e;t++)this.SetNewNext(i[t])}SetNewNext(t){let e=new er(t),i=this.Next;this.Next=e,e.Next=i}};var so=class{constructor(t,e){this.IsFixed=!1;this.Reversed=!1;this.index=-1;this.AxisEdge=t,this.Width=e}toString(){return this.Source+(" "+this.Target)}get LongestNudgedSegment(){return this.longestNudgedSegment}set LongestNudgedSegment(t){this.longestNudgedSegment=t,this.longestNudgedSegment!=null&&(this.longestNudgedSegment.AddEdge(this),this.AxisEdge.AddLongestNudgedSegment(this.longestNudgedSegment))}get Source(){return this.Reversed?this.AxisEdge.TargetPoint:this.AxisEdge.SourcePoint}get Target(){return this.Reversed?this.AxisEdge.SourcePoint:this.AxisEdge.TargetPoint}static VectorsAreParallel(t,e){return Q(t.x*e.y-t.y*e.x,0)}static EdgesAreParallel(t,e){return so.VectorsAreParallel(t.AxisEdge.TargetPoint.sub(t.AxisEdge.SourcePoint),e.AxisEdge.TargetPoint.sub(e.AxisEdge.SourcePoint))}get Direction(){return this.Reversed?F.OppositeDir(this.AxisEdge.Direction):this.AxisEdge.Direction}get Index(){return this.index}set Index(t){this.index=t}};var Ut=class{constructor(t){this.pathVisibilityGraph=new Ie;this.axisEdgesToPathOrders=new Map;this.OriginalPaths=t}get PathVisibilityGraph(){return this.pathVisibilityGraph}GetOrder(){return this.FillTheVisibilityGraphByWalkingThePaths(),this.InitPathOrder(),this.OrderPaths(),this.axisEdgesToPathOrders}FillTheVisibilityGraphByWalkingThePaths(){for(let t of this.OriginalPaths)this.FillTheVisibilityGraphByWalkingPath(t)}FillTheVisibilityGraphByWalkingPath(t){let e=this.CreatePathEdgesFromPoints(n(),t.Width),i=e.next();for(i.done||t.SetFirstEdge(i.value);(i=e.next()).done===!1;)t.AddEdge(i.value);function*n(){if(t.PathPoints instanceof er)for(let o=t.PathPoints;o!=null;o=o.Next)yield o.Point;else for(let o of t.PathPoints)yield o}}*CreatePathEdgesFromPoints(t,e){let i=t.next(),n=i.value;for(;!(i=t.next()).done;)yield this.CreatePathEdge(n,i.value,e),n=i.value}CreatePathEdge(t,e,i){switch(F.DirectionFromPointToPoint(t,e)){case 2:case 1:return new so(this.GetAxisEdge(t,e),i);case 4:case 8:{let o=new so(this.GetAxisEdge(e,t),i);return o.Reversed=!0,o}default:throw new Error("Not a rectilinear path")}}GetAxisEdge(t,e){return this.PathVisibilityGraph.AddEdgeF(t,e,(i,n)=>new nl(i,n))}InitPathOrder(){for(let t of this.PathVisibilityGraph.Edges)this.axisEdgesToPathOrders.set(t,new Array);for(let t of this.OriginalPaths)for(let e of t.PathEdges())this.axisEdgesToPathOrders.get(e.AxisEdge).push(e)}OrderPaths(){for(let t of Ut.WalkGraphEdgesInTopologicalOrderIfPossible(this.PathVisibilityGraph))this.OrderPathEdgesSharingEdge(t)}OrderPathEdgesSharingEdge(t){let e=this.PathOrderOfVisEdge(t);e.sort(Ut.CompareTwoPathEdges);let i=0;for(let n of e)n.Index=i++}static CompareTwoPathEdges(t,e){if(t===e)return 0;let i=Ut.CompareInDirectionStartingFromAxisEdge(t,e,t.AxisEdge,t.AxisEdge.Direction);return i!==0?i:-Ut.CompareInDirectionStartingFromAxisEdge(t,e,t.AxisEdge,F.OppositeDir(t.AxisEdge.Direction))}static CompareInDirectionStartingFromAxisEdge(t,e,i,n){for(;;){if(t=Ut.GetNextPathEdgeInDirection(t,i,n),t==null||(e=Ut.GetNextPathEdgeInDirection(e,i,n),e==null))return 0;if(t.AxisEdge===e.AxisEdge){n=Ut.FindContinuedDirection(i,n,t.AxisEdge),i=t.AxisEdge;let h=Ut.GetExistingOrder(t,e);if(h===Ut.NotOrdered)continue;return n===i.Direction?h:-h}let o=n===i.Direction?i.Target:i.Source,s=Ut.OtherVertex(t.AxisEdge,o),a=Ut.OtherVertex(e.AxisEdge,o),u=Ut.ProjectionForCompare(i,n!==i.Direction);return ce(u(s.point),u(a.point))}}static FindContinuedDirection(t,e,i){return t.Direction===e?i.Source===t.Target?i.Direction:F.OppositeDir(i.Direction):i.Source===t.Source?i.Direction:F.OppositeDir(i.Direction)}static OtherVertex(t,e){return t.Source===e?t.Target:t.Source}static ProjectionForCompare(t,e){return t.Direction===1?e?i=>-i.x:i=>i.x:e?i=>i.y:i=>-i.y}static GetNextPathEdgeInDirection(t,e,i){return e.Direction===i?t.Reversed?t.Prev:t.Next:t.Reversed?t.Next:t.Prev}static GetExistingOrder(t,e){let i=t.Index;if(i===-1)return Ut.NotOrdered;let n=e.Index;return ce(i,n)}PathOrderOfVisEdge(t){return this.axisEdgesToPathOrders.get(t)}static InitQueueOfSources(t,e,i){for(let n of i.Vertices()){let o=n.InEdgesLength();e.set(n,o),o===0&&t.enqueue(n)}}static*WalkGraphEdgesInTopologicalOrderIfPossible(t){let e=new rd.Queue,i=new Map;for(Ut.InitQueueOfSources(e,i,t);e.length>0;){let n=e.dequeue();for(let o of n.OutEdges){let s=i.get(o.Target);i.set(o.Target,s-1),s===1&&e.enqueue(o.Target),yield o}}}},Vs=Ut;Vs.NotOrdered=Number.MAX_VALUE;var ol=class extends ot{constructor(e,i){super();this.site=i,this.AxisEdge=e}get Site(){return this.site}};var ks=class extends ot{constructor(e,i){super();this.site=i,this.AxisEdge=e}get Site(){return this.site}};var sl=class{constructor(t){this.edges=new Set;this.Source=t}get Edges(){return this.edges}AddEdge(t){this.UpPoint=t.TargetPoint,this.edges.add(t)}RemoveAxis(t){this.edges.delete(t)}IsEmpty(){return this.edges.size===0}};var An=class extends Ho{constructor(e,i,n,o,s){super(i,new F(e).ToPoint());this.DirectionPerp=new F(e).Right.ToPoint(),this.PathOrders=o,this.xProjection=e===1?a=>a.x:a=>-a.y,this.edgeContainersTree=new Me((a,u)=>this.CompareAA(a,u)),this.SweepPole=F.VectorDirection(this.SweepDirection),this.AxisEdges=s,this.AxisEdgesToObstaclesTheyOriginatedFrom=n}FindFreeSpace(){this.InitTheQueueOfEvents(),this.ProcessEvents()}ProcessEvents(){for(;this.EventQueue.Count>0;)this.ProcessEvent(this.EventQueue.Dequeue())}ProcessEvent(e){e instanceof lr?this.ProcessVertexEvent(e):(this.Z=this.GetZP(e.Site),e instanceof ks?this.ProcessLowEdgeEvent(e):this.ProcessHighEdgeEvent(e))}ProcessHighEdgeEvent(e){let i=e.AxisEdge;this.RemoveEdge(i),this.ConstraintEdgeWithObstaclesAtZ(i,i.Target.point)}ProcessLowEdgeEvent(e){let i=e.AxisEdge,n=this.GetOrCreateAxisEdgesContainer(i);n.item.AddEdge(i);let o=this.edgeContainersTree.previous(n);if(o!=null)for(let a of o.item.edges)for(let u of n.item.edges)this.TryToAddRightNeighbor(a,u);let s=this.edgeContainersTree.next(n);if(s!=null)for(let a of n.item.Edges)for(let u of s.item.edges)this.TryToAddRightNeighbor(a,u);this.ConstraintEdgeWithObstaclesAtZ(i,i.Source.point)}TryToAddRightNeighbor(e,i){this.ProjectionsOfEdgesOverlap(e,i)&&e.AddRightNeighbor(i)}ProjectionsOfEdgesOverlap(e,i){return this.SweepPole===1?!(e.TargetPoint.y<i.SourcePoint.y-C.distanceEpsilon||i.TargetPoint.y<e.SourcePoint.y-C.distanceEpsilon):!(e.TargetPoint.x<i.SourcePoint.x-C.distanceEpsilon||i.TargetPoint.x<e.SourcePoint.x-C.distanceEpsilon)}GetObstacleBoundaries(e){return this.Obstacles.map(i=>oe.mkDebugCurveWCI(1,e,i))}ConstraintEdgeWithObstaclesAtZ(e,i){this.ConstraintEdgeWithObstaclesAtZFromLeft(e,i),this.ConstraintEdgeWithObstaclesAtZFromRight(e,i)}ConstraintEdgeWithObstaclesAtZFromRight(e,i){let n=this.GetActiveSideFromRight(i);if(n==null||this.NotRestricting(e,n.item.Polyline))return;let o=this.ObstacleSideComparer.IntersectionOfSideAndSweepLine(n.item);e.BoundFromRight(o.dot(this.DirectionPerp))}GetActiveSideFromRight(e){return this.LeftObstacleSideTree.findFirst(i=>An.PointToTheLeftOfLineOrOnLineLocal(e,i.Start,i.End))}ConstraintEdgeWithObstaclesAtZFromLeft(e,i){let n=this.GetActiveSideFromLeft(i);if(n==null||this.NotRestricting(e,n.item.Polyline))return;let o=this.ObstacleSideComparer.IntersectionOfSideAndSweepLine(n.item);e.BoundFromLeft(o.dot(this.DirectionPerp))}static PointToTheLeftOfLineOrOnLineLocal(e,i,n){return d.signedDoubledTriangleArea(e,i,n)>-An.AreaComparisonEpsilon}static PointToTheRightOfLineOrOnLineLocal(e,i,n){return d.signedDoubledTriangleArea(i,n,e)<An.AreaComparisonEpsilon}GetActiveSideFromLeft(e){return this.RightObstacleSideTree.findLast(i=>An.PointToTheRightOfLineOrOnLineLocal(e,i.Start,i.End))}static EdgeMidPoint(e){return d.middle(e.SourcePoint,e.TargetPoint)}GetOrCreateAxisEdgesContainer(e){let i=e.Source.point,n=this.GetAxisEdgesContainerNode(i);return n!=null?n:this.edgeContainersTree.insert(new sl(i))}GetAxisEdgesContainerNode(e){let i=this.xProjection(e),n=this.edgeContainersTree.findFirst(o=>this.xProjection(o.Source)>=i-C.distanceEpsilon/2);return n!=null&&this.xProjection(n.item.Source)<=i+C.distanceEpsilon/2?n:null}ProcessVertexEvent(e){this.Z=this.GetZS(e),e instanceof $r?this.ProcessLeftVertex(e,e.Vertex.nextOnPolyline):e instanceof Kr?this.ProcessRightVertex(e,e.Vertex.prevOnPolyline):(this.ProcessLeftVertex(e,e.Vertex.nextOnPolyline),this.ProcessRightVertex(e,e.Vertex.prevOnPolyline))}ProcessRightVertex(e,i){let n=e.Site;this.ProcessPrevSegmentForRightVertex(e,n);let o=i.point.sub(e.Site),s=o.dot(this.DirectionPerp),a=o.dot(this.SweepDirection);a<=C.distanceEpsilon?s>0&&a>=0?this.EnqueueEvent(new Kr(i)):this.RestrictEdgeContainerToTheRightOfEvent(e.Vertex):(this.InsertRightSide(new Pi(e.Vertex)),this.EnqueueEvent(new Kr(i)),this.RestrictEdgeContainerToTheRightOfEvent(e.Vertex))}RestrictEdgeContainerToTheRightOfEvent(e){let i=e.point,n=this.xProjection(i),o=this.edgeContainersTree.findFirst(s=>n<=this.xProjection(s.Source));if(o!=null)for(let s of o.item.Edges)this.NotRestricting(s,e.polyline)||s.BoundFromLeft(this.DirectionPerp.dot(i))}NotRestricting(e,i){return this.AxisEdgesToObstaclesTheyOriginatedFrom.get(e)===i}ProcessPrevSegmentForRightVertex(e,i){let n=e.Vertex.nextOnPolyline.point;i.sub(n).dot(this.SweepDirection)>C.distanceEpsilon&&this.RemoveRightSide(new Pi(e.Vertex.nextOnPolyline))}RemoveEdge(e){let i=this.GetAxisEdgesContainerNode(e.Source.point);i.item.RemoveAxis(e),i.item.IsEmpty()&&this.edgeContainersTree.deleteNodeInternal(i)}ProcessLeftVertex(e,i){let n=e.Site;this.ProcessPrevSegmentForLeftVertex(e,n);let o=i.point.sub(e.Site),s=o.dot(this.DirectionPerp),a=o.dot(this.SweepDirection);a<=C.distanceEpsilon?s<0&&a>=0&&this.EnqueueEvent(new $r(i)):(this.InsertLeftSide(new bi(e.Vertex)),this.EnqueueEvent(new $r(i))),this.RestrictEdgeFromTheLeftOfEvent(e.Vertex)}RestrictEdgeFromTheLeftOfEvent(e){let i=e.point,n=this.GetContainerNodeToTheLeftOfEvent(i);if(n!=null)for(let o of n.item.Edges)this.NotRestricting(o,e.polyline)||o.BoundFromRight(i.dot(this.DirectionPerp))}GetContainerNodeToTheLeftOfEvent(e){let i=this.xProjection(e);return this.edgeContainersTree.findLast(n=>this.xProjection(n.Source)<=i)}ProcessPrevSegmentForLeftVertex(e,i){let n=e.Vertex.prevOnPolyline.point;i.sub(n).dot(this.SweepDirection)>C.distanceEpsilon&&this.RemoveLeftSide(new bi(e.Vertex.prevOnPolyline))}InitTheQueueOfEvents(){this.InitQueueOfEvents();for(let e of this.AxisEdges)this.EnqueueEventsForEdge(e)}EnqueueEventsForEdge(e){this.EdgeIsParallelToSweepDir(e)&&(this.EnqueueEvent(An.EdgeLowPointEvent(e,e.Source.point)),this.EnqueueEvent(An.EdgeHighPointEvent(e,e.Target.point)))}EdgeIsParallelToSweepDir(e){return e.Direction===this.SweepPole||e.Direction===F.OppositeDir(this.SweepPole)}static EdgeHighPointEvent(e,i){return new ol(e,i)}static EdgeLowPointEvent(e,i){return new ks(e,i)}CompareAA(e,i){return ce(e.Source.dot(this.DirectionPerp),i.Source.dot(this.DirectionPerp))}},Ms=An;Ms.AreaComparisonEpsilon=C.intersectionEpsilon;var al=class extends mn{constructor(e){super();this.CompassDirection=0;this.edges=new Array;this._isFixed=!1;this.Id=-1;this.IdealPosition=0;this.Id=e}get Start(){return this.start}get End(){return this.end}get Edges(){return this.edges}AddEdge(e){if(this.Edges.length===0){let i=F.VectorDirectionPP(e.Source,e.Target);switch(i){case 4:i=1;break;case 8:i=2;break}this.CompassDirection=i,this.start=e.Source,this.end=e.Source}switch(this.CompassDirection){case 1:this.TryPointForStartAndEndNorth(e.Source),this.TryPointForStartAndEndNorth(e.Target);break;case 2:this.TryPointForStartAndEndEast(e.Source),this.TryPointForStartAndEndEast(e.Target);break}this.Edges.push(e)}TryPointForStartAndEndNorth(e){e.y<this.start.y?this.start=e:e.y>this.end.y&&(this.end=e)}TryPointForStartAndEndEast(e){e.x<this.start.x?this.start=e:e.x>this.end.x&&(this.end=e)}get IsFixed(){return this._isFixed}set IsFixed(e){this._isFixed=e}get Width(){let e=0;for(let i of this.edges)e=Math.max(e,i.Width);return e}GetLeftBound(){if(!this.IsFixed){let e=Number.NEGATIVE_INFINITY;for(let i of this.edges)e=Math.max(e,i.AxisEdge.LeftBound);return e}return this.CompassDirection===1?this.Edges[0].Source.x:-this.Edges[0].Source.y}GetRightBound(){if(!this.IsFixed){let e=Number.POSITIVE_INFINITY;for(let i of this.edges)e=Math.min(e,i.AxisEdge.RightBound);return e}return this.Position()}Position(){return this.CompassDirection===1?this.Edges[0].Source.x:-this.Edges[0].Source.y}};var Er=class{constructor(t,e){this.tree=new Me((t,e)=>ce(t.Point.x,e.Point.x));this.VerticalPoints=e,this.HorizontalPoints=t}SplitPoints(){this.VerticalPoints.length===0||this.HorizontalPoints.length===0||(this.InitEventQueue(),this.ProcessEvents())}ProcessEvents(){for(;!this.Queue.IsEmpty();){let t={priority:0},e=this.Queue.DequeueAndGetPriority(t);this.ProcessEvent(e,t.priority)}}ProcessEvent(t,e){Q(t.Next.Point.x,t.Point.x)?e===Er.Low(t)?this.ProcessLowLinkedPointEvent(t):this.ProcessHighLinkedPointEvent(t):this.IntersectWithTree(t)}IntersectWithTree(t){let e,i,n,o=t.Y;if(t.Point.x<t.Next.Point.x?(i=t.Point.x,e=t.Next.Point.x,n=!0):(e=t.Point.x,i=t.Next.Point.x,n=!1),n)for(let s=this.tree.findFirst(a=>i<=a.Point.x);s!=null&&s.item.Point.x<=e;s=this.tree.next(s)){let a=new d(s.item.Point.x,o);t=Er.TrySplitHorizontalPoint(t,a,!0),Er.TrySplitVerticalPoint(s.item,a)}else for(let s=this.tree.findLast(a=>a.Point.x<=e);s!=null&&s.item.Point.x>=i;s=this.tree.previous(s)){let a=new d(s.item.Point.x,o);t=Er.TrySplitHorizontalPoint(t,a,!1),Er.TrySplitVerticalPoint(s.item,a)}}static TrySplitVerticalPoint(t,e){Er.Low(t)+C.distanceEpsilon<e.y&&e.y+C.distanceEpsilon<Er.High(t)&&t.SetNewNext(e)}static TrySplitHorizontalPoint(t,e,i){return i&&t.X+C.distanceEpsilon<e.x&&e.x+C.distanceEpsilon<t.Next.X||!i&&t.Next.X+C.distanceEpsilon<e.x&&e.x+C.distanceEpsilon<t.X?(t.SetNewNext(e),t.Next):t}ProcessHighLinkedPointEvent(t){this.tree.remove(t)}ProcessLowLinkedPointEvent(t){this.tree.insert(t)}InitEventQueue(){this.Queue=new At(ce);for(let t of this.VerticalPoints)this.Queue.Enqueue(t,Er.Low(t));for(let t of this.HorizontalPoints)this.Queue.Enqueue(t,t.Point.y)}static Low(t){return Math.min(t.Point.y,t.Next.Point.y)}static High(t){return Math.max(t.Point.y,t.Next.Point.y)}};var qi=class{constructor(t){this.verticesToPathOffsets=new qe;this.Paths=t}MergePaths(){this.InitVerticesToPathOffsetsAndRemoveSelfCycles();for(let t of this.Paths)this.ProcessPath(t)}ProcessPath(t){let e=new Map,i=null;for(let n=t.PathPoints;n!=null;n=n.Next){let o=this.verticesToPathOffsets.get(n.Point);if(i!=null){if(e.size>0)for(let[s,a]of o){let u=e.get(s);u&&(this.CollapseLoopingPath(s,u,a,t,n),e.delete(s))}for(let[s,a]of i)o.has(s)||e.set(s,a)}i=o}}CollapseLoopingPath(t,e,i,n,o){let s=qi.FindLinkedPointInPath(n,e.Point),a=Array.from(qi.GetPointsInBetween(s,o));qi.Before(e,i)?(this.CleanDisappearedPiece(e,i,t),this.ReplacePiece(e,i,a,t)):(this.CleanDisappearedPiece(i,e,t),this.ReplacePiece(i,e,a.reverse(),t))}static*GetPointsInBetween(t,e){for(let i=t.Next;i!==e;i=i.Next)yield i.Point}ReplacePiece(t,e,i,n){let o=t;for(let s of i){let a=new er(s);o.Next=a,o=a,this.verticesToPathOffsets.get(s).set(n,o)}o.Next=e}CleanDisappearedPiece(t,e,i){for(let n of qi.GetPointsInBetween(t,e))this.verticesToPathOffsets.get(n).delete(i)}static Before(t,e){for(t=t.Next;t!=null;t=t.Next)if(t===e)return!0;return!1}static FindLinkedPointInPath(t,e){for(let i=t.PathPoints;;i=i.Next)if(i.Point.equal(e))return i}InitVerticesToPathOffsetsAndRemoveSelfCycles(){for(let t of this.Paths)for(let e=t.PathPoints;e!=null;e=e.Next){let i=this.verticesToPathOffsets.get(e.Point);i||this.verticesToPathOffsets.set(e.Point,i=new Map);let n=i.get(t);n?(this.CleanDisappearedPiece(n,e,t),n.Next=e.Next):i.set(t,e)}}};var ll=class{constructor(t){this.projection=t}compare(t,e){return ce(this.projection(t),this.projection(e))}};var Ko;(function(l){l.has=Symbol.for("@esfx/collection-core!ReadonlyCollection.has"),l.name="ReadonlyContainer";function t(e){return(typeof e=="object"&&e!==null||typeof e=="function")&&l.has in e}l.hasInstance=t})(Ko||(Ko={}));var Ws;(function(l){l.has=Ko.has,l.add=Symbol.for("@esfx/collection-core!Collection.add"),l.delete=Symbol.for("@esfx/collection-core!Collection.delete"),l.name="Container";function t(e){return Ko.hasInstance(e)&&l.add in e&&l.delete in e}l.hasInstance=t})(Ws||(Ws={}));var tr;(function(l){l.has=Ko.has,l.size=Symbol.for("@esfx/collection-core!ReadonlyCollection.size"),l.name="ReadonlyCollection";function t(e){return Ko.hasInstance(e)&&(typeof e=="object"&&e!==null||typeof e=="function")&&Symbol.iterator in e&&l.size in e}l.hasInstance=t})(tr||(tr={}));var rt;(function(l){l.size=tr.size,l.has=tr.has,l.add=Ws.add,l.delete=Ws.delete,l.clear=Symbol.for("@esfx/collection-core!Collection.clear"),l.name="Collection";function t(e){return tr.hasInstance(e)&&Ws.hasInstance(e)&&l.clear in e}l.hasInstance=t})(rt||(rt={}));var ao;(function(l){l.size=tr.size,l.has=tr.has,l.indexOf=Symbol.for("@esfx/collection-core!ReadonlyIndexedCollection.indexOf"),l.getAt=Symbol.for("@esfx/collection-core!ReadonlyIndexedCollection.getAt"),l.name="ReadonlyIndexedCollection";function t(e){return tr.hasInstance(e)&&l.indexOf in e&&l.getAt in e}l.hasInstance=t})(ao||(ao={}));var ul;(function(l){l.size=tr.size,l.has=tr.has,l.indexOf=ao.indexOf,l.getAt=ao.getAt,l.setAt=Symbol.for("@esfx/collection-core!FixedSizeIndexedCollection.setAt"),l.name="FixedSizeIndexedCollection";function t(e){return ao.hasInstance(e)&&l.setAt in e}l.hasInstance=t})(ul||(ul={}));var id;(function(l){l.size=tr.size,l.has=tr.has,l.indexOf=ao.indexOf,l.getAt=ao.getAt,l.setAt=ul.setAt,l.add=rt.add,l.delete=rt.delete,l.clear=rt.clear,l.insertAt=Symbol.for("@esfx/collection-core!IndexedCollection.insertAt"),l.removeAt=Symbol.for("@esfx/collection-core!IndexedCollection.removeAt"),l.name="IndexedCollection";function t(e){return ul.hasInstance(e)&&l.insertAt in e&&l.removeAt in e}l.hasInstance=t})(id||(id={}));var In;(function(l){l.has=Symbol.for("@esfx/collection-core!ReadonlyKeyedContainer.has"),l.get=Symbol.for("@esfx/collection-core!ReadonlyKeyedContainer.get"),l.name="ReadonlyKeyedContainer";function t(e){return(typeof e=="object"&&e!==null||typeof e=="function")&&l.has in e&&l.get in e}l.hasInstance=t})(In||(In={}));var Hs;(function(l){l.has=In.has,l.get=In.get,l.set=Symbol.for("@esfx/collection-core!KeyedCollection.set"),l.delete=Symbol.for("@esfx/collection-core!KeyedCollection.delete"),l.name="KeyedContainer";function t(e){return In.hasInstance(e)&&l.set in e&&l.delete in e}l.hasInstance=t})(Hs||(Hs={}));var dr;(function(l){l.has=In.has,l.get=In.get,l.size=Symbol.for("@esfx/collection-core!ReadonlyKeyedCollection.size"),l.keys=Symbol.for("@esfx/collection-core!ReadonlyKeyedCollection.keys"),l.values=Symbol.for("@esfx/collection-core!ReadonlyKeyedCollection.values"),l.name="ReadonlyKeyedCollection";function t(e){return(typeof e=="object"&&e!==null||typeof e=="function")&&Symbol.iterator in e&&In.hasInstance(e)&&l.size in e&&l.keys in e&&l.values in e}l.hasInstance=t})(dr||(dr={}));var rr;(function(l){l.size=dr.size,l.has=dr.has,l.get=dr.get,l.keys=dr.keys,l.values=dr.values,l.set=Hs.set,l.delete=Hs.delete,l.clear=Symbol.for("@esfx/collection-core!KeyedCollection.clear"),l.name="KeyedCollection";function t(e){return dr.hasInstance(e)&&Hs.hasInstance(e)&&l.clear in e}l.hasInstance=t})(rr||(rr={}));var jt;(function(l){l.size=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.size"),l.has=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.has"),l.hasValue=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.hasValue"),l.get=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.get"),l.keys=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.keys"),l.values=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.values"),l.name="ReadonlyKeyedMultiCollection";function t(e){return(typeof e=="object"&&e!==null||typeof e=="function")&&Symbol.iterator in e&&l.size in e&&l.has in e&&l.hasValue in e&&l.get in e&&l.keys in e&&l.values in e}l.hasInstance=t})(jt||(jt={}));var lo;(function(l){l.size=jt.size,l.has=jt.has,l.hasValue=jt.hasValue,l.get=jt.get,l.keys=jt.keys,l.values=jt.values,l.add=Symbol.for("@esfx/collection-core!KeyedMultiCollection.add"),l.delete=Symbol.for("@esfx/collection-core!KeyedMultiCollection.delete"),l.deleteValue=Symbol.for("@esfx/collection-core!KeyedMultiCollection.deleteValue"),l.clear=Symbol.for("@esfx/collection-core!KeyedMultiCollection.clear"),l.name="KeyedMultiCollection";function t(e){return jt.hasInstance(e)&&l.add in e&&l.delete in e&&l.deleteValue in e&&l.clear in e}l.hasInstance=t})(lo||(lo={}));function nd(l,t,e,i){if(t%4)throw new TypeError("Pointer not aligned");let n=new Uint32Array(l),o,s,a,u,h,c,f;if(s=t+e,t>>=2,e>=16){a=s-16>>2,u=(i+2654435761|0)+2246822519|0,h=i+2246822519|0,c=i+0|0,f=i+2654435761|0;do u=u+n[t++]*2246822519|0|0,u=(u<<13|u>>>19)*2654435761|0,h=h+n[t++]*2246822519|0|0,h=(h<<13|h>>>19)*2654435761|0,c=c+n[t++]*2246822519|0|0,c=(c<<13|c>>>19)*2654435761|0,f=f+n[t++]*2246822519|0|0,f=(f<<13|f>>>19)*2654435761|0;while(t<=a);o=(u<<1|u>>>31)+(h<<7|h>>>25)|(c<<12|c>>>20)|(f<<18|f>>>14)}else o=i+374761393|0;for(o=o+e|0,a=s-4>>2;t<=a;)o=o+n[t++]*3266489917|0|0,o=(o<<17|o>>>15)*668265263|0;if(t=t<<2,t<s){let P=new Uint8Array(n.buffer);do o=o+P[t++]*374761393|0|0,o=(o<<11|o>>>21)*2654435761|0;while(t<s)}return o=(o^o>>>15)*2246822519|0,o=(o^o>>>13)*3266489917|0,o=o^o>>>16,o>>>0}var ep=typeof WebAssembly<"u"&&typeof WebAssembly.Module=="function"&&typeof WebAssembly.Instance=="function",tp=new Uint8Array([0,97,115,109,1,0,0,0,1,8,1,96,3,127,127,126,1,126,3,2,1,0,5,3,1,0,1,7,15,2,3,109,101,109,2,0,5,120,120,104,54,52,0,0,10,130,6,1,255,5,2,3,126,1,127,32,0,32,1,106,33,6,32,1,65,32,79,4,126,32,6,65,32,107,33,6,32,2,66,214,235,130,238,234,253,137,245,224,0,124,33,3,32,2,66,177,169,172,193,173,184,212,166,61,125,33,4,32,2,66,249,234,208,208,231,201,161,228,225,0,124,33,5,3,64,32,3,32,0,41,3,0,66,207,214,211,190,210,199,171,217,66,126,124,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,33,3,32,4,32,0,65,8,106,34,0,41,3,0,66,207,214,211,190,210,199,171,217,66,126,124,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,33,4,32,2,32,0,65,8,106,34,0,41,3,0,66,207,214,211,190,210,199,171,217,66,126,124,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,33,2,32,5,32,0,65,8,106,34,0,41,3,0,66,207,214,211,190,210,199,171,217,66,126,124,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,33,5,32,6,32,0,65,8,106,34,0,79,13,0,11,32,2,66,12,137,32,5,66,18,137,124,32,4,66,7,137,124,32,3,66,1,137,124,32,3,66,207,214,211,190,210,199,171,217,66,126,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,133,66,135,149,175,175,152,182,222,155,158,127,126,66,157,163,181,234,131,177,141,138,250,0,125,32,4,66,207,214,211,190,210,199,171,217,66,126,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,133,66,135,149,175,175,152,182,222,155,158,127,126,66,157,163,181,234,131,177,141,138,250,0,125,32,2,66,207,214,211,190,210,199,171,217,66,126,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,133,66,135,149,175,175,152,182,222,155,158,127,126,66,157,163,181,234,131,177,141,138,250,0,125,32,5,66,207,214,211,190,210,199,171,217,66,126,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,133,66,135,149,175,175,152,182,222,155,158,127,126,66,157,163,181,234,131,177,141,138,250,0,125,5,32,2,66,197,207,217,178,241,229,186,234,39,124,11,32,1,173,124,33,2,32,0,32,1,65,31,113,106,33,1,3,64,32,1,32,0,65,8,106,79,4,64,32,0,41,3,0,66,207,214,211,190,210,199,171,217,66,126,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,32,2,133,66,27,137,66,135,149,175,175,152,182,222,155,158,127,126,66,157,163,181,234,131,177,141,138,250,0,125,33,2,32,0,65,8,106,33,0,12,1,11,11,32,0,65,4,106,32,1,77,4,64,32,2,32,0,53,2,0,66,135,149,175,175,152,182,222,155,158,127,126,133,66,23,137,66,207,214,211,190,210,199,171,217,66,126,66,249,243,221,241,153,246,153,171,22,124,33,2,32,0,65,4,106,33,0,11,3,64,32,0,32,1,73,4,64,32,2,32,0,49,0,0,66,197,207,217,178,241,229,186,234,39,126,133,66,11,137,66,135,149,175,175,152,182,222,155,158,127,126,33,2,32,0,65,1,106,33,0,12,1,11,11,32,2,32,2,66,33,136,133,66,207,214,211,190,210,199,171,217,66,126,34,2,66,29,136,32,2,133,66,249,243,221,241,153,246,153,171,22,126,34,2,66,32,136,32,2,133,11]),uo=ep?new WebAssembly.Instance(new WebAssembly.Module(tp)).exports:void 0;var ho=uo===null||uo===void 0?void 0:uo.mem,rh=uo===null||uo===void 0?void 0:uo.xxh64;var np=typeof TextEncoder=="function",od=(l,t)=>(od=op())(l,t),ih=(l,t)=>od(l,t);function op(){function l(){let e=new TextEncoder;function i(n,o){let{written:s=0}=e.encodeInto(n,o);return s}return i}function t(){function e(i,n){let o=i.length,s=0;for(let a=0;a<o;a++){let u=i.charCodeAt(a);if((u&55296)!==0&&(u&4294910976)===0&&a<o-1){let h=i.charCodeAt(a+1);(h&64512)===56320&&(u=((u&1023)<<10)+(h&1023)+65536,a++)}if((u&4294967168)===0)n[s++]=u;else if((u&4294965248)===0)n[s++]=u>>6|192,n[s++]=u&63|128;else if((u&268431360)===0)n[s++]=u>>12|224,n[s++]=u>>6&63|128,n[s++]=u&63|128;else if((u&4292870144)===0)n[s++]=u>>18|240,n[s++]=u>>12&63|128,n[s++]=u>>6&63|128,n[s++]=u&63|128;else throw new RangeError("Unsupported charCode.")}return s}return e}return np?l():t()}var nh=typeof BigInt=="function"&&typeof BigInt(0)=="bigint",sd=typeof BigUint64Array=="function",ap=typeof ho=="object"&&typeof rh=="function",oh=new ArrayBuffer(8),lp=new Float64Array(oh),Ui=new Uint32Array(oh),Zo=()=>(Zo=up())(),ad=l=>(ad=hp())(l),ld=l=>(ld=cp())(l),ud=l=>(ud=Zo())(l),hd=l=>(hd=dp())(l),cd=l=>(cd=gp())(l),dd=l=>ad(l),gd=l=>ld(l),md=l=>ud(l),fd=l=>hd(l),sh=l=>cd(l);function up(){function l(){let e=new BigUint64Array(Ui.buffer),i=new Uint8Array(ho.buffer);function n(h){ho.buffer.byteLength<h&&(ho.grow(Math.ceil((h-ho.buffer.byteLength)/65536)),i=new Uint8Array(ho.buffer))}function o(h){e[0]=h;let c=Ui[0],f=Ui[1];return(c<<7|c>>>25)^f}function s(){return Ui[0]=hl(),Ui[1]=hl(),e[0]}function a(h,c){n(h.length*3);let f=ih(h,i);return o(rh(0,f,c))}function u(){let h=s();function c(f){return a(f,h)}return c}return u}function t(){let e=new Uint8Array(65536);function i(s){e.byteLength<s&&(e=new Uint8Array(s+(65536-s%65536)))}function n(s,a){i(s.length*3);let u=ih(s,e);return nd(e.buffer,0,u,a)>>0}function o(){let s=hl();function a(u){return n(u,s)}return a}return o}return nh&&sd&&ap?l():t()}function hp(){function l(e){lp[0]=e;let i=Ui[0],n=Ui[1];return(i<<7|i>>>25)^n|0}function t(e){return e>>0===e?e|0:l(e)}return t}function cp(){function l(){let i=new BigUint64Array(oh),n=BigInt(0),o=BigInt(1),s=BigInt(2),a=BigInt(2)**BigInt(31)-BigInt(1),u=~a,h=BigInt(64);function c(f){if(f===n)return 0;if(f>=u&&f<=a)return Number(f);f=f<n?~f*s+o:f*s;let P=0;for(;f;)i[0]=f,P=(P<<7|P>>>25)^Ui[0],P=(P<<7|P>>>25)^Ui[1],f=f>>h;return P|0}return c}function t(){let i=BigInt(0),n=BigInt(1),o=BigInt(2),s=BigInt(2)**BigInt(31)-BigInt(1),a=~s,u=BigInt(32),h=BigInt("0xFFFFFFFF");function c(f){if(f===i)return 0;if(f>=a&&f<=s)return Number(f);f=f<i?~f*o+n:f*o;let P=0;for(;f!==i;)P=(P<<7|P>>>25)^Number(f&h),f>>=u,P=(P<<7|P>>>25)^Number(f&h),f>>=u;return P|0}return c}function e(){let i=Zo();function n(o){return i(o.toString())}return n}return nh&&sd?l():nh?t():e()}function dp(){let l="description"in Symbol.prototype?v=>v.description:v=>{let A=v.toString();return A.length>=8&&A.slice(0,7)==="Symbol("&&A.slice(-1)===")"?A.slice(7,-1):A},t=Zo(),e,i;try{new WeakMap().set(Symbol.iterator,null),e=new WeakMap,i=new WeakMap}catch{e=new Map,i=new Map}for(let v of Object.getOwnPropertyNames(Symbol))if(typeof v=="string"){let A=Symbol[v];typeof A=="symbol"&&i.set(A,`Symbol.${v}`)}let n=Zo(),o;try{new WeakMap().set(Symbol.for("@esfx/equatable!~globalSymbolTest"),null),o=new WeakMap}catch{o=new Map}let s=Zo(),a,u=1;try{new WeakMap().set(Symbol(),null),a=new WeakMap}catch{a=new Map}function h(v,A){let O=o.get(v);return O===void 0&&(O=n(A),o.set(v,O)),O}function c(v,A){let O=e.get(v);return O===void 0&&(O=t(A),e.set(v,O)),O}function f(v){let A=a.get(v);return A===void 0&&(A=s(`${u++}#${l(v)}`),a.set(v,A)),A}function P(v){let A=i.get(v);if(A!==void 0)return c(v,A);let O=Symbol.keyFor(v);return O!==void 0?h(v,O):f(v)}return P}function gp(){let l=new WeakMap,t=hl(),e=1;function i(o){return o=~o+(o<<15),o=o^o>>12,o=o+(o<<2),o=o^o>>4,o=o*2057,o=o^o>>16,o>>>0}function n(o){let s=l.get(o);return s===void 0&&(s=i(e++^t)^t,l.set(o,s)),s}return n}function hl(){return Math.floor(Math.random()*4294967295)>>>0}var cl=typeof globalThis=="object"?globalThis:typeof global=="object"?global:typeof self=="object"?self:void 0,ah=Symbol.for("@esfx/equatable!~hashUnknown"),dl;cl&&typeof cl[ah]=="function"?dl=cl[ah]:(dl=function(t){switch(typeof t){case"boolean":return t?1:0;case"number":return dd(t);case"bigint":return gd(t);case"string":return md(t);case"symbol":return fd(t);case"function":return sh(t);case"object":return t===null?0:sh(t);case"undefined":return 0;default:throw new TypeError(`Unsupported type: ${typeof t}`)}},Object.defineProperty(cl,ah,{value:dl}));function pd(l){return dl(l)}var xn;(function(l){l.equals=Symbol.for("@esfx/equatable:Equatable.equals"),l.hash=Symbol.for("@esfx/equatable:Equatable.hash"),l.name="Equatable";function t(e){let i;return e!=null&&l.equals in(i=Object(e))&&l.hash in i}l.hasInstance=t,Object.defineProperty(l,Symbol.hasInstance,{configurable:!0,writable:!0,value:t})})(xn||(xn={}));var _o;(function(l){l.compareTo=Symbol.for("@esfx/equatable:Comparable.compareTo"),l.name="Comparable";function t(e){return e!=null&&l.compareTo in Object(e)}l.hasInstance=t,Object.defineProperty(l,Symbol.hasInstance,{configurable:!0,writable:!0,value:t})})(_o||(_o={}));var wn;(function(l){l.structuralEquals=Symbol.for("@esfx/equatable:StructualEquatable.structuralEquals"),l.structuralHash=Symbol.for("@esfx/equatable:StructuralEquatable.structuralHash"),l.name="StructuralEquatable";function t(e){let i;return e!=null&&l.structuralEquals in(i=Object(e))&&l.structuralHash in i}l.hasInstance=t,Object.defineProperty(l,Symbol.hasInstance,{configurable:!0,writable:!0,value:t})})(wn||(wn={}));var es;(function(l){l.structuralCompareTo=Symbol.for("@esfx/equatable:StructuralComparable.structuralCompareTo"),l.name="StructuralComparable";function t(e){return e!=null&&l.structuralCompareTo in Object(e)}l.hasInstance=t,Object.defineProperty(l,Symbol.hasInstance,{configurable:!0,writable:!0,value:t})})(es||(es={}));var Nt;(function(l){let t=Object.defineProperty({},Symbol.toStringTag,{configurable:!0,value:"Equaler"});l.defaultEqualer=e((o,s)=>xn.hasInstance(o)?o[xn.equals](s):xn.hasInstance(s)?s[xn.equals](o):Object.is(o,s),o=>xn.hasInstance(o)?o[xn.hash]():fp(o)),l.structuralEqualer=e((o,s)=>wn.hasInstance(o)?o[wn.structuralEquals](s,l.structuralEqualer):wn.hasInstance(s)?s[wn.structuralEquals](o,l.structuralEqualer):l.defaultEqualer.equals(o,s),o=>wn.hasInstance(o)?o[wn.structuralHash](l.structuralEqualer):l.defaultEqualer.hash(o)),l.tupleEqualer=e((o,s)=>{if(o!=null&&!Array.isArray(o)||s!=null&&!Array.isArray(s))throw new TypeError("Array expected");if(o===s)return!0;if(!o||!s||o.length!==s.length)return!1;for(let a=0;a<o.length;a++)if(!l.defaultEqualer.equals(o[a],s[a]))return!1;return!0},o=>{if(o==null)return 0;if(!Array.isArray(o))throw new TypeError("Array expected");let s=0;for(let a of o)s=i(s,l.defaultEqualer.hash(a));return s}),l.tupleStructuralEqualer=e((o,s)=>{if(o!=null&&!Array.isArray(o)||s!=null&&!Array.isArray(s))throw new TypeError("Array expected");if(o===s)return!0;if(!o||!s||o.length!==s.length)return!1;for(let a=0;a<o.length;a++)if(!l.structuralEqualer.equals(o[a],s[a]))return!1;return!0},o=>{if(o==null)return 0;if(!Array.isArray(o))throw new TypeError("Array expected");let s=0;for(let a of o)s=i(s,l.structuralEqualer.hash(a));return s});function e(o,s=l.defaultEqualer.hash){return Object.setPrototypeOf({equals:o,hash:s},t)}l.create=e;function i(o,s,a=7){if(typeof o!="number")throw new TypeError("Integer expected: x");if(typeof s!="number")throw new TypeError("Integer expected: y");if(typeof a!="number")throw new TypeError("Integer expected: rotate");if(isNaN(o)||!isFinite(o))throw new RangeError("Argument must be a finite number value: x");if(isNaN(s)||!isFinite(s))throw new RangeError("Argument must be a finite number value: y");if(isNaN(a)||!isFinite(a))throw new RangeError("Argument must be a finite number value: rotate");for(;a<0;)a+=32;for(;a>=32;)a-=32;return(o<<a|o>>>32-a)^s}l.combineHashes=i;function n(o){return typeof o=="object"&&o!==null&&typeof o.equals=="function"&&typeof o.hash=="function"}l.hasInstance=n,Object.defineProperty(l,Symbol.hasInstance,{configurable:!0,writable:!0,value:n})})(Nt||(Nt={}));var Pw=Nt.defaultEqualer,yw=Nt.structuralEqualer,Sw=Nt.tupleEqualer,Cw=Nt.tupleEqualer,Ew=Nt.combineHashes,Vr;(function(l){let t=Object.defineProperty({},Symbol.toStringTag,{configurable:!0,value:"Comparer"});l.defaultComparer=e((n,o)=>_o.hasInstance(n)?n[_o.compareTo](o):_o.hasInstance(o)?-o[_o.compareTo](n):n<o?-1:n>o?1:0),l.structuralComparer=e((n,o)=>es.hasInstance(n)?n[es.structuralCompareTo](o,l.structuralComparer):es.hasInstance(o)?-o[es.structuralCompareTo](n,l.structuralComparer):l.defaultComparer.compare(n,o)),l.tupleComparer=e((n,o)=>{if(n!=null&&!Array.isArray(n)||o!=null&&!Array.isArray(o))throw new TypeError("Array expected");let s;if(s=l.defaultComparer.compare(n.length,o.length))return s;for(let a=0;a<n.length;a++)if(s=l.defaultComparer.compare(n[a],o[a]))return s;return 0}),l.tupleStructuralComparer=e((n,o)=>{if(n!=null&&!Array.isArray(n)||o!=null&&!Array.isArray(o))throw new TypeError("Array expected");let s;if(s=l.defaultComparer.compare(n.length,o.length))return s;for(let a=0;a<n.length;a++)if(s=l.structuralComparer.compare(n[a],o[a]))return s;return 0});function e(n){return Object.setPrototypeOf({compare:n},t)}l.create=e;function i(n){return typeof n=="object"&&n!==null&&typeof n.compare=="function"}l.hasInstance=i,Object.defineProperty(l,Symbol.hasInstance,{configurable:!0,writable:!0,value:i})})(Vr||(Vr={}));var vw=Vr.defaultComparer,Aw=Vr.structuralComparer,Iw=Vr.tupleComparer,xw=Vr.tupleStructuralComparer;function fp(l){return pd(l)}var bd,gl=function(){var l={exports:{}};return function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});function n(o,s,a){if(o.length===0)return-1;let u=0,h=o.length-1;for(;u<=h;){let c=u+(h-u>>1),f=o[c];switch(Math.sign(a.compare(f,s))){case-1:u=c+1;break;case 0:return c;case 1:h=c-1;break}}return~u}e.binarySearch=n}(l,l.exports,null),l.exports}(),Ei=class{constructor(...t){this._keys=[],this._values=[];let e,i;if(t.length>0){let n=t[0];n===void 0||n!=null&&Symbol.iterator in Object(n)?(e=n,t.length>1&&(i=t[1])):i=n}if(i??(i=Vr.defaultComparer),this._comparer=typeof i=="function"?Vr.create(i):i,e)for(let[n,o]of e)this.set(n,o)}get comparer(){return this._comparer}get size(){return this._keys.length}has(t){return(0,gl.binarySearch)(this._keys,t,this._comparer)>=0}get(t){let e=(0,gl.binarySearch)(this._keys,t,this._comparer);return e>=0?this._values[e]:void 0}set(t,e){let i=(0,gl.binarySearch)(this._keys,t,this._comparer);return i>=0?this._values[i]=e:(this._keys.splice(~i,0,t),this._values.splice(~i,0,e)),this}delete(t){let e=(0,gl.binarySearch)(this._keys,t,this._comparer);return e>=0?(this._keys.splice(e,1),this._values.splice(e,1),!0):!1}clear(){this._keys.length=0,this._values.length=0}keys(){return this._keys.values()}values(){return this._values.values()}*entries(){for(let t=0;t<this._keys.length;t++)yield[this._keys[t],this._values[t]]}[Symbol.iterator](){return this.entries()}forEach(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");for(let[i,n]of this)t.call(e,n,i,this)}get[rr.size](){return this.size}[rr.has](t){return this.has(t)}[rr.get](t){return this.get(t)}[rr.set](t,e){this.set(t,e)}[rr.delete](t){return this.delete(t)}[rr.clear](){this.clear()}[rr.keys](){return this.keys()}[rr.values](){return this.values()}};bd=Ei;Object.defineProperty(bd.prototype,Symbol.toStringTag,{configurable:!0,writable:!0,value:"SortedMap"});var pt=class{static RefinePaths(t,e){pt.AdjustPaths(t);let i=pt.CreatePathsToFirstLinkedVerticesMap(t);pt.Refine(Array.from(i.values())),pt.CrossVerticalAndHorizontalSegs(i.values()),pt.ReconstructPathsFromLinkedVertices(i),e&&new qi(t).MergePaths()}static AdjustPaths(t){for(let e of t)e.PathPoints=pt.AdjustPathPoints(e.PathPoints)}static AdjustPathPoints(t){if(!t||t.length===0)return;let e=[],i=d.RoundPoint(t[0]);e.push(i);for(let n=1;n<t.length;n++){let o=d.RoundPoint(t[n]);i.equal(o)||(i=o,e.push(i))}return e}static CrossVerticalAndHorizontalSegs(t){let e=new Array,i=new Array;for(let n of t)for(let o=n;o.Next!=null;o=o.Next)Q(o.Point.x,o.Next.Point.x)?i.push(o):e.push(o);new Er(e,i).SplitPoints()}static ReconstructPathsFromLinkedVertices(t){for(let[e,i]of t)e.PathPoints=i}static Refine(t){pt.RefineInDirection(1,t),pt.RefineInDirection(2,t)}static*groupByProj(t,e){let i=new Map;for(let n of e){let o=t(n.Point),s=i.get(o);s||(s=new Array,i.set(o,s)),s.push(n)}for(let n of i.values())yield n}static RefineInDirection(t,e){let i={projectionToPerp:void 0,projectionToDirection:void 0};pt.GetProjectionsDelegates(t,i);let n=Array.from(pt.GetAllLinkedVertsInDirection(i.projectionToPerp,e)),o=pt.groupByProj(i.projectionToPerp,n);for(let s of o)pt.RefineCollinearBucket(s,i.projectionToDirection)}static GetProjectionsDelegates(t,e){t===2?(e.projectionToDirection=i=>i.x,e.projectionToPerp=i=>i.y):(e.projectionToPerp=i=>i.x,e.projectionToDirection=i=>i.y)}static*GetAllLinkedVertsInDirection(t,e){for(let i of e)for(let n=i;n.Next!=null;n=n.Next)Q(t(n.Point),t(n.Next.Point))&&(yield n)}static RefineCollinearBucket(t,e){let i=new Ei(new ll(e));for(let s of t)i.has(s.Point)||i.set(s.Point,0),i.has(s.Next.Point)||i.set(s.Next.Point,0);let n=new Array(i.size),o=0;for(let s of i.keys())n[o++]=s;for(o=0;o<n.length;o++)i.set(n[o],o);for(let s of t){o=i.get(s.Point);let a=i.get(s.Next.Point);Math.abs(a-o)>1&&pt.InsertPoints(s,n,o,a)}}static InsertPoints(t,e,i,n){i<n?t.InsertVerts(i,n,e):t.InsertVertsInReverse(n,i,e)}static CreatePathsToFirstLinkedVerticesMap(t){let e=new Map;for(let i of t)e.set(i,pt.CreateLinkedVertexOfEdgePath(i));return e}static CreateLinkedVertexOfEdgePath(t){let e=t.PathPoints,i=new er(e[0]),n=i;for(let o=1;o<e.length;o++)i.Next=new er(e[o]),i=i.Next;return n}};var vi=class{constructor(t,e){this.Points=t,this.I=e}static equal(t,e){return t.I===e.I&&t.Points===e.Points}get Start(){return this.Points[this.I]}get End(){return this.Points[this.I+1]}};var Ai=class{constructor(t,e){this.segTree=new mi(null);this.crossedOutPaths=new Set;this.HierarchyOfObstacles=new mi(e),this.Paths=t}static RemoveStaircases(t,e){new Ai(t,e).Calculate()}Calculate(){this.InitHierarchies();let t;do{t=!1;for(let e of this.Paths.filter(i=>!this.crossedOutPaths.has(i)))this.ProcessPath(e)&&(t=!0)}while(t)}ProcessPath(t){let e={pts:t.PathPoints,canHaveStaircase:!1};return this.ProcessPoints(e)?(t.PathPoints=e.pts,!0):(e.canHaveStaircase||this.crossedOutPaths.add(t),!1)}ProcessPoints(t){let e=this.FindStaircaseStart(t);return e<0?!1:(t.pts=this.RemoveStaircasePN(t.pts,e),!0)}FindStaircaseStart(t){if(t.canHaveStaircase=!1,t.pts.length<5)return-1;let e=[new vi(t.pts,0),new vi(t.pts,1),new vi(t.pts,2),new vi(t.pts,3)],i=0;for(let n=0;;){let o={canHaveStaircaseAtI:!1};if(this.IsStaircase(t.pts,n,e,o))return t.canHaveStaircase=!0,n;if(t.canHaveStaircase=t.canHaveStaircase||o.canHaveStaircaseAtI,n++,t.pts.length<n+5)return-1;e[i]=new vi(t.pts,n+3),i++,i%=4}}static GetFlippedPoint(t,e){return Q(t[e].y,t[e+1].y)?new d(t[e+4].x,t[e].y):new d(t[e].x,t[e+4].y)}Crossing(t,e,i){return Ai.IsCrossing(w.mkPP(t,e),this.segTree,i)}static IsCrossing(t,e,i){for(let n of e.GetAllIntersecting(t.boundingBox))if(i.findIndex(o=>o===n)===-1)return!0;return!1}IntersectObstacleHierarchyPPP(t,e,i){return this.IntersectObstacleHierarchyL(w.mkPP(t,e))||this.IntersectObstacleHierarchyL(w.mkPP(e,i))}IntersectObstacleHierarchyL(t){return this.HierarchyOfObstacles.GetAllIntersecting(t.boundingBox).some(e=>E.intersectionOne(t,e,!1)!=null)}IsStaircase(t,e,i,n){let o=t[e],s=t[e+1],a=t[e+2],u=t[e+3],h=t[e+4];return n.canHaveStaircaseAtI=!1,F.DirectionFromPointToPoint(o,s)!==F.DirectionFromPointToPoint(a,u)||F.DirectionFromPointToPoint(s,a)!==F.DirectionFromPointToPoint(u,h)||(a=Ai.GetFlippedPoint(t,e),this.IntersectObstacleHierarchyPPP(s,a,u))?!1:(n.canHaveStaircaseAtI=!0,!this.Crossing(s,a,i))}RemoveStaircasePN(t,e){let i=t[e],n=t[e+1],o=Math.abs(i.y-n.y)<C.distanceEpsilon/2;return this.RemoveStaircasePNB(t,e,o)}RemoveStaircasePNB(t,e,i){this.RemoveSegs(t);let n=new Array(t.length-2);bp(t,n,e+1);let o=t[e+1],s=t[e+3];return n[e+1]=i?new d(s.x,o.y):new d(o.x,s.y),pp(t,e+4,n,e+2,n.length-e-2),this.InsertNewSegs(n,e),n}RemoveSegs(t){for(let e=0;e<t.length-1;e++)this.RemoveSeg(new vi(t,e))}RemoveSeg(t){this.segTree.Remove(Ai.Rect(t),t)}InsertNewSegs(t,e){this.InsSeg(t,e),this.InsSeg(t,e+1)}InitHierarchies(){for(let t of this.Paths)this.InsertPathSegs(t)}InsertPathSegs(t){this.InsertSegs(t.PathPoints)}InsertSegs(t){for(let e=0;e<t.length-1;e++)this.InsSeg(t,e)}InsSeg(t,e){let i=new vi(t,e);this.segTree.Add(Ai.Rect(i),i)}static Rect(t){return D.mkPP(t.Start,t.End)}};function pp(l,t,e,i,n){for(;n-- >0;)e[i++]=l[t++]}function bp(l,t,e){let i=0;for(;e-- >0;)t[i++]=l[i++]}var Ne=class{get HasGroups(){return this.HierarchyOfGroups!=null&&this.HierarchyOfGroups.Count>0}constructor(t,e,i,n){this.AncestorsSets=n,this.HierarchyOfGroups=Oe(Array.from(n.keys()).filter(o=>o.IsGroup).map(o=>Fe(o,o.BoundingBox))),this.Obstacles=i,this.EdgeSeparation=2*e,this.Paths=t,this.HierarchyOfObstacles=Oe(i.map(o=>Fe(o,o.boundingBox))),this.MapPathsToTheirObstacles()}MapPathsToTheirObstacles(){this.PathToObstacles=new Map;for(let t of this.Paths)this.MapPathToItsObstacles(t)}MapPathToItsObstacles(t){if(!t.PathPoints||t.PathPoints.length===0)return;let e=t.PathPoints,i=this.HierarchyOfObstacles.FirstHitNodeWithPredicate(e[0],Ne.ObstacleTest),n=this.HierarchyOfObstacles.FirstHitNodeWithPredicate(e[e.length-1],Ne.ObstacleTest);i!=null&&n!=null&&this.PathToObstacles.set(t,[i.UserData,n.UserData])}static ObstacleTest(t,e){return E.PointRelativeToCurveLocation(t,e)!==0?1:0}Calculate(t,e){this.NudgingDirection=t,pt.RefinePaths(this.Paths,e),this.GetPathOrdersAndPathGraph(),this.MapAxisEdgesToTheirObstacles(),this.DrawPaths()}MapAxisEdgesToTheirObstacles(){this.axisEdgesToObstaclesTheyOriginatedFrom=new Map;for(let t of this.Paths)this.MapPathEndAxisEdgesToTheirObstacles(t);for(let t of this.Paths)this.UmmapPathInteriourFromStrangerObstacles(t)}UmmapPathInteriourFromStrangerObstacles(t){let e=this.FindFirstUnmappedEdge(t);if(e==null)return;let i=this.FindLastUnmappedEdge(t);for(let n=e;n!=null&&n!==i;n=n.Next)this.axisEdgesToObstaclesTheyOriginatedFrom.delete(n.AxisEdge)}FindLastUnmappedEdge(t){for(let e=t.LastEdge;e!=null;e=e.Prev)if(e.AxisEdge.Direction!==this.NudgingDirection)return e;return null}FindFirstUnmappedEdge(t){for(let e=t.FirstEdge;e!=null;e=e.Next)if(e.AxisEdge.Direction!==this.NudgingDirection)return e;return null}MapPathEndAxisEdgesToTheirObstacles(t){let e=this.PathToObstacles.get(t);e&&(this.ProcessThePathStartToMapAxisEdgesToTheirObstacles(t,e[0]),this.ProcessThePathEndToMapAxisEdgesToTheirObstacles(t,e[1]))}ProcessThePathEndToMapAxisEdgesToTheirObstacles(t,e){for(let i=t.LastEdge;i!=null&&F.DirectionsAreParallel(i.Direction,this.NudgingDirection);i=i.Prev)this.axisEdgesToObstaclesTheyOriginatedFrom.set(i.AxisEdge,e)}ProcessThePathStartToMapAxisEdgesToTheirObstacles(t,e){for(let i=t.FirstEdge;i!=null&&F.DirectionsAreParallel(i.Direction,this.NudgingDirection);i=i.Next)this.axisEdgesToObstaclesTheyOriginatedFrom.set(i.AxisEdge,e)}GetPathOrdersAndPathGraph(){let t=new Vs(this.Paths);this.PathOrders=t.GetOrder(),this.PathVisibilityGraph=t.PathVisibilityGraph}static GetCurvesForShow(t,e){let i=new Array;for(let n of t){let o=new j;for(let s of n.PathPoints)o.addPoint(s);i.push(o)}return i.concat(Array.from(e))}DrawPaths(){this.SetWidthsOfArrowheads(),this.CreateLongestNudgedSegments(),this.FindFreeSpaceInDirection(Array.from(this.PathVisibilityGraph.Edges)),this.MoveLongestSegsIdealPositionsInsideFeasibleIntervals(),this.PositionShiftedEdqges()}SetWidthsOfArrowheads(){for(let t of this.Paths)Ne.SetWidthsOfArrowheadsForEdge(t)}static SetWidthsOfArrowheadsForEdge(t){let e=t.GeomEdge;if(e.targetArrowhead!=null){let i=t.LastEdge;i.Width=Math.max(e.targetArrowhead.width,i.Width)}if(e.sourceArrowhead!=null){let i=t.FirstEdge;i.Width=Math.max(e.sourceArrowhead.width,i.Width)}}PositionShiftedEdqges(){this.Solver=new il(this.EdgeSeparation);for(let t=0;t<this.LongestNudgedSegs.length;t++)this.CreateVariablesOfLongestSegment(this.LongestNudgedSegs[t]);this.CreateConstraintsOfTheOrder(),this.CreateConstraintsBetweenLongestSegments(),this.Solver.SolveByRegularSolver(),this.ShiftPathEdges()}MoveLongestSegsIdealPositionsInsideFeasibleIntervals(){for(let t=0;t<this.LongestNudgedSegs.length;t++){let e=this.LongestNudgedSegs[t];Ne.MoveLongestSegIdealPositionsInsideFeasibleInterval(e)}}static MoveLongestSegIdealPositionsInsideFeasibleInterval(t){if(t.IsFixed)return;let e=t.GetLeftBound(),i=t.GetRightBound();t.IdealPosition<e?t.IdealPosition=e:t.IdealPosition>i&&(t.IdealPosition=i)}ShiftPathEdges(){for(let t of this.Paths)t.PathPoints=this.GetShiftedPoints(t)}GetShiftedPoints(t){return Ne.RemoveSwitchbacksAndMiddlePoints(this.GetShiftedPointsSimple(t))}static Rectilinearise(t,e){if(t.x===e.x||t.y===e.y)return e;let i=Math.abs(t.x-e.x),n=Math.abs(t.y-e.y);return i<n?new d(t.x,e.y):new d(e.x,t.y)}GetShiftedPointsSimple(t){let e=[],i=t.FirstEdge;e.push(this.ShiftedPoint(i.Source,i.LongestNudgedSegment));for(let n of t.PathEdges())e.push(this.ShiftedEdgePositionOfTarget(n));return e}ShiftedEdgePositionOfTarget(t){return t.LongestNudgedSegment!=null||t.Next==null?this.ShiftedPoint(t.Target,t.LongestNudgedSegment):this.ShiftedPoint(t.Next.Source,t.Next.LongestNudgedSegment)}ShiftedPoint(t,e){if(e==null)return t;let i=this.Solver.GetVariablePosition(e.Id);return this.NudgingDirection===1?new d(i,t.y):new d(t.x,-i)}static LineSegOfLongestSeg(t,e){let i=e===2?o=>o.x:o=>o.y,n={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};for(let o of t.Edges)Ne.UpdateMinMaxWithPoint(n,i,o.Source),Ne.UpdateMinMaxWithPoint(n,i,o.Target);return e===2?new w(n.min,-t.IdealPosition,n.max,-t.IdealPosition):new w(t.IdealPosition,n.min,t.IdealPosition,n.max)}static UpdateMinMaxWithPoint(t,e,i){let n=e(i);t.min>n&&(t.min=n),t.max<n&&(t.max=n)}CreateConstraintsBetweenLongestSegments(){for(let t of this.LongestNudgedSegs)this.CreateConstraintsBetweenLongestSegmentsForSegment(t)}CreateConstraintsBetweenLongestSegmentsForSegment(t){let e=new Set;for(let i of t.Edges){let n=i.AxisEdge;if(n!=null)for(let o of n.RightNeighbors)for(let s of o.LongestNudgedSegments)e.add(s)}for(let i of e)this.ConstraintTwoLongestSegs(t,i)}CreateConstraintsOfTheOrder(){for(let t of this.PathOrders)Ne.ParallelToDirection(t[0],this.NudgingDirection)&&this.CreateConstraintsOfThePathOrder(t[1])}static ParallelToDirection(t,e){switch(e){case 1:case 4:return Q(t.SourcePoint.x,t.TargetPoint.x);default:return Q(t.SourcePoint.y,t.TargetPoint.y)}}CreateConstraintsOfThePathOrder(t){let e=null;for(let i of t.filter(n=>n.LongestNudgedSegment!=null))e!=null&&this.ConstraintTwoLongestSegs(e.LongestNudgedSegment,i.LongestNudgedSegment),e=i}ConstraintTwoLongestSegs(t,e){(!t.IsFixed||!e.IsFixed)&&this.Solver.AddConstraint(t.Id,e.Id)}CreateVariablesOfLongestSegment(t){if(t.IsFixed)this.Solver.AddFixedVariable(t.Id,Ne.SegmentPosition(t,this.NudgingDirection));else{let e=t.GetLeftBound(),i=t.GetRightBound();e>=i?(this.Solver.AddFixedVariable(t.Id,Ne.SegmentPosition(t,this.NudgingDirection)),t.IsFixed=!0):(this.Solver.AddVariableNNNN(t.Id,Ne.SegmentPosition(t,this.NudgingDirection),t.IdealPosition,t.Width),e!==Number.NEGATIVE_INFINITY&&this.Solver.SetLowBound(e,t.Id),i!==Number.POSITIVE_INFINITY&&this.Solver.SetUpperBound(t.Id,i))}}static SegmentPosition(t,e){return e===1?t.Start.x:-t.Start.y}FindFreeSpaceInDirection(t){this.BoundAxisEdgesByRectsKnownInAdvance(),new Ms(this.NudgingDirection,this.Obstacles,this.axisEdgesToObstaclesTheyOriginatedFrom,this.PathOrders,t).FindFreeSpace()}BoundAxisEdgesByRectsKnownInAdvance(){for(let t of this.Paths)this.HasGroups&&this.BoundPathByMinCommonAncestors(t),this.BoundAxisEdgesAdjacentToSourceAndTargetOnEdge(t)}BoundPathByMinCommonAncestors(t){for(let e of this.GetMinCommonAncestors(t.GeomEdge)){let i=e.BoundingBox;for(let n of t.PathEdges()){let o=n.AxisEdge;o.Direction===this.NudgingDirection&&this.BoundAxisEdgeByRect(i,o)}}}GetMinCommonAncestors(t){this.PortToShapes==null&&(this.PortToShapes=Ne.MapPortsToShapes(this.AncestorsSets.keys()));let e=Pp(this.AncestorsForPort(t.sourcePort),this.AncestorsForPort(t.targetPort));return Array.from(e).filter(i=>!i.Children.some(n=>e.has(n)))}AncestorsForPort(t){let e=this.PortToShapes.get(t);return e?this.AncestorsSets.get(e):new Set(this.HierarchyOfGroups.AllHitItems(D.mkPP(t.Location,t.Location),null))}BoundAxisEdgeAdjacentToObstaclePort(t,e){t.Curve==null?this.BoundAxisByPoint(t.Location,e):t.Curve.boundingBox.contains(t.Location)&&this.BoundAxisEdgeByRect(t.Curve.boundingBox,e)}BoundAxisByPoint(t,e){e!=null&&e.Direction===this.NudgingDirection&&(this.NudgingDirection===1?(e.BoundFromLeft(t.x),e.BoundFromRight(t.x)):(e.BoundFromLeft(-t.y),e.BoundFromRight(-t.y)))}BoundAxisEdgesAdjacentToSourceAndTargetOnEdge(t){this.BoundAxisEdgeAdjacentToObstaclePort(t.GeomEdge.sourcePort,t.FirstEdge.AxisEdge),this.BoundAxisEdgeAdjacentToObstaclePort(t.GeomEdge.targetPort,t.LastEdge.AxisEdge)}BoundAxisEdgeByRect(t,e){e!=null&&e.Direction===this.NudgingDirection&&(this.NudgingDirection===1?(e.BoundFromLeft(t.left),e.BoundFromRight(t.right)):(e.BoundFromLeft(t.top*-1),e.BoundFromRight(t.bottom*-1)))}CreateLongestNudgedSegments(){let t=this.NudgingDirection===2?e=>-e.y:e=>e.x;this.LongestNudgedSegs=new Array;for(let e=0;e<this.Paths.length;e++)this.CreateLongestNudgedSegmentsForPath(this.Paths[e],t)}CreateLongestNudgedSegmentsForPath(t,e){this.GoOverPathAndCreateLongSegs(t),Ne.CalculateIdealPositionsForLongestSegs(t,e)}static CalculateIdealPositionsForLongestSegs(t,e){let i=null,n=null,o=e(t.Start);for(let s of t.PathEdges())if(s.LongestNudgedSegment!=null){if(i=s.LongestNudgedSegment,n!=null){let a;Ne.SetIdealPositionForSeg(n,a=e(n.start),o,e(i.Start)),o=a,n=null}}else i!=null&&(n=i,i=null);n!=null?Ne.SetIdealPositionForSeg(n,e(n.Start),o,e(t.End)):i!=null&&(i.IdealPosition=e(i.Start))}static SetIdealPositionForSeg(t,e,i,n){let o=Math.max(i,n),s=Math.min(i,n);s+C.distanceEpsilon<e?e<o?t.IdealPosition=.5*(o+s):t.IdealPosition=o:t.IdealPosition=s}GoOverPathAndCreateLongSegs(t){let e=null,i=F.OppositeDir(this.NudgingDirection);for(let n of t.PathEdges()){let o=n.Direction;o===this.NudgingDirection||o===i?(e==null?(n.LongestNudgedSegment=e=new al(this.LongestNudgedSegs.length),this.LongestNudgedSegs.push(e)):n.LongestNudgedSegment=e,n.IsFixed&&(e.IsFixed=!0)):(n.LongestNudgedSegment=null,e=null)}}static BuildPolylineForPath(t){let e={points:t.PathPoints.map(i=>i.clone())};return Ne.ExtendPolylineToPorts(e,t),e.points}static ExtendPolylineToPorts(t,e){Ne.ExtendPolylineToSourcePort(t,e.GeomEdge.sourcePort.Location),Ne.ExtendPolylineToTargetPort(t,e.GeomEdge.targetPort.Location),t.points.length<2&&(t.points=new Array(2),t.points[0]=e.GeomEdge.sourcePort.Location,t.points[1]=e.GeomEdge.targetPort.Location)}static ExtendPolylineToTargetPort(t,e){let i=t.points.length-1,n=F.VectorDirectionPP(t.points[i-1],t.points[i]);if(Ne.ProjectionsAreClose(t.points[i-1],n,e)){t.points=t.points.slice(0,i);return}let o=t.points[i];n===2||n===8?t.points[i]=new d(e.x,o.y):t.points[i]=new d(o.x,e.y)}static ProjectionsAreClose(t,e,i){return e===2||e===8?Q(t.x,i.x):Q(t.y,i.y)}static ExtendPolylineToSourcePort(t,e){let i=F.VectorDirectionPP(t.points[0],t.points[1]);if(Ne.ProjectionsAreClose(t.points[1],i,e)){t.points=t.points.slice(1);return}let n=t.points[0];i===2||i===8?t.points[0]=new d(e.x,n.y):t.points[0]=new d(n.x,e.y)}static RemoveSwitchbacksAndMiddlePoints(t){let e=[],i=t[0];e.push(i);let n=t[1],o=F.VectorDirectionPP(i,n),s=1;for(;++s<t.length;){let a=F.VectorDirectionPP(n,t[s]);a===o||F.OppositeDir(a)===o||a===0||(d.closeDistEps(i,n)||e.push(i=Ne.Rectilinearise(i,n)),o=a),n=t[s]}return d.closeDistEps(i,n)||e.push(Ne.Rectilinearise(i,n)),e}static NudgePaths(t,e,i,n,o){if(t.length===0)return;let s=new Ne(t,e,i,n);s.Calculate(1,!0),s.Calculate(2,!1),s.Calculate(1,!1),o&&s.RemoveStaircases();for(let a of t)a.GeomEdge.curve=j.mkFromPoints(Ne.BuildPolylineForPath(a))}RemoveStaircases(){Ai.RemoveStaircases(this.Paths,this.HierarchyOfObstacles)}static MapPortsToShapes(t){let e=new Map;for(let i of t)for(let n of i.Ports)e.set(n,i);return e}static*GetEdgePathFromPathEdgesAsDebugCurves(t,e,i,n){let o=n.ArrayOfPathPoints(),s=o.length,a=s>1?(e-t)/(s-1):1;for(let u=0;u<o.length-1;u++)yield oe.mkDebugCurveTWCI(200,t+a*u,i,w.mkPP(o[u],o[u+1]))}};function Pp(l,t){let e=new Set;if(l.size<t.size)for(let i of l)t.has(i)&&e.add(i);else for(let i of t)l.has(i)&&e.add(i);return e}var Pd=he(gt(),1);var ml=class{constructor(t,e){this.Crossings=[];this.Location=t,this.Crossings=e}};var Ii=class{constructor(){this.ListOfPointsAndCrossings=[];this.index=0;this.ListOfPointsAndCrossings=new Array}Count(){return this.ListOfPointsAndCrossings.length}Add(t,e){this.ListOfPointsAndCrossings.push(new ml(t,e))}Pop(){return this.ListOfPointsAndCrossings[this.index++]}CurrentIsBeforeOrAt(t){return this.index>=this.ListOfPointsAndCrossings.length?!1:B.ComparePP(this.ListOfPointsAndCrossings[this.index].Location,t)<=0}get First(){return this.ListOfPointsAndCrossings[0]}get Last(){return this.ListOfPointsAndCrossings[this.ListOfPointsAndCrossings.length-1]}Reset(){this.index=0}MergeFrom(t){if(this.Reset(),t==null)return;let e=this.ListOfPointsAndCrossings.length,i=0,n=t.ListOfPointsAndCrossings.length,o=0,s=new Array(this.ListOfPointsAndCrossings.length);for(;i<e||o<n;){if(i>=e){s.push(t.ListOfPointsAndCrossings[o++]);continue}if(o>=n){s.push(this.ListOfPointsAndCrossings[i++]);continue}let a=this.ListOfPointsAndCrossings[i],u=t.ListOfPointsAndCrossings[o],h=B.ComparePP(a.Location,u.Location);h===0?(s.push(a),++i,++o):h===-1?(s.push(a),++i):(s.push(u),++o)}this.ListOfPointsAndCrossings=s}Trim(t,e){this.Reset(),!(this.ListOfPointsAndCrossings==null||this.ListOfPointsAndCrossings.length===0)&&(this.ListOfPointsAndCrossings=this.ListOfPointsAndCrossings.filter(i=>B.ComparePP(i.Location,t)>=0&&B.ComparePP(i.Location,e)<=0))}static ToCrossingArray(t,e){let i=0,n=t.length;for(let a=0;a<n;a++)t[a].DirectionToInside===e&&i++;if(i===0)return null;let o=new Array(i),s=0;for(let a=0;a<n;a++)t[a].DirectionToInside===e&&(o[s++]=t[a]);return o}ToString(){return Pd.String.Format("{0} [{1}]",this.ListOfPointsAndCrossings.length,this.index)}};var H=class{static EdgeDirectionVE(t){return H.EdgeDirectionVV(t.Source,t.Target)}static EdgeDirectionVV(t,e){return B.GetDirections(t.point,e.point)}static GetEdgeEnd(t,e){let i=H.EdgeDirectionVE(t);return e===i?t.Target:t.Source}static FindAdjacentVertex(t,e){for(let i of t.InEdges)if(B.GetDirections(t.point,i.SourcePoint)===e)return i.Source;for(let i of t.OutEdges)if(B.GetDirections(t.point,i.TargetPoint)===e)return i.Target;return null}static FindAdjacentEdge(t,e){for(let i of t.InEdges)if(B.GetDirections(i.SourcePoint,t.point)===e)return i;for(let i of t.OutEdges)if(B.GetDirections(t.point,i.TargetPoint)===e)return i;return null}static FindBendPointBetween(t,e,i){return H.IsVerticalD(i)?new d(e.x,t.y):new d(t.x,e.y)}static SegmentIntersectionPPP(t,e,i){let n=B.GetDirections(t,e);return H.IsVerticalD(n)?new d(t.x,i.y):new d(i.x,t.y)}static SegmentIntersectionSP(t,e){return H.SegmentIntersectionPPP(t.Start,t.End,e)}static SegmentsIntersection(t,e){return H.IntervalsIntersect(t.Start,t.End,e.Start,e.End)}static SegmentsIntersectLL(t,e){return H.IntervalsIntersect(t.start,t.end,e.start,e.end)}static IntervalsOverlapSS(t,e){return H.IntervalsOverlapPPPP(t.Start,t.End,e.Start,e.End)}static IntervalsOverlapPPPP(t,e,i,n){return H.IntervalsAreCollinear(t,e,i,n)&&B.ComparePP(t,n)!==B.ComparePP(e,i)}static IntervalsAreCollinear(t,e,i,n){let o=H.IsVerticalPP(t,e);return H.IsVerticalPP(i,n)===o?o?B.Equal(t.x,i.x):B.Equal(t.y,i.y):!1}static IntervalsAreSame(t,e,i,n){return B.EqualPP(t,i)&&B.EqualPP(e,n)}static IntervalsIntersect(t,e,i,n){let o=H.SegmentIntersectionPPP(t,e,i);return H.PointIsOnSegmentPPP(t,e,o)&&H.PointIsOnSegmentPPP(i,n,o)?o:void 0}static SegmentIntersectionEP(t,e){return H.SegmentIntersectionPPP(t.SourcePoint,t.TargetPoint,e)}static PointIsOnSegmentPPP(t,e,i){return B.EqualPP(t,i)||B.EqualPP(e,i)||B.GetDirections(t,i)===B.GetDirections(i,e)}static PointIsOnSegmentSP(t,e){return H.PointIsOnSegmentPPP(t.Start,t.End,e)}static IsVerticalD(t){return(t&5)!==0}static IsVerticalE(t){return H.IsVerticalD(B.GetDirections(t.SourcePoint,t.TargetPoint))}static IsVerticalPP(t,e){return H.IsVerticalD(B.GetDirections(t,e))}static IsVertical(t){return H.IsVerticalD(B.GetDirections(t.start,t.end))}static IsAscending(t){return(t&3)!==0}static Slope(t,e,i){let n=e.sub(t);return n.dot(i.PerpDirectionAsPoint)/n.dot(i.DirectionAsPoint)}static SortAscending(t,e){let i=B.GetDirections(t,e);return 0===i||H.IsAscending(i)?[t,e]:[e,t]}static RectangleBorderIntersect(t,e,i){switch(i){case 1:case 4:return new d(e.x,H.GetRectangleBound(t,i));case 2:case 8:return new d(H.GetRectangleBound(t,i),e.y);default:throw new Error}}static GetRectangleBound(t,e){switch(e){case 1:return t.top;case 4:return t.bottom;case 2:return t.right;case 8:return t.left;default:throw new Error}}static RectangleInteriorsIntersect(t,e){return B.Compare(t.bottom,e.top)<0&&B.Compare(e.bottom,t.top)<0&&B.Compare(t.left,e.right)<0&&B.Compare(e.left,t.right)<0}static PointIsInRectangleInterior(t,e){return B.Compare(t.y,e.top)<0&&B.Compare(e.bottom,t.y)<0&&B.Compare(t.x,e.right)<0&&B.Compare(e.left,t.x)<0}};var Tn=class{get Dir(){return this.dir}set Dir(t){this.dir=t}constructor(t){this.Dir=t,this.DirectionAsPoint=F.toPoint(this.Dir),this.PerpDirection=1===t?2:1,this.PerpDirectionAsPoint=F.toPoint(this.PerpDirection),this.OppositeDirection=F.OppositeDir(t)}get IsHorizontal(){return 2===this.Dir}get IsVertical(){return 1===this.Dir}Compare(t,e){let i=this.ComparePerpCoord(t,e);return i!==0?i:this.CompareScanCoord(t,e)}CompareScanCoord(t,e){return B.Compare(t.sub(e).dot(this.DirectionAsPoint),0)}ComparePerpCoord(t,e){return B.Compare(t.sub(e).dot(this.PerpDirectionAsPoint),0)}IsFlatS(t){return this.IsFlatPP(t.Start,t.End)}IsFlatPP(t,e){return B.Equal(e.sub(t).dot(this.PerpDirectionAsPoint),0)}IsPerpendicularS(t){return this.IsPerpendicularPP(t.Start,t.End)}IsPerpendicularPP(t,e){return B.Equal(e.sub(t).dot(this.DirectionAsPoint),0)}Coord(t){return t.dot(this.DirectionAsPoint)}Min(t,e){return this.Compare(t,e)<=0?t:e}Max(t,e){return this.Compare(t,e)>=0?t:e}get PerpendicularInstance(){return this.IsHorizontal?Tn.VerticalInstance:Tn.HorizontalInstance}static GetInstance(t){return H.IsVerticalD(t)?Tn.VerticalInstance:Tn.HorizontalInstance}ToString(){return this.Dir.toString()}},Xe=Tn;Xe.HorizontalInstance=new Tn(2),Xe.VerticalInstance=new Tn(1);var ji=class extends mn{constructor(e,i,n,o){super();this.Update(e,i),this.Weight=n,this.GroupBoundaryPointAndCrossingsList=o}static mk(e,i){return new ji(e,i,ji.NormalWeight,null)}get Start(){return this.startPoint}get End(){return this.endPoint}get IsVertical(){return ji.IsVerticalSegment(this.Start,this.End)}get ScanDirection(){return this.IsVertical?Xe.VerticalInstance:Xe.HorizontalInstance}get IsOverlapped(){return ji.OverlappedWeight===this.Weight}get IsReflection(){return ji.ReflectionWeight===this.Weight}static IsVerticalSegment(e,i){return e.x===i.x}MergeGroupBoundaryCrossingList(e){e!=null&&(this.GroupBoundaryPointAndCrossingsList==null&&(this.GroupBoundaryPointAndCrossingsList=new Ii),this.GroupBoundaryPointAndCrossingsList.MergeFrom(e))}TrimGroupBoundaryCrossingList(){this.GroupBoundaryPointAndCrossingsList!=null&&this.GroupBoundaryPointAndCrossingsList.Trim(this.Start,this.End)}Update(e,i){this.startPoint=e,this.endPoint=i}SetInitialVisibilityVertex(e){this.LowestVisibilityVertex=e,this.HighestVisibilityVertex=e}AppendVisibilityVertex(e,i){if(this.HighestVisibilityVertex==null)this.AddGroupCrossingsBeforeHighestVisibilityVertex(e,i)||this.SetInitialVisibilityVertex(i);else{if(B.IsPureLower(i.point,this.HighestVisibilityVertex.point))return;this.AddGroupCrossingsBeforeHighestVisibilityVertex(e,i)||this.AppendHighestVisibilityVertex(i)}}AddVisibilityEdge(e,i){let n=new _t(e,i,this.Weight);return Ie.AddEdge(n),n}AppendHighestVisibilityVertex(e){B.EqualPP(this.HighestVisibilityVertex.point,e.point)||(this.AddVisibilityEdge(this.HighestVisibilityVertex,e),this.HighestVisibilityVertex=e)}LoadStartOverlapVertexIfNeeded(e){if(this.NeedStartOverlapVertex){let i=e.FindVertex(this.Start);this.AppendVisibilityVertex(e,i!=null?i:e.AddVertexP(this.Start))}}LoadEndOverlapVertexIfNeeded(e){if(this.NeedEndOverlapVertex){let i=e.FindVertex(this.End);this.AppendVisibilityVertex(e,i!=null?i:e.AddVertexP(this.End))}}OnSegmentIntersectorBegin(e){this.AppendGroupCrossingsThroughPoint(e,this.Start)||this.LoadStartOverlapVertexIfNeeded(e)}OnSegmentIntersectorEnd(e){this.AppendGroupCrossingsThroughPoint(e,this.End),this.GroupBoundaryPointAndCrossingsList=null,(this.HighestVisibilityVertex==null||B.IsPureLower(this.HighestVisibilityVertex.point,this.End))&&this.LoadEndOverlapVertexIfNeeded(e)}static Subsume(e,i,n,o,s,a,u,h){return h.extendStart=!0,h.extendEnd=!0,e.seg==null||!H.IntervalsOverlapPPPP(e.seg.Start,e.seg.End,i,n)?!1:e.seg.Weight!==o?e.seg.Start===i&&e.seg.End===n?(e.seg.Weight=Math.min(e.seg.Weight,o),!0):!1:(h.extendStart=a.CompareScanCoord(i,e.seg.Start)===-1,h.extendEnd=a.CompareScanCoord(n,e.seg.End)===1,(h.extendStart||h.extendEnd)&&(u.Remove(e.seg),e.seg.startPoint=a.Min(e.seg.Start,i),e.seg.endPoint=a.Max(e.seg.End,n),e.seg=u.InsertUnique(e.seg).item,e.seg.MergeGroupBoundaryCrossingList(s)),!0)}IntersectsSegment(e){return H.SegmentsIntersection(this,e)!==void 0}toString(){return"["+this.Start+" -> "+this.End+(this.IsOverlapped?" olap":" free")+"]"}ContainsPoint(e){return B.EqualPP(this.Start,e)||B.EqualPP(this.End,e)||B.GetDirections(this.Start,e)===B.GetDirections(e,this.End)}get HasSparsePerpendicularCoords(){return this.sparsePerpendicularCoords==null?!1:this.sparsePerpendicularCoords.size>0}CreatePointFromPerpCoord(e){return this.IsVertical?new d(this.Start.x,e):new d(e,this.Start.y)}AddSparseVertexCoord(e){this.sparsePerpendicularCoords==null&&(this.sparsePerpendicularCoords=new Set),this.sparsePerpendicularCoords.add(e)}AddSparseEndpoint(e){return this.sparsePerpendicularCoords.has(e)?!1:(this.sparsePerpendicularCoords.add(e),!0)}CreateSparseVerticesAndEdges(e){var i;if(this.sparsePerpendicularCoords!=null){this.AppendGroupCrossingsThroughPoint(e,this.Start);for(let n of Array.from(this.sparsePerpendicularCoords.values()).sort(ce)){let o=this.CreatePointFromPerpCoord(n);this.AppendVisibilityVertex(e,(i=e.FindVertex(o))!=null?i:e.AddVertexP(o))}this.AppendGroupCrossingsThroughPoint(e,this.End),this.GroupBoundaryPointAndCrossingsList=null,this.sparsePerpendicularCoords.clear(),this.sparsePerpendicularCoords=null}}HasVisibility(){return this.LowestVisibilityVertex!=null}AddGroupCrossingsBeforeHighestVisibilityVertex(e,i){return this.AppendGroupCrossingsThroughPoint(e,i.point)?(B.IsPureLower(this.HighestVisibilityVertex.point,i.point)&&(this.AddVisibilityEdge(this.HighestVisibilityVertex,i),this.HighestVisibilityVertex=i),!0):!1}AppendGroupCrossingsThroughPoint(e,i){var o;if(this.GroupBoundaryPointAndCrossingsList==null)return!1;let n=!1;for(;this.GroupBoundaryPointAndCrossingsList.CurrentIsBeforeOrAt(i);){let s=this.GroupBoundaryPointAndCrossingsList.Pop(),a=null,u=null;B.ComparePP(s.Location,this.Start)>0&&(a=Ii.ToCrossingArray(s.Crossings,this.ScanDirection.OppositeDirection)),B.ComparePP(s.Location,this.End)<0&&(u=Ii.ToCrossingArray(s.Crossings,this.ScanDirection.Dir)),n=!0;let h=(o=e.FindVertex(s.Location))!=null?o:e.AddVertexP(s.Location);e.AddVertexP(s.Location),a!=null||u!=null?(this.AddLowCrossings(e,h,a),this.AddHighCrossings(e,h,u)):this.LowestVisibilityVertex==null?this.SetInitialVisibilityVertex(h):this.AppendHighestVisibilityVertex(h)}return n}static GetCrossingInteriorVertex(e,i,n){var s;let o=n.GetInteriorVertexPoint(i.point);return(s=e.FindVertex(o))!=null?s:e.AddVertexP(o)}AddCrossingEdge(e,i,n,o){let s=null;this.HighestVisibilityVertex!=null&&(B.EqualPP(this.HighestVisibilityVertex.point,n.point)?s=e.FindEdgePP(i.point,n.point):this.AppendHighestVisibilityVertex(i)),s==null&&(s=this.AddVisibilityEdge(i,n));let a=o.map(h=>h.Group.InputShape),u=s.IsPassable;u==null?s.IsPassable=()=>{for(let h of a)if(h.IsTransparent)return!0;return!1}:s.IsPassable=()=>{for(let h of a)if(h.IsTransparent||u())return!0;return!1},this.LowestVisibilityVertex==null&&this.SetInitialVisibilityVertex(i),this.HighestVisibilityVertex=n}AddLowCrossings(e,i,n){if(n!=null){let o=ji.GetCrossingInteriorVertex(e,i,n[0]);this.AddCrossingEdge(e,o,i,n)}}AddHighCrossings(e,i,n){if(n!=null){let o=ji.GetCrossingInteriorVertex(e,i,n[0]);this.AddCrossingEdge(e,i,o,n)}}},re=ji;re.NormalWeight=_t.DefaultWeight,re.ReflectionWeight=5,re.OverlappedWeight=500;var qs=class{constructor(t,e,i,n,o){this.IsClosed=!1;this.Vertex=t,this.Direction=e!=null?F.DirectionFromPointToPoint(e.Vertex.point,t.point):0,this.ResetEntry(e,i,n,o)}ResetEntry(t,e,i,n){this.PreviousEntry=t,this.Length=e,this.NumberOfBends=i,this.Cost=n}get PreviousVertex(){return this.PreviousEntry==null?null:this.PreviousEntry.Vertex}toString(){return this.Vertex.point+(" "+(this.Direction+(" "+(this.IsClosed+(" "+this.Cost)))))}};var Us=class{constructor(){this.Clear()}Set(t,e){this.Vertex=t,this.Weight=e}Clear(){this.Vertex=null,this.Weight=Number.NaN}},Ye=class{constructor(){this.nextNeighbors=[new Us,new Us,new Us];this.LengthImportance=1,this.BendsImportance=1}CombinedCost(t,e){return this.LengthImportance*t+this.BendsImportance*e}TotalCostFromSourceToVertex(t,e){return this.CombinedCost(t,e)+this.sourceCostAdjustment}InitPath(t,e,i){if(e===i||!this.InitEntryDirectionsAtTarget(i))return!1;this.Target=i,this.Source=e;let n=this.TotalCostFromSourceToVertex(0,0)+this.HeuristicDistanceFromVertexToTarget(e.point,0);return n>=this.upperBoundOnCost?!1:(this.queue=new At(ce),this.visitedVertices=[e],t==null?this.EnqueueInitialVerticesFromSource(n):this.EnqueueInitialVerticesFromSourceEntries(t),this.queue.count>0)}InitEntryDirectionsAtTarget(t){this.EntryDirectionsToTarget=0;for(let e of t.OutEdges)this.EntryDirectionsToTarget=this.EntryDirectionsToTarget|F.DirectionFromPointToPoint(e.TargetPoint,t.point);for(let e of t.InEdges)this.EntryDirectionsToTarget=this.EntryDirectionsToTarget|F.DirectionFromPointToPoint(e.SourcePoint,t.point);return this.EntryDirectionsToTarget!==0}static IsInDirs(t,e){return t===(t&e)}MultistageAdjustedCostBound(t){return Number.isFinite(t)?t+this.BendsImportance:t}HeuristicDistanceFromVertexToTarget(t,e){let i=this.Target.point.sub(t);if(Q(i.x,0)&&Q(i.y,0))return this.targetCostAdjustment;let n=F.VectorDirection(i),o;return e===0?(e=15,o=this.GetNumberOfBends(e,n)):o=this.GetNumberOfBends(e,n),this.CombinedCost(Ye.ManhattanDistance(t,this.Target.point),o)+this.targetCostAdjustment}GetNumberOfBends(t,e){return F.IsPureDirection(e)?this.GetNumberOfBendsForPureDirection(t,e):Ye.GetBendsForNotPureDirection(e,t,this.EntryDirectionsToTarget)}GetNumberOfBendsForPureDirection(t,e){return(e&t)===e?Ye.IsInDirs(e,this.EntryDirectionsToTarget)?0:Ye.IsInDirs(Ye.Left(e),this.EntryDirectionsToTarget)||Ye.IsInDirs(Ye.Right(e),this.EntryDirectionsToTarget)?2:4:this.GetNumberOfBendsForPureDirection(Ye.AddOneTurn[t],e)+1}static GetBendsForNotPureDirection(t,e,i){let n=t&e;if(n===0)return Ye.GetBendsForNotPureDirection(t,Ye.AddOneTurn[e],i)+1;let o=t&i;return o===0?Ye.GetBendsForNotPureDirection(t,e,Ye.AddOneTurn[i])+1:(n|o)===t?1:2}static Left(t){switch(t){case 0:return 0;case 1:return 8;case 2:return 1;case 4:return 2;case 8:return 4;default:throw new Error("direction")}}static Right(t){switch(t){case 0:return 0;case 1:return 2;case 2:return 4;case 4:return 8;case 8:return 1;default:throw new Error("direction")}}static RestorePathV(t){return Ye.RestorePath(t,null)}static RestorePath(t,e){if(t.entry==null)return[];let i=new Array,n=!1,o=0;for(;;){o===t.entry.Direction?n=!0:(n=!1,i.push(t.entry.Vertex.point),o=t.entry.Direction);let s=t.entry.PreviousEntry;if(s==null||t.entry.Vertex===e)break;t.entry=s}return n&&i.push(t.entry.Vertex.point),i.reverse(),i}QueueReversedEntryToNeighborVertexIfNeeded(t,e,i){let n={numberOfBends:0,length:0},o=e.PreviousVertex,s=Ye.GetLengthAndNumberOfBendsToNeighborVertex(t,o,i,n);if(this.CombinedCost(n.length,n.numberOfBends)<this.CombinedCost(e.Length,e.NumberOfBends)||t.Vertex.Degree===1){let a=this.TotalCostFromSourceToVertex(n.length,n.numberOfBends)+this.HeuristicDistanceFromVertexToTarget(o.point,s);this.EnqueueEntry(t,o,n.length,n.numberOfBends,a)}}UpdateEntryToNeighborVertexIfNeeded(t,e,i){let n={numberOfBends:0,length:0},o=Ye.GetLengthAndNumberOfBendsToNeighborVertex(t,e.Vertex,i,n);if(this.CombinedCost(n.length,n.numberOfBends)<this.CombinedCost(e.Length,e.NumberOfBends)){let s=this.TotalCostFromSourceToVertex(n.length,n.numberOfBends)+this.HeuristicDistanceFromVertexToTarget(e.Vertex.point,o);e.ResetEntry(t,n.length,n.numberOfBends,s),this.queue.DecreasePriority(e,s)}}CreateAndEnqueueEntryToNeighborVertex(t,e,i){let n={numberOfBends:0,length:0},o=Ye.GetLengthAndNumberOfBendsToNeighborVertex(t,e,i,n),s=this.TotalCostFromSourceToVertex(n.length,n.numberOfBends)+this.HeuristicDistanceFromVertexToTarget(e.point,o);s<this.upperBoundOnCost&&(e.VertexEntries==null&&this.visitedVertices.push(e),this.EnqueueEntry(t,e,n.length,n.numberOfBends,s))}EnqueueEntry(t,e,i,n,o){let s=new qs(e,t,i,n,o);e.SetVertexEntry(s),this.queue.Enqueue(s,s.Cost)}static GetLengthAndNumberOfBendsToNeighborVertex(t,e,i,n){n.length=t.Length+Ye.ManhattanDistance(t.Vertex.point,e.point)*i;let o=F.DirectionFromPointToPoint(t.Vertex.point,e.point);return n.numberOfBends=t.NumberOfBends,t.Direction!==0&&o!==t.Direction&&n.numberOfBends++,o}static ManhattanDistance(t,e){return Math.abs(e.x-t.x)+Math.abs(e.y-t.y)}GetPathWithCost(t,e,i,n,o,s,a){if(this.upperBoundOnCost=a,this.sourceCostAdjustment=i,this.targetCostAdjustment=s,!this.InitPath(t,e,o))return null;for(;this.queue.count>0;){let u=this.queue.Dequeue(),h=u.Vertex;if(h===this.Target){if(n==null)return this.Cleanup(),u;if(u.Direction,this.EntryDirectionsToTarget===0){let f=0;for(let P of this.Target.VertexEntries)n[f++]=P;return this.Cleanup(),null}this.upperBoundOnCost=Math.min(this.MultistageAdjustedCostBound(u.Cost),this.upperBoundOnCost);continue}u.IsClosed=!0;for(let f of this.nextNeighbors)f.Clear();let c=Ye.Right(u.Direction);this.ExtendPathAlongInEdges(u,h.InEdges,c),this.ExtendPathAlongOutEdges(u,h.OutEdges,c);for(let f of this.nextNeighbors)f.Vertex!=null&&this.ExtendPathToNeighborVertex(u,f.Vertex,f.Weight)}if(n!=null&&this.Target.VertexEntries!=null)for(let u=0;u<this.Target.VertexEntries.length;u++)n[u]=this.Target.VertexEntries[u];return this.Cleanup(),null}ExtendPathAlongInEdges(t,e,i){for(let n of e)this.ExtendPathAlongEdge(t,n,!0,i)}ExtendPathAlongOutEdges(t,e,i){let n=e.isEmpty()?null:e.treeMinimum();for(;n!=null;n=e.next(n))this.ExtendPathAlongEdge(t,n.item,!1,i)}ExtendPathAlongEdge(t,e,i,n){if(!Ye.IsPassable(e))return;let o=i?e.Source:e.Target;if(o===t.PreviousVertex){if(t.Vertex.Degree>1||t.Vertex!==this.Source)return;this.ExtendPathToNeighborVertex(t,o,e.Weight);return}let s=F.DirectionFromPointToPoint(t.Vertex.point,o.point),a=this.nextNeighbors[2];s!==t.Direction&&(a=this.nextNeighbors[s===n?1:0]),a.Set(o,e.Weight)}EnqueueInitialVerticesFromSource(t){let e=new qs(this.Source,null,0,0,t);e.IsClosed=!0;for(let i of this.Source.OutEdges)!Ye.IsPassable(i)||this.ExtendPathToNeighborVertex(e,i.Target,i.Weight);for(let i of this.Source.InEdges)!Ye.IsPassable(i)||this.ExtendPathToNeighborVertex(e,i.Source,i.Weight)}EnqueueInitialVerticesFromSourceEntries(t){for(let e of t)e!=null&&this.queue.Enqueue(e,e.Cost)}ExtendPathToNeighborVertex(t,e,i){let n=F.DirectionFromPointToPoint(t.Vertex.point,e.point),o=e.VertexEntries!=null?e.VertexEntries[F.ToIndex(n)]:null;o==null?this.CreateAndEnqueueReversedEntryToNeighborVertex(t,e,i)||this.CreateAndEnqueueEntryToNeighborVertex(t,e,i):o.IsClosed||this.UpdateEntryToNeighborVertexIfNeeded(t,o,i)}CreateAndEnqueueReversedEntryToNeighborVertex(t,e,i){if(t.Vertex.VertexEntries!=null){let n=F.DirectionFromPointToPoint(e.point,t.Vertex.point),o=t.Vertex.VertexEntries[F.ToIndex(n)];if(o!=null)return this.QueueReversedEntryToNeighborVertexIfNeeded(t,o,i),!0}return!1}static IsPassable(t){return t.IsPassable==null||t.IsPassable()}Cleanup(){for(let t of this.visitedVertices)t.RemoveVertexEntries();this.visitedVertices=[],this.queue=null}},vr=Ye;vr.DefaultBendPenaltyAsAPercentageOfDistance=4,vr.AddOneTurn=[0,11,7,15,14,15,15,15,13,15,15,15,15,15,15,15];var On=class{constructor(t){this.bendPenaltyAsAPercentageOfDistance=vr.DefaultBendPenaltyAsAPercentageOfDistance;this.currentPassTargetEntries=new Array(4);this.bendPenaltyAsAPercentageOfDistance=t}GetPath(t,e){let i={entry:this.GetPathStage(null,t,null,e)};return vr.RestorePathV(i)}GetPathStage(t,e,i,n){let o=new vr,s={bestEntry:null,bestCost:Number.MAX_VALUE/re.OverlappedWeight},a=Number.POSITIVE_INFINITY,u=On.Barycenter(e),h=On.Barycenter(n),c=vr.ManhattanDistance(u,h);o.BendsImportance=Math.max(.001,c*(this.bendPenaltyAsAPercentageOfDistance*.01));let f=o.LengthImportance,P=i!=null?this.currentPassTargetEntries:null,v=[];for(let M of e)for(let z of n)v.push([M,z]);v.sort(([M,z],[$,N])=>A(M,z)-A($,N));for(let[M,z]of v){if(d.closeDistEps(M.point,z.point))continue;let $=O(M,u)*f,N=O(z,h)*f,q=s.bestCost;if(i!=null){for(let Wt=0;Wt<P.length;Wt++)P[Wt]=null;q=o.MultistageAdjustedCostBound(s.bestCost)}let Te=o.GetPathWithCost(t,M,$,P,z,N,q);if(P!=null){On.UpdateTargetEntriesForEachDirection(i,P,s);continue}if(Te==null)continue;let ve=Te.Cost/A(M,z);(Te.Cost<s.bestCost||Q(Te.Cost,s.bestCost)&&ve<a)&&(s.bestCost=Te.Cost,s.bestEntry=Te,a=Te.Cost/A(M,z))}return s.bestEntry;function A(M,z){return vr.ManhattanDistance(M.point,z.point)}function O(M,z){return vr.ManhattanDistance(M.point,z)}}static UpdateTargetEntriesForEachDirection(t,e,i){for(let n=0;n<e.length;n++){let o=e[n];o!=null&&(t[n]==null||o.Cost<t[n].Cost)&&(t[n]=o,o.Cost<i.bestCost&&(i.bestCost=o.Cost,i.bestEntry=o))}}static Barycenter(t){let e=new d(0,0);for(let i of t)e=e.add(i.point);return e.div(t.length)}};var Sd=he(gt(),1);var fl=class{get PathPoints(){return this._pathPoints}set PathPoints(t){this._pathPoints=t}get Width(){return this.GeomEdge.lineWidth}constructor(t){this.GeomEdge=t}get End(){return this.LastEdge.Target}get Start(){return this.FirstEdge.Source}ArrayOfPathPoints(){return this._pathPoints instanceof er?Array.from(yd(this._pathPoints)):this._pathPoints}*PathEdges(){for(let t=this.FirstEdge;t!=null;t=t.Next)yield t}AddEdge(t){t.Path=this,this.LastEdge.Next=t,t.Prev=this.LastEdge,this.LastEdge=t}SetFirstEdge(t){this.FirstEdge=t,this.LastEdge=t,t.Path=this}toString(){let t=new Sd.StringBuilder;this.PathPoints instanceof er&&t.Append("L");for(let e of yd(this.PathPoints))t.Append(e.toString());return t.ToString()}};function*yd(l){if(l instanceof er)for(let t=l;t!=null;t=t.Next)yield t.Point;else for(let t of l)yield t}var pl=class extends fn{constructor(e,i,n,o){super(i);this.Slope=0;this.SlopeInverse=0;this.Obstacle=e,this.endVertex=o?i.nextOnPolyline:i.prevOnPolyline,n.IsPerpendicularPP(i.point,this.endVertex.point)||(this.Slope=H.Slope(i.point,this.endVertex.point,n),this.SlopeInverse=1/this.Slope)}get Obstacle(){return this.obstacle}set Obstacle(e){this.obstacle=e}get EndVertex(){return this.endVertex}},Dt=class extends pl{constructor(t,e,i){super(t,e,i,i.IsHorizontal)}},Qi=class extends pl{constructor(t,e,i){super(t,e,i,i.IsVertical)}};var Bn=class{get PaddedPolyline(){return this._PaddedPolyline}set PaddedPolyline(t){this._PaddedPolyline=t}get looseVisibilityPolyline(){return this._looseVisibilityPolyline==null&&(this._looseVisibilityPolyline=Bn.CreateLoosePolyline(this.VisibilityPolyline)),this._looseVisibilityPolyline}set looseVisibilityPolyline(t){this._looseVisibilityPolyline=t}GetPortChanges(t){return t.addedPorts=Fi(this.InputShape.Ports,this.Ports),t.removedPorts=Fi(this.Ports,this.InputShape.Ports),t.addedPorts.size===0&&t.removedPorts.size===0?!1:(this.Ports=new Set(this.InputShape.Ports),!0)}get IsInConvexHull(){return this.ConvexHull!=null}get IsGroup(){return this.InputShape!=null&&this.InputShape.IsGroup}get VisibilityBoundingBox(){return this.VisibilityPolyline.boundingBox}get VisibilityPolyline(){return this.ConvexHull!=null?this.ConvexHull.Polyline:this.PaddedPolyline}static CreateSentinel(t,e,i,n){let o=Bn.mk(t,e,n);return o.CreateInitialSides(o.PaddedPolyline.startPoint,i),o}CreateInitialSides(t,e){this.ActiveLowSide=new Dt(this,t,e),this.ActiveHighSide=new Qi(this,t,e),e.IsFlatS(this.ActiveHighSide)&&(this.ActiveHighSide=new Qi(this,this.ActiveHighSide.EndVertex,e))}constructor(t,e){t!=null&&(this.PaddedPolyline=lt.PaddedPolylineBoundaryOfNode(t.BoundaryCurve,e),Bn.RoundVerticesAndSimplify(this.PaddedPolyline),this.IsRectangle=this.IsPolylineRectangle(),this.InputShape=t,this.Ports=new Set(this.InputShape.Ports))}static mk(t,e,i){let n=new Bn(null,0);return n.PaddedPolyline=j.mkClosedFromPoints([d.RoundPoint(t),d.RoundPoint(e)]),n.Ordinal=i,n}IsPolylineRectangle(){if(this.PaddedPolyline.count!==4)return!1;let t=this.PaddedPolyline.startPoint,e=t.nextOnPolyline,i=F.VectorDirectionPP(t.point,e.point);if(!F.IsPureDirection(i))return!1;do{t=e,e=t.nextOnPolyline;let n=F.DirectionFromPointToPoint(t.point,e.point);if(n!==F.RotateRight(i))return!1;i=n}while(t!==this.PaddedPolyline.startPoint);return!0}static RoundVerticesAndSimplify(t){let e=t.startPoint;do e.point=d.RoundPoint(e.point),e=e.nextOnPolyline;while(e!==t.startPoint);Bn.RemoveCloseAndCollinearVerticesInPlace(t),t.setInitIsRequired()}get IsPrimaryObstacle(){return this.ConvexHull==null||this===this.ConvexHull.PrimaryObstacle}static RemoveCloseAndCollinearVerticesInPlace(t){let e=C.intersectionEpsilon*10;for(let i=t.startPoint.next;i!=null;i=i.next)d.close(i.prev.point,i.point,e)&&(i.next==null?t.RemoveEndPoint():(i.prev.next=i.next,i.next.prev=i.prev));return d.close(t.start,t.end,e)&&t.RemoveStartPoint(),t=t.RemoveCollinearVertices(),t.endPoint.prev!=null&&t.endPoint.prev!==t.startPoint&&d.getTriangleOrientation(t.endPoint.prev.point,t.end,t.start)===2&&t.RemoveEndPoint(),t.startPoint.next!=null&&t.endPoint.prev!==t.startPoint&&d.getTriangleOrientation(t.end,t.start,t.startPoint.next.point)===2&&t.RemoveStartPoint(),t.setInitIsRequired(),t}get isOverlapped(){return this.clump!==void 0&&this.clump.length>0}get IsSentinel(){return this.InputShape==null}IsInSameClump(t){return this.isOverlapped&&this.clump===t.clump}Close(){this.ActiveLowSide=null,this.ActiveHighSide=null}SetConvexHull(t){this.clump=null,this.IsRectangle=!1,this.ConvexHull=t,this.looseVisibilityPolyline=null}static CreateLoosePolyline(t){let e=lt.CreatePaddedPolyline(t,C.intersectionEpsilon*10);return Bn.RoundVerticesAndSimplify(e),e}get IsTransparentAncestor(){return this.InputShape==null?!1:this.InputShape.IsTransparent}set IsTransparentAncestor(t){this.InputShape.IsTransparent=t}},xt=Bn;xt.FirstSentinelOrdinal=1,xt.FirstNonSentinelOrdinal=10;var Cd=he(gt(),1);var bl=class{constructor(t,e,i,n){this.IsOverlapped=!1;this.unpaddedToPaddedBorderWeight=re.NormalWeight;this.ObstaclePort=t,this.UnpaddedBorderIntersect=e,this.OutwardDirection=i;let o=w.mkPP(this.UnpaddedBorderIntersect,H.RectangleBorderIntersect(t.Obstacle.VisibilityBoundingBox,this.UnpaddedBorderIntersect,i)),s=E.getAllIntersections(o,t.Obstacle.VisibilityPolyline,!0);this.VisibilityBorderIntersect=d.RoundPoint(s[0].x);let a={pacList:null};this.MaxVisibilitySegment=n.CreateMaxVisibilitySegment(this.VisibilityBorderIntersect,this.OutwardDirection,a),this.pointAndCrossingsList=a.pacList,(this.Obstacle.isOverlapped||this.Obstacle.IsGroup&&!this.Obstacle.IsInConvexHull)&&(this.IsOverlapped=n.IntersectionIsInsideAnotherObstacle(null,this.Obstacle,this.VisibilityBorderIntersect,Xe.GetInstance(this.OutwardDirection)),(!this.Obstacle.IsGroup||this.IsOverlapped||this.InteriorEdgeCrossesObstacle(n))&&(this.unpaddedToPaddedBorderWeight=re.OverlappedWeight)),this.Obstacle.IsInConvexHull&&this.unpaddedToPaddedBorderWeight===re.NormalWeight&&this.SetUnpaddedToPaddedBorderWeightFromHullSiblingOverlaps(n)}get Obstacle(){return this.ObstaclePort.Obstacle}get InitialWeight(){return this.IsOverlapped?re.OverlappedWeight:re.NormalWeight}get IsCollinearWithPort(){return F.IsPureDirection(B.GetDirections(this.VisibilityBorderIntersect,this.ObstaclePort.Location))}get IsVertical(){return H.IsVertical(this.MaxVisibilitySegment)}get WantVisibilityIntersection(){return!this.IsOverlapped&&this.CanExtend&&(!this.ObstaclePort.HasCollinearEntrances||this.IsCollinearWithPort)}get CanExtend(){return B.GetDirections(this.MaxVisibilitySegment.start,this.MaxVisibilitySegment.end)!==0}SetUnpaddedToPaddedBorderWeightFromHullSiblingOverlaps(t){(this.Obstacle.IsGroup?this.InteriorEdgeCrossesObstacle(t):this.InteriorEdgeCrossesConvexHullSiblings())&&(this.unpaddedToPaddedBorderWeight=re.OverlappedWeight)}InteriorEdgeCrossesObstacle(t){let e=D.mkPP(this.UnpaddedBorderIntersect,this.VisibilityBorderIntersect);return this.InteriorEdgeCrossesObstacleRFI(e,i=>i.VisibilityPolyline,Array.from(t.Root.GetLeafRectangleNodesIntersectingRectangle(e)).filter(i=>!i.UserData.IsGroup&&i.UserData!==this.Obstacle).map(i=>i.UserData))}InteriorEdgeCrossesConvexHullSiblings(){let t=D.mkPP(this.UnpaddedBorderIntersect,this.VisibilityBorderIntersect);return this.InteriorEdgeCrossesObstacleRFI(t,e=>e.PaddedPolyline,this.Obstacle.ConvexHull.Obstacles.filter(e=>e!==this.Obstacle))}InteriorEdgeCrossesObstacleRFI(t,e,i){let n=null;for(let o of i){let s=e(o);if(!H.RectangleInteriorsIntersect(t,s.boundingBox))continue;if(n=n!=null?n:w.mkPP(this.UnpaddedBorderIntersect,this.VisibilityBorderIntersect),E.intersectionOne(n,s,!1)!=null||0!==E.PointRelativeToCurveLocation(this.UnpaddedBorderIntersect,s))return!0}return!1}get HasGroupCrossings(){return this.pointAndCrossingsList!=null&&this.pointAndCrossingsList.Count()>0}HasGroupCrossingBeforePoint(t){if(!this.HasGroupCrossings)return!1;let e=H.IsAscending(this.OutwardDirection)?this.pointAndCrossingsList.First:this.pointAndCrossingsList.Last;return B.GetDirections(this.MaxVisibilitySegment.start,e.Location)===B.GetDirections(e.Location,t)}AddToAdjacentVertex(t,e,i,n){let o=t.VisGraph.FindVertex(this.VisibilityBorderIntersect);if(o!=null){this.ExtendEdgeChain(t,o,o,i,n);return}this.OutwardDirection===B.GetDirections(e.point,this.VisibilityBorderIntersect)?(this.VisibilityBorderIntersect=e.point,o=e):(o=t.FindOrAddVertex(this.VisibilityBorderIntersect),t.FindOrAddEdge(o,e,this.InitialWeight)),this.ExtendEdgeChain(t,o,e,i,n)}ExtendEdgeChain(t,e,i,n,o){t.ExtendEdgeChainVRLPB(i,n,this.MaxVisibilitySegment,this.pointAndCrossingsList,this.IsOverlapped);let s=t.FindOrAddVertex(this.UnpaddedBorderIntersect);t.FindOrAddEdge(s,e,this.unpaddedToPaddedBorderWeight),o&&t.ConnectVertexToTargetVertex(this.ObstaclePort.CenterVertex,s,this.OutwardDirection,this.InitialWeight)}toString(){return Cd.String.Format("{0} {1}~{2} {3}",this.ObstaclePort.Location,this.UnpaddedBorderIntersect,this.VisibilityBorderIntersect,this.OutwardDirection)}};var Pl=class{constructor(t,e){this.HasCollinearEntrances=!1;this.VisibilityRectangle=D.mkEmpty();this.Port=t,this.Obstacle=e,this.PortEntrances=new Array,this.Location=d.RoundPoint(this.Port.Location)}CreatePortEntrance(t,e,i){let n=new bl(this,t,e,i);this.PortEntrances.push(n),this.VisibilityRectangle.add(n.MaxVisibilitySegment.end),this.HasCollinearEntrances=this.HasCollinearEntrances||n.IsCollinearWithPort}ClearVisibility(){this.PortEntrances=[]}AddToGraph(t,e){e&&(this.CenterVertex=t.FindOrAddVertex(this.Location))}RemoveFromGraph(){this.CenterVertex=null}get LocationHasChanged(){return!d.closeDistEps(this.Location,d.RoundPoint(this.Port.Location))}get PortCurve(){return this.Port.Curve}get PortLocation(){return this.Port.Location}toString(){return this.Port+this.Obstacle.toString()}};var yl=class{constructor(t,e){this.maxVisibilitySegmentsAndCrossings=new Array(4);this.OutOfBoundsDirectionFromGraph=0,this.GetVertex(t,e)}get Point(){return this.Vertex.point}get InitialWeight(){return this.IsOverlapped?re.OverlappedWeight:re.NormalWeight}get IsOutOfBounds(){return 0!==this.OutOfBoundsDirectionFromGraph}GetVertex(t,e){this.Vertex=t.FindOrAddVertex(e)}AddEdgeToAdjacentEdge(t,e,i,n){let o=H.SegmentIntersectionEP(e,this.Point),s=t.VisGraph.FindVertex(o);return s!=null?this.AddToAdjacentVertex(t,s,i,n):s=t.AddEdgeToTargetEdge(this.Vertex,e,o),this.ExtendEdgeChain(t,s,i,n),s}AddToAdjacentVertex(t,e,i,n){B.EqualPP(this.Point,e.point)||t.FindOrAddEdge(this.Vertex,e,this.InitialWeight),this.ExtendEdgeChain(t,e,i,n)}ExtendEdgeChain(t,e,i,n){let o=this.IsOverlapped;o&&(o=t.ObstacleTree.PointIsInsideAnObstaclePD(e.point,i));let s=this.GetSegmentAndCrossings(this.IsOverlapped?e:this.Vertex,i,t);t.ExtendEdgeChainVRLPB(e,n,s[0],s[1],o)}GetSegmentAndCrossings(t,e,i){let n=F.ToIndex(e),o=this.maxVisibilitySegmentsAndCrossings[n];if(o==null){let s={pacList:null};o=[i.ObstacleTree.CreateMaxVisibilitySegment(t.point,e,s),s.pacList],this.maxVisibilitySegmentsAndCrossings[n]=o}else B.GetDirections(t.point,o[0].start)===e&&(o[0].start=t.point);return o}MaxVisibilityInDirectionForNonOverlappedFreePoint(t,e){return this.GetSegmentAndCrossings(this.Vertex,t,e)[0].end}AddOobEdgesFromGraphCorner(t,e){let i=B.GetDirections(e,this.Vertex.point),n=t.VisGraph.FindVertex(e);t.ConnectVertexToTargetVertex(n,this.Vertex,i&5,re.NormalWeight),t.ConnectVertexToTargetVertex(n,this.Vertex,i&10,re.NormalWeight)}RemoveFromGraph(){this.Vertex=null}toString(){return this.Vertex.toString()}};var Ad=he(gt(),1);var Ed=he(gt(),1);var co=class{constructor(t,e){this.BoundaryWidth=C.distanceEpsilon;this.Group=t,this.DirectionToInside=e}GetInteriorVertexPoint(t){return d.RoundPoint(t.add(F.toPoint(this.DirectionToInside).mul(this.BoundaryWidth)))}toString(){return Ed.String.Format("{0} {1}",this.DirectionToInside,this.Group)}};co.BoundaryWidth=C.distanceEpsilon;var rs=class extends ot{constructor(e){super();this.site=e}get Site(){return this.site}};var Ln=class extends lr{constructor(e,i){super(i);this.Obstacle=e}};var Gn=class extends Ln{constructor(t,e){super(t,e)}};var Sl=class{AddPendingPerpendicularCoord(t){this.pendingPerpCoords==null&&(this.pendingPerpCoords=new Array),this.pendingPerpCoords.push(t)}ResetForIntersections(){this.CurrentSegment=this.FirstSegment}get IsHorizontal(){return!this.FirstSegment.IsVertical}constructor(t){this.Coord=t}TraverseToSegmentContainingPoint(t){if(this.CurrentSegment.ContainsPoint(t))return!0;let e=this.IsHorizontal?t.y:t.x;if(!B.Equal(this.Coord,e)){for(;this.MoveNext(););return!1}for(;;){if((this.CurrentSegment.NextSegment==null||B.GetDirections(this.CurrentSegment.End,t)==B.GetDirections(t,this.CurrentSegment.NextSegment.Start))&&d.closeIntersections(this.CurrentSegment.End,t))return this.CurrentSegment.Update(this.CurrentSegment.Start,t),!0;if(!this.MoveNext())return!1;if(this.CurrentSegment.ContainsPoint(t))return!0;if(B.IsPureLower(t,this.CurrentSegment.Start))return this.CurrentSegment.Update(t,this.CurrentSegment.End),!0}}MoveNext(){return this.CurrentSegment=this.CurrentSegment.NextSegment,this.HasCurrent}get HasCurrent(){return this.CurrentSegment!=null}PointIsCurrentEndAndNextStart(t){return t.equal(this.CurrentSegment.End)&&this.CurrentSegment.NextSegment!=null&&t.equal(this.CurrentSegment.NextSegment.Start)}AddPerpendicularCoord(t){let e=this.IsHorizontal?new d(t,this.Coord):new d(this.Coord,t);this.TraverseToSegmentContainingPoint(e),this.CurrentSegment.AddSparseVertexCoord(t)}toString(){return this.FirstSegment==null?"-0- "+this.Coord:this.IsHorizontal?"(H) Y === "+this.Coord:"(V) X === "}AppendScanSegment(t){this.FirstSegment==null?this.FirstSegment=t:this.CurrentSegment.NextSegment=t,this.CurrentSegment=t}AddPendingPerpendicularCoordsToScanSegments(){if(this.pendingPerpCoords!=null){this.ResetForIntersections();for(let t of this.pendingPerpCoords)this.AddPerpendicularCoord(t)}}};var js=class{constructor(t,e){this.CurrentSlotIndex=0;this.vector=[],this.IsHorizontal=e;let i=Array.from(t).sort((n,o)=>n>o?1:n<o?-1:0);for(let n of i)this.vector.push(new Sl(n))}get Length(){return this.vector.length}get CurrentSlot(){return this.vector[this.CurrentSlotIndex]}Item(t){return this.vector[t]}CreateScanSegment(t,e,i,n){this.CurrentSlot.AppendScanSegment(new re(t,e,i,n))}ScanSegmentsCompleteForCurrentSlot(){this.CurrentSlotIndex++}ScanSegmentsComplete(){for(let t of this.vector)t.AddPendingPerpendicularCoordsToScanSegments()}Items(){return this.vector}ResetForIntersections(){for(let t of this.vector)t.ResetForIntersections()}FindNearest(t,e){let i=0,n=this.vector.length-1;if(t<=this.vector[i].Coord)return i;if(t>=this.vector[n].Coord)return n;for(;n-i>2;){let o=i+(n-i>>1),s=this.vector[o];if(t<s.Coord){n=o;continue}if(t>s.Coord){i=o;continue}return o}for(i++;i<=n;i++){let o=this.vector[i];if(t<o.Coord)return e>0?i:i-1;if(t===o.Coord)break}return i}CreateSparseVerticesAndEdges(t){for(let e of this.vector){e.ResetForIntersections();for(let i=e.FirstSegment;i!=null;i=i.NextSegment)i.CreateSparseVerticesAndEdges(t)}}GetParallelCoord(t){return this.IsHorizontal?t.y:t.x}GetPerpendicularCoord(t){return this.IsHorizontal?t.x:t.y}ConnectAdjoiningSegmentEndpoints(){for(let t of this.vector){t.ResetForIntersections();let e=t.FirstSegment;for(let i=e.NextSegment;i!=null;i=i.NextSegment){if(i.HasSparsePerpendicularCoords&&e.HasSparsePerpendicularCoords&&i.Start===e.End){let n=this.GetPerpendicularCoord(i.Start);e.AddSparseEndpoint(n),i.AddSparseEndpoint(n)}e=i}}}toString(){return(this.IsHorizontal?"(H) count":"(V) count === ")+this.vector.length}};var Ar=class extends ot{constructor(e,i,n){super();this.InitialObstacle=e,this.ReflectingObstacle=i,this.site=n}static mk(e,i,n){let o=new Ar(e.ReflectingObstacle,i,n);return o.PreviousSite=e,o}IsStaircaseStep(e){return this.InitialObstacle===e}get Site(){return this.site}};var Qs=class{constructor(){this.eventTree=new hn((t,e)=>this.Compare(t,e))}Reset(t){this.scanDirection=t}Enqueue(t){this.eventTree.Enqueue(t)}Dequeue(){return this.eventTree.Dequeue()}get Count(){return this.eventTree.Count}Compare(t,e){if(t===e)return 0;if(t==null)return-1;if(e==null)return 1;let i=this.scanDirection.ComparePerpCoord(t.Site,e.Site);if(i)return i;let n=t instanceof Ar?0:1,o=e instanceof Ar?0:1;return i=n-o,i||this.scanDirection.CompareScanCoord(t.Site,e.Site)}};var vd=he(gt(),1);var is=class{constructor(){this.pointCrossingMap=new qe;this.pointList=new Array}AddIntersection(t,e,i){let n=this.pointCrossingMap.get(t);n||(n=new Array,this.pointCrossingMap.set(t,n));let o=n.length;for(let a=0;a<o;a++){let u=n[a];if(u.Group===e)return u}let s=new co(e,i);return n.push(s),s}Clear(){this.pointCrossingMap.clear()}GetOrderedListBetween(t,e){if(this.pointCrossingMap.size===0)return null;if(B.ComparePP(t,e)>0){let o=t;t=e,e=o}this.pointList=[];for(let o of this.pointCrossingMap.keys())B.ComparePP(o,t)>=0&&B.ComparePP(o,e)<=0&&this.pointList.push(o);this.pointList.sort((o,s)=>o.compareTo(s));let i=new Ii,n=this.pointList.length;for(let o=0;o<n;o++){let s=this.pointList[o];i.Add(s,this.pointCrossingMap.get(s))}return i}toString(){return vd.String.Format("{0}",this.pointCrossingMap.size)}};var Xs=class extends Ar{constructor(e,i,n){super(e.ReflectingObstacle,i.Obstacle,n);this.Side=i}};var Cl=class{constructor(t){this.staleSites=new Array;this.scanDirection=t,this.eventTree=new Me((e,i)=>this.CompareBB(e,i)),this.findFirstPred=e=>this.CompareToFindFirstPoint(e.Site)>=0}Add(t){this.eventTree.insert(t)}MarkStaleSite(t){this.staleSites.push(t)}RemoveStaleSites(){let t=this.staleSites.length;if(t>0){for(let e=0;e<t;e++)this.RemoveExact(this.staleSites[e]);this.staleSites=[]}}RemoveSitesForFlatBottom(t,e){for(let i=this.FindFirstInRange(t,e);i!=null;i=this.FindNextInRange(i,e))this.MarkStaleSite(i.item);this.RemoveStaleSites()}Find(t){return this.FindFirstInRange(t,t)}RemoveExact(t){let e=this.eventTree.find(t);return e!=null&&e.item.Site===t.Site?(this.eventTree.deleteNodeInternal(e),!0):!1}FindFirstInRange(t,e){this.findFirstPoint=t;let i=this.eventTree.findFirst(this.findFirstPred);return i!=null&&this.Compare(i.item.Site,e)<=0?i:null}CompareToFindFirstPoint(t){return this.Compare(t,this.findFirstPoint)}FindNextInRange(t,e){let i=this.eventTree.next(t);return i!=null&&this.Compare(i.item.Site,e)<=0?i:null}CompareBB(t,e){return this.scanDirection.CompareScanCoord(t.Site,e.Site)}Compare(t,e){return this.scanDirection.CompareScanCoord(t,e)}};var Js=class extends Ln{constructor(t,e){super(t,e)}},$s=class extends Ln{constructor(t,e){super(t,e)}},Ks=class extends Ln{constructor(t,e){super(t,e)}};var Ys=class extends Ar{constructor(e,i,n){super(e.ReflectingObstacle,i.obstacle,n);this.Side=i}};var Zs=class{get LowNeighborSide(){return this.LowNeighbor==null?null:this.LowNeighbor.item}get HighNeighborSide(){return this.HighNeighbor==null?null:this.HighNeighbor.item}Clear(){this.LowNeighbor=null,this.LowOverlapEnd=null,this.GroupSideInterveningBeforeLowNeighbor=null,this.HighNeighbor=null,this.HighOverlapEnd=null,this.GroupSideInterveningBeforeHighNeighbor=null}SetSides(t,e,i,n){if(H.IsAscending(t)){this.HighNeighbor=e,this.HighOverlapEnd=i,this.GroupSideInterveningBeforeHighNeighbor=n;return}this.LowNeighbor=e,this.LowOverlapEnd=i,this.GroupSideInterveningBeforeLowNeighbor=n}};var wt=class{has(t){return this.hasxy(t.x,t.y)}remove(t){if(!(t.x<0||t.x>=this.arrayOfSets.length))return this.arrayOfSets[t.x].delete(t.y)}hasxy(t,e){if(t<0||t>=this.arrayOfSets.length)return!1;let i=this.arrayOfSets[t];return i!==void 0&&i.has(e)}constructor(){this.arrayOfSets=new Array}static mk(t){let e=new wt;for(let i of t)e.add(i);return e}*values(){for(let t=0;t<this.arrayOfSets.length;t++){let e=this.arrayOfSets[t];if(!!e)for(let i of e.values())yield new Z(t,i)}}add(t){let e=this.arrayOfSets[t.x];e==null&&(this.arrayOfSets[t.x]=e=new Set),e.add(t.y)}addNN(t,e){let i=this.arrayOfSets[t];i==null&&(this.arrayOfSets[t]=i=new Set),i.add(e)}clear(){for(let t of this.arrayOfSets)t&&t.clear()}};var _s=class{constructor(t,e){this.Polyline=t,this.Obstacles=Array.from(e),this.PrimaryObstacle=this.Obstacles[0],xt.RoundVerticesAndSimplify(this.Polyline)}};var xi=class{static MungeClosestIntersectionInfo(t,e,i){let n=e.seg1.boundingBox,o=d.RoundPoint(e.x).clone();return i?new d(xi.MungeIntersect(t.x,o.x,n.left,n.right),o.y):new d(o.x,xi.MungeIntersect(t.y,o.y,n.bottom,n.top))}static MungeIntersect(t,e,i,n){if(t<e){let o=Math.min(i,n);e<o&&(e=o)}else if(t>e){let o=Math.max(i,n);e>o&&(e=o)}return d.RoundDouble(e)}};var He=class{constructor(){this.CurrentGroupBoundaryCrossingMap=new is;this.overlapPairs=new wt;this.hasOverlaps=!1;this.lookupIntPair=new Z(-1,-1)}get GraphBox(){return this.Root.irect}Init(t,e,i){this.CreateObstacleListAndOrdinals(t),this.AncestorSets=e,this.CreateRoot(),this.shapeIdToObstacleMap=i}CreateObstacleListAndOrdinals(t){this.allObstacles=Array.from(t);let e=xt.FirstNonSentinelOrdinal;for(let i of this.allObstacles)i.Ordinal=e++}OrdinalToObstacle(t){return this.allObstacles[t-xt.FirstNonSentinelOrdinal]}CreateRoot(){this.Root=He.CalculateHierarchy(this.GetAllObstacles()),this.OverlapsExist()&&(this.AccreteClumps(),this.AccreteConvexHulls(),this.GrowGroupsToAccommodateOverlaps(),this.Root=He.CalculateHierarchy(this.GetAllObstacles().filter(t=>t.IsPrimaryObstacle)))}OverlapsExist(){return this.Root==null?!1:(tt(this.Root,this.Root,(t,e)=>this.CheckForInitialOverlaps(t,e)),this.hasOverlaps)}OverlapPairAlreadyFound(t,e){return this.lookupIntPair.x=e.Ordinal,this.lookupIntPair.y=t.Ordinal,this.overlapPairs.has(this.lookupIntPair)}CheckForInitialOverlaps(t,e){if(this.hasOverlaps)return;let i={bIsInsideA:!1,aIsInsideB:!1};if(He.ObstaclesIntersect(t,e,i)){this.hasOverlaps=!0;return}!i.aIsInsideB&&!i.bIsInsideA||t.IsGroup&&e.IsGroup||t.IsGroup&&i.bIsInsideA||e.IsGroup&&i.aIsInsideB||(this.hasOverlaps=!0)}AccreteClumps(){this.AccumulateObstaclesForClumps(),this.CreateClumps()}AccreteConvexHulls(){for(;;)if(this.AccumulateObstaclesForConvexHulls(),!this.CreateConvexHulls())return}static CalculateHierarchy(t){let e=Array.from(t).map(i=>Fe(i,i.VisibilityBoundingBox));return Oe(e)}AccumulateObstaclesForClumps(){this.overlapPairs.clear();let t=He.CalculateHierarchy(this.GetAllObstacles().filter(e=>!e.IsGroup&&e.IsRectangle));t!=null&&Et(t,t,(e,i)=>this.EvaluateOverlappedPairForClump(e,i))}EvaluateOverlappedPairForClump(t,e){if(t===e||this.OverlapPairAlreadyFound(t,e))return;let i={bIsInsideA:!1,aIsInsideB:!1};!He.ObstaclesIntersect(t,e,i)&&!i.aIsInsideB&&!i.bIsInsideA||this.overlapPairs.add(new Z(t.Ordinal,e.Ordinal))}AccumulateObstaclesForConvexHulls(){this.overlapPairs.clear();let t=He.CalculateHierarchy(this.GetAllObstacles().filter(e=>e.IsPrimaryObstacle&&!e.IsGroup));t!=null&&Et(t,t,(e,i)=>this.EvaluateOverlappedPairForConvexHull(e,i))}EvaluateOverlappedPairForConvexHull(t,e){if(t===e||this.OverlapPairAlreadyFound(t,e))return;let i={bIsInsideA:!1,aIsInsideB:!1};!He.ObstaclesIntersect(t,e,i)&&!i.aIsInsideB&&!i.bIsInsideA||!t.IsInConvexHull&&!e.IsInConvexHull&&t.IsRectangle&&e.IsRectangle||(this.overlapPairs.add(new Z(t.Ordinal,e.Ordinal)),this.AddClumpToConvexHull(t),this.AddClumpToConvexHull(e),this.AddConvexHullToConvexHull(t),this.AddConvexHullToConvexHull(e))}GrowGroupsToAccommodateOverlaps(){for(;;)if(this.AccumulateObstaclesForGroupOverlaps(),!this.GrowGroupsToResolveOverlaps())return}AccumulateObstaclesForGroupOverlaps(){let t=He.CalculateHierarchy(this.GetAllObstacles().filter(i=>i.IsGroup)),e=He.CalculateHierarchy(this.GetAllObstacles().filter(i=>i.IsPrimaryObstacle));t==null||e==null||Et(t,e,(i,n)=>this.EvaluateOverlappedPairForGroup(i,n))}EvaluateOverlappedPairForGroup(t,e){if(t===e||this.OverlapPairAlreadyFound(t,e))return;let i={bIsInsideA:!1,aIsInsideB:!1},n=He.ObstaclesIntersect(t,e,i);if(!(!n&&!i.aIsInsideB&&!i.bIsInsideA)){if(t.IsRectangle&&e.IsRectangle){e.IsGroup||(i.aIsInsideB||He.FirstRectangleContainsACornerOfTheOther(e.VisibilityBoundingBox,t.VisibilityBoundingBox))&&(e.OverlapsGroupCorner=!0);return}!n&&(e.IsGroup||i.bIsInsideA)||this.overlapPairs.add(new Z(t.Ordinal,e.Ordinal))}}static FirstRectangleContainsACornerOfTheOther(t,e){return t.contains(e.leftBottom)||t.contains(e.leftTop)||t.contains(e.rightTop)||t.contains(e.rightBottom)}static FirstPolylineStartIsInsideSecondPolyline(t,e){return E.PointRelativeToCurveLocation(t.start,e)!==0}AddClumpToConvexHull(t){if(t.isOverlapped){for(let e of t.clump.filter(i=>i.Ordinal!==t.Ordinal))this.overlapPairs.add(new Z(t.Ordinal,e.Ordinal));t.clump=[]}}AddConvexHullToConvexHull(t){if(t.IsInConvexHull){for(let e of t.ConvexHull.Obstacles.filter(i=>i.Ordinal!==t.Ordinal))this.overlapPairs.add(new Z(t.Ordinal,e.Ordinal));t.ConvexHull.Obstacles=[]}}CreateClumps(){let t=jo(Array.from(this.overlapPairs.values())),e=Zr(t);for(let i of e){if(i.length===1)continue;let n=i.map(o=>this.OrdinalToObstacle(o));for(let o of n)o.clump=n}}CreateConvexHulls(){let t=!1,e=jo(Array.from(this.overlapPairs.values())),i=Zr(e);for(let n of i){if(n.length===1)continue;t=!0;let o=n.map(this.OrdinalToObstacle),s=gi(o,u=>u.VisibilityPolyline),a=new _s(zt.createConvexHullAsClosedPolyline(s),o);for(let u of o)u.SetConvexHull(a)}return t}GrowGroupsToResolveOverlaps(){let t=!1;for(let e of this.overlapPairs.values()){t=!0;let i=this.OrdinalToObstacle(e.x),n=this.OrdinalToObstacle(e.y);He.ResolveGroupAndGroupOverlap(i,n)||He.ResolveGroupAndObstacleOverlap(i,n)}return this.overlapPairs.clear(),t}static ResolveGroupAndGroupOverlap(t,e){return e.IsGroup?(t.VisibilityPolyline.boundingBox.area>e.VisibilityPolyline.boundingBox.area?He.ResolveGroupAndObstacleOverlap(t,e):He.ResolveGroupAndObstacleOverlap(e,t),!0):!1}static ResolveGroupAndObstacleOverlap(t,e){let i=e.looseVisibilityPolyline;He.GrowGroupAroundLoosePolyline(t,i);let n={bIsInsideA:!1,aIsInsideB:!1};for(;He.ObstaclesIntersect(e,t,n)||!n.aIsInsideB;)i=xt.CreateLoosePolyline(i),He.GrowGroupAroundLoosePolyline(t,i)}static GrowGroupAroundLoosePolyline(t,e){let i=Array.from(t.VisibilityPolyline).concat(Array.from(e));t.SetConvexHull(new _s(zt.createConvexHullAsClosedPolyline(i),[t]))}static ObstaclesIntersect(t,e,i){return E.CurvesIntersect(t.VisibilityPolyline,e.VisibilityPolyline)?(i.aIsInsideB=!1,i.bIsInsideA=!1,!0):(i.aIsInsideB=He.FirstPolylineStartIsInsideSecondPolyline(t.VisibilityPolyline,e.VisibilityPolyline),i.bIsInsideA=!i.aIsInsideB&&He.FirstPolylineStartIsInsideSecondPolyline(e.VisibilityPolyline,t.VisibilityPolyline),t.IsRectangle&&e.IsRectangle?!1:He.ObstaclesAreCloseEnoughToBeConsideredTouching(t,e,i.aIsInsideB,i.bIsInsideA)?(i.aIsInsideB=!1,i.bIsInsideA=!1,!0):!1)}static ObstaclesAreCloseEnoughToBeConsideredTouching(t,e,i,n){if(!i&&!n)return E.CurvesIntersect(t.looseVisibilityPolyline,e.VisibilityPolyline);let o=i?t.looseVisibilityPolyline:e.looseVisibilityPolyline,s=i?e.VisibilityPolyline:t.VisibilityPolyline;for(let a of o)if(E.PointRelativeToCurveLocation(a,s)===0){let u=E.ClosestPoint(s,a);if(!d.closeIntersections(a,u))return!0}return!1}AdjustSpatialAncestors(){if(this.SpatialAncestorsAdjusted)return!1;for(let e of this.GetAllGroups()){let i=e.VisibilityBoundingBox;for(let n of this.Root.GetNodeItemsIntersectingRectangle(i))if(n!==e&&E.ClosedCurveInteriorsIntersect(n.VisibilityPolyline,e.VisibilityPolyline)){if(n.IsInConvexHull)for(let o of n.ConvexHull.Obstacles)this.AncestorSets.get(o.InputShape).add(e.InputShape);this.AncestorSets.get(n.InputShape).add(e.InputShape)}}let t=new Array;for(let e of this.Root.GetAllLeaves()){let i=e.VisibilityBoundingBox;t=t.concat(Array.from(this.AncestorSets.get(e.InputShape)).filter(n=>!i.intersects(this.shapeIdToObstacleMap.get(n).VisibilityBoundingBox)));for(let n of t)this.AncestorSets.get(e.InputShape).delete(n);t=[]}return this.SpatialAncestorsAdjusted=!0,!0}GetAllGroups(){return this.GetAllObstacles().filter(t=>t.IsGroup)}Clear(){this.Root=null,this.AncestorSets=null}CreateMaxVisibilitySegment(t,e,i){let n=H.RectangleBorderIntersect(this.GraphBox,t,e);if(B.GetDirections(t,n)===0)return i.pacList=null,w.mkPP(t,t);let o=this.RestrictSegmentWithObstacles(t,n);return i.pacList=this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(o.start,o.end),o}GetAllObstacles(){return this.allObstacles}GetAllPrimaryObstacles(){return this.Root.GetAllLeaves()}IntersectionIsInsideAnotherObstacle(t,e,i,n){return this.insideHitTestIgnoreObstacle1=e,this.insideHitTestIgnoreObstacle2=t,this.insideHitTestScanDirection=n,this.Root.FirstHitNodeWithPredicate(i,this.InsideObstacleHitTest.bind(this))!=null}PointIsInsideAnObstaclePD(t,e){return this.PointIsInsideAnObstacle(t,Xe.GetInstance(e))}PointIsInsideAnObstacle(t,e){return this.insideHitTestIgnoreObstacle1=null,this.insideHitTestIgnoreObstacle2=null,this.insideHitTestScanDirection=e,this.Root.FirstHitNodeWithPredicate(t,this.InsideObstacleHitTest.bind(this))!=null}InsideObstacleHitTest(t,e){if(e===this.insideHitTestIgnoreObstacle1||e===this.insideHitTestIgnoreObstacle2)return 0;if(e.IsGroup)return 0;if(!H.PointIsInRectangleInterior(t,e.VisibilityBoundingBox))return 0;let i=H.RectangleBorderIntersect(e.VisibilityBoundingBox,t,this.insideHitTestScanDirection.dir).add(this.insideHitTestScanDirection.DirectionAsPoint),n=H.RectangleBorderIntersect(e.VisibilityBoundingBox,t,this.insideHitTestScanDirection.OppositeDirection).sub(this.insideHitTestScanDirection.DirectionAsPoint),o=w.mkPP(n,i),s=E.getAllIntersections(o,e.VisibilityPolyline,!0);if(s.length===2){let a=d.RoundPoint(s[0].x),u=d.RoundPoint(s[1].x);if(!B.EqualPP(t,a)&&!B.EqualPP(t,u)&&t.compareTo(a)!==t.compareTo(u)&&!Q(Math.floor(s[0].par1),Math.floor(s[1].par1)))return 1}return 0}SegmentCrossesAnObstacle(t,e){this.stopAtGroups=!0,this.wantGroupCrossings=!1;let i=this.RestrictSegmentPrivate(t,e);return!B.EqualPP(i.end,e)}SegmentCrossesANonGroupObstacle(t,e){this.stopAtGroups=!1,this.wantGroupCrossings=!1;let i=this.RestrictSegmentPrivate(t,e);return!B.EqualPP(i.end,e)}RestrictSegmentWithObstacles(t,e){return this.stopAtGroups=!1,this.wantGroupCrossings=!0,this.RestrictSegmentPrivate(t,e)}RestrictSegmentPrivate(t,e){return this.GetRestrictedIntersectionTestSegment(t,e),this.currentRestrictedRay=w.mkPP(t,e),this.restrictedRayLengthSquared=t.sub(e).lengthSquared,this.CurrentGroupBoundaryCrossingMap.Clear(),this.RecurseRestrictRayWithObstacles(this.Root),this.currentRestrictedRay}GetRestrictedIntersectionTestSegment(t,e){let i=B.GetDirections(t,e),n=8===i?this.GraphBox.right:2===i?this.GraphBox.left:t.x,o=8===i?this.GraphBox.left:2===i?this.GraphBox.right:e.x,s=4===i?this.GraphBox.top*2:1===i?this.GraphBox.bottom:t.y,a=4===i?this.GraphBox.bottom:1===i?this.GraphBox.top:t.y;this.restrictedIntersectionTestSegment=w.mkPP(new d(n,s),new d(o,a))}RecurseRestrictRayWithObstacles(t){if(!H.RectangleInteriorsIntersect(this.currentRestrictedRay.boundingBox,t.irect))return;let e=t.UserData;if(e!=null){let i=E.getAllIntersections(this.restrictedIntersectionTestSegment,e.VisibilityPolyline,!0);if(!e.IsGroup||this.stopAtGroups){this.LookForCloserNonGroupIntersectionToRestrictRay(i);return}this.wantGroupCrossings&&this.AddGroupIntersectionsToRestrictedRay(e,i);return}this.RecurseRestrictRayWithObstacles(t.Left),this.RecurseRestrictRayWithObstacles(t.Right)}LookForCloserNonGroupIntersectionToRestrictRay(t){let e=0,i=null,n=this.restrictedRayLengthSquared,o=B.GetDirections(this.restrictedIntersectionTestSegment.start,this.restrictedIntersectionTestSegment.end);for(let s of t){let a=d.RoundPoint(s.x),u=B.GetDirections(this.currentRestrictedRay.start,a);if(u===F.OppositeDir(o))continue;if(e++,0===u){n=0,i=s;continue}let h=a.sub(this.currentRestrictedRay.start).lengthSquared;if(h<n){if(s.x.sub(this.currentRestrictedRay.start).lengthSquared<C.squareOfDistanceEpsilon)continue;n=h,i=s}}if(i!=null){if(e===1){let s=d.RoundPoint(i.x);if(d.closeIntersections(s,this.currentRestrictedRay.start)||d.closeIntersections(s,this.currentRestrictedRay.end))return}this.restrictedRayLengthSquared=n,this.currentRestrictedRay.end=xi.MungeClosestIntersectionInfo(this.currentRestrictedRay.start,i,!H.IsVerticalPP(this.currentRestrictedRay.start,this.currentRestrictedRay.end))}}AddGroupIntersectionsToRestrictedRay(t,e){for(let i of e){let n=d.RoundPoint(i.x);if(n.sub(this.currentRestrictedRay.start).lengthSquared>this.restrictedRayLengthSquared)continue;let s=B.GetDirections(this.currentRestrictedRay.start,this.currentRestrictedRay.end),a=i.seg1,u=F.VectorDirection(a.derivative(i.par1)),h=s;(u&F.RotateRight(s))!==0&&(h=F.OppositeDir(h)),this.CurrentGroupBoundaryCrossingMap.AddIntersection(n,t,h)}}};var El=class{constructor(t,e){this.scanDirection=t,this.SideTree=new Me((i,n)=>this.Compare(i,n)),this.linePositionAtLastInsertOrRemove=e}Insert(t,e){return this.linePositionAtLastInsertOrRemove=e,this.SideTree.insert(t)}get Count(){return this.SideTree.count}Remove(t,e){this.linePositionAtLastInsertOrRemove=e,this.SideTree.remove(t)}Find(t){return this.scanDirection.ComparePerpCoord(this.linePositionAtLastInsertOrRemove,t.Start)===-1?null:this.SideTree.find(t)}NextLowB(t){return this.NextLowR(this.Find(t))}NextLowR(t){return this.SideTree.previous(t)}NextHighB(t){return this.NextHighR(this.Find(t))}NextHighR(t){return this.SideTree.next(t)}Next(t,e){return H.IsAscending(t)?this.SideTree.next(e):this.SideTree.previous(e)}Lowest(){return this.SideTree.treeMinimum()}Compare(t,e){if(t.Obstacle===e.Obstacle)return t===e?0:t instanceof Dt?-1:1;let i=Rn.ScanLineIntersectSidePBS(this.linePositionAtLastInsertOrRemove,t,this.scanDirection),n=Rn.ScanLineIntersectSidePBS(this.linePositionAtLastInsertOrRemove,e,this.scanDirection),o=i.compareTo(n);if(o===0){let s=t instanceof Dt,a=e instanceof Dt;o=Oc(s,a),o===0&&(o=ce(t.Obstacle.Ordinal,e.Obstacle.Ordinal))}return o}};var go=class{constructor(t){this.lookupSegment=re.mk(new d(0,0),new d(0,1));this.ScanDirection=t,this.segmentTree=new Me((e,i)=>this.Compare(e,i)),this.findIntersectorPred=e=>this.CompareIntersector(e),this.findPointPred=e=>this.CompareToPoint(e)}get Segments(){return this.segmentTree.allNodes()}InsertUnique(t){this.AssertValidSegmentForInsertion(t);let e=this.segmentTree.find(t);return e!=null?e:this.segmentTree.insert(t)}AssertValidSegmentForInsertion(t){}Remove(t){this.segmentTree.remove(t)}Find(t,e){this.lookupSegment.Update(t,e);let i=this.segmentTree.find(this.lookupSegment);return i!=null&&B.EqualPP(i.item.End,e)?i.item:null}FindLowestIntersector(t,e){let i=this.FindLowestIntersectorNode(t,e);return i!=null?i.item:null}FindLowestIntersectorNode(t,e){this.lookupSegment.Update(t,t);let i=this.segmentTree.findLast(this.findIntersectorPred);if(B.EqualPP(t,e))i!=null&&this.ScanDirection.Compare(i.item.End,t)<0&&(i=null);else for(this.lookupSegment.Update(t,e);i!=null&&!i.item.IntersectsSegment(this.lookupSegment);){if(this.ScanDirection.Compare(i.item.Start,e)>0)return null;i=this.segmentTree.next(i)}return i}FindHighestIntersector(t,e){this.lookupSegment.Update(e,e);let i=this.segmentTree.findLast(this.findIntersectorPred);if(B.EqualPP(t,e))i!=null&&this.ScanDirection.Compare(i.item.End,t)<0&&(i=null);else for(this.lookupSegment.Update(t,e);i!=null&&!i.item.IntersectsSegment(this.lookupSegment);){if(this.ScanDirection.Compare(i.item.End,t)<0)return null;i=this.segmentTree.previous(i)}return i!=null?i.item:null}CompareIntersector(t){return this.ScanDirection.Compare(t.Start,this.lookupSegment.Start)<=0}FindSegmentContainingPoint(t,e){return this.FindSegmentOverlappingPoints(t,t,e)}FindSegmentOverlappingPoints(t,e,i){this.lookupSegment.Update(t,e);let n=this.segmentTree.findFirst(this.findPointPred);if(n!=null){let o=n.item;if(this.ScanDirection.Compare(o.Start,e)<=0)return o}return null}CompareToPoint(t){return this.ScanDirection.Compare(t.End,this.lookupSegment.Start)>=0}MergeAndRemoveNextNode(t,e){return this.ScanDirection.Compare(t.End,e.item.End)===-1&&t.Update(t.Start,e.item.End),t.MergeGroupBoundaryCrossingList(e.item.GroupBoundaryPointAndCrossingsList),this.segmentTree.deleteNodeInternal(e),this.segmentTree.find(t)}MergeSegments(){if(this.segmentTree.count<2)return;let t=this.segmentTree.treeMinimum(),e=this.segmentTree.next(t);for(;e!=null;e=this.segmentTree.next(t))switch(this.ScanDirection.Compare(e.item.Start,t.item.End)){case 1:t=e;break;case 0:e.item.IsOverlapped===t.item.IsOverlapped?t=this.MergeAndRemoveNextNode(t.item,e):(t.item.NeedEndOverlapVertex=!0,e.item.NeedStartOverlapVertex=!0,t=e);break;default:if(t.item.IsOverlapped!==e.item.IsOverlapped){if(t.item.IsOverlapped)t.item.Start===e.item.Start?t=this.MergeAndRemoveNextNode(e.item,t):(t.item.Update(t.item.Start,e.item.Start),t=e);else if(t.item.End===e.item.End)t=this.MergeAndRemoveNextNode(t.item,e);else{let n=e.item,o=t.item;this.segmentTree.deleteNodeInternal(e),n.Update(o.End,n.End),this.segmentTree.insert(n),n.TrimGroupBoundaryCrossingList(),t=this.segmentTree.find(o)}break}t=this.MergeAndRemoveNextNode(t.item,e);break}}Compare(t,e){if(t===e)return 0;if(t==null)return-1;if(e==null)return 1;let i=this.ScanDirection.Compare(t.Start,e.Start);return i===0&&(i=this.ScanDirection.Compare(t.End,e.End)*-1),i}};var vl=class extends fi{constructor(e){super(e)}SetVertexEntry(e){this.VertexEntries==null&&(this.VertexEntries=new Array(4)),this.VertexEntries[F.ToIndex(e.Direction)]=e}RemoveVertexEntries(){this.VertexEntries=null}};var ut=class{constructor(t){this.ObstacleTree=new He;this.CurrentGroupBoundaryCrossingMap=new is;this.LowNeighborSides=new Zs;this.HighNeighborSides=new Zs;this.ScanDirection=Xe.HorizontalInstance,this.eventQueue=new Qs,this.HorizontalScanSegments=new go(Xe.HorizontalInstance),this.VerticalScanSegments=new go(Xe.VerticalInstance),this.wantReflections=t}get ParallelScanSegments(){return this.ScanDirection.IsHorizontal?this.HorizontalScanSegments:this.VerticalScanSegments}get PerpendicularScanSegments(){return this.ScanDirection.IsHorizontal?this.VerticalScanSegments:this.HorizontalScanSegments}static NewVisibilityGraph(){let t=new Ie;return t.VertexFactory=e=>new vl(e),t}GenerateVisibilityGraph(){if(this.ObstacleTree.Root==null)return;this.InitializeEventQueue(Xe.HorizontalInstance);let t=xt.FirstSentinelOrdinal,e=new d(this.ObstacleTree.GraphBox.left-ut.SentinelOffset,this.ObstacleTree.GraphBox.bottom-ut.SentinelOffset),i=new d(this.ObstacleTree.GraphBox.left-ut.SentinelOffset,this.ObstacleTree.GraphBox.top+ut.SentinelOffset),n=xt.CreateSentinel(e,i,this.ScanDirection,t++);this.scanLine.Insert(n.ActiveHighSide,this.ObstacleTree.GraphBox.leftBottom),e=new d(this.ObstacleTree.GraphBox.right+ut.SentinelOffset,this.ObstacleTree.GraphBox.bottom-ut.SentinelOffset),i=new d(this.ObstacleTree.GraphBox.right+ut.SentinelOffset,this.ObstacleTree.GraphBox.top+ut.SentinelOffset),n=xt.CreateSentinel(e,i,this.ScanDirection,t++),this.scanLine.Insert(n.ActiveLowSide,this.ObstacleTree.GraphBox.leftBottom),this.ProcessEvents(),this.InitializeEventQueue(Xe.VerticalInstance),e=new d(this.ObstacleTree.GraphBox.left-ut.SentinelOffset,this.ObstacleTree.GraphBox.bottom-ut.SentinelOffset),i=new d(this.ObstacleTree.GraphBox.right+ut.SentinelOffset,this.ObstacleTree.GraphBox.bottom-ut.SentinelOffset),n=xt.CreateSentinel(e,i,this.ScanDirection,t++),this.scanLine.Insert(n.ActiveHighSide,this.ObstacleTree.GraphBox.leftBottom),e=new d(this.ObstacleTree.GraphBox.left-ut.SentinelOffset,this.ObstacleTree.GraphBox.top+ut.SentinelOffset),i=new d(this.ObstacleTree.GraphBox.right+ut.SentinelOffset,this.ObstacleTree.GraphBox.top+ut.SentinelOffset),n=xt.CreateSentinel(e,i,this.ScanDirection,t),this.scanLine.Insert(n.ActiveLowSide,this.ObstacleTree.GraphBox.leftBottom),this.ProcessEvents()}static ScanLineIntersectSidePBS(t,e,i){let n=e.Direction,o=e.Start.x,s=e.Start.y;return i.IsHorizontal?(o+=n.x/n.y*(t.y-e.Start.y),o=xi.MungeIntersect(t.x,o,e.Start.x,e.End.x),s=t.y):(o=t.x,s+=n.y/n.x*(t.x-e.Start.x),s=xi.MungeIntersect(t.y,s,e.Start.y,e.End.y)),new d(o,s)}GetOpenVertex(t){let e=t.startPoint,i=this.TraversePolylineForEvents(e),n=this.PointCompare(i.point,e.point);for(;;i=this.TraversePolylineForEvents(i)){let o=this.PointCompare(i.point,e.point);if(o<=0)e=i;else if(o>0&&n<=0)break;n=o}return e}TraversePolylineForEvents(t){return this.ScanDirection.IsHorizontal?t.nextOnPolyline:t.prevOnPolyline}InitializeEventQueue(t){this.ScanDirection=t,this.eventQueue.Reset(this.ScanDirection),this.EnqueueBottomVertexEvents(),this.scanLine=new El(this.ScanDirection,this.ObstacleTree.GraphBox.leftBottom),this.lookaheadScan=new Cl(this.ScanDirection)}EnqueueBottomVertexEvents(){for(let t of this.ObstacleTree.GetAllPrimaryObstacles()){let e=this.GetOpenVertex(t.VisibilityPolyline);this.eventQueue.Enqueue(new Gn(t,e))}}IsFlat(t){return this.ScanDirection.IsFlatS(t)}IsPerpendicular(t){return this.ScanDirection.IsPerpendicularS(t)}ScanLineIntersectSide(t,e){return ut.ScanLineIntersectSidePBS(t,e,this.ScanDirection)}SideReflectsUpward(t){return t instanceof Dt?this.ScanDirection.Coord(t.End)>this.ScanDirection.Coord(t.Start):this.ScanDirection.Coord(t.End)<this.ScanDirection.Coord(t.Start)}SideReflectsDownward(t){return t instanceof Dt?this.ScanDirection.Coord(t.End)<this.ScanDirection.Coord(t.Start):this.ScanDirection.Coord(t.End)>this.ScanDirection.Coord(t.Start)}StoreLookaheadSite(t,e,i,n){if(!!this.wantReflections&&!this.IsPerpendicular(e)){if(!n&&!H.PointIsInRectangleInterior(i,e.Obstacle.VisibilityBoundingBox))return;this.SideReflectsUpward(e)&&this.lookaheadScan.Find(i)==null&&this.lookaheadScan.Add(new Ar(t,e.Obstacle,i))}}LoadReflectionEvents(t){this.LoadReflectionEventsBB(t,t)}LoadReflectionEventsBB(t,e){if(t==null||this.SideReflectsUpward(t)||this.IsPerpendicular(t))return;let i=D.mkPP(t.Start,t.End),n=D.mkPP(e.Start,e.End);if(this.ScanDirection.IsHorizontal?!i.intersectsOnX(n):!i.intersectsOnY(n))return;let o=D.intersect(i,n),s=o.leftBottom,a=o.rightTop,u=this.lookaheadScan.FindFirstInRange(s,a);for(;u!=null;){let h=ut.ScanLineIntersectSidePBS(u.item.Site,t,this.ScanDirection.PerpendicularInstance);this.ScanDirection.ComparePerpCoord(h,u.item.Site)>0?this.AddReflectionEvent(u.item,t,h):u.item.ReflectingObstacle!==t.Obstacle&&this.lookaheadScan.MarkStaleSite(u.item),u=this.lookaheadScan.FindNextInRange(u,a)}this.lookaheadScan.RemoveStaleSites()}AddPerpendicularReflectionSegment(t,e,i){if(this.lookaheadScan.RemoveExact(t.PreviousSite)){if(e==null)return!1;if(t.PreviousSite.IsStaircaseStep(t.ReflectingObstacle)){if(!H.PointIsInRectangleInterior(t.Site,t.ReflectingObstacle.VisibilityBoundingBox)||!this.InsertPerpendicularReflectionSegment(t.PreviousSite.Site,t.Site))return!1;if(i!=null&&t.IsStaircaseStep(i.Obstacle))return this.ScanLineCrossesObstacle(t.Site,i.Obstacle)}}return!1}AddParallelReflectionSegment(t,e,i,n){{let o=this.ScanLineIntersectSide(n.Site,e!=null?e:i),s=e!=null?o:n.Site,a=e!=null?n.Site:o;return e==null?e=this.scanLine.NextLowB(i).item:i=this.scanLine.NextHighB(e).item,this.InsertParallelReflectionSegment(s,a,t,e,i,n)}}AddReflectionEvent(t,e,i){let n=e;n!=null?this.eventQueue.Enqueue(new Ys(t,n,i)):this.eventQueue.Enqueue(new Xs(t,e,i))}AddSideToScanLine(t,e){let i=this.scanLine.Insert(t,e);return this.LoadReflectionEvents(t),i}RemoveSideFromScanLine(t,e){this.scanLine.Remove(t.item,e)}PointCompare(t,e){return this.ScanDirection.Compare(t,e)}Clear(){this.ObstacleTree.Clear(),this.eventQueue=new Qs,this.HorizontalScanSegments=new go(Xe.HorizontalInstance),this.VerticalScanSegments=new go(Xe.VerticalInstance),this.VisibilityGraph=null}ProcessEvents(){for(;this.eventQueue.Count>0;){let t=this.eventQueue.Dequeue();t instanceof Gn?this.ProcessEventO(t):t instanceof Js?this.ProcessEventLB(t):t instanceof $s?this.ProcessEventHB(t):t instanceof Ks?this.ProcessEventCV(t):t instanceof Ys?this.ProcessEventLR(t):t instanceof Xs?this.ProcessEventHR(t):this.ProcessCustomEvent(t),this.LowNeighborSides.Clear(),this.HighNeighborSides.Clear()}}ProcessCustomEvent(t){}ScanLineCrossesObstacle(t,e){return this.ScanDirection.ComparePerpCoord(t,e.VisibilityBoundingBox.leftBottom)>0&&this.ScanDirection.ComparePerpCoord(t,e.VisibilityBoundingBox.rightTop)<0}FindInitialNeighborSides(t,e){e.lowNborSideNode=this.scanLine.NextLowR(t),e.highNborSideNode=this.scanLine.NextHighR(t)}FindNeighborsBRR(t,e,i){this.LowNeighborSides.Clear(),this.HighNeighborSides.Clear(),this.FindNeighbors(t,e,this.LowNeighborSides),this.FindNeighbors(t,i,this.HighNeighborSides)}FindNeighbors(t,e,i){let n=t instanceof Gn?e.item.Start:e.item.End,o={lowNborSideNode:null,highNborSideNode:null};this.FindInitialNeighborSides(e,o),this.SkipToNeighbor(this.ScanDirection.OppositeDirection,e.item,n,o.lowNborSideNode,i),this.SkipToNeighbor(this.ScanDirection.Dir,e.item,n,o.highNborSideNode,i)}SkipToNeighbor(t,e,i,n,o){let s=null,a=null;for(;;n=this.scanLine.Next(t,n))if(n.item.Obstacle!==e.Obstacle){if(n.item.Obstacle.IsGroup){this.ProcessGroupSideEncounteredOnTraversalToNeighbor(n,i,t)&&a==null&&(a=n.item);continue}if(n.item instanceof Qi===H.IsAscending(t)){this.ScanLineCrossesObstacle(i,n.item.Obstacle)&&(s=n,a=null);continue}break}o.SetSides(t,n,s,a)}ProcessGroupSideEncounteredOnTraversalToNeighbor(t,e,i){if(!this.ScanLineCrossesObstacle(e,t.item.Obstacle))return!1;let n=t.item instanceof Dt===H.IsAscending(i)?i:F.OppositeDir(i),o=this.ScanLineIntersectSide(e,t.item);return this.CurrentGroupBoundaryCrossingMap.AddIntersection(o,t.item.Obstacle,n),!0}FindNeighborsAndProcessVertexEvent(t,e,i){this.CurrentGroupBoundaryCrossingMap.Clear(),this.FindNeighborsBRR(i,t,e),this.ProcessVertexEvent(t,e,i),this.CurrentGroupBoundaryCrossingMap.Clear()}ProcessEventO(t){var a,u;let e=t.Obstacle;e.CreateInitialSides(t.Vertex,this.ScanDirection),this.AddSideToScanLine(e.ActiveLowSide,t.Site);let i=this.AddSideToScanLine(e.ActiveHighSide,t.Site),n=this.scanLine.Find(e.ActiveLowSide);this.FindNeighborsAndProcessVertexEvent(n,i,t);let o=(a=this.LowNeighborSides.GroupSideInterveningBeforeLowNeighbor)!=null?a:this.LowNeighborSides.LowNeighborSide;this.SideReflectsUpward(o)&&this.LoadReflectionEvents(e.ActiveLowSide);let s=(u=this.HighNeighborSides.GroupSideInterveningBeforeHighNeighbor)!=null?u:this.HighNeighborSides.HighNeighborSide;if(this.SideReflectsUpward(s)&&this.LoadReflectionEvents(e.ActiveHighSide),e.ActiveHighSide.Start!==e.ActiveLowSide.Start){let h=new Qi(e,t.Vertex,this.ScanDirection);this.lookaheadScan.RemoveSitesForFlatBottom(h.Start,h.End)}this.EnqueueLowBendVertexEvent(e.ActiveLowSide),this.EnqueueHighBendOrCloseVertexEvent(e.ActiveHighSide)}ProcessEventLB(t){let e=t.Obstacle,i=new Dt(e,t.Vertex,this.ScanDirection);this.ScanDirection.ComparePerpCoord(i.End,i.Start)>0&&(this.RemoveSideFromScanLine(this.scanLine.Find(e.ActiveLowSide),t.Site),this.AddSideToScanLine(i,t.Site),e.ActiveLowSide=i,this.EnqueueLowBendVertexEvent(i))}EnqueueLowBendVertexEvent(t){this.eventQueue.Enqueue(new Js(t.Obstacle,t.EndVertex))}ProcessEventHB(t){let e=t.Obstacle,i=new Qi(e,t.Vertex,this.ScanDirection);this.RemoveSideFromScanLine(this.scanLine.Find(e.ActiveHighSide),t.Site);let n=this.AddSideToScanLine(i,t.Site);if(e.ActiveHighSide=i,this.EnqueueHighBendOrCloseVertexEvent(e.ActiveHighSide),this.wantReflections&&this.ScanDirection.IsHorizontal&&i.Start.x===e.VisibilityBoundingBox.right&&this.SideReflectsUpward(i)){let o=this.scanLine.NextHighR(n);o.item instanceof Dt&&this.SideReflectsDownward(o.item)&&(!e.isOverlapped||!this.ObstacleTree.PointIsInsideAnObstacle(i.Start,this.ScanDirection))&&(this.StoreLookaheadSite(o.item.Obstacle,i,i.Start,!0),this.LoadReflectionEvents(o.item))}}EnqueueHighBendOrCloseVertexEvent(t){let e=t.Obstacle,i=this.ScanDirection.IsHorizontal?t.EndVertex.prevOnPolyline:t.EndVertex.nextOnPolyline;this.ScanDirection.ComparePerpCoord(i.point,t.End)>0?this.eventQueue.Enqueue(new $s(e,t.EndVertex)):this.eventQueue.Enqueue(new Ks(e,t.EndVertex))}CreateCloseEventSegmentsAndFindNeighbors(t){let e=t.Obstacle,i=this.scanLine.Find(e.ActiveLowSide),n=this.scanLine.Find(e.ActiveHighSide);if(this.scanLine.Compare(e.ActiveLowSide,e.ActiveHighSide)===1){let o=i;i=n,n=o}if(this.FindNeighborsAndProcessVertexEvent(i,n,t),this.wantReflections&&e.isOverlapped)for(let o=this.scanLine.NextHighR(i);o.item!==n.item;o=this.scanLine.NextHighR(o))this.LoadReflectionEvents(o.item);this.scanLine.Remove(e.ActiveLowSide,t.Site),this.scanLine.Remove(e.ActiveHighSide,t.Site)}ProcessEventCV(t){this.CreateCloseEventSegmentsAndFindNeighbors(t);let e=this.LowNeighborSides.LowNeighbor.item,i=this.HighNeighborSides.HighNeighbor.item,n=t.Obstacle;this.LoadReflectionEvents(e),this.LoadReflectionEvents(i),n.Close()}ProcessEventLR(t){let e=t.Side.Obstacle,i=this.scanLine.NextLowB(t.Side).item;this.AddPerpendicularReflectionSegment(t,t.Side,i)&&this.AddParallelReflectionSegment(e,i,null,t)&&this.LoadReflectionEvents(e.ActiveLowSide)}ProcessEventHR(t){let e=t.Side.Obstacle,i=this.scanLine.NextHighB(t.Side).item;this.AddPerpendicularReflectionSegment(t,t.Side,i)&&this.AddParallelReflectionSegment(e,null,i,t)&&this.LoadReflectionEvents(e.ActiveHighSide)}MakeInBoundsLocation(t){let e=Math.max(t.x,this.ObstacleTree.GraphBox.left),i=Math.max(t.y,this.ObstacleTree.GraphBox.bottom);return new d(Math.min(e,this.ObstacleTree.GraphBox.right),Math.min(i,this.ObstacleTree.GraphBox.top))}IsInBoundsV(t){return this.IsInBoundsP(t.point)}IsInBoundsP(t){return B.EqualPP(t,this.MakeInBoundsLocation(t))}},Rn=ut;Rn.SentinelOffset=1;var Ft=class extends Rn{constructor(){super(!1);this.horizontalVertexPoints=new Se;this.verticalVertexPoints=new Se;this.boundingBoxSteinerPoints=new Se;this.xCoordAccumulator=new Set;this.yCoordAccumulator=new Set;this.horizontalCoordMap=new Map;this.verticalCoordMap=new Map}Clear(){super.Clear(),this.Cleanup()}Cleanup(){this.horizontalVertexPoints.clear(),this.verticalVertexPoints.clear(),this.boundingBoxSteinerPoints.clear(),this.xCoordAccumulator.clear(),this.yCoordAccumulator.clear(),this.horizontalCoordMap.clear(),this.verticalCoordMap.clear()}GenerateVisibilityGraph(){this.AccumulateVertexCoords(),this.CreateSegmentVectorsAndPopulateCoordinateMaps(),this.RunScanLineToCreateSegmentsAndBoundingBoxSteinerPoints(),this.GenerateSparseIntersectionsFromVertexPoints(),this.CreateScanSegmentTrees(),this.Cleanup()}AccumulateVertexCoords(){for(let e of this.ObstacleTree.GetAllObstacles())this.xCoordAccumulator.add(e.VisibilityBoundingBox.left),this.xCoordAccumulator.add(e.VisibilityBoundingBox.right),this.yCoordAccumulator.add(e.VisibilityBoundingBox.top),this.yCoordAccumulator.add(e.VisibilityBoundingBox.bottom)}CreateSegmentVectorsAndPopulateCoordinateMaps(){this.horizontalScanSegmentVector=new js(this.yCoordAccumulator,!0),this.verticalScanSegmentVector=new js(this.xCoordAccumulator,!1);for(let e=0;e<this.horizontalScanSegmentVector.Length;e++)this.horizontalCoordMap.set(this.horizontalScanSegmentVector.Item(e).Coord,e);for(let e=0;e<this.verticalScanSegmentVector.Length;e++)this.verticalCoordMap.set(this.verticalScanSegmentVector.Item(e).Coord,e)}RunScanLineToCreateSegmentsAndBoundingBoxSteinerPoints(){super.GenerateVisibilityGraph(),this.horizontalScanSegmentVector.ScanSegmentsComplete(),this.verticalScanSegmentVector.ScanSegmentsComplete(),this.xCoordAccumulator.clear(),this.yCoordAccumulator.clear()}InitializeEventQueue(e){super.InitializeEventQueue(e),this.SetVectorsAndCoordMaps(e),this.AddAxisCoordinateEvents(e)}AddAxisCoordinateEvents(e){if(e.IsHorizontal){for(let i of this.yCoordAccumulator)this.eventQueue.Enqueue(new rs(new d(this.ObstacleTree.GraphBox.left-Ft.SentinelOffset,i)));return}for(let i of this.xCoordAccumulator)this.eventQueue.Enqueue(new rs(new d(i,this.ObstacleTree.GraphBox.bottom-Ft.SentinelOffset)))}ProcessCustomEvent(e){this.ProcessAxisCoordinate(e)||this.ProcessCustomEvent(e)}ProcessAxisCoordinate(e){return e instanceof rs?(this.CreateScanSegmentsOnAxisCoordinate(e.Site),!0):!1}InsertPerpendicularReflectionSegment(e,i){return!1}InsertParallelReflectionSegment(e,i,n,o,s,a){return!1}ProcessVertexEvent(e,i,n){let o=this.ScanDirection.IsHorizontal?this.horizontalVertexPoints:this.verticalVertexPoints;o.add(n.Site);let s=this.LowNeighborSides.LowNeighbor.item,a=this.HighNeighborSides.HighNeighbor.item,u=this.ScanDirection.Dir,h=this.ScanDirection.OppositeDirection,c=this.ScanLineIntersectSide(n.Site,s),f=this.ScanLineIntersectSide(n.Site,a);if(this.ObstacleTree.GraphBox.contains(c)){let v=H.RectangleBorderIntersect(s.Obstacle.VisibilityBoundingBox,c,u);B.IsPureLower(v,n.Site)&&this.boundingBoxSteinerPoints.add(v)}if(this.ObstacleTree.GraphBox.contains(f)){let v=H.RectangleBorderIntersect(a.Obstacle.VisibilityBoundingBox,f,h);B.IsPureLower(n.Site,v)&&this.boundingBoxSteinerPoints.add(v)}let P={lowCorner:void 0,highCorner:void 0};Ft.GetBoundingCorners(e.item.Obstacle.VisibilityBoundingBox,n instanceof Gn,this.ScanDirection.IsHorizontal,P),(B.IsPureLower(c,P.lowCorner)||s.Obstacle.IsInSameClump(n.Obstacle))&&o.add(P.lowCorner),(B.IsPureLower(P.highCorner,f)||a.Obstacle.IsInSameClump(n.Obstacle))&&o.add(P.highCorner)}static GetBoundingCorners(e,i,n,o){if(i){o.lowCorner=e.leftBottom,o.highCorner=n?e.rightBottom:e.leftTop;return}o.lowCorner=n?e.leftTop:e.rightBottom,o.highCorner=e.rightTop}CreateScanSegmentsOnAxisCoordinate(e){this.CurrentGroupBoundaryCrossingMap.Clear();let i=this.scanLine.Lowest(),n=this.scanLine.NextHighR(i),o=0,s=e,a=!1;for(;n!=null;n=this.scanLine.NextHighR(n)){if(this.SkipSide(s,n.item))continue;if(n.item.Obstacle.IsGroup){(o===0||a)&&this.HandleGroupCrossing(e,n.item);continue}if(n.item instanceof Dt){if(o>0){o++;continue}s=this.CreateScanSegment(s,n.item,re.NormalWeight),this.CurrentGroupBoundaryCrossingMap.Clear(),o=1,a=n.item.Obstacle.isOverlapped;continue}o++,!(o>0)&&(s=n.item.Obstacle.isOverlapped||n.item.Obstacle.OverlapsGroupCorner?this.CreateScanSegment(s,n.item,re.OverlappedWeight):this.ScanLineIntersectSide(s,n.item),this.CurrentGroupBoundaryCrossingMap.Clear(),a=!1)}let u=this.ScanDirection.IsHorizontal?new d(this.ObstacleTree.GraphBox.right+Ft.SentinelOffset,s.y):new d(s.x,this.ObstacleTree.GraphBox.top+Ft.SentinelOffset);this.parallelSegmentVector.CreateScanSegment(s,u,re.NormalWeight,this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(s,u)),this.parallelSegmentVector.ScanSegmentsCompleteForCurrentSlot()}HandleGroupCrossing(e,i){if(!this.ScanLineCrossesObstacle(e,i.Obstacle))return;let n=i instanceof Dt?this.ScanDirection.Dir:this.ScanDirection.OppositeDirection,o=this.ScanLineIntersectSide(e,i),s=this.CurrentGroupBoundaryCrossingMap.AddIntersection(o,i.Obstacle,n);this.AddPerpendicularCoordForGroupCrossing(o);let a=s.GetInteriorVertexPoint(o);this.AddPerpendicularCoordForGroupCrossing(a)}AddPerpendicularCoordForGroupCrossing(e){let i=this.FindPerpendicularSlot(e,0);i!==-1&&this.perpendicularSegmentVector.Item(i).AddPendingPerpendicularCoord(this.parallelSegmentVector.CurrentSlot.Coord)}SkipSide(e,i){if(i.Obstacle.IsSentinel)return!0;let n=i.Obstacle.VisibilityBoundingBox;return this.ScanDirection.IsHorizontal?e.y===n.bottom||e.y===n.top:e.x===n.left||e.x===n.right}CreateScanSegment(e,i,n){let o=this.ScanLineIntersectSide(e,i);return e!==o&&this.parallelSegmentVector.CreateScanSegment(e,o,n,this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(e,o)),o}GenerateSparseIntersectionsFromVertexPoints(){this.VisibilityGraph=Ft.NewVisibilityGraph(),this.GenerateSparseIntersectionsAlongHorizontalAxis(),this.GenerateSparseIntersectionsAlongVerticalAxis(),this.ConnectAdjoiningScanSegments(),this.horizontalScanSegmentVector.CreateSparseVerticesAndEdges(this.VisibilityGraph),this.verticalScanSegmentVector.CreateSparseVerticesAndEdges(this.VisibilityGraph)}GenerateSparseIntersectionsAlongHorizontalAxis(){this.currentAxisPointComparer=Vo;let e=Array.from(this.horizontalVertexPoints.values()).sort(this.currentAxisPointComparer),i=Array.from(this.boundingBoxSteinerPoints.values()).sort(this.currentAxisPointComparer);this.ScanDirection=Xe.HorizontalInstance,this.SetVectorsAndCoordMaps(this.ScanDirection),this.GenerateSparseIntersections(e,i)}GenerateSparseIntersectionsAlongVerticalAxis(){this.currentAxisPointComparer=(n,o)=>n.compareTo(o);let e=Array.from(this.verticalVertexPoints.values()).sort(this.currentAxisPointComparer),i=Array.from(this.boundingBoxSteinerPoints.values()).sort(this.currentAxisPointComparer);this.ScanDirection=Xe.VerticalInstance,this.SetVectorsAndCoordMaps(this.ScanDirection),this.GenerateSparseIntersections(e,i)}SetVectorsAndCoordMaps(e){e.IsHorizontal?(this.parallelSegmentVector=this.horizontalScanSegmentVector,this.perpendicularSegmentVector=this.verticalScanSegmentVector,this.perpendicularCoordMap=this.verticalCoordMap):(this.parallelSegmentVector=this.verticalScanSegmentVector,this.perpendicularSegmentVector=this.horizontalScanSegmentVector,this.perpendicularCoordMap=this.horizontalCoordMap)}ConnectAdjoiningScanSegments(){this.horizontalScanSegmentVector.ConnectAdjoiningSegmentEndpoints(),this.verticalScanSegmentVector.ConnectAdjoiningSegmentEndpoints()}GenerateSparseIntersections(e,i){this.perpendicularSegmentVector.ResetForIntersections(),this.parallelSegmentVector.ResetForIntersections();let n=1,o={j:0};for(let s of this.parallelSegmentVector.Items())for(;!(!s.CurrentSegment.ContainsPoint(e[n])&&(!this.AddSteinerPointsToInterveningSegments(e[n],i,o,s)||!s.TraverseToSegmentContainingPoint(e[n])));){if(this.AddPointsToCurrentSegmentIntersections(i,o,s),this.GenerateIntersectionsFromVertexPointForCurrentSegment(e[n],s),s.PointIsCurrentEndAndNextStart(e[n])){s.MoveNext();continue}if(++n>=e.length)return}}AddSteinerPointsToInterveningSegments(e,i,n,o){for(;n.j<i.length&&this.currentAxisPointComparer(i[n.j],e)===-1;){if(!o.TraverseToSegmentContainingPoint(i[n.j]))return!1;this.AddPointsToCurrentSegmentIntersections(i,n,o)}return!0}AddPointsToCurrentSegmentIntersections(e,i,n){for(;i.j<e.length&&n.CurrentSegment.ContainsPoint(e[i.j]);i.j++){let o=this.FindPerpendicularSlot(e[i.j],0);this.AddSlotToSegmentIntersections(n,o)}}GenerateIntersectionsFromVertexPointForCurrentSegment(e,i){let n=this.FindPerpendicularSlot(i.CurrentSegment.Start,1),o=this.FindPerpendicularSlot(i.CurrentSegment.End,-1),s=this.FindPerpendicularSlot(e,0);n>=o||(this.AddSlotToSegmentIntersections(i,n),this.AddSlotToSegmentIntersections(i,o),s>n&&s<o&&(this.AddSlotToSegmentIntersections(i,s),this.AddBinaryDivisionSlotsToSegmentIntersections(i,n,s,o)))}FindPerpendicularSlot(e,i){return Ft.FindIntersectingSlot(this.perpendicularSegmentVector,this.perpendicularCoordMap,e,i)}static FindIntersectingSlot(e,i,n,o){let s=e.GetParallelCoord(n),a=i.get(s);return a!==void 0?a:o===0?-1:e.FindNearest(s,o)}AddSlotToSegmentIntersections(e,i){let n=this.perpendicularSegmentVector.Item(i);e.CurrentSegment.AddSparseVertexCoord(n.Coord),n.AddPerpendicularCoord(e.Coord)}AddBinaryDivisionSlotsToSegmentIntersections(e,i,n,o){let s=0,a=this.perpendicularSegmentVector.Length-1;for(;a-s>1;){let u=s+Math.floor((a-s)/2);if(n<=u){a=u,n<a&&a<=o&&this.AddSlotToSegmentIntersections(e,a);continue}s=u,n>s&&s>=i&&this.AddSlotToSegmentIntersections(e,s)}}CreateScanSegmentTrees(){Ft.CreateScanSegmentTree(this.horizontalScanSegmentVector,this.HorizontalScanSegments),Ft.CreateScanSegmentTree(this.verticalScanSegmentVector,this.VerticalScanSegments)}static CreateScanSegmentTree(e,i){for(let n of e.Items())for(let o=n.FirstSegment;o!=null;o=o.NextSegment)o.HasVisibility()&&i.InsertUnique(o)}};var Qt=class{constructor(t){this.AddedVertices=new Array;this.AddedEdges=new Array;this.edgesToRestore=new Array;this.LimitPortVisibilitySpliceToEndpointBoundingBox=!1;this.GraphGenerator=t}get ObstacleTree(){return this.GraphGenerator.ObstacleTree}get VisGraph(){return this.GraphGenerator.VisibilityGraph}get IsSparseVg(){return this.GraphGenerator instanceof Ft}AddVertex(t){let e=this.VisGraph.AddVertexP(t);return this.AddedVertices.push(e),e}FindOrAddVertex(t){let e=this.VisGraph.FindVertex(t);return e!=null?e:this.AddVertex(t)}FindOrAddEdgeVV(t,e){return this.FindOrAddEdge(t,e,re.NormalWeight)}FindOrAddEdge(t,e,i){let n=B.GetPureDirectionVV(t,e),o={bracketSource:void 0,bracketTarget:void 0,splitVertex:void 0};Qt.GetBrackets(t,e,n,o);let s=this.VisGraph.FindEdgePP(o.bracketSource.point,o.bracketTarget.point);return s=s!=null?this.SplitEdge(s,o.splitVertex):this.CreateEdge(o.bracketSource,o.bracketTarget,i),s}static GetBrackets(t,e,i,n){if(n.splitVertex=e,!Qt.FindBracketingVertices(t,e.point,i,n)){let o={bracketSource:null,bracketTarget:null};Qt.FindBracketingVertices(e,t.point,F.OppositeDir(i),o)&&(n.bracketSource=o.bracketTarget,n.splitVertex=t),n.bracketTarget=o.bracketSource}}static FindBracketingVertices(t,e,i,n){for(n.bracketSource=t;n.bracketTarget=H.FindAdjacentVertex(n.bracketSource,i),n.bracketTarget!=null;){if(d.closeDistEps(n.bracketTarget.point,e))return!0;if(i!==B.GetDirections(n.bracketTarget.point,e))break;n.bracketSource=n.bracketTarget}return n.bracketTarget!=null}CreateEdge(t,e,i){let n=t,o=e;B.IsPureLower(n.point,o.point)||(n=e,o=t);let s=new mt(n,o,i);return Ie.AddEdge(s),this.AddedEdges.push(s),s}RemoveFromGraph(){this.RemoveAddedVertices(),this.RemoveAddedEdges(),this.RestoreRemovedEdges()}RemoveAddedVertices(){for(let t of this.AddedVertices)this.VisGraph.FindVertex(t.point)!=null&&this.VisGraph.RemoveVertex(t);this.AddedVertices=[]}RemoveAddedEdges(){for(let t of this.AddedEdges)this.VisGraph.FindVertex(t.SourcePoint)!=null&&Ie.RemoveEdge(t);this.AddedEdges=[]}RestoreRemovedEdges(){for(let t of this.edgesToRestore)Ie.AddEdge(t);this.edgesToRestore=[]}FindNextEdge(t,e){return H.FindAdjacentEdge(t,e)}FindPerpendicularOrContainingEdge(t,e,i){for(;;){let n=H.FindAdjacentVertex(t,e);if(n==null)break;let o=B.GetDirections(n.point,i);if((F.OppositeDir(e)&o)!==0)return this.VisGraph.FindEdgePP(t.point,n.point);t=n}return null}FindNearestPerpendicularOrContainingEdge(t,e,i){let n;e&B.GetDirections(t.point,i);let o=t,s=n;for(;0!==s;){let u=H.FindAdjacentVertex(o,n);if(u==null||(F.OppositeDir(n)&B.GetDirections(u.point,i))!==0)break;o=u,e&B.GetDirections(o.point,i)}let a;for(;a=this.FindPerpendicularOrContainingEdge(o,e,i),!(a!=null||o===t);)o=H.FindAdjacentVertex(o,F.OppositeDir(n));return a}ConnectVertexToTargetVertex(t,e,i,n){if(d.closeDistEps(t.point,e.point))return;let o=B.GetDirections(t.point,e.point);if(B.IsPureDirectionD(o)){this.FindOrAddEdgeVV(t,e);return}let s=H.FindBendPointBetween(t.point,e.point,i),a=this.FindOrAddVertex(s);this.FindOrAddEdge(t,a,n),this.FindOrAddEdge(a,e,n)}AddEdgeToTargetEdge(t,e,i){let n=this.VisGraph.FindVertex(i);return n==null&&(n=this.AddVertex(i),this.SplitEdge(e,n)),this.FindOrAddEdgeVV(t,n),n}SplitEdge(t,e){return t==null?null:d.closeDistEps(t.Source.point,e.point)||d.closeDistEps(t.Target.point,e.point)?t:(t instanceof mt||this.edgesToRestore.push(t),Ie.RemoveEdge(t),(this.IsSparseVg||t.Weight===re.OverlappedWeight)&&e.Degree>0?(this.FindOrAddEdge(e,t.Source,t.Weight),this.FindOrAddEdge(e,t.Target,t.Weight)):(this.CreateEdge(e,t.Target,t.Weight),this.CreateEdge(t.Source,e,t.Weight)))}ExtendEdgeChainVRLPB(t,e,i,n,o){let s=B.GetDirections(i.start,i.end);if(s===0)return;let a=H.GetRectangleBound(e,s),u=H.IsVerticalD(s)?d.RoundPoint(new d(t.point.x,a)):d.RoundPoint(new d(a,t.point.y));if(d.closeDistEps(u,t.point)||B.GetDirections(t.point,u)!==s)return;let h=i;B.GetDirections(u,h.end)===s&&(h=w.mkPP(h.start,u)),this.ExtendEdgeChain(t,s,h,i,n,o)}ExtendEdgeChain(t,e,i,n,o,s){if(B.GetDirections(t.point,i.end)!==e)return;let u=F.RotateLeft(e),h=H.FindAdjacentVertex(t,u);if(h==null&&(u=F.OppositeDir(u),h=H.FindAdjacentVertex(t,u),h==null))return;let c=F.OppositeDir(u),f={spliceTarget:null};this.ExtendSpliceWorker(h,e,c,i,n,s,f)&&this.ExtendSpliceWorker(f.spliceTarget,e,u,i,n,s,f),this.SpliceGroupBoundaryCrossings(o,t,i)}SpliceGroupBoundaryCrossings(t,e,i){if(t==null||t.Count()===0)return;t.Reset();let n=i.start,o=i.end,s=B.GetDirections(n,o);H.IsAscending(s)||(n=i.end,o=i.start,s=F.OppositeDir(s)),e=Qt.TraverseToFirstVertexAtOrAbove(e,n,F.OppositeDir(s));for(let a=e;a!=null;a=H.FindAdjacentVertex(a,s)){let u=B.ComparePP(a.point,o)>=0;for(;t.CurrentIsBeforeOrAt(a.point);){let h=t.Pop();B.ComparePP(h.Location,e.point)>0&&B.ComparePP(h.Location,o)<=0&&this.SpliceGroupBoundaryCrossing(a,h,F.OppositeDir(s)),B.ComparePP(h.Location,e.point)>=0&&B.ComparePP(h.Location,o)<0&&this.SpliceGroupBoundaryCrossing(a,h,s)}if(u)break}}static TraverseToFirstVertexAtOrAbove(t,e,i){let n=t,o=F.OppositeDir(i);for(;;){let s=H.FindAdjacentVertex(n,i);if(s==null||B.GetDirections(s.point,e)===o)break;n=s}return n}SpliceGroupBoundaryCrossing(t,e,i){var o,s;let n=Ii.ToCrossingArray(e.Crossings,i);if(n!=null){let a=(o=this.VisGraph.FindVertex(e.Location))!=null?o:this.AddVertex(e.Location);t.point.equal(a.point)||this.FindOrAddEdgeVV(t,a);let u=n[0].GetInteriorVertexPoint(e.Location),h=(s=this.VisGraph.FindVertex(u))!=null?s:this.AddVertex(u),c=this.FindOrAddEdgeVV(a,h),f=n.map(P=>P.Group.InputShape);c.IsPassable=()=>f.some(P=>P.IsTransparent)}}ExtendSpliceWorker(t,e,i,n,o,s,a){let u=H.FindAdjacentVertex(t,i);a.spliceTarget=H.FindAdjacentVertex(u,i);let h={spliceSource:t};for(;Qt.GetNextSpliceSource(h,i,e);){let c=H.FindBendPointBetween(u.point,h.spliceSource.point,F.OppositeDir(i));if(Qt.IsPointPastSegmentEnd(o,c))break;if(a.spliceTarget=Qt.GetSpliceTarget(h,i,c),a.spliceTarget==null){if(this.IsSkippableSpliceSourceWithNullSpliceTarget(h.spliceSource,e))continue;if(this.ObstacleTree.SegmentCrossesAnObstacle(h.spliceSource.point,c))return!1}let f=this.VisGraph.FindVertex(c);if(f!=null){if(a.spliceTarget==null||this.VisGraph.FindEdgePP(u.point,c)!=null)return a.spliceTarget==null&&this.FindOrAddEdge(u,f,s?re.OverlappedWeight:re.NormalWeight),!1}else f=this.AddVertex(c);if(this.FindOrAddEdge(u,f,s?re.OverlappedWeight:re.NormalWeight),this.FindOrAddEdge(h.spliceSource,f,s?re.OverlappedWeight:re.NormalWeight),s&&(s=this.SeeIfSpliceIsStillOverlapped(e,f)),u=f,(e&B.GetDirections(c,n.end))===0){a.spliceTarget=null;break}}return a.spliceTarget!=null}static GetNextSpliceSource(t,e,i){let n=H.FindAdjacentVertex(t.spliceSource,i);if(n==null)for(n=t.spliceSource;;){if(n=H.FindAdjacentVertex(n,F.OppositeDir(e)),n==null)return!1;let o=H.FindAdjacentVertex(n,i);if(o!=null){n=o;break}}return t.spliceSource=n,!0}static GetSpliceTarget(t,e,i){let n=B.GetDirections(t.spliceSource.point,i),o=n,s=t.spliceSource;for(;o===n&&(t.spliceSource=s,s=H.FindAdjacentVertex(t.spliceSource,e),s!=null);){if(d.closeDistEps(s.point,i)){s=H.FindAdjacentVertex(s,e);break}o=B.GetDirections(s.point,i)}return s}SeeIfSpliceIsStillOverlapped(t,e){let i=this.FindNextEdge(e,F.RotateLeft(t)),n=i==null?!1:re.NormalWeight===i.Weight;return n||(i=this.FindNextEdge(e,F.RotateRight(t)),n=i==null?!1:re.NormalWeight===i.Weight),!n||this.ObstacleTree.PointIsInsideAnObstaclePD(e.point,t)}IsSkippableSpliceSourceWithNullSpliceTarget(t,e){if(Qt.IsSkippableSpliceSourceEdgeWithNullTarget(H.FindAdjacentEdge(t,e)))return!0;let i=H.FindAdjacentEdge(t,F.OppositeDir(e));return Qt.IsSkippableSpliceSourceEdgeWithNullTarget(i)||Qt.IsReflectionEdge(i)}static IsSkippableSpliceSourceEdgeWithNullTarget(t){return t!=null&&t.IsPassable!=null&&Q(t.Length,co.BoundaryWidth)}static IsReflectionEdge(t){return t!=null&&t.Weight===re.ReflectionWeight}static IsPointPastSegmentEnd(t,e){return B.GetDirections(t.start,t.end)===B.GetDirections(t.end,e)}toString(){return Ad.String.Format("{0} {1}",this.AddedVertices.length,this.edgesToRestore.length)}};var Nn=class{constructor(t){this.obstaclePortMap=new Map;this.freePointMap=new qe;this.freePointLocationsUsedByRouteEdges=new Se;this.RouteToCenterOfObstacles=!1;this.obstaclePortsInGraph=new Array;this.freePointsInGraph=new Set;this.activeAncestors=new Array;this.TransUtil=new Qt(t),this.graphGenerator=t}get LimitPortVisibilitySpliceToEndpointBoundingBox(){return this.TransUtil.LimitPortVisibilitySpliceToEndpointBoundingBox}set LimitPortVisibilitySpliceToEndpointBoundingBox(t){this.TransUtil.LimitPortVisibilitySpliceToEndpointBoundingBox=t}get VisGraph(){return this.graphGenerator.VisibilityGraph}get HScanSegments(){return this.graphGenerator.HorizontalScanSegments}get VScanSegments(){return this.graphGenerator.VerticalScanSegments}get ObstacleTree(){return this.graphGenerator.ObstacleTree}get AncestorSets(){return this.ObstacleTree.AncestorSets}Clear(){this.TransUtil.RemoveFromGraph(),this.obstaclePortMap.clear()}CreateObstaclePorts(t){for(let e of t.Ports)this.CreateObstaclePort(t,e)}CreateObstaclePort(t,e){if(e.Curve==null)return null;let i=d.RoundPoint(e.Location);if(0===E.PointRelativeToCurveLocation(i,t.InputShape.BoundaryCurve)||t.InputShape.BoundaryCurve!==e.Curve&&0===E.PointRelativeToCurveLocation(i,e.Curve))return null;let n=new Pl(e,t);return this.obstaclePortMap.set(e,n),n}FindVertices(t){let e=new Array,i=this.obstaclePortMap.get(t);if(i)if(this.RouteToCenterOfObstacles)e.push(i.CenterVertex);else for(let n of i.PortEntrances){let o=this.VisGraph.FindVertex(n.UnpaddedBorderIntersect);o!=null&&e.push(o)}else e.push(this.VisGraph.FindVertex(d.RoundPoint(t.Location)));return e}RemoveObstaclePorts(t){for(let e of t.Ports)this.RemoveObstaclePort(e)}RemoveObstaclePort(t){this.obstaclePortMap.delete(t)}AddControlPointsToGraph(t,e){this.GetPortSpliceLimitRectangle(t),this.activeAncestors=[];let i={oport:null},n={oport:null},o=this.FindAncestorsAndObstaclePort(t.sourcePort,i),s=this.FindAncestorsAndObstaclePort(t.targetPort,n);if(this.AncestorSets.size>0&&i.oport!=null&&n.oport!=null){let a=Fi(s,o),u=Fi(o,s);this.ActivateAncestors(u,a,e)}this.AddPortToGraph(t.sourcePort,i.oport),this.AddPortToGraph(t.targetPort,n.oport)}ConnectOobWaypointToEndpointVisibilityAtGraphBoundary(t,e){if(t==null||!t.IsOutOfBounds)return;let i=this.FindVertices(e),n=t.OutOfBoundsDirectionFromGraph&5;this.ConnectToGraphAtPointsCollinearWithVertices(t,n,i),n=t.OutOfBoundsDirectionFromGraph&10,this.ConnectToGraphAtPointsCollinearWithVertices(t,n,i)}ConnectToGraphAtPointsCollinearWithVertices(t,e,i){if(0===e)return;let n=F.OppositeDir(e);for(let o of i){let s=this.InBoundsGraphBoxIntersect(o.point,e),a=this.VisGraph.FindVertex(s);a!=null&&this.TransUtil.ConnectVertexToTargetVertex(t.Vertex,a,n,re.NormalWeight)}}SetAllAncestorsActive(t,e){if(this.AncestorSets.size===0)return!1;this.ObstacleTree.AdjustSpatialAncestors(),this.ClearActiveAncestors();let i={oport:null},n={oport:null},o=this.FindAncestorsAndObstaclePort(t.sourcePort,n),s=this.FindAncestorsAndObstaclePort(t.targetPort,i);return this.AncestorSets.size>0&&o!=null&&s!=null?(this.ActivateAncestors(o,s,e),!0):!1}SetAllGroupsActive(){this.ClearActiveAncestors();for(let t of this.ObstacleTree.GetAllGroups())t.IsTransparentAncestor=!0,this.activeAncestors.push(t)}FindAncestorsAndObstaclePort(t,e){return e.oport=this.FindObstaclePort(t),this.AncestorSets.size===0?null:e.oport!=null?this.AncestorSets.get(e.oport.Obstacle.InputShape):new Set(Array.from(this.ObstacleTree.Root.AllHitItems(D.mkPP(t.Location,t.Location),i=>i.IsGroup)).map(i=>i.InputShape))}ActivateAncestors(t,e,i){for(let n of Ur(t,e)){let o=i.get(n);o.IsTransparentAncestor=!0,this.activeAncestors.push(o)}}ClearActiveAncestors(){for(let t of this.activeAncestors)t.IsTransparentAncestor=!1;this.activeAncestors=[]}RemoveControlPointsFromGraph(){this.ClearActiveAncestors(),this.RemoveObstaclePortsFromGraph(),this.RemoveFreePointsFromGraph(),this.TransUtil.RemoveFromGraph(),this.portSpliceLimitRectangle=D.mkEmpty()}RemoveObstaclePortsFromGraph(){for(let t of this.obstaclePortsInGraph)t.RemoveFromGraph();this.obstaclePortsInGraph=[]}RemoveFreePointsFromGraph(){for(let t of this.freePointsInGraph)t.RemoveFromGraph();this.freePointsInGraph.clear()}RemoveStaleFreePoints(){if(this.freePointMap.size>this.freePointLocationsUsedByRouteEdges.size){let t=Array.from(this.freePointMap).filter(e=>!this.freePointLocationsUsedByRouteEdges.has(e[0]));for(let e of t)this.freePointMap.deleteP(e[0])}}ClearVisibility(){this.freePointMap.clear();for(let t of this.obstaclePortMap.values())t.ClearVisibility()}BeginRouteEdges(){this.RemoveControlPointsFromGraph(),this.freePointLocationsUsedByRouteEdges.clear()}EndRouteEdges(){this.RemoveStaleFreePoints()}FindObstaclePort(t){let e=this.obstaclePortMap.get(t);if(e){let i={removedPorts:null,addedPorts:null};if(e.Obstacle.GetPortChanges(i)){for(let n of i.addedPorts)this.CreateObstaclePort(e.Obstacle,n);for(let n of i.removedPorts)this.RemoveObstaclePort(n);e=this.obstaclePortMap.get(t)}}return e}AddPortToGraph(t,e){if(e!=null){this.AddObstaclePortToGraph(e);return}this.AddFreePointToGraph(t.Location)}AddObstaclePortToGraph(t){if(!(t.LocationHasChanged&&(this.RemoveObstaclePort(t.Port),t=this.CreateObstaclePort(t.Obstacle,t.Port),t==null))){t.AddToGraph(this.TransUtil,this.RouteToCenterOfObstacles),this.obstaclePortsInGraph.push(t),this.CreateObstaclePortEntrancesIfNeeded(t);for(let e of t.PortEntrances)this.AddObstaclePortEntranceToGraph(e)}}CreateObstaclePortEntrancesIfNeeded(t){t.PortEntrances.length>0||this.CreateObstaclePortEntrancesFromPoints(t)}GetPortVisibilityIntersection(t){let e=this.FindObstaclePort(t.sourcePort),i=this.FindObstaclePort(t.targetPort);if(e==null||i==null||e.Obstacle.IsInConvexHull||i.Obstacle.IsInConvexHull||(this.CreateObstaclePortEntrancesIfNeeded(e),this.CreateObstaclePortEntrancesIfNeeded(i),!e.VisibilityRectangle.intersects(i.VisibilityRectangle)))return null;for(let n of e.PortEntrances)if(!!n.WantVisibilityIntersection)for(let o of i.PortEntrances){if(!o.WantVisibilityIntersection)continue;let s=n.IsVertical===o.IsVertical?Nn.GetPathPointsFromOverlappingCollinearVisibility(n,o):Nn.GetPathPointsFromIntersectingVisibility(n,o);if(s!=null)return s}return null}static GetPathPointsFromOverlappingCollinearVisibility(t,e){return!H.IntervalsAreSame(t.MaxVisibilitySegment.start,t.MaxVisibilitySegment.end,e.MaxVisibilitySegment.end,e.MaxVisibilitySegment.start)||t.HasGroupCrossings||e.HasGroupCrossings||d.closeDistEps(t.UnpaddedBorderIntersect,e.UnpaddedBorderIntersect)?null:[t.UnpaddedBorderIntersect,e.UnpaddedBorderIntersect]}static GetPathPointsFromIntersectingVisibility(t,e){let i=H.SegmentsIntersectLL(t.MaxVisibilitySegment,e.MaxVisibilitySegment);return!i||t.HasGroupCrossingBeforePoint(i)||e.HasGroupCrossingBeforePoint(i)?null:[t.UnpaddedBorderIntersect,i,e.UnpaddedBorderIntersect]}CreateObstaclePortEntrancesFromPoints(t){let e=this.graphGenerator.ObstacleTree.GraphBox,i=D.mkPP(d.RoundPoint(t.PortCurve.boundingBox.leftBottom),d.RoundPoint(t.PortCurve.boundingBox.rightTop)),n=d.RoundPoint(t.PortLocation),o=!1,s={xx0:null,xx1:null};if(!B.Equal(n.y,i.top)&&!B.Equal(n.y,i.bottom)){o=!0;let a=new w(e.left,n.y,e.right,n.y);this.GetBorderIntersections(n,a,t.PortCurve,s);let u=new d(Math.min(s.xx0.x,s.xx1.x),n.y);u.x<i.left&&(u=new d(i.left,u.y));let h=new d(Math.max(s.xx0.x,s.xx1.x),n.y);h.x>i.right&&(h=new d(i.right,h.y)),this.CreatePortEntrancesAtBorderIntersections(i,t,n,u,h)}if(!B.Equal(n.x,i.left)&&!B.Equal(n.x,i.right)){o=!0;let a=new w(n.x,e.bottom,n.x,e.top);this.GetBorderIntersections(n,a,t.PortCurve,s);let u=new d(n.x,Math.min(s.xx0.y,s.xx1.y));u.y<e.bottom&&(u=new d(u.x,e.bottom));let h=new d(n.x,Math.max(s.xx0.y,s.xx1.y));h.y>e.top&&(h=new d(h.x,e.top)),this.CreatePortEntrancesAtBorderIntersections(i,t,n,u,h)}o||this.CreateEntrancesForCornerPort(i,t,n)}GetBorderIntersections(t,e,i,n){let o=E.getAllIntersections(e,i,!0);n.xx0=d.RoundPoint(o[0].x),n.xx1=d.RoundPoint(o[1].x)}CreatePortEntrancesAtBorderIntersections(t,e,i,n,o){let s=B.GetDirections(n,o);B.EqualPP(n,i)||this.CreatePortEntrance(t,e,o,s),B.EqualPP(o,i)||this.CreatePortEntrance(t,e,n,F.OppositeDir(s))}static GetDerivative(t,e){let i=t.PortCurve.closestParameter(e),n=t.PortCurve.derivative(i),o=(t.PortCurve.parStart+t.PortCurve.parEnd)/2;return lt.CurveIsClockwise(t.PortCurve,t.PortCurve.value(o))||(n=n.mul(-1)),n}CreatePortEntrance(t,e,i,n){e.CreatePortEntrance(i,n,this.ObstacleTree);let o=Xe.GetInstance(n),s=H.GetRectangleBound(t,n)-o.Coord(i);if(s<0&&(s=-s),s>C.intersectionEpsilon){let a=F.VectorDirection(Nn.GetDerivative(e,i)),u;n|F.OppositeDir(n),0!==(n&a)&&(u=F.OppositeDir(u)),e.CreatePortEntrance(i,u,this.ObstacleTree)}}CreateEntrancesForCornerPort(t,e,i){let n=1;B.EqualPP(i,t.leftBottom)?n=4:B.EqualPP(i,t.leftTop)?n=8:B.EqualPP(i,t.rightTop)?n=1:B.EqualPP(i,t.rightBottom)&&(n=2),e.CreatePortEntrance(i,n,this.ObstacleTree),e.CreatePortEntrance(i,F.RotateRight(n),this.ObstacleTree)}AddObstaclePortEntranceToGraph(t){let e=this.VisGraph.FindVertex(t.VisibilityBorderIntersect);if(e){t.ExtendEdgeChain(this.TransUtil,e,e,this.portSpliceLimitRectangle,this.RouteToCenterOfObstacles);return}let i={targetVertex:null},n=t.IsOverlapped?re.OverlappedWeight:re.NormalWeight;this.FindorCreateNearestPerpEdgePPDNT(t.MaxVisibilitySegment.end,t.VisibilityBorderIntersect,t.OutwardDirection,n,i)!=null&&t.AddToAdjacentVertex(this.TransUtil,i.targetVertex,this.portSpliceLimitRectangle,this.RouteToCenterOfObstacles)}InBoundsGraphBoxIntersect(t,e){return H.RectangleBorderIntersect(this.graphGenerator.ObstacleTree.GraphBox,t,e)}FindorCreateNearestPerpEdgePPDN(t,e,i,n){let o={targetVertex:null};return this.FindorCreateNearestPerpEdgePPDNT(t,e,i,n,o)}FindorCreateNearestPerpEdgePPDNT(t,e,i,n,o){let s=H.SortAscending(t,e),a=s[0],u=s[1],h=H.IsVerticalD(i)?this.HScanSegments:this.VScanSegments,c=H.IsAscending(i)?h.FindLowestIntersector(a,u):h.FindHighestIntersector(a,u);if(c==null)return o.targetVertex=null,null;let f=H.SegmentIntersectionSP(c,a);return this.FindOrCreateNearestPerpEdgeFromNearestPerpSegment(H.IsAscending(i)?a:u,c,f,n,o)}FindOrCreateNearestPerpEdgeFromNearestPerpSegment(t,e,i,n,o){var c;let s={segsegVertex:this.VisGraph.FindVertex(i),targetVertex:null};if(s.segsegVertex==null){let f=this.FindOrCreateSegmentIntersectionVertexAndAssociatedEdge(t,i,e,n,s);if(f!=null)return f}else if(B.EqualPP(t,i))return o.targetVertex=s.segsegVertex,this.TransUtil.FindNextEdge(o.targetVertex,F.OppositeDir(e.ScanDirection.Dir));let a=B.GetDirections(i,t),u=B.GetDirections(s.segsegVertex.point,t);if(a===u){let f={bracketTarget:null,bracketSource:null};return Qt.FindBracketingVertices(s.segsegVertex,t,a,f),(c=this.TransUtil.FindNextEdge(f.bracketSource,F.RotateLeft(a)))!=null?c:this.TransUtil.FindNextEdge(f.bracketSource,F.RotateRight(a))}u&=~a;let h=this.TransUtil.FindNearestPerpendicularOrContainingEdge(s.segsegVertex,u,t);return h==null?(o.targetVertex=this.TransUtil.AddVertex(i),this.TransUtil.FindOrAddEdge(o.targetVertex,e.HighestVisibilityVertex,e.Weight)):(s.segsegVertex=H.GetEdgeEnd(h,F.OppositeDir(u)),i=H.SegmentIntersectionPPP(t,i,s.segsegVertex.point),B.EqualPP(s.segsegVertex.point,i)?(o.targetVertex=s.segsegVertex,this.TransUtil.FindNextEdge(s.segsegVertex,u)):(o.targetVertex=this.TransUtil.FindOrAddVertex(i),this.TransUtil.FindOrAddEdge(s.segsegVertex,o.targetVertex,n)))}FindOrCreateSegmentIntersectionVertexAndAssociatedEdge(t,e,i,n,o){let a=(i.IsVertical?this.HScanSegments:this.VScanSegments).FindHighestIntersector(i.Start,e);if(a==null)return o.segsegVertex=null,o.targetVertex=this.TransUtil.AddVertex(e),this.TransUtil.FindOrAddEdge(o.targetVertex,i.LowestVisibilityVertex,i.Weight);let u=H.SegmentsIntersection(i,a);if(o.segsegVertex=this.VisGraph.FindVertex(u),!o.segsegVertex){o.segsegVertex=this.TransUtil.AddVertex(u);let h=this.AddEdgeToClosestSegmentEnd(i,o.segsegVertex,i.Weight);if(this.AddEdgeToClosestSegmentEnd(a,o.segsegVertex,a.Weight),B.EqualPP(o.segsegVertex.point,e))return o.targetVertex=o.segsegVertex,h}return B.EqualPP(t,e)?(o.targetVertex=this.TransUtil.FindOrAddVertex(e),this.TransUtil.FindOrAddEdge(o.segsegVertex,o.targetVertex,n)):(o.targetVertex=null,null)}AddEdgeToClosestSegmentEnd(t,e,i){return B.IsPureLower(t.HighestVisibilityVertex.point,e.point)?this.TransUtil.FindOrAddEdge(t.HighestVisibilityVertex,e,i):B.IsPureLower(e.point,t.LowestVisibilityVertex.point)?this.TransUtil.FindOrAddEdge(e,t.LowestVisibilityVertex,i):this.TransUtil.FindOrAddEdgeVV(t.LowestVisibilityVertex,e)}GetPortSpliceLimitRectangle(t){if(!this.LimitPortVisibilitySpliceToEndpointBoundingBox){this.portSpliceLimitRectangle=this.graphGenerator.ObstacleTree.GraphBox;return}this.portSpliceLimitRectangle=this.GetPortRectangle(t.sourcePort),this.portSpliceLimitRectangle.addRecSelf(this.GetPortRectangle(t.targetPort))}GetPortRectangle(t){let e=this.obstaclePortMap.get(t);return e?e.Obstacle.VisibilityBoundingBox.clone():D.mkOnPoints([d.RoundPoint(t.Location)])}AddToLimitRectangle(t){this.graphGenerator.IsInBoundsP(t)&&this.portSpliceLimitRectangle.add(t)}FindOrCreateFreePoint(t){let e=this.freePointMap.get(t);return e?e.GetVertex(this.TransUtil,t):(e=new yl(this.TransUtil,t),this.freePointMap.set(t,e)),this.freePointsInGraph.add(e),this.freePointLocationsUsedByRouteEdges.add(t),e}AddFreePointToGraph(t){t=d.RoundPoint(t);let e=this.VisGraph.FindVertex(t),i=this.FindOrCreateFreePoint(t);if(e!=null)return i;if(!this.graphGenerator.IsInBoundsP(t))return this.CreateOutOfBoundsFreePoint(i),i;let n=null;i.IsOverlapped=this.ObstacleTree.PointIsInsideAnObstacle(i.Point,this.HScanSegments.ScanDirection);let o;if(this.VScanSegments.FindSegmentContainingPoint(t,!0),o!=null){let a={targetVertex:null};n=this.FindOrCreateNearestPerpEdgeFromNearestPerpSegment(t,o,t,i.InitialWeight,a)}let s=4;if(n!=null)s=H.EdgeDirectionVE(n),this.ConnectFreePointToLateralEdge(i,F.RotateLeft(s)),this.ConnectFreePointToLateralEdge(i,F.RotateRight(s));else for(let a=0;a<4;a++)this.ConnectFreePointToLateralEdge(i,s),s=F.RotateLeft(s);return i}CreateOutOfBoundsFreePoint(t){let e=t.Point,i=this.graphGenerator.MakeInBoundsLocation(e),n=B.GetDirections(i,e);if(t.OutOfBoundsDirectionFromGraph=n,!B.IsPureDirectionD(n)){t.AddOobEdgesFromGraphCorner(this.TransUtil,i);return}let o=this.VisGraph.FindVertex(i),s=F.OppositeDir(n);if(o!=null)t.AddToAdjacentVertex(this.TransUtil,o,s,this.portSpliceLimitRectangle);else{let h=this.FindorCreateNearestPerpEdgePPDN(e,i,n,re.NormalWeight);h!=null&&(o=t.AddEdgeToAdjacentEdge(this.TransUtil,h,s,this.portSpliceLimitRectangle))}let a=H.FindAdjacentVertex(o,F.RotateLeft(s));a!=null&&this.TransUtil.ConnectVertexToTargetVertex(t.Vertex,a,s,re.NormalWeight);let u=H.FindAdjacentVertex(o,F.RotateRight(s));u!=null&&this.TransUtil.ConnectVertexToTargetVertex(t.Vertex,u,s,re.NormalWeight)}ConnectFreePointToLateralEdge(t,e){let i=t.IsOverlapped?this.InBoundsGraphBoxIntersect(t.Point,e):t.MaxVisibilityInDirectionForNonOverlappedFreePoint(e,this.TransUtil),n=this.FindorCreateNearestPerpEdgePPDN(i,t.Point,e,t.InitialWeight);n!=null&&t.AddEdgeToAdjacentEdge(this.TransUtil,n,e,this.portSpliceLimitRectangle)}};var bt=class extends _{constructor(e,i,n){super(null);this.Padding=0;this.CornerFitRadius=0;this.edgeSeparatian=3;this.BendPenaltyAsAPercentageOfDistance=0;this.ShapeToObstacleMap=new Map;this.EdgesToRoute=new Array;this.removeStaircases=!0;this.selfEdges=new Array;this.Padding=i,this.CornerFitRadius=n,this.BendPenaltyAsAPercentageOfDistance=vr.DefaultBendPenaltyAsAPercentageOfDistance,this.GraphGenerator=new Ft,this.PortManager=new Nn(this.GraphGenerator),this.AddShapes(e)}get RouteToCenterOfObstacles(){return this.PortManager.RouteToCenterOfObstacles}set RouteToCenterOfObstacles(e){this.PortManager.RouteToCenterOfObstacles=e}get LimitPortVisibilitySpliceToEndpointBoundingBox(){return this.PortManager.LimitPortVisibilitySpliceToEndpointBoundingBox}set LimitPortVisibilitySpliceToEndpointBoundingBox(e){this.PortManager.LimitPortVisibilitySpliceToEndpointBoundingBox=e}AddEdgeGeometryToRoute(e){d.closeDistEps(d.RoundPoint(e.sourcePort.Location),d.RoundPoint(e.targetPort.Location))?this.selfEdges.push(e):this.EdgesToRoute.push(e)}get EdgeGeometriesToRoute(){return this.EdgesToRoute}RemoveAllEdgeGeometriesToRoute(){this.EdgesToRoute=[]}get UseSparseVisibilityGraph(){return this.GraphGenerator instanceof Ft}get Obstacles(){return Array.from(this.ShapeToObstacleMap.values()).map(e=>e.InputShape)}get PaddedObstacles(){return Array.from(this.ShapeToObstacleMap.values()).map(e=>e.PaddedPolyline)}AddObstacles(e){this.AddShapes(e),this.RebuildTreeAndGraph()}AddShapes(e){for(let i of e)this.AddObstacleWithoutRebuild(i)}AddObstacle(e){this.AddObstacleWithoutRebuild(e),this.RebuildTreeAndGraph()}UpdateObstacles(e){for(let i of e)this.UpdateObstacleWithoutRebuild(i);this.RebuildTreeAndGraph()}UpdateObstacle(e){this.UpdateObstacleWithoutRebuild(e),this.RebuildTreeAndGraph()}RemoveObstacles(e){for(let i of e)this.RemoveObstacleWithoutRebuild(i);this.RebuildTreeAndGraph()}RemoveObstacle(e){this.RemoveObstacleWithoutRebuild(e),this.RebuildTreeAndGraph()}AddObstacleWithoutRebuild(e){if(e.BoundaryCurve==null)throw new Error("Shape must have a BoundaryCurve");this.CreatePaddedObstacle(e)}UpdateObstacleWithoutRebuild(e){if(e.BoundaryCurve==null)throw new Error("Shape must have a BoundaryCurve");this.PortManager.RemoveObstaclePorts(this.ShapeToObstacleMap.get(e)),this.CreatePaddedObstacle(e)}CreatePaddedObstacle(e){let i=new xt(e,this.Padding);this.ShapeToObstacleMap.set(e,i),this.PortManager.CreateObstaclePorts(i)}RemoveObstacleWithoutRebuild(e){let i=this.ShapeToObstacleMap.get(e);this.ShapeToObstacleMap.delete(e),this.PortManager.RemoveObstaclePorts(i)}RemoveAllObstacles(){this.InternalClear(!1)}RebuildTreeAndGraph(){let e=this.ObsTree.Root!=null,i=this.GraphGenerator.VisibilityGraph!=null;this.InternalClear(!0),e&&this.GenerateObstacleTree(),i&&this.GenerateVisibilityGraph()}get VisibilityGraph(){return this.GenerateVisibilityGraph(),this.GraphGenerator.VisibilityGraph}Clear(){this.InternalClear(!1)}static constructorEmpty(){return bt.constructorC(null)}static constructorC(e){return new bt([],bt.DefaultPadding,bt.DefaultCornerFitRadius)}static constructorI(e){return new bt(e,bt.DefaultPadding,bt.DefaultCornerFitRadius)}static constructorINN(e,i,n){return new bt(e,i,n)}static constructorGNAN(e,i,n,o){let s=new bt(It.GetShapes(e),n,o);if(i==null)for(let a of e.deepEdges)s.AddEdgeGeometryToRoute(a);else for(let a of i)s.AddEdgeGeometryToRoute(a);return s}run(){this.GenerateVisibilityGraph(),this.GeneratePaths()}GeneratePaths(){let e=this.EdgesToRoute.map(i=>new fl(i));this.FillEdgePathsWithShortestPaths(e),this.NudgePaths(e),this.RouteSelfEdges(),this.FinaliseEdgeGeometries()}RouteSelfEdges(){for(let e of this.selfEdges){let i={smoothedPolyline:null};e.curve=Re.RouteSelfEdge(e.sourcePort.Curve,Math.max(this.Padding,2*e.GetMaxArrowheadLength()),i)}}FillEdgePathsWithShortestPaths(e){this.PortManager.BeginRouteEdges();let i=new On(this.BendPenaltyAsAPercentageOfDistance);for(let n of e)this.AddControlPointsAndGeneratePath(i,n);this.PortManager.EndRouteEdges()}AddControlPointsAndGeneratePath(e,i){let n=this.PortManager.GetPortVisibilityIntersection(i.GeomEdge);if(n!=null){this.GeneratePathThroughVisibilityIntersection(i,n);return}this.SpliceVisibilityAndGeneratePath(e,i)}GeneratePathThroughVisibilityIntersection(e,i){e.PathPoints=i}SpliceVisibilityAndGeneratePath(e,i){this.PortManager.AddControlPointsToGraph(i.GeomEdge,this.ShapeToObstacleMap),this.GeneratePath(e,i,!1)||this.RetryPathsWithAdditionalGroupsEnabled(e,i),this.PortManager.RemoveControlPointsFromGraph()}GeneratePath(e,i,n){let o=this.PortManager.FindVertices(i.GeomEdge.sourcePort),s=this.PortManager.FindVertices(i.GeomEdge.targetPort);return bt.GetSingleStagePath(i,e,o,s,n)}static GetSingleStagePath(e,i,n,o,s){return e.PathPoints=i.GetPath(n,o),s&&bt.EnsureNonNullPath(e),e.PathPoints!=null&&e.PathPoints.length>0}static EnsureNonNullPath(e){e.PathPoints==null&&(B.IsPureDirection(e.GeomEdge.sourcePort.Location,e.GeomEdge.targetPort.Location)?e.PathPoints=[e.GeomEdge.sourcePort.Location,e.GeomEdge.targetPort.Location]:e.PathPoints=[e.GeomEdge.sourcePort.Location,new d(e.GeomEdge.sourcePort.Location.x,e.GeomEdge.targetPort.Location.y),e.GeomEdge.targetPort.Location])}RetryPathsWithAdditionalGroupsEnabled(e,i){(!this.PortManager.SetAllAncestorsActive(i.GeomEdge,this.ShapeToObstacleMap)||!this.GeneratePath(e,i,!1))&&(this.PortManager.SetAllGroupsActive(),this.GeneratePath(e,i,!0))}NudgePaths(e){let i=this.ObsTree.SpatialAncestorsAdjusted?fe.GetAncestorSetsMap(this.Obstacles):this.AncestorsSets;Ne.NudgePaths(e,this.edgeSeparatian,this.PaddedObstacles,i,this.RemoveStaircases)}get RemoveStaircases(){return this.removeStaircases}set RemoveStaircases(e){this.removeStaircases=e}FinaliseEdgeGeometries(){for(let e of this.EdgesToRoute.concat(this.selfEdges)){if(e.curve==null)continue;e.curve instanceof j&&(e.curve=bt.FitArcsIntoCorners(this.CornerFitRadius,Array.from(e.curve))),bt.CalculateArrowheads(e)}}CreateVisibilityGraph(){this.GraphGenerator.Clear(),this.InitObstacleTree(),this.GraphGenerator.GenerateVisibilityGraph()}static CalculateArrowheads(e){We.trimSplineAndCalculateArrowheadsII(e,e.sourcePort.Curve,e.targetPort.Curve,e.curve,!0)}get ObsTree(){return this.GraphGenerator.ObstacleTree}GenerateObstacleTree(){if(this.Obstacles==null||this.Obstacles.length===0)throw new Error("No obstacles have been added");this.ObsTree.Root==null&&this.InitObstacleTree()}InitObstacleTree(){this.AncestorsSets=fe.GetAncestorSetsMap(this.Obstacles),this.ObsTree.Init(this.ShapeToObstacleMap.values(),this.AncestorsSets,this.ShapeToObstacleMap)}InternalClear(e){this.GraphGenerator.Clear(),this.ClearShortestPaths(),e?this.PortManager.ClearVisibility():(this.PortManager.Clear(),this.ShapeToObstacleMap.clear(),this.EdgesToRoute=[])}ClearShortestPaths(){for(let e of this.EdgesToRoute)e.curve=null}GenerateVisibilityGraph(){if(this.Obstacles==null||this.Obstacles.length===0)throw new Error("No obstacles have been set");this.GraphGenerator.VisibilityGraph==null&&this.CreateVisibilityGraph()}static FitArcsIntoCorners(e,i){if(e==0)return j.mkFromPoints(i);let n=bt.GetFittedArcSegs(e,i),o=new E,s=null;for(let a of n){let u=bt.EllipseIsAlmostLineSegment(a);s!=null?u?E.continueWithLineSegmentP(o,bt.CornerPoint(a)):(E.continueWithLineSegmentP(o,a.start),o.addSegment(a)):u?E.addLineSegment(o,i[0],bt.CornerPoint(a)):(E.addLineSegment(o,i[0],a.start),o.addSegment(a)),s=a}return o.segs.length>0?E.continueWithLineSegmentP(o,i[i.length-1]):E.addLineSegment(o,i[0],i[i.length-1]),o}static CornerPoint(e){return e.center.add(e.aAxis.add(e.bAxis))}static EllipseIsAlmostLineSegment(e){return e.aAxis.lengthSquared<1e-4||e.aAxis.lengthSquared<1e-4}static*GetFittedArcSegs(e,i){let n=i[1].sub(i[0]),o=n.normalize(),s=Math.min(e,n.length/2);for(let a=1;a<i.length-1;a++){n=i[a+1].sub(i[a]);let u=n.length;if(u<C.intersectionEpsilon){yield new ee(0,0,new d(0,0),new d(0,0),i[a]);continue}let h=n.div(u);Math.abs(h.dot(o))>.9&&(yield new ee(0,0,new d(0,0),new d(0,0),i[a]));let c=Math.min(e,n.length/2),f=h.mul(-c),P=o.mul(s);yield new ee(0,Math.PI/2,f,P,i[a].sub(P.add(f))),o=h,s=c}}},Dn=bt;Dn.DefaultPadding=1,Dn.DefaultCornerFitRadius=3;var Id=he(gt(),1),gr=class{constructor(t,e,i,n=1){this.Source=t,this.Target=e,this.CrossingWeight=i,this.Weight=n}toString(){return Id.String.Format("{0}->{1}",this.Source,this.Target)}};var Fn=class{static FindClosestPoints(t,e){let i=E.minDistWithinIntervals(t,e,t.parStart,t.parEnd,e.parStart,e.parEnd,(t.parStart+t.parEnd)/2,(e.parStart+e.parEnd)/2);if(i)return{curveClosestPoint:i.aX,labelSideClosest:i.bX}}static GetSegmentInFrontOfLabel(t,e){if(t instanceof E){for(let i of t.segs)if((i.start.y-e)*(i.end.y-e)<=0)return i}return null}static ShiftLabel(t,e,i){let n=t.lineWidth/2,o=e.sub(i),s=o.length;s>n&&t.label.positionCenter(t.label.center.add(o.div(s*(s-n))))}static updateLabel(t,e){let i=null;e.labelIsToTheRightOfTheSpline?(t.label.positionCenter(new d(e.x+e.rightAnchor/2,e.y)),i=w.mkPP(t.label.boundingBox.leftTop,t.label.boundingBox.leftBottom)):e.labelIsToTheLeftOfTheSpline&&(t.label.positionCenter(new d(e.x-e.leftAnchor/2,e.y)),i=w.mkPP(t.label.boundingBox.rightTop,t.label.boundingBox.rightBottom));let n=Fn.GetSegmentInFrontOfLabel(t.curve,t.label.center.y);if(n!=null&&E.getAllIntersections(t.curve,E.polyFromBox(t.label.boundingBox),!1).length===0){let o=Fn.FindClosestPoints(n,i);if(o)Fn.ShiftLabel(t,o.curveClosestPoint,o.labelSideClosest);else{let s,a,u=n.closestParameter(i.start),h=n.closestParameter(i.end);n.value(u).sub(i.start).length<n.value(h).sub(i.end).length?(s=n.value(u),a=i.start):(s=n.value(h),a=i.end),Fn.ShiftLabel(t,s,a)}}}},Vt=class{constructor(t,e,i,n=1,o=1){this.reversed=!1;this.source=t,this.target=e,this.edge=i,this.weight=n,this.separation=o}get CrossingWeight(){return 1}get hasLabel(){return this.edge.label!=null}get labelWidth(){return this.edge.label.width}get labelHeight(){return this.edge.label.height}reverse(){let t=this.source;this.source=this.target,this.target=t,this.reversed=!this.reversed}toString(){return"edge("+this.source+"->"+this.target+")"}get curve(){return this.edge.curve}set curve(t){this.edge.curve=t}get underlyingPolyline(){return this.edge.smoothedPolyline}set underlyingPolyline(t){this.edge.smoothedPolyline=t}get LayerSpan(){return this.LayerEdges!=null?this.LayerEdges.length:0}isSelfEdge(){return this.source===this.target}reversedClone(){let t=new Vt(this.target,this.source,this.edge);if(this.LayerEdges!=null){let e=this.LayerEdges.length;t.LayerEdges=new Array(e);for(let i=0;i<e;i++){let n=this.LayerEdges[e-1-i];t.LayerEdges[i]=new gr(n.Target,n.Source,n.CrossingWeight)}t.LayerEdges[0].Source=this.target,t.LayerEdges[this.LayerEdges.length-1].Target=this.source}return t}get count(){return this.LayerEdges.length}getNode(t){if(t>=0){if(t<this.LayerEdges.length)return this.LayerEdges[t].Source;if(t===this.LayerEdges.length)return this.LayerEdges[t-1].Target}throw new Error("wrong index "+t)}updateEdgeLabelPosition(t){if(this.edge.label!=null){let e=this.LayerEdges.length/2,i=this.LayerEdges[e];Fn.updateLabel(this.edge,t[i.Source])}}[Symbol.iterator](){return this.nodes()}*nodes(){yield this.LayerEdges[0].Source;for(let t of this.LayerEdges)yield t.Target}};var Al=class{constructor(){this.maxLayerOfGeomGraph=new Set;this.minLayerOfGeomGraph=new Set;this.sameLayerConstraints=new Array;this.upDownConstraints=new Array;this.gluedUpDownIntConstraints=new wt;this.sameLayerDictionaryOfRepresentatives=new Map;this.representativeToItsLayer=new Map;this.maxLayerInt=new Array;this.minLayerInt=new Array;this.sameLayerInts=new Array;this.upDownInts=new Array}getFeedbackSetExternal(t,e){throw new Error("Method not implemented.")}pinNodeToMaxLayer(t){this.maxLayerOfGeomGraph.add(t)}pinNodeToMinLayer(t){this.minLayerOfGeomGraph.add(t)}get isEmpty(){return this.maxLayerOfGeomGraph.size===0&&this.minLayerOfGeomGraph.size===0&&this.sameLayerConstraints.length===0&&this.upDownConstraints.length===0}clear(){this.maxLayerOfGeomGraph.clear(),this.minLayerOfGeomGraph.clear(),this.sameLayerConstraints=[],this.upDownConstraints=[]}getFeedbackSetImp(t,e){return this.nodeIdToIndex=e,this.intGraph=t,this.maxRepresentative=-1,this.minRepresentative=-1,this.createIntegerConstraints(),this.glueTogetherSameConstraintsMaxAndMin(),this.addMaxMinConstraintsToGluedConstraints(),this.removeCyclesFromGluedConstraints(),this.getFeedbackSet()}removeCyclesFromGluedConstraints(){let t=vt(Array.from(this.gluedUpDownIntConstraints.values()),this.intGraph.nodeCount),e=cr.getFeedbackSetWithConstraints(t,null);for(let i of e)this.gluedUpDownIntConstraints.remove(i)}addMaxMinConstraintsToGluedConstraints(){if(this.maxRepresentative!==-1)for(let t=0;t<this.intGraph.nodeCount;t++){let e=this.nodeToRepr(t);e!==this.maxRepresentative&&this.gluedUpDownIntConstraints.add(new Z(this.maxRepresentative,e))}if(this.minRepresentative!==-1)for(let t=0;t<this.intGraph.nodeCount;t++){let e=this.nodeToRepr(t);e!==this.minRepresentative&&this.gluedUpDownIntConstraints.add(new Z(e,this.minRepresentative))}}glueTogetherSameConstraintsMaxAndMin(){this.createDictionaryOfSameLayerRepresentatives();let t=this.upDownInts.map(this.gluedIntPairNN);this.gluedUpDownIntConstraints=new wt}gluedIntPairNN(t){return new Z(this.nodeToRepr(t[0]),this.nodeToRepr(t[1]))}gluedIntPairI(t){return new Z(this.nodeToRepr(t.source),this.nodeToRepr(t.target))}gluedIntPair(t){return new Z(this.nodeToRepr(t.source),this.nodeToRepr(t.target))}gluedIntEdge(t){let e=this.nodeToRepr(t.source),i=this.nodeToRepr(t.target),n=new Vt(e,i,t.edge);return n.separation=t.separation,n.weight=0,n}nodeToRepr(t){let e=this.sameLayerDictionaryOfRepresentatives.get(t);return e||t}createDictionaryOfSameLayerRepresentatives(){let t=this.createGraphOfSameLayers();for(let e of Zr(t))this.glueSameLayerNodesOfALayer(e)}createGraphOfSameLayers(){return vt(this.createEdgesOfSameLayers(),this.intGraph.nodeCount)}createEdgesOfSameLayers(){let t=new Array;return this.maxRepresentative!==-1&&this.maxLayerInt.filter(e=>e!==this.maxRepresentative).map(e=>new Z(this.maxRepresentative,e)).forEach(e=>t.push(e)),this.minRepresentative!==-1&&this.minLayerInt.filter(e=>e!==this.minRepresentative).map(e=>new Z(this.minRepresentative,e)).forEach(e=>t.push(e)),this.sameLayerInts.forEach(e=>t.push(new Z(e[0],e[1]))),t}glueSameLayerNodesOfALayer(t){if(t.length>1){let e=-1;if(this.componentsIsMaxLayer(t))for(let i of t)this.sameLayerDictionaryOfRepresentatives.set(i,e=this.maxRepresentative);else if(this.componentIsMinLayer(t))for(let i of t)this.sameLayerDictionaryOfRepresentatives.set(i,e=this.minRepresentative);else for(let i of t)e===-1&&(e=i),this.sameLayerDictionaryOfRepresentatives.set(i,e);this.representativeToItsLayer.set(e,t)}}componentIsMinLayer(t){return t.findIndex(e=>this.minRepresentative===e)>=0}componentsIsMaxLayer(t){return t.findIndex(e=>this.maxRepresentative===e)>=0}createIntegerConstraints(){this.createMaxIntConstraints(),this.createMinIntConstraints(),this.createUpDownConstraints(),this.createSameLayerConstraints()}createSameLayerConstraints(){this.sameLayerInts=this.createIntConstraintsFromStringCouples(this.sameLayerConstraints)}createUpDownConstraints(){this.upDownInts=this.createIntConstraintsFromStringCouples(this.upDownConstraints)}createIntConstraintsFromStringCouples(t){return t.map(e=>[this.nodeIndex(e[0]),this.nodeIndex(e[1])]).filter(e=>e[0]!==-1&&e[1]!==-1)}createMinIntConstraints(){this.minLayerInt=this.createIntConstraintsFromExtremeLayer(this.minLayerOfGeomGraph),this.minLayerInt.length>0&&(this.minRepresentative=this.minLayerInt[0])}createMaxIntConstraints(){this.maxLayerInt=this.createIntConstraintsFromExtremeLayer(this.maxLayerOfGeomGraph),this.maxLayerInt.length>0&&(this.maxRepresentative=this.maxLayerInt[0])}createIntConstraintsFromExtremeLayer(t){return Array.from(t).map(e=>this.nodeIndex(e)).filter(e=>e!==-1)}nodeIndex(t){let e=this.nodeIdToIndex.get(t.node.id);return e||-1}getFeedbackSet(){return this.gluedIntGraph=this.createGluedGraph(),Array.from(this.unglueIntPairs(cr.getFeedbackSetWithConstraints(this.gluedIntGraph,this.gluedUpDownIntConstraints)))}*unglueIntPairs(t){for(let e of t)for(let i of this.unglueEdge(e))yield i}*unglueEdge(t){for(let e of this.unglueNode(t.source))for(let i of this.intGraph.outEdges[e])this.nodeToRepr(i.target)===t.target&&(yield i)}createGluedGraph(){let t=new wt;return this.intGraph.edges.forEach(e=>t.add(this.gluedIntPairI(e))),vt(Array.from(t.values()),this.intGraph.nodeCount)}unglueNode(t){let e=this.representativeToItsLayer.get(t);return e||[t]}getGluedNodeCounts(){let t=new Array(this.nodeIdToIndex.size).fill(0);for(let e=0;e<t.length;e++)t[this.nodeToRepr(e)]++;return t}};function yp(l,t){return[l,t]}var Il=class{constructor(){this.leftRightConstraints=new Array;this.leftRightNeighbors=new Array;this.nodeToBlockRoot=new Map;this.upDownVerticalConstraints=new Array;this.BlockRootToBlock=new Map}get IsEmpty(){return this.leftRightNeighbors.length===0&&this.upDownVerticalConstraints.length===0&&this.leftRightConstraints.length===0}AddSameLayerNeighbors(t){for(let e=0;e<t.length-1;e++)this.AddSameLayerNeighborsPair(t[e],t[e+1])}AddSameLayerNeighborsPair(t,e){this.leftRightNeighbors.push([t,e])}NodeToBlockRootSoft(t){let e=this.nodeToBlockRoot.get(t);return e||t}CreateMappingOfNeibBlocks(){let t=this.BasicGraphFromLeftRightIntNeibs();for(let e=0;e<t.nodeCount;e++)if(t.inEdges[e].length===0&&!this.nodeToBlockRoot.has(e)){let i=new Array,n=e;for(let o=t.outEdges[n];o.length>0;o=t.outEdges[n])n=o[0].y,i.push(n),this.nodeToBlockRoot.set(n,e);i.length>0&&this.BlockRootToBlock.set(e,i)}}BasicGraphFromLeftRightIntNeibs(){return jo(Array.from(this.LeftRightIntNeibs.values()).map(t=>new Z(t.x,t.y)))}NodeIndex(t){let e=this.nodeIdToIndex.get(t.id);return e||-1}PrepareForOrdering(t,e){this.nodeIdToIndex=t,this.MapNodesToToIntegers(e),this.CreateMappingOfNeibBlocks(),this.LiftLeftRightRelationsToNeibBlocks()}LiftLeftRightRelationsToNeibBlocks(){this.LeftRighInts=wt.mk(this.leftRightConstraints.map(e=>yp(this.NodeIndex(e[0]),this.NodeIndex(e[1]))).filter(e=>e[0]!==-1&&e[1]!==-1).map(e=>new Z(this.NodeToBlockRootSoft(e[0]),this.NodeToBlockRootSoft(e[1]))).filter(e=>e.x!==e.x));let t=cr.getFeedbackSet(jo(Array.from(this.LeftRighInts.values())));for(let e of t)this.LeftRighInts.remove(new Z(e.source,e.target))}MapNodesToToIntegers(t){this.LeftRightIntNeibs=wt.mk(Array.from(this.leftRightNeighbors.values()).map(e=>[this.NodeIndex(e[0]),this.NodeIndex(e[1])]).filter(e=>e[0]!==-1&&e[1]!==-1).map(e=>new Z(e[0],e[1]))),this.VerticalInts=wt.mk(this.upDownVerticalConstraints.map(e=>[this.NodeIndex(e[0]),this.NodeIndex(e[1])]).filter(e=>e[0]!==-1&&e[1]!==-1&&t[e[0]]>t[e[1]]).map(e=>new Z(e[0],e[1])))}};var ns=(o=>(o[o.TB=0]="TB",o[o.LR=1]="LR",o[o.BT=2]="BT",o[o.RL=3]="RL",o[o.None=4]="None",o))(ns||{});var wi=class{constructor(){this.coneAngle=30*(Math.PI/180);this.padding=2;this.polylinePadding=1;this.routingToParentConeAngle=Math.PI/6;this.simpleSelfLoopsForParentEdgesThreshold=200;this.incrementalRoutingThreshold=5e6;this.routeMultiEdgesAsBundles=!0;this.KeepOriginalSpline=!1;this.EdgeRoutingMode=0}toJSON(){let t={};return this.EdgeRoutingMode!=0&&(t.edgeRoutingMode=0),this.ConeAngle!=30*(Math.PI/180)&&(t.coneAngle=this.ConeAngle),this.padding!=3&&(t.padding=this.padding),this.polylinePadding!=1.5&&(t.polylinePadding=this.polylinePadding),this.bundlingSettings&&(t.bundlingSettingsJSON=this.bundlingSettings.toJSON()),t}static fromJSON(t){let e=new wi;return t.edgeRoutingMode&&(t.edgeRoutingMode=e.edgeRoutingMode),t.coneAngle&&(e.coneAngle=t.coneAngle),t.padding&&(e.padding=t.padding),t.polylinePadding&&(e.polylinePadding=t.polylinePadding),t.bundlingSettingsJSON&&(e.bundlingSettings=Dr.createFromJSON(t.bundlingSettingsJSON)),t.routingToParentConeAngle&&(e.routingToParentConeAngle=t.routingToParentConeAngle),t.simpleSelfLoopsForParentEdgesThreshold&&(e.simpleSelfLoopsForParentEdgesThreshold=t.simpleSelfLoopsForParentEdgesThreshold),t.incrementalRoutingThreshold&&(e.incrementalRoutingThreshold=t.incrementalRoutingThreshold),t.routeMultiEdgesAsBundles&&(e.routeMultiEdgesAsBundles=t.routeMultiEdgesAsBundles),t.KeepOriginalSpline&&(e.KeepOriginalSpline=t.KeepOriginalSpline),e}get EdgeRoutingMode(){return this.edgeRoutingMode}set EdgeRoutingMode(t){t===1&&this.bundlingSettings==null&&this.bundlingSettings==null&&(this.bundlingSettings=new Dr),this.edgeRoutingMode=t}get ConeAngle(){return this.coneAngle}set ConeAngle(t){this.coneAngle=t}get Padding(){return this.padding}set Padding(t){this.padding=t}get PolylinePadding(){return this.polylinePadding}set PolylinePadding(t){this.polylinePadding=t}get RoutingToParentConeAngle(){return this.routingToParentConeAngle}set RoutingToParentConeAngle(t){this.routingToParentConeAngle=t}get SimpleSelfLoopsForParentEdgesThreshold(){return this.simpleSelfLoopsForParentEdgesThreshold}set SimpleSelfLoopsForParentEdgesThreshold(t){this.simpleSelfLoopsForParentEdgesThreshold=t}get IncrementalRoutingThreshold(){return this.incrementalRoutingThreshold}set IncrementalRoutingThreshold(t){this.incrementalRoutingThreshold=t}get RouteMultiEdgesAsBundles(){return this.routeMultiEdgesAsBundles}set RouteMultiEdgesAsBundles(t){this.routeMultiEdgesAsBundles=t}};var ei=class{constructor(){this.edgeRoutingSettings=new wi;this.nodeSeparation=10;this.packingAspectRatio=1.5}static fromJSON(t){let e=new ei;return t.nodeSeparation!=10&&(e.nodeSeparation=t.nodeSeparation),t.packingAspectRatio&&(e.packingAspectRatio=t.packingAspectRatio),t.edgeRoutingSettings&&(e.edgeRoutingSettings=wi.fromJSON(t.edgeRoutingSettings)),e}toJSON(){let t=!1,e={};return this.nodeSeparation!=10&&(e.nodeSeparation=this.nodeSeparation,t=!0),this.packingAspectRatio!=1.5&&(e.packingAspectRatio=this.packingAspectRatio,t=!0),(e.edgeRoutingSettings=this.edgeRoutingSettings.toJSON())&&(t=!0),t?e:void 0}get NodeSeparation(){return this.nodeSeparation}set NodeSeparation(t){this.nodeSeparation=t}get PackingAspectRatio(){return this.packingAspectRatio}set PackingAspectRatio(t){this.packingAspectRatio=t}};var _e=class{constructor(){this.commonSettings=new ei;this.verticalConstraints=new Al;this.horizontalConstraints=new Il;this.NoGainAdjacentSwapStepsBound=5;this.NoGainStepsForOrderingMultiplier=1;this.AspectRatio=0;this.MaxNumberOfPassesInOrdering=24;this.BrandesThreshold=600;this.LabelCornersPreserveCoefficient=.1;this.MinNodeHeight=72*.5/4;this.MinNodeWidth=72*.75/4;this.SnapToGridByY=0;this.yLayerSep=10*3;this.transform=Qe.getIdentity();this.GridSizeByY=0;this.GridSizeByX=0;this.commonSettings.edgeRoutingSettings.EdgeRoutingMode=3}get NodeSeparation(){return this.commonSettings.NodeSeparation}get edgeRoutingSettings(){return this.commonSettings.edgeRoutingSettings}set edgeRoutingSettings(t){this.commonSettings.edgeRoutingSettings=t}toJSON(){let t={};return this.sameRanks&&(t.sameRanks=this.sameRanks),this.verticalConstraints&&(t.verticalConstraints=this.verticalConstraints),this.horizontalConstraints&&(t.horizontalConstraints=this.horizontalConstraints),this.NoGainAdjacentSwapStepsBound!=5&&(t.horizontalConstraints=this.horizontalConstraints),this.NoGainStepsForOrderingMultiplier!=1&&(t.RepetitionCoefficientForOrdering=this.NoGainStepsForOrderingMultiplier),this.AspectRatio&&(t.AspectRatio=this.AspectRatio),this.MaxNumberOfPassesInOrdering!=24&&(t.MaxNumberOfPassesInOrdering=this.MaxNumberOfPassesInOrdering),this.BrandesThreshold!=600&&(t.BrandesThreshold=this.BrandesThreshold),this.LabelCornersPreserveCoefficient!=.1&&(t.LabelCornersPreserveCoefficient=this.LabelCornersPreserveCoefficient),this.MinNodeHeight!=72*.5/4&&(t.MinNodeHeight=this.MinNodeHeight),this.MinNodeWidth!=72*.75/4&&(t.MinNodeWidth=this.MinNodeWidth),this.SnapToGridByY!=0&&(t.SnapToGridByY=this.SnapToGridByY),this.yLayerSep!=10*3&&(t.yLayerSep=this.yLayerSep),this.transform&&(t.transform=this.transform.elements),this.GridSizeByY&&(t.GridSizeByY=this.GridSizeByY),this.GridSizeByX&&(t.GridSizeByX=this.GridSizeByX),t.commonLayoutSettings=this.commonSettings.toJSON(),t}static fromJSON(t){let e=new _e;return t.sameRanks&&(e.sameRanks=t.sameRanks),t.verticalConstraints&&(e.verticalConstraints=t.verticalConstraints),t.horizontalConstraints&&(e.horizontalConstraints=t.horizontalConstraints),t.NoGainAdjacentSwapStepsBound&&(e.horizontalConstraints=t.horizontalConstraints),t.RepetitionCoefficientForOrdering&&(e.NoGainStepsForOrderingMultiplier=t.RepetitionCoefficientForOrdering),t.AspectRatio&&(e.AspectRatio=t.AspectRatio),t.MaxNumberOfPassesInOrdering&&(e.MaxNumberOfPassesInOrdering=t.MaxNumberOfPassesInOrdering),t.BrandesThreshold&&(e.BrandesThreshold=t.BrandesThreshold),t.LabelCornersPreserveCoefficient&&(e.LabelCornersPreserveCoefficient=t.LabelCornersPreserveCoefficient),t.MinNodeHeight&&(e.MinNodeHeight=t.MinNodeHeight),t.MinNodeWidth&&(e.MinNodeWidth=e.MinNodeWidth),t.SnapToGridByY&&(e.SnapToGridByY=t.SnapToGridByY),t.yLayerSep&&(e.yLayerSep=t.yLayerSep),t.transform&&(e.transform=new Qe(t.transform[0][0],t.transform[0][1],t.transform[0][2],t.transform[1][0],t.transform[1][1],t.transform[1][2])),t.GridSizeByY&&(e.GridSizeByY=t.GridSizeByY),t.GridSizeByX&&(e.GridSizeByX=t.GridSizeByX),t.commonLayoutSettings&&(e.commonSettings=ei.fromJSON(t.commonLayoutSettings)),e}get LayerSeparation(){return this.yLayerSep}set LayerSeparation(t){this.yLayerSep=Math.max(10*3,t)}ActualLayerSeparation(t){return t?this.LayerSeparation/2:this.LayerSeparation}transformIsRotation(t){let e=Qe.rotation(t);for(let i=0;i<2;i++)for(let n=0;n<3;n++)if(!Q(e.elements[i][n],this.transform.elements[i][n]))return!1;return!0}get layerDirection(){if(this.transformIsRotation(0))return 0;if(this.transformIsRotation(Math.PI/2))return 1;if(this.transformIsRotation(-Math.PI/2))return 3;if(this.transformIsRotation(Math.PI))return 2;throw new Error("unexpected layout direction")}set layerDirection(t){switch(t){case 0:this.transform=Qe.getIdentity();break;case 1:this.transform=Qe.rotation(Math.PI/2);break;case 3:this.transform=Qe.rotation(-Math.PI/2);break;case 2:this.transform=Qe.rotation(Math.PI);break;default:throw new Error("unexpected layout direction")}}};var os=class extends _{constructor(e,i,n){super(null);this.graph=e,this.source=i,this.length=n}get Result(){return this.result}run(){let e=new At((o,s)=>o-s),i=new Map;for(let o of this.graph.shallowNodes){let s=o===this.source?0:Number.POSITIVE_INFINITY;e.Enqueue(o,s),i.set(o,s)}for(;e.count>0;){let o={priority:0},s=e.DequeueAndGetPriority(o);i.set(s,o.priority);let a=i.get(s);for(let u of s.inEdges()){let h=u.source,c=a+this.length(u);i.get(h)>c&&(i.set(h,c),e.DecreasePriority(h,c))}for(let u of s.outEdges()){let h=u.target,c=a+this.length(u);i.get(h)>c&&(i.set(h,c),e.DecreasePriority(h,c))}}this.result=new Array(this.graph.shallowNodeCount);let n=0;for(let o of this.graph.shallowNodes){let s=i.get(o);s!==void 0?this.result[n++]=s:this.result[n++]=Number.POSITIVE_INFINITY}}};var ss=class extends _{constructor(e,i){super(null);this.graph=e,this.length=i}get Result(){return this.result}set Result(e){this.result=e}run(){this.result=new Array(this.graph.shallowNodeCount);let e=0;for(let i of this.graph.shallowNodes){let n=new os(this.graph,i,this.length);n.run(),this.Result[e++]=n.Result}}static Stress(e,i){let n=0;if(e.edgeCount===0)return n;let o=new ss(e,i);o.run();let s=o.Result,a=0;for(let h of e.shallowEdges)a+=i(h);a/=e.edgeCount;let u=0;for(let h of e.shallowNodes){let c=0;for(let f of e.shallowNodes){if(u!==c){let P=h.center.sub(f.center).length,v=a*s[u][c],A=v-P;n+=A*A/(v*v)}c++}u++}return n}};var xl=class extends _{constructor(e,i,n){super(null);this.graph=e,this.pivotArray=i,this.length=n}get Result(){return this.result}run(){this.result=new Array(this.pivotArray.length);let e=Array.from(this.graph.shallowNodes),i=new Array(this.graph.shallowNodeCount).fill(Number.POSITIVE_INFINITY),n=e[0];this.pivotArray[0]=0;for(let o=0;;o++){let s=new os(this.graph,n,this.length);if(s.run(),this.Result[o]=s.Result,o+1<this.pivotArray.length){let a=0;for(let u=0;u<this.Result[o].length;u++)i[u]=Math.min(i[u],this.Result[o][u]),i[u]>i[a]&&(a=u);n=e[a],this.pivotArray[o+1]=a}else break}}};var wl=class{static Rotate(t,e,i){let n=Math.sin(i*(Math.PI/180)),o=Math.cos(i*(Math.PI/180));for(let s=0;s<t.length;s++){let a=o*t[s]+n*e[s];e[s]=o*e[s]-n*t[s],t[s]=a}}};var Be=class{static DoubleCenter(t){let e=new Array(t.length).fill(0),i=new Array(t[0].length).fill(0),n=0;for(let o=0;o<t.length;o++)for(let s=0;s<t[0].length;s++)e[o]+=t[o][s],i[s]+=t[o][s],n+=t[o][s];for(let o=0;o<t.length;o++)e[o]/=t.length;for(let o=0;o<t[0].length;o++)i[o]/=t[0].length;n/=t.length,n/=t[0].length;for(let o=0;o<t.length;o++)for(let s=0;s<t[0].length;s++)t[o][s]-=e[o]+i[s]-n}static SquareEntries(t){for(let e=0;e<t.length;e++)for(let i=0;i<t[0].length;i++)t[e][i]=Math.pow(t[e][i],2)}static Multiply(t,e){for(let i=0;i<t.length;i++)for(let n=0;n<t[0].length;n++)t[i][n]*=e}static MultiplyX(t,e){if(t[0].length!==e.length)return null;let i=new Array(e.length).fill(0);for(let n=0;n<t.length;n++)for(let o=0;o<t[0].length;o++)i[n]+=t[n][o]*e[o];return i}static Norm(t){let e=0;for(let i=0;i<t.length;i++)e+=Math.pow(t[i],2);return Math.sqrt(e)}static Normalize(t){let e=Be.Norm(t);if(e<=0)return 0;for(let i=0;i<t.length;i++)t[i]/=e;return e}static RandomUnitLengthVector(t){let e=new Array(t);for(let i=0;i<t;i++)e[i]=Si();return Be.Normalize(e),e}static SpectralDecomposition(t,e){Be.SpectralDecompositionIE(t,e,30,1e-6)}static SpectralDecompositionIE(t,e,i,n){let o=t[0].length;e.u1=Be.RandomUnitLengthVector(o),e.lambda1=0,e.u2=Be.RandomUnitLengthVector(o),e.lambda2=0;let s=0,a=1-n;for(let u=0;u<i&&s<a;u++){let h=Be.MultiplyX(t,e.u1),c=Be.MultiplyX(t,e.u2);e.lambda1=Be.Normalize(h),e.lambda2=Be.Normalize(c),Be.MakeOrthogonal(c,h),Be.Normalize(c),s=Math.min(Be.DotProduct(e.u1,h),Be.DotProduct(e.u2,c)),e.u1=h,e.u2=c}}static DotProduct(t,e){if(t.length!==e.length)return 0;let i=0;for(let n=0;n<t.length;n++)i+=t[n]*e[n];return i}static MakeOrthogonal(t,e){if(t.length!==e.length)return;let i=Be.DotProduct(t,e)/Be.DotProduct(e,e);for(let n=0;n<t.length;n++)t[n]-=i*e[n]}static ClassicalScaling(t,e){let i=new Array(t.length);for(let n=0;n<t.length;n++)i[n]=t[n].slice();Be.SquareEntries(i),Be.DoubleCenter(i),Be.Multiply(i,-.5),Be.SpectralDecomposition(i,e),e.lambda1=Math.sqrt(Math.abs(e.lambda1)),e.lambda2=Math.sqrt(Math.abs(e.lambda2));for(let n=0;n<e.u1.length;n++)e.u1[n]*=e.lambda1,e.u2[n]*=e.lambda2}static DistanceScalingSubset(t,e,i,n,o){let s=e.length,a=t.length,u=new Array(a);for(let c=0;c<a;c++)for(let f=0;f<s;f++)t[c][f]===0&&(u[c]=f);let h=new Array(a).fill(0);for(let c=0;c<a;c++)for(let f=0;f<s;f++)u[c]!==f&&(h[c]+=n[c][f]);for(let c=0;c<o;c++)for(let f=0;f<a;f++){let P=0,v=0;for(let A=0;A<s;A++)if(f!==A){let O=Math.sqrt(Math.pow(e[u[f]]-e[A],2)+Math.pow(i[u[f]]-i[A],2));O>0&&(O=1/O),P+=n[f][A]*(e[A]+t[f][A]*(e[u[f]]-e[A])*O),v+=n[f][A]*(i[A]+t[f][A]*(i[u[f]]-i[A])*O)}e[u[f]]=P/h[f],i[u[f]]=v/h[f]}}static DistanceScaling(t,e,i,n,o){let s=e.length,a=new Array(s).fill(0);for(let u=0;u<s;u++)for(let h=0;h<s;h++)u!==h&&(a[u]+=n[u][h]);for(let u=0;u<o;u++)for(let h=0;h<s;h++){let c=0,f=0;for(let P=0;P<s;P++)if(h!==P){let v=Math.sqrt(Math.pow(e[h]-e[P],2)+Math.pow(i[h]-i[P],2));v>0&&(v=1/v),c+=n[h][P]*(e[P]+t[h][P]*(e[h]-e[P])*v),f+=n[h][P]*(i[P]+t[h][P]*(i[h]-i[P])*v)}e[h]=c/a[h],i[h]=f/a[h]}}static ExponentialWeightMatrix(t,e){let i=new Array(t.length);for(let n=0;n<t.length;n++){i[n]=new Array(t[n].length).fill(0);for(let o=0;o<t[n].length;o++)t[n][o]>0&&(i[n][o]=Math.pow(t[n][o],e))}return i}static EuclideanDistanceMatrix(t,e){let i=new Array(t.length);for(let n=0;n<t.length;n++){i[n]=new Array(t.length);for(let o=0;o<t.length;o++)i[n][o]=Math.sqrt(Math.pow(t[n]-t[o],2)+Math.pow(e[n]-e[o],2))}return i}static LandmarkClassicalScaling(t,e,i){let n=new Array(t.length);for(let a=0;a<t.length;a++){n[a]=new Array(t.length);for(let u=0;u<t.length;u++)n[a][u]=t[a][i[u]]}Be.SquareEntries(n);let o=new Array(t.length).fill(0);for(let a=0;a<t.length;a++){for(let u=0;u<t.length;u++)o[a]+=n[a][u];o[a]/=t.length}Be.DoubleCenter(n),Be.Multiply(n,-.5);let s={u1:new Array,u2:new Array,lambda1:0,lambda2:0};Be.SpectralDecomposition(n,s),s.lambda1=Math.sqrt(Math.abs(s.lambda1)),s.lambda2=Math.sqrt(Math.abs(s.lambda2)),e.x=new Array(t[0].length).fill(0),e.y=new Array(t[0].length).fill(0);for(let a=0;a<e.x.length;a++)for(let u=0;u<n.length;u++){let h=(Math.pow(t[u][a],2)-o[u])/2;e.x[a]-=s.u1[u]*h,e.y[a]-=s.u2[u]*h}}};var xd=he(gt(),1);var Tl=class{constructor(t,e){this.constrained=!1;this.Capacity=1e6;Ee.AbovePP(t.point,e.point)===1?(this.upperSite=t,this.lowerSite=e):(this.lowerSite=t,this.upperSite=e),this.upperSite.AddEdgeToSite(this)}get CcwTriangle(){return this.ccwTriangle}set CcwTriangle(t){this.ccwTriangle=t}get CwTriangle(){return this.cwTriangle}set CwTriangle(t){this.cwTriangle=t}GetOtherTriangle_c(t){return this.cwTriangle.Contains(t)?this.ccwTriangle:this.cwTriangle}IsAdjacent(t){return t===this.upperSite||t===this.lowerSite}GetOtherTriangle_T(t){return this.ccwTriangle===t?this.cwTriangle:this.ccwTriangle}toString(){return xd.String.Format("({0},{1})",this.upperSite,this.lowerSite)}OtherSite(t){return this.upperSite===t?this.lowerSite:this.upperSite}};var Vn=class{constructor(t){this.Owner=null;this.InEdges=new Array;this.point=t}cleanRemovedEdges(){for(let t of this.Edges)t.CcwTriangle===null&&t.CwTriangle===null&&this.Edges.splice(this.Edges.indexOf(t),1)}static mkSO(t,e){let i=new Vn(t);return i.Owner=e,i}AddEdgeToSite(t){this.Edges==null&&(this.Edges=new Array),this.Edges.push(t)}EdgeBetweenUpperSiteAndLowerSite(t){if(this.Edges!=null){for(let e of this.Edges)if(e.lowerSite===t)return e}return null}AddInEdge(t){this.InEdges.push(t)}*Triangles(){let t;if(this.Edges!=null&&this.Edges.length>0)t=this.Edges[0];else if(this.InEdges!=null&&this.InEdges.length>0)t=this.InEdges[0];else return;let e=t;do{let i=e.upperSite===this?e.CcwTriangle:e.CwTriangle;if(i==null){e=null;break}yield i,e=i.Edges.getItem(i.Edges.index(e)+2)}while(e!==t);if(e!==t){e=t;do{let i=e.upperSite===this?e.CwTriangle:e.CcwTriangle;if(i==null)break;yield i,e=i.Edges.getItem(i.Edges.index(e)+1)}while(!0)}}toString(){return this.point.toString()}};var lh=he(Gr(),1);var Xi=class{get x(){return this.LeftSite.point.x}constructor(t,e){this.RightSite=e.upperSite===t?e.lowerSite:e.upperSite,this.LeftSite=t,this.Edge=e}toString(){return"("+this.LeftSite.toString()+", "+this.Edge.toString()+","+this.RightSite.toString()+")"}};var fo=class{has(t){return t===this.item0||t===this.item1||t===this.item2}index(t){return t===this.item0?0:t===this.item1?1:t===this.item2?2:-1}getItem(t){switch(t){case 0:case 3:case-3:return this.item0;case 1:case 4:case-2:return this.item1;case 2:case 5:case-1:return this.item2;default:throw new Error}}setItem(t,e){switch(t){case 0:case 3:case-3:this.item0=e;break;case 1:case 4:case-2:this.item1=e;break;case 2:case 5:case-1:this.item2=e;break;default:throw new Error}}[Symbol.iterator](){return this.GetEnumerator()}*GetEnumerator(){yield this.item0,yield this.item1,yield this.item2}};var Tt=class{constructor(){this.Edges=new fo;this.Sites=new fo}containsPoint(t){return Tt.PointLocationForTriangle(t,this)!==0}static PointLocationForTriangle(t,e){let i=!1;for(let n=0;n<3;n++){let o=d.signedDoubledTriangleArea(t,e.Sites.getItem(n).point,e.Sites.getItem(n+1).point);if(o<-C.distanceEpsilon)return 0;o<C.distanceEpsilon&&(i=!0)}return i?1:2}intersectsLine(t,e,i){if(Tt.PointLocationForTriangle(t,this)!=0||Tt.PointLocationForTriangle(e,this)!=0)return!0;for(let n of this.Edges)if(this.abIntersectsTrianglSide(t,e,n))return!0;return!1}abIntersectsTrianglSide(t,e,i){return La(t,e,i.lowerSite.point,i.upperSite.point)}static mkSSSD(t,e,i,n){let o=d.getTriangleOrientation(t.point,e.point,i.point),s=new Tt;switch(o){case 1:s.FillCcwTriangle(t,e,i,n);break;case 0:s.FillCcwTriangle(t,i,e,n);break;default:throw new Error}return s}static mkSED(t,e,i){let n=new Tt;switch(d.getTriangleOrientation(e.upperSite.point,e.lowerSite.point,t.point)){case 1:e.CcwTriangle=n,n.Sites.setItem(0,e.upperSite),n.Sites.setItem(1,e.lowerSite);break;case 0:e.CwTriangle=n,n.Sites.setItem(0,e.lowerSite),n.Sites.setItem(1,e.upperSite);break;default:throw new Error}return n.Edges.setItem(0,e),n.Sites.setItem(2,t),n.CreateEdge(1,i),n.CreateEdge(2,i),n}static mkSSSEE(t,e,i,n,o,s){let a=Tt.mkSSSD(t,e,i,s);return a.Edges.setItem(0,n),a.Edges.setItem(1,o),a.BindEdgeToTriangle(t,n),a.BindEdgeToTriangle(e,o),a.CreateEdge(2,s),a}BindEdgeToTriangle(t,e){t===e.upperSite?e.CcwTriangle=this:e.CwTriangle=this}FillCcwTriangle(t,e,i,n){this.Sites.setItem(0,t),this.Sites.setItem(1,e),this.Sites.setItem(2,i);for(let o=0;o<3;o++)this.CreateEdge(o,n)}CreateEdge(t,e){let i=this.Sites.getItem(t),n=this.Sites.getItem(t+1),o=e(i,n);this.Edges.setItem(t,o),this.BindEdgeToTriangle(i,o)}Contains(t){return this.Sites.has(t)}OppositeEdge(t){let e=this.Sites.index(t);return this.Edges.getItem(e+1)}OppositeSite(t){let e=this.Edges.index(t);return this.Sites.getItem(e+2)}BoundingBox(){let t=D.mkPP(this.Sites.getItem(0).point,this.Sites.getItem(1).point);return t.add(this.Sites.getItem(2).point),t}static mkSSSEED(t,e,i,n,o,s){let a=new Tt;return a.Sites.setItem(0,t),a.Sites.setItem(1,e),a.Sites.setItem(2,i),a.Edges.setItem(0,n),a.Edges.setItem(1,o),a.BindEdgeToTriangle(t,n),a.BindEdgeToTriangle(e,o),a.CreateEdge(2,s),a}toString(){return this.Sites.getItem(0).toString()+","+this.Sites.getItem(1).toString()+","+this.Sites.getItem(2).toString()}};var ea=class{constructor(t){this.Edge=t}};var ht=class extends _{constructor(e,i,n,o){super(null);this.front=new Me((e,i)=>e.x-i.x);this.triangles=new Set;if(this.listOfSites=e,this.listOfSites.length===0)return;this.p_1=i,this.p_2=n,this.createEdgeDelegate=o;let s=Tt.mkSSSD(i,n,this.listOfSites[0],o);this.triangles.add(s),this.front.insert(new Xi(i,s.Edges.getItem(2))),this.front.insert(new Xi(this.listOfSites[0],s.Edges.getItem(1)))}run(){if(this.listOfSites.length!==0){for(let e=1;e<this.listOfSites.length;e++)this.ProcessSite(this.listOfSites[e]);this.FinalizeTriangulation()}}FinalizeTriangulation(){this.RemoveP1AndP2Triangles(),this.triangles.size>0&&this.MakePerimeterConvex()}MakePerimeterConvex(){let e=this.CreateDoubleLinkedListOfPerimeter();do{let i=this.FindConcaveEdge(e);if(i==null)return;e=this.ShortcutTwoListElements(i)}while(!0)}FindConcaveEdge(e){let i=e,n;do{if(n=i.Next,d.getTriangleOrientation(i.Start.point,i.End.point,n.End.point)===1)return i;i=n}while(n!==e);return null}static FindPivot(e){let i=e,n=e;do n=n.Next,(n.Start.point.x<i.Start.point.x||n.Start.point.x===i.Start.point.x&&n.Start.point.y<i.Start.point.y)&&(i=n);while(n!==e);return i}FindFirsePerimeterEdge(){for(let e of this.triangles)for(let i of e.Edges)if(i.GetOtherTriangle_T(e)==null)return i;return null}CreateDoubleLinkedListOfPerimeter(){let e=this.FindFirsePerimeterEdge(),i=e,n=null,o,s=null,a=new Array;do o=ht.CreatePerimeterElementFromEdge(i),a.push(w.mkPP(o.Start.point,o.End.point)),i=ht.FindNextEdgeOnPerimeter(i),s!=null?(o.Prev=s,s.Next=o):n=o,s=o;while(i!==e);return n.Prev=o,o.Next=n,n}static FindNextEdgeOnPerimeter(e){var n;let i=(n=e.CwTriangle)!=null?n:e.CcwTriangle;for(e=i.Edges.getItem(i.Edges.index(e)+2);e.CwTriangle!=null&&e.CcwTriangle!=null;)i=e.GetOtherTriangle_T(i),e=i.Edges.getItem(i.Edges.index(e)+2);return e}static CreatePerimeterElementFromEdge(e){let i=new ea(e);return e.CwTriangle!=null?(i.Start=e.upperSite,i.End=e.lowerSite):(i.End=e.upperSite,i.Start=e.lowerSite),i}RemoveP1AndP2Triangles(){let e=new Set;for(let i of this.triangles)(i.Sites.has(this.p_1)||i.Sites.has(this.p_2))&&e.add(i);for(let i of e)ht.RemoveTriangleWithEdges(this.triangles,i)}static RemoveTriangleWithEdges(e,i){e.delete(i);for(let n of i.Edges)n.CwTriangle===i?n.CwTriangle=null:n.CcwTriangle=null,n.CwTriangle==null&&n.CcwTriangle==null&&uh(n.upperSite.Edges,n)}static RemoveTriangleButLeaveEdges(e,i){e.delete(i);for(let n of i.Edges)n.CwTriangle===i?n.CwTriangle=null:n.CcwTriangle=null}ProcessSite(e){this.PointEvent(e);for(let i=0;i<e.Edges.length;i++){let n=e.Edges[i];n.constrained&&this.EdgeEvent(n)}}EdgeEvent(e){ht.EdgeIsProcessed(e)||(this.traversingEdge=e,this.runEdgeInserter())}static EdgeIsProcessed(e){return e.CwTriangle!=null||e.CcwTriangle!=null}ShowFrontWithSite(e,i=null){let n=new Array;if(e.Edges!=null)for(let o of e.Edges)n.push(oe.mkDebugCurveTWCI(200,.8,o.constrained?"Pink":"Brown",w.mkPP(o.upperSite.point,o.lowerSite.point)));n.push(oe.mkDebugCurveTWCI(200,1,"Brown",ee.mkFullEllipseNNP(.5,.5,e.point)));for(let o of this.triangles)for(let s=0;s<3;s++){let a=o.Edges.getItem(s);n.push(oe.mkDebugCurveTWCI(a.constrained?155:100,a.constrained?.8:.4,a.constrained?"Pink":"Navy",w.mkPP(a.upperSite.point,a.lowerSite.point)))}if(i!=null)for(let o of i)n.push(oe.mkDebugCurveTWCI(100,.5,"Red",o));for(let o of this.front)n.push(oe.mkDebugCurveTWCI(100,5.5,"Green",w.mkPP(o.Edge.upperSite.point,o.Edge.lowerSite.point)))}Show(e){ht.ShowCdt(Array.from(this.triangles.values()),this.front,null,null,[],e)}static ShowCdt(e,i,n,o,s,a){let u=new Array;if(n!=null)for(let h of n)u.push(oe.mkDebugCurveTWCI(200,.1,"Red",h));if(o!=null)for(let h of o)u.push(oe.mkDebugCurveTWCI(200,.1,"Blue",h));if(i!=null)for(let h of i)u.push(oe.mkDebugCurveTWCI(200,.1,"Green",w.mkPP(h.Edge.upperSite.point,h.Edge.lowerSite.point)));for(let h of e)for(let c=0;c<3;c++){let f=h.Edges.getItem(c);u.push(ht.GetDebugCurveOfCdtEdge(f))}u=u.concat(s)}static GetDebugCurveOfCdtEdge(e){return e.CcwTriangle==null||e.CwTriangle==null?oe.mkDebugCurveTWCI(255,.5,e.constrained?"Brown":"Black",w.mkPP(e.upperSite.point,e.lowerSite.point)):oe.mkDebugCurveTWCI(200,e.constrained?.8:.2,e.constrained?"Pink":"Navy",w.mkPP(e.upperSite.point,e.lowerSite.point))}PointEvent(e){let i=this.ProjectToFront(e),n={rightSite:null},o=i.item.x+C.distanceEpsilon<e.point.x?this.MiddleCase(e,i,n):this.LeftCase(e,i,n),s=this.InsertSiteIntoFront(o,e,n.rightSite);this.TriangulateEmptySpaceToTheRight(s),s=ht.FindNodeInFrontBySite(this.front,o),this.TriangulateEmptySpaceToTheLeft(s)}LeftCase(e,i,n){let o=i.item;this.InsertAndLegalizeTriangle(e,o);let s=this.front.previous(i),a=s.item.LeftSite;n.rightSite=i.item.RightSite,this.InsertAndLegalizeTriangle(e,s.item),this.front.deleteNodeInternal(s);let u=this.front.remove(o);return a}MiddleCase(e,i,n){let o=i.item.LeftSite;return n.rightSite=i.item.RightSite,this.InsertAndLegalizeTriangle(e,i.item),this.front.deleteNodeInternal(i),o}TriangulateEmptySpaceToTheLeft(e){let i=e.item.RightSite,n=this.front.previous(e);for(;n!=null;){let o=n.item,s=o.LeftSite,a=o.RightSite;if(a.point.sub(i.point).dot(s.point.sub(a.point))<0)e=this.ShortcutTwoFrontElements(n,e),n=this.front.previous(e);else{this.TryTriangulateBasinToTheLeft(e);break}}}ShortcutTwoListElements(e){var a;let i=e.Next,n=Tt.mkSSSEE(e.Start,e.End,i.End,e.Edge,i.Edge,this.createEdgeDelegate);this.triangles.add(n);let o=n.Edges.getItem(2);this.LegalizeEdge(e.Start,n.OppositeEdge(e.Start)),n=(a=o.CcwTriangle)!=null?a:o.CwTriangle,this.LegalizeEdge(i.End,n.OppositeEdge(i.End));let s=new ea(o);return s.Start=e.Start,s.End=i.End,e.Prev.Next=s,s.Prev=e.Prev,s.Next=i.Next,i.Next.Prev=s,s}ShortcutTwoFrontElements(e,i){var u;let n=e.item,o=i.item,s=Tt.mkSSSEED(n.LeftSite,n.RightSite,o.RightSite,n.Edge,o.Edge,this.createEdgeDelegate);this.triangles.add(s),this.front.deleteNodeInternal(e),this.front.remove(o);let a=s.Edges.getItem(2);return this.LegalizeEdge(n.LeftSite,s.OppositeEdge(n.LeftSite)),s=(u=a.CcwTriangle)!=null?u:a.CwTriangle,this.LegalizeEdge(o.RightSite,s.OppositeEdge(o.RightSite)),this.front.insert(new Xi(n.LeftSite,a))}TryTriangulateBasinToTheLeft(e){if(!ht.DropsSharpEnoughToTheLeft(e.item))return;let i=new lh.Stack;for(i.push(e.item.LeftSite);;){let n=i.pop();e=ht.FindNodeInFrontBySite(this.front,n);let o=this.front.previous(e);if(o==null)return;if(d.getTriangleOrientation(o.item.LeftSite.point,e.item.LeftSite.point,e.item.RightSite.point)==1)i.push(o.item.LeftSite),this.ShortcutTwoFrontElements(o,e);else if(e.item.LeftSite.point.y>e.item.RightSite.point.y)i.push(o.item.LeftSite);else{if(o.item.LeftSite.point.y<=o.item.RightSite.point.y)return;i.push(o.item.LeftSite)}}}static DropsSharpEnoughToTheLeft(e){let i=e.Edge;if(e.RightSite!==i.upperSite)return!1;let n=i.lowerSite.point.sub(i.upperSite.point);return n.x>=.5*n.y}InsertSiteIntoFront(e,i,n){let o=null,s=null;for(let a of i.Edges)if(s==null&&a.lowerSite===e&&(s=a),o==null&&a.lowerSite===n&&(o=a),s!=null&&o!=null)break;return this.front.insert(new Xi(e,s)),this.front.insert(new Xi(i,o))}TriangulateEmptySpaceToTheRight(e){let n=e.item.LeftSite.point,o=this.front.next(e);for(;o!=null;){let s=o.item,a=s.LeftSite,u=s.RightSite;if(a.point.sub(n).dot(u.point.sub(a.point))<0)e=this.ShortcutTwoFrontElements(e,o),o=this.front.next(e);else{this.TryTriangulateBasinToTheRight(e);break}}}TryTriangulateBasinToTheRight(e){if(!ht.DropsSharpEnoughToTheRight(e.item))return;let i=new lh.Stack;for(i.push(e.item.LeftSite);;){let n=i.pop();e=ht.FindNodeInFrontBySite(this.front,n);let o=this.front.next(e);if(o==null)return;if(d.getTriangleOrientation(e.item.LeftSite.point,e.item.RightSite.point,o.item.RightSite.point)==1)this.ShortcutTwoFrontElements(e,o),i.push(n);else if(e.item.LeftSite.point.y>e.item.RightSite.point.y)i.push(e.item.RightSite);else{if(o.item.LeftSite.point.y>=o.item.RightSite.point.y)return;i.push(e.item.RightSite)}}}static DropsSharpEnoughToTheRight(e){let i=e.Edge;if(e.LeftSite!==i.upperSite)return!1;let n=i.lowerSite.point.sub(i.upperSite.point);return n.x<=-.5*n.y}static FindNodeInFrontBySite(e,i){return e.findLast(n=>n.LeftSite.point.x<=i.point.x)}InsertAndLegalizeTriangle(e,i){var n;if(d.getTriangleOrientation(e.point,i.LeftSite.point,i.RightSite.point)!==2){let o=Tt.mkSED(e,i.Edge,this.createEdgeDelegate);this.triangles.add(o),this.LegalizeEdge(e,o.Edges.getItem(0))}else{let o=i.Edge;uh(o.upperSite.Edges,o);let s=(n=o.CcwTriangle)!=null?n:o.CwTriangle,a=s.OppositeSite(o);ht.RemoveTriangleButLeaveEdges(this.triangles,s),s=Tt.mkSSSD(i.LeftSite,a,e,this.createEdgeDelegate);let u=Tt.mkSSSD(i.RightSite,a,e,this.createEdgeDelegate);this.triangles.add(s),this.triangles.add(u),this.LegalizeEdge(e,s.OppositeEdge(e)),this.LegalizeEdge(e,u.OppositeEdge(e))}}LegalizeEdge(e,i){i.constrained||i.CcwTriangle==null||i.CwTriangle==null||(i.CcwTriangle.Contains(e)?this.LegalizeEdgeForOtherCwTriangle(e,i):this.LegalizeEdgeForOtherCcwTriangle(e,i))}LegalizeEdgeForOtherCwTriangle(e,i){let n=i.CwTriangle.Edges.index(i);if(wd(e,i.upperSite,i.CwTriangle.Sites.getItem(n+2),i.lowerSite)){let o=Td(e,i);this.LegalizeEdge(e,o.CwTriangle.OppositeEdge(e)),this.LegalizeEdge(e,o.CcwTriangle.OppositeEdge(e))}}LegalizeEdgeForOtherCcwTriangle(e,i){let n=i.CcwTriangle.Edges.index(i);if(wd(e,i.lowerSite,i.CcwTriangle.Sites.getItem(n+2),i.upperSite)){let o=Td(e,i);this.LegalizeEdge(e,o.CwTriangle.OppositeEdge(e)),this.LegalizeEdge(e,o.CcwTriangle.OppositeEdge(e))}}ProjectToFront(e){return this.front.findLast(i=>i.x<=e.point.x)}runEdgeInserter(){this.initEdgeInserter(),this.TraceEdgeThroughTriangles(),this.TriangulatePolygon0(this.rightPolygon,this.traversingEdge.upperSite,this.traversingEdge.lowerSite,!0),this.TriangulatePolygon0(this.leftPolygon,this.traversingEdge.upperSite,this.traversingEdge.lowerSite,!1),this.UpdateFront()}initEdgeInserter(){this.rightPolygon=new Array,this.leftPolygon=new Array,this.addedTriangles=new Array,this.piercedEdge=null,this.piercedTriangle=null,this.piercedToTheLeftFrontElemNode=null,this.piercedToTheRightFrontElemNode=null}UpdateFront(){let e=new Set;for(let i of this.addedTriangles)for(let n of i.Edges)if(n.CwTriangle==null||n.CcwTriangle==null){if(n.lowerSite==this.p_2&&n.upperSite==this.p_1)continue;e.add(n)}for(let i of e)this.AddEdgeToFront(i)}AddEdgeToFront(e){let i=e.upperSite.point.x<e.lowerSite.point.x?e.upperSite:e.lowerSite;this.front.insert(new Xi(i,e))}TriangulatePolygon0(e,i,n,o){e.length>0&&this.TriangulatePolygon1(0,e.length-1,e,i,n,o)}TriangulatePolygon1(e,i,n,o,s,a){let u=n[e],h=e;for(let P=e+1;P<=i;P++){let v=n[P];f(v)&&(h=P,u=v)}let c=Tt.mkSSSD(o,s,u,this.createEdgeDelegate);this.triangles.add(c),this.addedTriangles.push(c),e<h&&this.TriangulatePolygon1(e,h-1,n,o,u,a),h<i&&this.TriangulatePolygon1(h+1,i,n,u,s,a);function f(P){return a?hh(P,o,u,s):hh(P,o,s,u)}}TraceEdgeThroughTriangles(){this.initEdgeTracer(),this.Traverse()}Traverse(){for(;!this.BIsReached();)this.piercedToTheLeftFrontElemNode!=null?this.ProcessLeftFrontPiercedElement():this.piercedToTheRightFrontElemNode!=null?this.ProcessRightFrontPiercedElement():this.ProcessPiercedEdge();this.piercedTriangle!=null&&this.removePiercedTriangle(this.piercedTriangle),this.FindMoreRemovedFromFrontElements();for(let e of this.elementsToBeRemovedFromFront)this.front.remove(e)}ProcessLeftFrontPiercedElement(){let e=this.piercedToTheLeftFrontElemNode;do this.elementsToBeRemovedFromFront.push(e.item),this.AddSiteToLeftPolygon(e.item.LeftSite),e=this.front.previous(e);while(d.pointToTheLeftOfLine(e.item.LeftSite.point,this.a.point,this.b.point));if(this.elementsToBeRemovedFromFront.push(e.item),this.AddSiteToRightPolygon(e.item.LeftSite),e.item.LeftSite===this.b){this.piercedToTheLeftFrontElemNode=e;return}this.FindPiercedTriangle(e),this.piercedToTheLeftFrontElemNode=null}FindPiercedTriangle(e){var s;let i=e.item.Edge,n=(s=i.CcwTriangle)!=null?s:i.CwTriangle,o=n.Edges.index(i);for(let a=1;a<=2;a++){let u=n.Edges.getItem(a+o),h=Cr.sign(d.signedDoubledTriangleArea(u.lowerSite.point,this.a.point,this.b.point));if(Cr.sign(d.signedDoubledTriangleArea(u.upperSite.point,this.a.point,this.b.point))*h<=0){this.piercedTriangle=n,this.piercedEdge=u;break}}}FindMoreRemovedFromFrontElements(){for(let e of this.removedTriangles)for(let i of e.Edges)if(i.CcwTriangle==null&&i.CwTriangle==null){let n=i.upperSite.point.x<i.lowerSite.point.x?i.upperSite:i.lowerSite,o=ht.FindNodeInFrontBySite(this.front,n);o.item.Edge===i&&this.elementsToBeRemovedFromFront.push(o.item)}}ProcessPiercedEdge(){this.piercedEdge.CcwTriangle===this.piercedTriangle?(this.AddSiteToLeftPolygon(this.piercedEdge.lowerSite),this.AddSiteToRightPolygon(this.piercedEdge.upperSite)):(this.AddSiteToLeftPolygon(this.piercedEdge.upperSite),this.AddSiteToRightPolygon(this.piercedEdge.lowerSite)),this.removePiercedTriangle(this.piercedTriangle),this.PrepareNextStateAfterPiercedEdge()}PrepareNextStateAfterPiercedEdge(){var n,o;let e=(n=this.piercedEdge.CwTriangle)!=null?n:this.piercedEdge.CcwTriangle,i=e.Edges.index(this.piercedEdge);for(let s=1;s<=2;s++){let a=e.Edges.getItem(s+i),u=Cr.sign(d.signedDoubledTriangleArea(a.lowerSite.point,this.a.point,this.b.point));if(Cr.sign(d.signedDoubledTriangleArea(a.upperSite.point,this.a.point,this.b.point))*u<=0){if(a.CwTriangle!=null&&a.CcwTriangle!=null){this.piercedTriangle=e,this.piercedEdge=a;break}this.piercedTriangle=null,this.piercedEdge=null;let c=a.upperSite.point.x<a.lowerSite.point.x?a.upperSite:a.lowerSite,f=ht.FindNodeInFrontBySite(this.front,c);c.point.x<this.a.point.x?this.piercedToTheLeftFrontElemNode=f:this.piercedToTheRightFrontElemNode=f,this.removePiercedTriangle((o=a.CwTriangle)!=null?o:a.CcwTriangle);break}}}removePiercedTriangle(e){this.triangles.delete(e);for(let i of e.Edges)i.CwTriangle===e?i.CwTriangle=null:i.CcwTriangle=null,this.removedTriangles.push(e)}ProcessRightFrontPiercedElement(){let e=this.piercedToTheRightFrontElemNode;do this.elementsToBeRemovedFromFront.push(e.item),this.AddSiteToRightPolygon(e.item.RightSite),e=this.front.next(e);while(d.pointToTheRightOfLine(e.item.RightSite.point,this.a.point,this.b.point));if(this.elementsToBeRemovedFromFront.push(e.item),this.AddSiteToLeftPolygon(e.item.RightSite),e.item.RightSite===this.b){this.piercedToTheRightFrontElemNode=e;return}this.FindPiercedTriangle(e),this.piercedToTheRightFrontElemNode=null}AddSiteToLeftPolygon(e){this.AddSiteToPolygonWithCheck(e,this.leftPolygon)}AddSiteToPolygonWithCheck(e,i){e!==this.b&&(i.length===0||i[i.length-1]!==e)&&i.push(e)}AddSiteToRightPolygon(e){this.AddSiteToPolygonWithCheck(e,this.rightPolygon)}BIsReached(){var i;let e=(i=this.piercedToTheLeftFrontElemNode)!=null?i:this.piercedToTheRightFrontElemNode;return e!=null?e.item.Edge.IsAdjacent(this.b):this.piercedEdge.IsAdjacent(this.b)}initEdgeTracer(){this.elementsToBeRemovedFromFront=[],this.a=this.traversingEdge.upperSite,this.b=this.traversingEdge.lowerSite,this.removedTriangles=[];let e=ht.FindNodeInFrontBySite(this.front,this.a),i=this.front.previous(e);if(d.pointToTheLeftOfLine(this.b.point,i.item.LeftSite.point,i.item.RightSite.point))this.piercedToTheLeftFrontElemNode=i;else if(d.pointToTheRightOfLine(this.b.point,e.item.RightSite.point,e.item.LeftSite.point))this.piercedToTheRightFrontElemNode=e;else for(let n of this.a.Edges){let o=n.CcwTriangle;if(o==null||d.pointToTheLeftOfLine(this.b.point,n.lowerSite.point,n.upperSite.point))continue;let s=o.Edges.index(n),a=o.Sites.getItem(s+2);if(d.pointToTheLeftOfLineOrOnLine(this.b.point,a.point,n.upperSite.point)){this.piercedEdge=o.Edges.getItem(s+1),this.piercedTriangle=o;break}}}};function uh(l,t){if(l.length===0)return;let e=l.findIndex(i=>t===i);e>=0&&(e!==l.length-1&&(l[e]=l[l.length-1]),l.pop())}function wd(l,t,e,i){return Sp(l,t,e,i)&&hh(l,t,e,i)}function Sp(l,t,e,i){return d.getTriangleOrientation(t.point,l.point,e.point)===0&&d.getTriangleOrientation(e.point,l.point,i.point)===0}function hh(l,t,e,i){let n=t.point.x-l.point.x,o=t.point.y-l.point.y,s=e.point.x-l.point.x,a=e.point.y-l.point.y,u=i.point.x-l.point.x,h=i.point.y-l.point.y,c=n*n+o*o,f=s*s+a*a,P=u*u+h*h;return n*(a*P-h*f)-s*(o*P-h*c)+u*(o*f-a*c)>C.tolerance}function Td(l,t){let e,i;t.CcwTriangle.Contains(l)?(e=t.CcwTriangle,i=t.CwTriangle):(e=t.CwTriangle,i=t.CcwTriangle);let n=e.Edges.index(t),o=i.Edges.index(t),s=i.Sites.getItem(o+2),a=e.Edges.getItem(n+1),u=i.Edges.getItem(o+1),h=Ee.GetOrCreateEdge(l,s);return e.Sites.setItem(n+1,s),e.Edges.setItem(n,u),e.Edges.setItem(n+1,h),i.Sites.setItem(o+1,l),i.Edges.setItem(o,a),i.Edges.setItem(o+1,h),u.lowerSite===s?u.CcwTriangle=e:u.CwTriangle=e,a.lowerSite===l?a.CcwTriangle=i:a.CwTriangle=i,h.upperSite===l?(h.CcwTriangle=i,h.CwTriangle=e):(h.CcwTriangle=e,h.CwTriangle=i),uh(t.upperSite.Edges,t),h}var Ee=class extends _{constructor(e,i,n){super(null);this.isolatedSites=[];this.obstacles=[];this.PointsToSites=new qe;this.simplifyObstacles=!0;this.rectangleNodeOnTriangles=null;this.isolatedSites=e,this.obstacles=i,this.isolatedSegments=n}static constructor_(e){let i=new Ee(null,null,null);return i.isolatedSitesWithObject=e,i}FillAllInputSites(){if(this.isolatedSitesWithObject!=null)for(let e of this.isolatedSitesWithObject)this.AddSite(e[0],e[1]);if(this.isolatedSites!=null)for(let e of this.isolatedSites)this.AddSite(e,null);if(this.obstacles!=null)for(let e of this.obstacles)this.AddPolylineToAllInputSites(e);if(this.isolatedSegments!=null)for(let e of this.isolatedSegments)this.AddConstrainedEdge(e.A,e.B,null);this.AddP1AndP2(),this.allInputSites=Array.from(this.PointsToSites.values())}AddSite(e,i){let n;return(n=this.PointsToSites.get(e))?n.Owner=i:(n=Vn.mkSO(e,i),this.PointsToSites.set(e,n)),n}AddP1AndP2(){let e=D.mkEmpty();for(let o of this.PointsToSites.keys())e.add(o);let i=10,n=10;this.P1=new Vn(e.leftBottom.add(new d(-i,-n))),this.P2=new Vn(e.rightBottom.add(new d(i,-n)))}AddPolylineToAllInputSites(e){if(this.simplifyObstacles)for(let i=e.startPoint;i!=null;){let n=i.point;if(i=i.next,!i)break;for(;i.next&&d.getTriangleOrientation(n,i.point,i.next.point)===2;)i=i.next;this.AddConstrainedEdge(n,i.point,e)}else for(let i=e.startPoint;i.next!=null;i=i.next)this.AddConstrainedEdge(i.point,i.next.point,e);e.closed&&this.AddConstrainedEdge(e.endPoint.point,e.startPoint.point,e)}AddConstrainedEdge(e,i,n){let o=Ee.AbovePP(e,i),s,a;o>0?(s=this.AddSite(e,n),a=this.AddSite(i,n)):(s=this.AddSite(i,n),a=this.AddSite(e,n));let u=Ee.CreateEdgeOnOrderedCouple(s,a);u.constrained=!0}static GetOrCreateEdge(e,i){if(Ee.AboveCC(e,i)===1){let n=e.EdgeBetweenUpperSiteAndLowerSite(i);return n!=null?n:Ee.CreateEdgeOnOrderedCouple(e,i)}else{let n=i.EdgeBetweenUpperSiteAndLowerSite(e);return n!=null?n:Ee.CreateEdgeOnOrderedCouple(i,e)}}static CreateEdgeOnOrderedCouple(e,i){return new Tl(e,i)}GetTriangles(){return this.sweeper.triangles}run(){this.Initialization(),this.SweepAndFinalize()}SweepAndFinalize(){this.sweeper=new ht(this.allInputSites,this.P1,this.P2,Ee.GetOrCreateEdge),this.sweeper.run(),this.cleanRemovedEdges()}cleanRemovedEdges(){for(let e of this.PointsToSites.values())e.cleanRemovedEdges()}Initialization(){this.FillAllInputSites(),this.allInputSites.sort(Ee.OnComparison)}static OnComparison(e,i){return Ee.AboveCC(e,i)}static AbovePP(e,i){let n=e.y-i.y;return n>0?1:n<0?-1:(n=e.x-i.x,n>0?-1:n<0?1:0)}static AboveCC(e,i){return Ee.AbovePP(e.point,i.point)}RestoreEdgeCapacities(){for(let e of this.allInputSites)for(let i of e.Edges)i.constrained||(i.ResidualCapacity=i.Capacity)}SetInEdges(){for(let e of this.PointsToSites.values())for(let i of e.Edges)i.lowerSite.AddInEdge(i)}FindSite(e){return this.PointsToSites.get(e)}static PointIsInsideOfTriangle(e,i){for(let n=0;n<3;n++){let o=i.Sites.getItem(n).point,s=i.Sites.getItem(n+1).point;if(d.signedDoubledTriangleArea(e,o,s)<C.distanceEpsilon*-1)return!1}return!0}getRectangleNodeOnTriangles(){return this.rectangleNodeOnTriangles==null&&(this.rectangleNodeOnTriangles=Oe(Array.from(this.GetTriangles().values()).map(e=>Fe(e,e.BoundingBox())))),this.rectangleNodeOnTriangles}};function Ol(l){let t=Array.from(l.GetAllLeaves()),e=l.irect,i=e.diagonal/4,n=e.clone();return n.pad(i),Cp(t.concat([n.perimeter()]))}function Cp(l){let t=new Ee(null,l,null);return t.run(),t}var kn=class{constructor(t,e){this.start=t,this.end=e}add(t){this.add_d(t)}add_rect(t){let e=t,i=this.clone();return i.add_d(e.start),i.add_d(e.end),i}clone(){return new kn(this.start,this.end)}contains_point(t){return this.contains_d(t)}contains_rect(t){let e=t;return this.contains_d(e.start)&&this.contains_d(e.end)}intersection_rect(t){let e=t;return new kn(Math.max(this.start,e.start),Math.min(this.end,e.end))}intersects_rect(t){let e=t;return this.intersects(e)}contains_point_radius(t,e){return this.contains_d(t-e)&&this.contains_d(t+e)}static mkInterval(t,e){let i=new kn(t.start,t.end);return i.add_d(e.start),i.add_d(e.end),i}add_d(t){this.start>t&&(this.start=t),this.end<t&&(this.end=t)}get Start(){return this.start}set Start(t){this.start=t}get Length(){return this.end-this.start}contains_d(t){return this.start<=t&&t<=this.end}GetInRange(t){return t<this.start?this.start:t>this.end?this.end:t}intersects(t){return t.start>this.end+C.distanceEpsilon?!1:!(t.end<this.start-C.distanceEpsilon)}};var as=class{constructor(t){this.heapSize=0;this._priors=new Array(t),this._heap=new Array(t+1),this._reverse_heap=new Array(t)}get Count(){return this.heapSize}SwapWithParent(t){let e=this._heap[t>>1];this.PutAtI(t>>1,this._heap[t]),this.PutAtI(t,e)}Enqueue(t,e){this.heapSize++;let i=this.heapSize;for(this._priors[t]=e,this.PutAtI(i,t);i>1&&this._priors[this._heap[i>>1]]>e;)this.SwapWithParent(i),i>>=1}PutAtI(t,e){this._heap[t]=e,this._reverse_heap[e]=t}Dequeue(){if(this.heapSize===0)throw new Error;let t=this._heap[1];if(this.heapSize>1){this.PutAtI(1,this._heap[this.heapSize]);let e=1;for(;;){let i=e,n=e<<1;n<=this.heapSize&&this._priors[this._heap[n]]<this._priors[this._heap[e]]&&(i=n);let o=n+1;if(o<=this.heapSize&&this._priors[this._heap[o]]<this._priors[this._heap[i]]&&(i=o),i!==e)this.SwapWithParent(i);else break;e=i}}return this.heapSize--,t}IsEmpty(){return this.heapSize===0}DecreasePriority(t,e){this._priors[t]=e;let i=this._reverse_heap[t];for(;i>1&&this._priors[this._heap[i]]<this._priors[this._heap[i>>1]];){this.SwapWithParent(i);i>>=1}}};var Bl=class{constructor(t,e,i,n){this._numberOfOverlaps=0;this._proximityEdges=t,this._nodeSizes=e,this._nodePositions=i,this._forLayers=n,this._q=new as(e.length*2)}Run(){return this.InitQueue(),this.FindOverlaps(),this._numberOfOverlaps}FindOverlaps(){for(;this._q.Count>0;){let t=this._q.Dequeue();t<this._nodePositions.length?(this.FindOverlapsWithInterval(t),this.AddIntervalToTree(t)):(t-=this._nodePositions.length,this.RemoveIntervalFromTree(t))}}RemoveIntervalFromTree(t){this._intervalTree.Remove(this.GetInterval(t),t)}AddIntervalToTree(t){let e=this.GetInterval(t);this._intervalTree==null&&(this._intervalTree=ki([])),this._intervalTree.Add(e,t)}FindOverlapsWithInterval(t){if(this._intervalTree==null)return;let e=this.GetInterval(t);for(let i of this._intervalTree.GetAllIntersecting(e)){let n=Xt.GetIdealEdge(t,i,this._nodePositions[t],this._nodePositions[i],this._nodeSizes);if(n.overlapFactor<=1)return;this._proximityEdges.push(n),this._numberOfOverlaps++}}GetInterval(t){let e=this._nodeSizes[t].width/2,i=this._nodePositions[t].x;return new kn(i-e,i+e)}InitQueue(){for(let t=0;t<this._nodeSizes.length;t++){let e=this._nodeSizes[t].height/2,i=this._nodePositions[t].y;this._q.Enqueue(t,i-e),this._q.Enqueue(this._nodeSizes.length+t,i+e)}}};var ta=class{constructor(t,e,i){this.treeNodes=new Set;this.hedgehog=new Map;this.graph=t,this.weight=e,this.root=i,this.q=new as(this.graph.nodeCount)}NodeIsInTree(t){return this.treeNodes.has(t)}GetTreeEdges(){let t=new Array;for(this.Init();t.length<this.graph.nodeCount-1&&this.q.Count>0;)this.AddEdgeToTree(t);return t}AddEdgeToTree(t){let e=this.q.Dequeue(),i=this.hedgehog.get(e);this.treeNodes.add(e),t.push(i),this.UpdateOutEdgesOfV(e),this.UpdateInEdgesOfV(e)}UpdateOutEdgesOfV(t){for(let e of this.graph.outEdges[t]){let i=e.target;if(this.NodeIsInTree(i))continue;let n=this.hedgehog.get(i);if(n){let o=this.weight(n),s=this.weight(e);s<o&&(this.q.DecreasePriority(i,s),this.hedgehog.set(i,e))}else this.q.Enqueue(i,this.weight(e)),this.hedgehog.set(i,e)}}UpdateInEdgesOfV(t){for(let e of this.graph.inEdges[t]){let i=e.source;if(this.NodeIsInTree(i))continue;let n=this.hedgehog.get(i);if(n){let o=this.weight(n),s=this.weight(e);s<o&&(this.q.DecreasePriority(i,s),this.hedgehog.set(i,e))}else this.q.Enqueue(i,this.weight(e)),this.hedgehog.set(i,e)}}Init(){this.treeNodes.add(this.root);for(let t of this.graph.outEdges[this.root]){let e=this.weight(t);this.q.Enqueue(t.target,e),this.hedgehog.set(t.target,t)}for(let t of this.graph.inEdges[this.root]){let e=this.weight(t);this.q.Enqueue(t.source,e),this.hedgehog.set(t.source,t)}}};var ls=class{static GetMst(t,e){if(t.length===0)return null;let i=t.map(u=>new Z(u.source,u.target)),n=i.reduce((u,h)=>Math.max(u,Math.max(h.x,h.y)),0),o=new ar(n+1);for(let u=0;u<t.length;u++)o.setPair(i[u],t[u]);let s=vt(i,e);return new ta(s,u=>o.get(u.source,u.target).weight,i[0].source).GetTreeEdges().map(u=>o.get(u.source,u.target))}static GetMstOnCdt(t,e){let i=Array.from(t.PointsToSites.values()),n=new Map;for(let u=0;u<i.length;u++)n.set(i[u],u);let o=ls.GetEdges(i,n),s=Qa(Array.from(o.keys()));return new ta(s,u=>e(o.get(u.source,u.target)),0).GetTreeEdges().map(u=>o.get(u.source,u.target))}static GetEdges(t,e){let i=new ar(t.length);for(let n=0;n<t.length;n++){let o=t[n],s=e.get(o);for(let a of o.Edges)i.set(s,e.get(a.lowerSite),a)}return i}};var us=class{constructor(){this.epsilon=.01;this.iterationsMax=1e3;this.stopOnMaxIterat=!1;this.nodeSeparation=4;this.randomizationSeed=1;this.randomizationShift=.1}get StopOnMaxIterat(){return this.stopOnMaxIterat}set StopOnMaxIterat(t){this.stopOnMaxIterat=t}get Epsilon(){return this.epsilon}set Epsilon(t){this.epsilon=t}get IterationsMax(){return this.iterationsMax}set IterationsMax(t){this.iterationsMax=t}get NodeSeparation(){return this.nodeSeparation}set NodeSeparation(t){this.nodeSeparation=t}get RandomizationSeed(){return this.randomizationSeed}set RandomizationSeed(t){this.randomizationSeed=t}get RandomizationShift(){return this.randomizationShift}set RandomizationShift(t){this.randomizationShift=t}Clone(){let t=new us;return t.Epsilon=this.Epsilon,t.IterationsMax=this.IterationsMax,t.StopOnMaxIterat=this.StopOnMaxIterat,t.NodeSeparation=this.NodeSeparation,t.RandomizationSeed=this.RandomizationSeed,t.RandomizationShift=this.randomizationShift,t}};var Xt=class{constructor(t,e){this._settings=t,this._nodes=e}static RemoveOverlaps(t,e){let i=new us;i.RandomizationShift=1,i.NodeSeparation=e,new Xt(i,t).RemoveOverlaps()}RemoveOverlaps(){if(this._nodes.length<3){this.RemoveOverlapsOnTinyGraph();return}let t={nodePositions:new Array,nodeSizes:new Array};for(Ep(this._settings,this._nodes,t,this._settings.RandomizationShift),this.lastRunNumberIterations=0;this.OneIteration(t.nodePositions,t.nodeSizes,!1);)this.lastRunNumberIterations++;for(;this.OneIteration(t.nodePositions,t.nodeSizes,!0);)this.lastRunNumberIterations++;for(let e=0;e<this._nodes.length;e++)this._nodes[e].center=t.nodePositions[e]}RemoveOverlapsOnTinyGraph(){if(this._nodes.length!==1&&this._nodes.length===2){let t=this._nodes[0],e=this._nodes[1];d.closeDistEps(t.center,e.center)&&(e.center=e.center.add(new d(.001,0)));let i=this.GetIdealDistanceBetweenTwoNodes(t,e),n=d.middle(t.center,e.center),o=t.center.sub(e.center),s=o.length;o=o.mul(.5*(i/s)),t.center=n.add(o),e.center=n.sub(o)}}GetIdealDistanceBetweenTwoNodes(t,e){let i=t.center.sub(e.center),n=Math.abs(i.x),o=Math.abs(i.y),s=(t.width+e.width)/2+this._settings.NodeSeparation,a=(t.height+e.height)/2+this._settings.NodeSeparation,u=Number.POSITIVE_INFINITY,h=Number.POSITIVE_INFINITY;return n>C.tolerance&&(u=s/n),o>C.tolerance&&(h=a/o),Math.min(u,h)*i.length}static AvgEdgeLength(t){let e=0,i=0;for(let n of t)for(let o of n.outEdges())i+=n.center.sub(o.target.center).length,e++;return e>0?i/e:1}OneIteration(t,e,i){let n=new Array;for(let c=0;c<t.length;c++)n.push([t[c],c]);let o=Ee.constructor_(n);o.run();let s=new Map;for(let c=0;c<t.length;c++)s.set(o.PointsToSites.get(t[c]),c);let a=0,u=new Array;for(let c of o.PointsToSites.values())for(let f of c.Edges){let P=f.upperSite.point,v=f.lowerSite.point,A=s.get(f.upperSite),O=s.get(f.lowerSite),M=Xt.GetIdealEdge(A,O,P,v,e);u.push(M),M.overlapFactor>1&&a++}if(a===0||i){let c=this.FindProximityEdgesWithSweepLine(u,e,t);if(a===0&&c===0||a===0&&!i)return!1}let h=ls.GetMst(u,t.length);return Xt.MoveNodePositions(h,t,h[0].source),!0}FindProximityEdgesWithSweepLine(t,e,i){return new Bl(t,e,i,this._overlapForLayers).Run()}static GetIdealEdge(t,e,i,n,o){let s={overlapFactor:0},a=Xt.GetIdealEdgeLength(t,e,i,n,o,s),u=i.sub(n).length,h=D.mkSizeCenter(o[t],i),c=D.mkSizeCenter(o[e],n),f=s.overlapFactor>1?u-a:Xt.GetDistanceRects(h,c);return{source:Math.min(t,e),target:Math.max(t,e),overlapFactor:s.overlapFactor,idealDistance:a,weight:f}}static GetIdealEdgeLength(t,e,i,n,o,s){let a=i.sub(n),u=a.length,h=Math.abs(a.x),c=Math.abs(a.y),f=(o[t].width+o[e].width)/2,P=(o[t].height+o[e].height)/2;if(h>=f||c>=P)return s.overlapFactor=1,a.length;let v,A=1e-10;if(h>A)c>A?v=Math.min(f/h,P/c):v=f/h;else if(c>A)v=P/c;else return s.overlapFactor=2,Math.sqrt(f*f+P*P)/4;return v=Math.max(v,1.001),s.overlapFactor=v,v*u}static GetDistanceRects(t,e){if(t.intersects(e))return 0;let i=0,n=0;return(t.right<e.left||e.right<t.left)&&(n=t.left-e.right),t.top<e.bottom?i=e.bottom-t.top:e.top<t.bottom&&(i=t.bottom-e.top),Math.sqrt(n*n+i*i)}static MoveNodePositions(t,e,i){let n=e.map(s=>s.clone()),o=new Set;o.add(i);for(let s=0;s<t.length;s++){let a=t[s];o.has(a.source)?Xt.MoveNode(a.source,a.target,n,e,o,a.idealDistance):Xt.MoveNode(a.target,a.source,n,e,o,a.idealDistance)}}static MoveNode(t,e,i,n,o,s){let a=i[e].sub(i[t]);a=a.mul(s/a.length+.01),n[e]=n[t].add(a),o.add(e)}GetLastRunIterations(){return this.lastRunNumberIterations}};function Ep(l,t,e,i){e.nodePositions=t.map(n=>n.center),i&&vp(e.nodePositions,new bn(0,0),i),e.nodeSizes=t.map(n=>{let o=n.boundingBox.size;return o.width+=l.NodeSeparation,o.height+=l.NodeSeparation,o})}function vp(l,t,e){let i=new Se;for(let n=0;n<l.length;n++){let o=l[n];if(e||i.has(o))do{let s=o.x+(2*t.random()-1)*e,a=o.y+(2*t.random()-1)*e;o=new d(s,a)}while(i.has(o));l[n]=o,i.add(o)}}var Ji=class extends _{constructor(e,i,n,o){super(n);this.settings=e,this.graph=i,this.length=o}run(){this.LayoutConnectedGraphWithMds(),this.graph.pumpTheBoxToTheGraphWithMargins()}static ScaleToAverageEdgeLength(e,i,n,o){let s=new Map,a=0;for(let c of e.shallowNodes)s.set(c,a),a++;let u=0,h=0;for(let c of e.shallowEdges){let f=s.get(c.source),P=s.get(c.target);h+=Math.sqrt(Math.pow(i[f]-i[P],2)+Math.pow(n[f]-n[P],2)),u+=o(c)}if(u>0&&(h/=u),h>0)for(let c=0;c<i.length;c++)i[c]/=h,n[c]/=h}static LayoutGraphWithMds(e,i,n,o){if(n.x=new Array(e.shallowNodeCount),n.y=new Array(e.shallowNodeCount),n.x.length===0)return;if(n.x.length===1){n.x[0]=n.y[0]=0;return}let s=Math.min(i.PivotNumber,e.shallowNodeCount),a=i.GetNumberOfIterationsWithMajorization(e.shallowNodeCount),u=i.Exponent,h=new Array(s),c=new xl(e,h,o);c.run();let f=c.Result;if(Be.LandmarkClassicalScaling(f,n,h),Ji.ScaleToAverageEdgeLength(e,n.x,n.y,o),a>0){let P=new ss(e,o);P.run();let v=P.Result,A=Be.ExponentialWeightMatrix(v,u);Be.DistanceScalingSubset(v,n.x,n.y,A,a)}}LayoutConnectedGraphWithMds(){let e={x:[],y:[]};Ji.LayoutGraphWithMds(this.graph,this.settings,e,this.length),this.settings.RotationAngle!==0&&wl.Rotate(e.x,e.y,this.settings.RotationAngle);let i=0;for(let n of this.graph.shallowNodes)n.boundingBox&&(n.center=new d(e.x[i]*this.settings.ScaleX,e.y[i]*this.settings.ScaleY)),i++;this.settings.removeOverlaps&&Xt.RemoveOverlaps(Array.from(this.graph.shallowNodes),this.settings.NodeSeparation),this.graph.pumpTheBoxToTheGraphWithMargins()}ScaleNodes(e,i){for(let n of e)n.center=n.center.mul(i)}static PackGraphs(e,i){if(e.length===0)return D.mkEmpty();if(e.length===1)return e[0].boundingBox;let n=e.map(a=>a.boundingBox),o=new Array;for(let a of e)o.push({g:a,lb:a.boundingBox.leftBottom.clone()});let s=new _n(n,i.PackingAspectRatio);s.run();for(let{g:a,lb:u}of o){let h=a.boundingBox.leftBottom.sub(u);a.translate(h)}return new D({left:0,bottom:0,right:s.PackedWidth,top:s.PackedHeight})}};var Ir=class{constructor(){this.commonSettings=new ei;this.pivotNumber=50;this.iterationsWithMajorization=30;this.scaleX=100;this.scaleY=100;this.exponent=-2;this.rotationAngle=0;this._removeOverlaps=!0;this._callIterationsWithMajorizationThreshold=2e3;this.adjustScale=!1}static fromJSON(t){let e=new Ir;return t.pivotNumber&&(e.pivotNumber=t.pivotNumber),t.iterationsWithMajorization&&(e.iterationsWithMajorization=t.iterationsWithMajorization),t.scaleX&&(e.scaleX=t.scaleX),t.scaleY&&(e.scaleY=t.scaleY),t.exponent&&(e.exponent=t.exponent),t.rotationAngle&&(e.rotationAngle=t.rotationAngle),t.removeOverlaps!=null&&(e._removeOverlaps=t.removeOverlaps),t._callIterationsWithMajorizationThreshold&&(e._callIterationsWithMajorizationThreshold=t._callIterationsWithMajorizationThreshold),e}toJSON(){let t={};return this.pivotNumber!=50&&(t.pivotNumber=this.pivotNumber),this.iterationsWithMajorization!=30&&(t.iterationsWithMajorization=this.iterationsWithMajorization),this.scaleX!=200&&(t.scaleX=this.scaleX),this.scaleY!=200&&(t.scaleY=this.scaleY),this.exponent!=-2&&(t.exponent=this.exponent),this.rotationAngle!=0&&(t.rotationAngle=this.rotationAngle),this._removeOverlaps||(t.removeOverlaps=this._removeOverlaps),this._callIterationsWithMajorizationThreshold!=3e3&&(t._callIterationsWithMajorizationThreshold=this._callIterationsWithMajorizationThreshold),t}get NodeSeparation(){return this.commonSettings.NodeSeparation}set NodeSeparation(t){this.commonSettings.NodeSeparation=t}get edgeRoutingSettings(){return this.commonSettings.edgeRoutingSettings}set edgeRoutingSettings(t){this.commonSettings.edgeRoutingSettings=t}get removeOverlaps(){return this._removeOverlaps}set removeOverlaps(t){this._removeOverlaps=t}get PivotNumber(){return this.pivotNumber}set PivotNumber(t){this.pivotNumber=t}get IterationsWithMajorization(){return this.iterationsWithMajorization}set IterationsWithMajorization(t){this.iterationsWithMajorization=t}get ScaleX(){return this.scaleX}set ScaleX(t){this.scaleX=t}get ScaleY(){return this.scaleY}set ScaleY(t){this.scaleY=t}get Exponent(){return this.exponent}set Exponent(t){this.exponent=t}get RotationAngle(){return this.rotationAngle}set RotationAngle(t){this.rotationAngle=t%360}get AdjustScale(){return this.adjustScale}set AdjustScale(t){this.adjustScale=t}GetNumberOfIterationsWithMajorization(t){return t>this.CallIterationsWithMajorizationThreshold?0:this.IterationsWithMajorization}get CallIterationsWithMajorizationThreshold(){return this._callIterationsWithMajorizationThreshold}set CallIterationsWithMajorizationThreshold(t){this._callIterationsWithMajorizationThreshold=t}};var po=class extends _{constructor(e,i,n,o){super(i);this.graph=e,this.length=n,this.settings=o,this.settings.ScaleX=this.settings.ScaleY=200}get scaleX(){return this.settings.ScaleX}set scaleX(e){this.settings.ScaleX=e}get scaleY(){return this.settings.ScaleY}set scaleY(e){this.settings.ScaleY=e}run(){new Ji(this.settings,this.graph,this.cancelToken,this.length).run()}};function Ll(l,t,e){if(t)for(let i of t){if(e&&e.canceled)return;Ot.RouteEdge(i,l.padding)}else for(let i of l.nodesBreadthFirst){if(e&&e.canceled)return;for(let n of i.outEdges())n.curve==null&&Ot.RouteEdge(n,l.padding);for(let n of i.selfEdges())n.curve==null&&Ot.RouteEdge(n,l.padding)}}var Ot=class extends _{constructor(e,i){super(null);this.edges=e,this.padding=i}run(){fe.CreatePortsIfNeeded(this.edges);for(let e of this.edges)Ot.RouteEdge(e,this.padding)}static RouteEdge(e,i){let n=e;n.sourcePort==null&&(n.sourcePort=Rt.mk(()=>e.source.boundaryCurve,()=>e.source.center)),n.targetPort==null&&(n.targetPort=Rt.mk(()=>e.target.boundaryCurve,()=>e.target.center)),Ot.ContainmentLoop(n,i)||(n.curve=Ot.GetEdgeLine(e)),We.trimSplineAndCalculateArrowheadsII(n,n.sourcePort.Curve,n.targetPort.Curve,e.curve,!1)}static ContainmentLoop(e,i){let n=e.sourcePort.Curve,o=e.targetPort.Curve;if(n==null||o==null)return!1;let s=n.boundingBox,a=o.boundingBox,u=s.containsRect(a),h=!u&&a.containsRect(s);return u||h?(e.curve=Ot.CreateLoop(s,a,h,i),!0):!1}static CreateLoop(e,i,n,o){return n?Ot.CreateLoop_(e,i,o,!1):Ot.CreateLoop_(i,e,o,!0)}static CreateLoop_(e,i,n,o){let s=e.center,a=Ot.FindClosestPointOnBoxBoundary(e.center,i),u=a.sub(s),c=(Math.abs(u.x)<C.distanceEpsilon?Math.min(s.y-i.bottom,i.top-s.y):Math.min(s.x-i.left,i.right-s.x))/2,f=Math.min(n,c);u.length<=C.distanceEpsilon&&(u=new d(1,0));let P=u.normalize(),v=P.rotate(Math.PI/2),A=a.add(P.mul(n)),O=A.add(v.mul(f)),M=a.add(v.mul(f)),z=s.add(v.mul(f));return(o?Ge.mkFromPoints([z,M,O,A,a,s]):Ge.mkFromPoints([s,a,A,O,M,z])).createCurve()}static FindClosestPointOnBoxBoundary(e,i){let n=e.x-i.left<i.right-e.x?i.left:i.right,o=e.y-i.bottom<i.top-e.y?i.bottom:i.top;return Math.abs(n-e.x)<Math.abs(o-e.y)?new d(n,e.y):new d(e.x,o)}static GetEdgeLine(e){let i,n;e.sourcePort==null?(i=e.source.center,n=e.source.boundaryCurve):(i=e.sourcePort.Location,n=e.sourcePort.Curve);let o,s;e.targetPort==null?(o=e.target.center,s=e.target.boundaryCurve):(o=e.targetPort.Location,s=e.targetPort.Curve);let a=w.mkPP(i,o),u=E.getAllIntersections(n,a,!1);if(u.length>0){let h=a.trim(u[0].par1,1);h instanceof w&&(a=h,u=E.getAllIntersections(s,a,!1),u.length>0&&(h=a.trim(0,u[0].par1),h instanceof w&&(a=h)))}return a}static CreateSimpleEdgeCurveWithUnderlyingPolyline(e){let i=e.sourcePort?e.sourcePort.Location:e.source.center,n=e.targetPort?e.targetPort.Location:e.target.center;if(e.source===e.target){let o=2/(3*e.source.boundaryCurve.boundingBox.width),s=e.source.boundingBox.height/4;e.smoothedPolyline=Ot.CreateUnderlyingPolylineForSelfEdge(i,o,s),e.curve=e.smoothedPolyline.createCurve()}else e.smoothedPolyline=Ge.mkFromPoints([i,n]),e.curve=e.smoothedPolyline.createCurve();We.trimSplineAndCalculateArrowheadsII(e,e.source.boundaryCurve,e.target.boundaryCurve,e.curve,!1)}static CreateUnderlyingPolylineForSelfEdge(e,i,n){let o=e.add(new d(0,n)),s=e.add(new d(i,n)),a=e.add(new d(i,n*-1)),u=e.add(new d(0,n*-1)),h=ye.mkSiteP(e),c=new Ge(h);return h=ye.mkSiteSP(h,o),h=ye.mkSiteSP(h,s),h=ye.mkSiteSP(h,a),h=ye.mkSiteSP(h,u),ye.mkSiteSP(h,e),c}static SetStraightLineEdgesWithUnderlyingPolylines(e){fe.CreatePortsIfNeeded(Array.from(e.deepEdges));for(let i of e.deepEdges)Ot.CreateSimpleEdgeCurveWithUnderlyingPolyline(i)}};var Od,ch=function(){var l={exports:{}};return function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});function n(o,s,a){if(o.length===0)return-1;let u=0,h=o.length-1;for(;u<=h;){let c=u+(h-u>>1),f=o[c];switch(Math.sign(a.compare(f,s))){case-1:u=c+1;break;case 0:return c;case 1:h=c-1;break}}return~u}e.binarySearch=n}(l,l.exports,null),l.exports}(),dh=class{constructor(...t){this._values=[];let e,i;if(t.length>0){let n=t[0];n===void 0||n!=null&&Symbol.iterator in Object(n)?(e=n,t.length>1&&(i=t[1])):i=n}if(i??(i=Vr.defaultComparer),this._comparer=typeof i=="function"?Vr.create(i):i,e)for(let n of e)this.add(n)}get comparer(){return this._comparer}get size(){return this._values.length}has(t){return(0,ch.binarySearch)(this._values,t,this._comparer)>=0}add(t){let e=(0,ch.binarySearch)(this._values,t,this._comparer);return e>=0?this._values[e]=t:this._values.splice(~e,0,t),this}delete(t){let e=(0,ch.binarySearch)(this._values,t,this._comparer);return e>=0?(this._values.splice(e,1),!0):!1}clear(){this._values.length=0}keys(){return this._values.values()}values(){return this._values.values()}*entries(){for(let t=0;t<this._values.length;t++)yield[this._values[t],this._values[t]]}[Symbol.iterator](){return this.values()}forEach(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");for(let i of this)t.call(e,i,i,this)}get[rt.size](){return this.size}[rt.has](t){return this.has(t)}[rt.add](t){this.add(t)}[rt.delete](t){return this.delete(t)}[rt.clear](){this.clear()}};Od=dh;Object.defineProperty(Od.prototype,Symbol.toStringTag,{configurable:!0,writable:!0,value:"SortedSet"});var Bd,ir=function(){var l={exports:{}};return function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});let n=2**31-1,o=2146435069,s=101,a=[3,7,11,17,23,29,37,47,59,71,89,107,131,163,197,239,293,353,431,521,631,761,919,1103,1327,1597,1931,2333,2801,3371,4049,4861,5839,7013,8419,10103,12143,14591,17519,21023,25229,30293,36353,43627,52361,62851,75431,90523,108631,130363,156437,187751,225307,270371,324449,389357,467237,560689,672827,807403,968897,1162687,1395263,1674319,2009191,2411033,2893249,3471899,4166287,4999559,5999471,7199369];function u(T){if(T&1){let W=Math.sqrt(T)|0;for(let U=3;U<=W;U+=2)if(!(T%U))return!1;return!0}return T===2}function h(T){if(T<0)throw new RangeError;for(let W=0;W<a.length;W++){let U=a[W];if(U>=T)return U}for(let W=T|1;W<n;W+=2)if(u(W)&&(W-1)%s)return W;return T}function c(T){let W=2*T;return W>o&&o>T?o:h(W)}function f(){return{prevEntry:void 0,nextEntry:void 0,skipNextEntry:!1,next:0,hashCode:0,key:void 0,value:void 0}}function P(T,W){let U=f(),Y={buckets:void 0,entries:void 0,freeSize:0,freeList:0,size:0,equaler:T,head:U,tail:U};return v(Y,W),Y}e.createHashData=P;function v(T,W){let U=h(W);return T.freeList=-1,T.buckets=new Int32Array(U),T.entries=new Array(U),U}function A(T,W){let U=T.size,Y=new Int32Array(W),X=T.entries?T.entries.slice():[];X.length=W;for(let K=0;K<U;K++){let ge=X[K];if(ge&&ge.hashCode>=0){let Pe=ge.hashCode%W;ge.next=Y[Pe]-1,Y[Pe]=K+1}}T.buckets=Y,T.entries=X}function O(T,W){let U=-1;if(T.buckets&&T.entries){let Y=T.equaler.hash(W)&n;U=T.buckets[Y%T.buckets.length]-1;let X=T.entries.length;for(;U>>>0<X;){let K=T.entries[U];if(K.hashCode===Y&&T.equaler.equals(K.key,W))break;U=K.next}}return U}e.findEntryIndex=O;function M(T,W){let U=O(T,W);return U>=0?T.entries[U].value:void 0}e.findEntryValue=M;function z(T,W,U){if(T.buckets||v(T,0),!T.buckets||!T.entries)throw new Error;let Y=T.equaler.hash(W)&n,X=Y%T.buckets.length,K=T.buckets[X]-1;for(;K>>>0<T.entries.length;){let oi=T.entries[K];if(oi.hashCode===Y&&T.equaler.equals(oi.key,W)){oi.value=U;return}K=oi.next}let ge=!1,Pe;if(T.freeSize>0)Pe=T.freeList,ge=!0,T.freeSize--;else{let oi=T.size;if(oi===T.entries.length){if(A(T,c(T.size)),!T.buckets||!T.entries)throw new Error;X=Y%T.buckets.length}Pe=oi,T.size=oi+1}let Gt=T.entries[Pe]||(T.entries[Pe]=f());ge&&(T.freeList=Gt.next),Gt.hashCode=Y,Gt.next=T.buckets[X]-1,Gt.key=W,Gt.value=U,Gt.skipNextEntry=!1;let pr=T.tail;pr.nextEntry=Gt,Gt.prevEntry=pr,T.tail=Gt,T.buckets[X]=Pe+1}e.insertEntry=z;function $(T,W){if(T.buckets&&T.entries){let U=T.equaler.hash(W)&n,Y=U%T.buckets.length,X=-1,K;for(let ge=T.buckets[Y]-1;ge>=0;ge=K.next){if(K=T.entries[ge],K.hashCode===U&&T.equaler.equals(K.key,W)){X<0?T.buckets[Y]=K.next+1:T.entries[X].next=K.next;let Pe=K.prevEntry;return Pe.nextEntry=K.nextEntry,Pe.nextEntry&&(Pe.nextEntry.prevEntry=Pe),T.tail===K&&(T.tail=Pe),K.hashCode=-1,K.next=T.freeList,K.key=void 0,K.value=void 0,K.prevEntry=void 0,K.nextEntry=Pe,K.skipNextEntry=!0,T.freeList=ge,T.freeSize++,!0}X=ge}}return!1}e.deleteEntry=$;function N(T){if(T.size>0){T.buckets&&T.buckets.fill(0),T.entries&&T.entries.fill(void 0);let U=T.head.nextEntry;for(;U;){let Y=U.nextEntry;U.prevEntry=void 0,U.nextEntry=T.head,U.skipNextEntry=!0,U=Y}T.head.nextEntry=void 0,T.tail=T.head,T.size=0,T.freeList=-1,T.freeSize=0}}e.clearEntries=N;function q(T,W){if(W<0)throw new RangeError;let U=T.entries?T.entries.length:0;if(U>=W)return U;if(!T.buckets)return v(T,W);let Y=h(W);return A(T,h(W)),Y}e.ensureCapacity=q;function Te(T,W=T.size-T.freeSize){if(W<T.size)throw new RangeError;if(!T.buckets||!T.entries)return;let U=h(W),Y=T.entries;if(U>=(Y?Y.length:0))return;let X=T.size;if(v(T,U),!T.buckets||!T.entries)throw new Error;let K=0;for(let ge=0;ge<X;ge++){let Pe=Y[ge].hashCode;if(Pe>=0){let Gt=Pe%U;T.entries[K]=Y[ge],T.entries[K].next=T.buckets[Gt]-1,T.buckets[Gt]=K+1,K++}}T.size=K,T.freeSize=0}e.trimExcessEntries=Te;function ve(T){return T.key}e.selectEntryKey=ve;function Wt(T){return T.value}e.selectEntryValue=Wt;function Bo(T){return[T.key,T.value]}e.selectEntryEntry=Bo;function*Es(T,W){let U=T;for(;U;){let Y=U.skipNextEntry;U=U.nextEntry,!Y&&U&&(yield W(U))}}e.iterateEntries=Es;function R(T,W,U,Y){let X=W;for(;X;){let K=X.skipNextEntry;X=X.nextEntry,!K&&X&&U.call(Y,X.value,X.key,T)}}e.forEachEntry=R}(l,l.exports,null),l.exports}(),ia=class{constructor(...t){let e,i,n;if(t.length>0){let o=t[0];if(typeof o=="number"){if(!(Object.is(o,o|0)&&o>=0))throw new RangeError("Argument out of range: capacity");e=o,t.length>1&&(n=t[1])}else o===void 0||o!=null&&Symbol.iterator in Object(o)?(i=o,t.length>1&&(n=t[1])):n=o}if(e??(e=0),n??(n=Nt.defaultEqualer),this._hashData=(0,ir.createHashData)(n,e),i)for(let[o,s]of i)this.set(o,s)}get equaler(){return this._hashData.equaler}get size(){return this._hashData.size-this._hashData.freeSize}has(t){return(0,ir.findEntryIndex)(this._hashData,t)>=0}get(t){return(0,ir.findEntryValue)(this._hashData,t)}set(t,e){return(0,ir.insertEntry)(this._hashData,t,e),this}delete(t){return(0,ir.deleteEntry)(this._hashData,t)}clear(){(0,ir.clearEntries)(this._hashData)}ensureCapacity(t){if(typeof t!="number")throw new TypeError("Number expected: capacity");if(!(Object.is(t,t|0)&&t>=0))throw new RangeError("Argument out of range: capacity");return(0,ir.ensureCapacity)(this._hashData,t)}trimExcess(t){if(t!==void 0){if(typeof t!="number")throw new TypeError("Number expected: capacity");if(!(Object.is(t,t|0)&&t>=0))throw new RangeError("Argument out of range: capacity")}(0,ir.trimExcessEntries)(this._hashData,t)}keys(){return(0,ir.iterateEntries)(this._hashData.head,ir.selectEntryKey)}values(){return(0,ir.iterateEntries)(this._hashData.head,ir.selectEntryValue)}entries(){return(0,ir.iterateEntries)(this._hashData.head,ir.selectEntryEntry)}[Symbol.iterator](){return this.entries()}forEach(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");(0,ir.forEachEntry)(this,this._hashData.head,t,e)}get[dr.size](){return this.size}[dr.has](t){return this.has(t)}[dr.get](t){return this.get(t)}[dr.keys](){return this.keys()}[dr.values](){return this.values()}[rr.set](t,e){this.set(t,e)}[rr.delete](t){return this.delete(t)}[rr.clear](){this.clear()}};Bd=ia;Object.defineProperty(Bd.prototype,Symbol.toStringTag,{configurable:!0,writable:!0,value:"HashMap"});var Ld,nr=function(){var l={exports:{}};return function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});let n=2**31-1,o=2146435069,s=101,a=[3,7,11,17,23,29,37,47,59,71,89,107,131,163,197,239,293,353,431,521,631,761,919,1103,1327,1597,1931,2333,2801,3371,4049,4861,5839,7013,8419,10103,12143,14591,17519,21023,25229,30293,36353,43627,52361,62851,75431,90523,108631,130363,156437,187751,225307,270371,324449,389357,467237,560689,672827,807403,968897,1162687,1395263,1674319,2009191,2411033,2893249,3471899,4166287,4999559,5999471,7199369];function u(R){if(R&1){let T=Math.sqrt(R)|0;for(let W=3;W<=T;W+=2)if(!(R%W))return!1;return!0}return R===2}function h(R){if(R<0)throw new RangeError;for(let T=0;T<a.length;T++){let W=a[T];if(W>=R)return W}for(let T=R|1;T<n;T+=2)if(u(T)&&(T-1)%s)return T;return R}function c(R){let T=2*R;return T>o&&o>R?o:h(T)}function f(){return{prevEntry:void 0,nextEntry:void 0,skipNextEntry:!1,next:0,hashCode:0,key:void 0,value:void 0}}function P(R,T){let W=f(),U={buckets:void 0,entries:void 0,freeSize:0,freeList:0,size:0,equaler:R,head:W,tail:W};return v(U,T),U}e.createHashData=P;function v(R,T){let W=h(T);return R.freeList=-1,R.buckets=new Int32Array(W),R.entries=new Array(W),W}function A(R,T){let W=R.size,U=new Int32Array(T),Y=R.entries?R.entries.slice():[];Y.length=T;for(let X=0;X<W;X++){let K=Y[X];if(K&&K.hashCode>=0){let ge=K.hashCode%T;K.next=U[ge]-1,U[ge]=X+1}}R.buckets=U,R.entries=Y}function O(R,T){let W=-1;if(R.buckets&&R.entries){let U=R.equaler.hash(T)&n;W=R.buckets[U%R.buckets.length]-1;let Y=R.entries.length;for(;W>>>0<Y;){let X=R.entries[W];if(X.hashCode===U&&R.equaler.equals(X.key,T))break;W=X.next}}return W}e.findEntryIndex=O;function M(R,T,W){if(R.buckets||v(R,0),!R.buckets||!R.entries)throw new Error;let U=R.equaler.hash(T)&n,Y=U%R.buckets.length,X=R.buckets[Y]-1;for(;X>>>0<R.entries.length;){let pr=R.entries[X];if(pr.hashCode===U&&R.equaler.equals(pr.key,T)){pr.value=W;return}X=pr.next}let K=!1,ge;if(R.freeSize>0)ge=R.freeList,K=!0,R.freeSize--;else{let pr=R.size;if(pr===R.entries.length){if(A(R,c(R.size)),!R.buckets||!R.entries)throw new Error;Y=U%R.buckets.length}ge=pr,R.size=pr+1}let Pe=R.entries[ge]||(R.entries[ge]=f());K&&(R.freeList=Pe.next),Pe.hashCode=U,Pe.next=R.buckets[Y]-1,Pe.key=T,Pe.value=W,Pe.skipNextEntry=!1;let Gt=R.tail;Gt.nextEntry=Pe,Pe.prevEntry=Gt,R.tail=Pe,R.buckets[Y]=ge+1}e.insertEntry=M;function z(R,T){if(R.buckets&&R.entries){let W=R.equaler.hash(T)&n,U=W%R.buckets.length,Y=-1,X;for(let K=R.buckets[U]-1;K>=0;K=X.next){if(X=R.entries[K],X.hashCode===W&&R.equaler.equals(X.key,T)){Y<0?R.buckets[U]=X.next+1:R.entries[Y].next=X.next;let ge=X.prevEntry;return ge.nextEntry=X.nextEntry,ge.nextEntry&&(ge.nextEntry.prevEntry=ge),R.tail===X&&(R.tail=ge),X.hashCode=-1,X.next=R.freeList,X.key=void 0,X.value=void 0,X.prevEntry=void 0,X.nextEntry=ge,X.skipNextEntry=!0,R.freeList=K,R.freeSize++,!0}Y=K}}return!1}e.deleteEntry=z;function $(R){if(R.size>0){R.buckets&&R.buckets.fill(0),R.entries&&R.entries.fill(void 0);let W=R.head.nextEntry;for(;W;){let U=W.nextEntry;W.prevEntry=void 0,W.nextEntry=R.head,W.skipNextEntry=!0,W=U}R.head.nextEntry=void 0,R.tail=R.head,R.size=0,R.freeList=-1,R.freeSize=0}}e.clearEntries=$;function N(R,T){if(T<0)throw new RangeError;let W=R.entries?R.entries.length:0;if(W>=T)return W;if(!R.buckets)return v(R,T);let U=h(T);return A(R,h(T)),U}e.ensureCapacity=N;function q(R,T=R.size-R.freeSize){if(T<R.size)throw new RangeError;if(!R.buckets||!R.entries)return;let W=h(T),U=R.entries;if(W>=(U?U.length:0))return;let Y=R.size;if(v(R,W),!R.buckets||!R.entries)throw new Error;let X=0;for(let K=0;K<Y;K++){let ge=U[K].hashCode;if(ge>=0){let Pe=ge%W;R.entries[X]=U[K],R.entries[X].next=R.buckets[Pe]-1,R.buckets[Pe]=X+1,X++}}R.size=X,R.freeSize=0}e.trimExcessEntries=q;function Te(R){return R.key}e.selectEntryKey=Te;function ve(R){return R.value}e.selectEntryValue=ve;function Wt(R){return[R.key,R.value]}e.selectEntryEntry=Wt;function*Bo(R,T){let W=R;for(;W;){let U=W.skipNextEntry;W=W.nextEntry,!U&&W&&(yield T(W))}}e.iterateEntries=Bo;function Es(R,T,W,U){let Y=T;for(;Y;){let X=Y.skipNextEntry;Y=Y.nextEntry,!X&&Y&&W.call(U,Y.value,Y.key,R)}}e.forEachEntry=Es}(l,l.exports,null),l.exports}(),$i=class{constructor(...t){let e,i,n;if(t.length>0){let o=t[0];if(typeof o=="number"){if(!(Object.is(o,o|0)&&o>=0))throw new RangeError("Argument out of range: capacity");e=o,t.length>1&&(n=t[1])}else o===void 0||o!=null&&Symbol.iterator in Object(o)?(i=o,t.length>1&&(n=t[1])):n=o}if(e??(e=0),n??(n=Nt.defaultEqualer),this._hashData=(0,nr.createHashData)(n,e),i)for(let o of i)this.add(o)}get equaler(){return this._hashData.equaler}get size(){return this._hashData.size-this._hashData.freeSize}has(t){return(0,nr.findEntryIndex)(this._hashData,t)>=0}add(t){return(0,nr.insertEntry)(this._hashData,t,t),this}tryAdd(t){let e=this.size;return(0,nr.insertEntry)(this._hashData,t,t),this.size>e}delete(t){return(0,nr.deleteEntry)(this._hashData,t)}clear(){(0,nr.clearEntries)(this._hashData)}ensureCapacity(t){if(typeof t!="number")throw new TypeError("Number expected: capacity");if(!(Object.is(t,t|0)&&t>=0))throw new RangeError("Argument out of range: capacity");return(0,nr.ensureCapacity)(this._hashData,t)}trimExcess(t){if(t!==void 0){if(typeof t!="number")throw new TypeError("Number expected: capacity");if(!(Object.is(t,t|0)&&t>=0))throw new RangeError("Argument out of range: capacity")}(0,nr.trimExcessEntries)(this._hashData,t)}keys(){return(0,nr.iterateEntries)(this._hashData.head,nr.selectEntryKey)}values(){return(0,nr.iterateEntries)(this._hashData.head,nr.selectEntryValue)}entries(){return(0,nr.iterateEntries)(this._hashData.head,nr.selectEntryEntry)}[Symbol.iterator](){return this.values()}forEach(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");(0,nr.forEachEntry)(this,this._hashData.head,t,e)}get[rt.size](){return this.size}[rt.has](t){return this.has(t)}[rt.add](t){this.add(t)}[rt.delete](t){return this.delete(t)}[rt.clear](){this.clear()}};Ld=$i;Object.defineProperty(Ld.prototype,Symbol.toStringTag,{configurable:!0,writable:!0,value:"HashSet"});var Gd,gh=class{constructor(...t){var e,i;this._size=0;let n,o,s;Tp(t)?[n,s={}]=t:(n=0,wp(t)?[o,s={}]=t:s={});let a=(e=s?.keyEqualer)!==null&&e!==void 0?e:Nt.defaultEqualer,u=(i=s?.valueEqualer)!==null&&i!==void 0?i:Nt.defaultEqualer;if(this._map=new ia(n,a),this._keyEqualer=a,this._valueEqualer=u,o)for(let[h,c]of o)this.add(h,c)}get keyEqualer(){return this._keyEqualer}get valueEqualer(){return this._valueEqualer}get size(){return this._size}has(t){return this._map.has(t)}hasValue(t,e){let i=this._map.get(t);return i?i.has(e):!1}get(t){return this._map.get(t)}add(t,e){let i=this._map.get(t);i||(i=new $i(this._valueEqualer),this._map.set(t,i));let n=i.size;return i.add(e),this._size+=i.size-n,this}delete(t){let e=this._map.get(t);return e?(this._size-=e.size,this._map.delete(t),e.size):0}deleteValue(t,e){let i=this._map.get(t);if(i){let n=i.size;if(i.delete(e))return this._size+=i.size-n,i.size<=0&&this._map.delete(t),!0}return!1}clear(){this._map.clear(),this._size=0}ensureCapacity(t){return this._map.ensureCapacity(t)}trimExcess(t){this._map.trimExcess(t)}keys(){return this._map.keys()}*values(){for(let t of this._map.values())yield*t}*entries(){for(let[t,e]of this._map)for(let i of e)yield[t,i]}[Symbol.iterator](){return this.entries()}forEach(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");for(let[i,n]of this._map)for(let o of n)t.call(e,o,i,this)}get[jt.size](){return this.size}[jt.has](t){return this.has(t)}[jt.hasValue](t,e){return this.hasValue(t,e)}[jt.get](t){return this.get(t)}[jt.keys](){return this.keys()}[jt.values](){return this.values()}[lo.add](t,e){this.add(t,e)}[lo.delete](t){return this.delete(t)}[lo.deleteValue](t,e){return this.deleteValue(t,e)}[lo.clear](){this.clear()}};Gd=gh;Object.defineProperty(Gd.prototype,Symbol.toStringTag,{configurable:!0,writable:!0,value:"MultiMap"});function wp(l){let[t,e]=l;return(t===void 0||t!=null&&Symbol.iterator in Object(t))&&(e===void 0||typeof e=="object"&&e!==null||typeof e=="function")}function Tp(l){let[t,e]=l;return typeof t=="number"&&(e===void 0||typeof e=="object"&&e!==null||typeof e=="function")}var Rd,Nd,mh,Po,Mn,yo,Wn,Bt=class{constructor(t){this._list=void 0,this._previous=void 0,this._next=void 0,this.value=t}get list(){return this._list}get previous(){if(this._previous&&this._list&&this!==this._list.first)return this._previous}get next(){if(this._next&&this._list&&this._next!==this._list.first)return this._next}detachSelf(){return this._list?this._list.deleteNode(this):!1}};Rd=Bt;mh=(l,t)=>{l._list=t},Po=l=>l._previous,Mn=(l,t)=>{l._previous=t},yo=l=>l._next,Wn=(l,t)=>{l._next=t},Object.defineProperty(Rd.prototype,Symbol.toStringTag,{configurable:!0,writable:!0,value:"LinkedListNode"});var Ti=class{constructor(...t){this._size=0,this._head=void 0;let e,i;if(t.length>0){let n=t[0];n===void 0||n!=null&&Symbol.iterator in Object(n)?(e=n,t.length>1&&(i=t[1])):i=n}if(i??(i=Nt.defaultEqualer),this._equaler=typeof i=="function"?Nt.create(i):i,e)for(let n of e)this.push(n)}get equaler(){return this._equaler}get first(){return this._head}get last(){if(this._head)return Po(this._head)}get size(){return this._size}[Symbol.iterator](){return this.values()}*values(){for(let t of this.nodes())yield t.value}*nodes(){let t,e=this.first;for(;e!==void 0;)t=e,e=t.next,yield t}*drain(){for(let t of this.nodes())this.deleteNode(t),yield t.value}nodeOf(t,e){if(e!=null&&!(e instanceof Bt))throw new TypeError("LinkedListNode expected: fromNode");if(e!=null&&e.list!==this)throw new TypeError("Wrong list.");for(let i=e??this.first;i;i=i.next)if(this._equaler.equals(i.value,t))return i}lastNodeOf(t,e){if(e!=null&&!(e instanceof Bt))throw new TypeError("LinkedListNode expected: fromNode");if(e!=null&&e.list!==this)throw new TypeError("Wrong list.");for(let i=e??this.last;i;i=i.previous)if(this._equaler.equals(i.value,t))return i}find(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");let i,n=this.first;for(;n!==void 0;){i=n,n=i.next;let o=i.value;if(t.call(e,o,i,this))return o}}findLast(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");let i,n=this.last;for(;n!==void 0;){i=n,n=i.previous;let o=i.value;if(t.call(e,o,i,this))return o}}findNode(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");let i,n=this.first;for(;n!==void 0;)if(i=n,n=i.next,t.call(e,i.value,i,this))return i}findLastNode(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");let i,n=this.last;for(;n!==void 0;)if(i=n,n=i.previous,t.call(e,i.value,i,this))return i}has(t){return this.nodeOf(t)!==void 0}insertBefore(t,e){if(t!=null&&!(t instanceof Bt))throw new TypeError("LinkedListNode expected: node");if(t!=null&&t.list!==this)throw new TypeError("Wrong list.");return this._insertNode(t??void 0,new Bt(e),0)}insertNodeBefore(t,e){if(t!=null&&!(t instanceof Bt))throw new TypeError("LinkedListNode expected: node");if(t!=null&&t.list!==this)throw new TypeError("Wrong list.");if(!(e instanceof Bt))throw new TypeError("LinkedListNode expected: newNode");if(e.list)throw new Error("Node is already attached to a list.");this._insertNode(t||void 0,e,0)}insertAfter(t,e){if(t!=null&&!(t instanceof Bt))throw new TypeError("LinkedListNode expected: node");if(t!=null&&t.list!==this)throw new TypeError("Wrong list.");return this._insertNode(t||void 0,new Bt(e),1)}insertNodeAfter(t,e){if(t!=null&&!(t instanceof Bt))throw new TypeError("LinkedListNode expected: node");if(t!=null&&t.list!==this)throw new TypeError("Wrong list.");if(!(e instanceof Bt))throw new TypeError("LinkedListNode expected: newNode");if(e.list)throw new Error("Node is already attached to a list.");this._insertNode(t||void 0,e,1)}push(t){return this._insertNode(void 0,new Bt(t),1)}pushNode(t){if(!(t instanceof Bt))throw new TypeError("LinkedListNode expected: newNode");if(t.list)throw new Error("Node is already attached to a list.");this._insertNode(void 0,t,1)}pop(){let t=this.popNode();return t?t.value:void 0}popNode(){let t=this.last;if(this.deleteNode(t))return t}shift(){let t=this.shiftNode();return t?t.value:void 0}shiftNode(){let t=this.first;if(this.deleteNode(t))return t}unshift(t){return this._insertNode(void 0,new Bt(t),0)}unshiftNode(t){if(!(t instanceof Bt))throw new TypeError("LinkedListNode expected: newNode");if(t.list)throw new Error("Node is already attached to a list.");this._insertNode(void 0,t,0)}delete(t){let e=this.nodeOf(t);if(e&&this.deleteNode(e))return e}deleteNode(t){if(t!=null&&!(t instanceof Bt))throw new TypeError("LinkedListNode expected: node");if(t!=null&&t.list!==this)throw new TypeError("Wrong list.");return t==null||!t.list?!1:this._deleteNode(t)}deleteAll(t,e){if(typeof t!="function")throw new TypeError("Function expected: predicate");let i=0,n=this.first;for(;n;){let o=n.next;t.call(e,n.value,n,this)&&n.list===this&&(this._deleteNode(n),++i),n=o}return i}clear(){for(;this.size>0;)this.deleteNode(this.last)}forEach(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");let i,n=this.first;for(;n!==void 0;)i=n,n=i.next,t.call(e,i.value,i,this)}map(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");let i=new Ti,n,o=this.first;for(;o!==void 0;){n=o,o=n.next;let s=t.call(e,n.value,n,this);i.push(s)}return i}filter(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");let i=new Ti(this.equaler),n,o=this.first;for(;o!==void 0;){n=o,o=n.next;let s=n.value;t.call(e,s,n,this)&&i.push(s)}return i}reduce(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");let i=arguments.length>1,n=e,o,s=this.first;for(;s!==void 0;){o=s,s=o.next;let a=o.value;i?n=t(n,a,o,this):(n=a,i=!0)}return n}reduceRight(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");let i=arguments.length>1,n=e,o,s=this.last;for(;s!==void 0;){o=s;let a=o.value;i?n=t(n,a,o,this):(n=a,i=!0),s=o.previous}return n}some(t,e){if(t!==void 0&&typeof t!="function")throw new TypeError("Function expected: callback");let i,n=this.first;for(;n!==void 0;)if(i=n,n=i.next,!t||t.call(e,i.value,i,this))return!0;return!1}every(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");let i=!1,n,o=this.first;for(;o!==void 0;){if(n=o,o=n.next,!t.call(e,n.value,n,this))return!1;i=!0}return i}_deleteNode(t){return yo(t)===t?this._head=void 0:(Mn(yo(t),Po(t)),Wn(Po(t),yo(t)),this._head===t&&(this._head=yo(t))),mh(t,void 0),Mn(t,void 0),Wn(t,void 0),this._size--,!0}_insertNode(t,e,i){if(mh(e,this),this._head===void 0)Wn(e,e),Mn(e,e),this._head=e;else switch(i){case 0:t===void 0?(t=this._head,this._head=e):t===this._head&&(this._head=e),Wn(e,t),Mn(e,Po(t)),Wn(Po(t),e),Mn(t,e);break;case 1:t===void 0&&(t=Po(this._head)),Mn(e,t),Wn(e,yo(t)),Mn(yo(t),e),Wn(t,e);break}return this._size++,e}get[tr.size](){return this.size}[tr.has](t){return this.has(t)}[rt.add](t){this.push(t)}[rt.delete](t){return!!this.delete(t)}[rt.clear](){this.clear()}};Nd=Ti;Object.defineProperty(Nd.prototype,Symbol.toStringTag,{configurable:!0,writable:!0,value:"LinkedList"});var Dd=(n=>(n[n.OverlapsOtherLabels=0]="OverlapsOtherLabels",n[n.OverlapsNodes=1]="OverlapsNodes",n[n.OverlapsEdges=2]="OverlapsEdges",n[n.OverlapsNothing=Number.MAX_VALUE]="OverlapsNothing",n))(Dd||{});var fh=class{},ph=class{constructor(){this.points=new Ti;this.coveredLength=0}AddFirst(t){if(this.points.size!==0){let e=this.points.first.value;this.coveredLength=this.coveredLength+t.Center.sub(e.Center).length}return this.points.insertBefore(null,t),this.coveredLength}AddLast(t){if(this.points.size!==0){let e=this.points.last.value;this.coveredLength=this.coveredLength+t.Center.sub(e.Center).length}return this.points.insertAfter(null,t),this.coveredLength}};var Gl=class{constructor(t){this.location=t,this.boundingBox=D.rectangleOnPoint(t)}},So=class{constructor(t,e){this.data=e,this.boundingBox=t}},bh=class{constructor(t){this.innerPoints=[];this.outerPoints=[];this.placementSide=0;this.placementOffset=.5;this.edgePoints=t,this.placementSide}},xe=class extends _{constructor(e,i){super(null);this.placementStrategy=[1,0];this.obstacleMaps=[];this.edgeInfos=new Map;this.granularity=xe.MinGranularity;this.ScaleCollisionGranularity=!0;this.granularity=this.ScaleCollisionGranularity?this.interpolateGranularity(i.length):xe.MinGranularity,this.InitializeObstacles(e,i),this.edges=i}get CollisionGranularity(){return this.granularity}set CollisionGranularity(e){this.granularity=e}static constructorG(e){return new xe(Array.from(e.nodesBreadthFirst),Array.from(e.deepEdges).filter(i=>i.label))}static constructorGA(e,i){return new xe(Array.from(e.nodesBreadthFirst),i.filter(n=>n.label))}interpolateGranularity(e){if(e<=xe.LowerEdgeBound)return xe.MaxGranularity;if(e>=xe.UpperEdgeBound)return xe.MinGranularity;let i=(xe.UpperEdgeBound-xe.LowerEdgeBound)/(e-xe.LowerEdgeBound);return Math.ceil(xe.MinGranularity+i)}InitializeObstacles(e,i){let n=this.GetEdgeObstacles(i);this.obstacleMaps[1]=ki(e.map(o=>[o.boundingBox,new So(o.boundingBox,o)])),this.obstacleMaps[2]=ki(n.map(o=>[o.boundingBox,new So(o.boundingBox,o)]))}static CurvePoints(e,i){let n=[],o=e.end.sub(e.start).lengthSquared/(i*i);return xe.SubdivideCurveSegment(n,e,o,e.parStart,e.parEnd),n.sort(xe.compareByArgument),n}static compareByArgument(e,i){return e[0]<i[0]?-1:e[0]>i[0]?1:0}static SubdivideCurveSegment(e,i,n,o,s){if(e.length>64)return;let a=i.value(o),u=i.value(s);if(a.sub(u).lengthSquared>n){let h=(o+s)/2;xe.SubdivideCurveSegment(e,i,n,o,h),xe.SubdivideCurveSegment(e,i,n,h,s)}else e.push([o,a])}static PlaceLabelsAtDefaultPositions(e,i){for(let n of i)n.label&&new xe([n.source,n.target],[n]).run()}GetEdgeObstacles(e){let i=[];for(let n of e){if(n.curve==null)continue;let o=xe.CurvePoints(n.curve,this.CollisionGranularity);this.edgeInfos.set(n,new bh(o));for(let s of o)i.push(new Gl(s[1]))}return i}AddLabelObstacle(e){this.labelObstacleMap==null?(this.labelObstacleMap=ki([[e.boundingBox,e]]),this.obstacleMaps[0]=this.labelObstacleMap):this.labelObstacleMap.Add(e.boundingBox,e)}run(){this.edges.sort((e,i)=>this.edgeInfos.get(e).edgePoints.length-this.edgeInfos.get(i).edgePoints.length);for(let e of this.edges)this.PlaceLabel(e)}PlaceLabel(e){let i=!1;for(let n of this.placementStrategy){switch(n){case 0:i=this.PlaceEdgeLabelOnCurve(e.label);break;case 1:i=this.PlaceEdgeLabelHorizontally(e);break;default:throw new Error("unexpected case")}if(i)break}i?this.CalculateCenterLabelInfoCenter(e.label):this.PlaceLabelAtFirstPosition(e.label)}getLabelInfo(e){let i=e.parent;return this.edgeInfos.get(i)}PlaceLabelAtFirstPosition(e){let i=e.parent,n=i.curve,o=this.edgeInfos.get(i).edgePoints,s=this.StartIndex(e,o.map(v=>v[1])),a=o[s][1],u=n.derivative(o[s][0]);u.length<C.distanceEpsilon&&(u=new d(1,1)),u=u.normalize();let h=new nt(e.width,e.height),c=this.getLabelInfo(e),f=xe.GetPossibleSides(c.placementSide,u)[0],P=xe.GetLabelBounds(a,u,h,f);this.SetLabelBounds(this.getLabelInfo(e),P)}StartIndex(e,i){let n=this.getLabelInfo(e);return Math.min(i.length-1,Math.max(0,Math.floor(i.length*n.placementOffset)))}CalculateCenterLabelInfoCenter(e){let i=this.getLabelInfo(e),n=new d(0,0);for(let o of i.innerPoints)n=n.add(o);for(let o of i.outerPoints)n=n.add(o);e.positionCenter(n.div(i.innerPoints.length+i.outerPoints.length))}PlaceEdgeLabelHorizontally(e){let i=e.label,o=this.getLabelInfo(i).edgePoints,s=new nt(i.width,i.height),a=-1,u=D.mkEmpty(),h=e.curve;for(let c of xe.ExpandingSearch(this.StartIndex(i,o.map(f=>f[1])),0,o.length)){let f=o[c],P=h.derivative(f[0]);if(!Q(P.lengthSquared,0)){P=P.normalize();for(let v of xe.GetPossibleSides(this.getLabelInfo(i).placementSide,P)){let A=xe.GetLabelBounds(f[1],P,s,v),O=this.ConflictIndexRL(A,i);if(O>a&&(a=O,u=A,a===Number.MAX_VALUE))break}if(a===Number.MAX_VALUE)break}}if(a>=0){this.SetLabelBounds(this.getLabelInfo(i),u);let c=new So(u,null);this.AddLabelObstacle(c);let f=this.getLabelInfo(i);return a===0?f.placementResult=0:a===1?f.placementResult=1:a===2?f.placementResult=2:f.placementResult=Dd.OverlapsNothing,!0}return!1}static GetLabelBounds(e,i,n,o){let s=i.rotate(Math.PI/2).mul(o),a=e.add(s),u=1,h=s.x>0?a.x:a.x-n.width,c=s.y>0?a.y:a.y-n.height;if(Math.abs(s.x)<.75){let f=Math.acos(Math.abs(s.y)/u),P=u/Math.sin(f),v=u/Math.cos(f);h+=(s.x>0?-1:1)*Math.min(P,n.width/2),c+=(s.y>0?1:-1)*v}else if(Math.abs(s.y)<.75){let f=Math.acos(Math.abs(s.x)/u),P=u/Math.sin(f),v=u/Math.cos(f);h+=(s.x>0?1:-1)*v,c+=(s.y>0?-1:1)*Math.min(P,n.height/2)}return D.mkLeftBottomSize(h,c,n)}SetLabelBounds(e,i){e.innerPoints=[i.leftTop,i.rightTop],e.outerPoints=[i.leftBottom,i.rightBottom]}static GetPossibleSides(e,i){switch(i.length===0&&(e=0),e){case 1:return[-1];case 2:return[1];case 3:return Q(i.x,0)?xe.GetPossibleSides(5,i):[1];case 4:return Q(i.x,0)?xe.GetPossibleSides(6,i):[i.x<0?-1:1];case 5:return Q(i.y,0)?xe.GetPossibleSides(3,i):[i.y<0?-1:1];case 6:return Q(i.y,0)?xe.GetPossibleSides(4,i):[i.y<0?1:-1];default:return[-1,1]}}static*ExpandingSearch(e,i,n){let o=e+1,s=o;for(;s>i;)yield--s;for(;o<n;)yield o++}static PointSetLength(e){let i=0,n=null;for(let o of e)n!=null&&(i+=n.sub(o.Center).length),n=o.Center;return i}PlaceEdgeLabelOnCurve(e){let i=e.parent,n=this.getLabelInfo(e);n.innerPoints=null;let o=n.edgePoints,s=3,a=e.height/2,u=new nt(a,a),h=e.width;for(let c of xe.ExpandingSearch(this.StartIndex(e,o),0,o.length)){let f=this.GetSidesAndEdgeCurve(e,i,o,c);for(let P of f){let v=new ph,A={coveredLength:0};if(this.ProcessExpandingSearchOnSide(c,o,i.curve,P,a,s,u,A,v,h),A.coveredLength>=h)return this.CaseOfCoveredLengthGreaterThanLabelLength(e,v,A.coveredLength,h,u),!0}}return!1}CaseOfCoveredLengthGreaterThanLabelLength(e,i,n,o,s){let a=new Array,u=new Array,h=Array.from(i.points),c=n-o;if(c>0){let P=h[h.length-1],v=h[h.length-2],A=P.Center.sub(v.Center),O=A.length;c>O&&(P=h[0],v=h[1],A=P.Center.sub(v.Center),O=A.length);let M=A.mul((O-c)/O);P.Center=v.Center.add(M),P.Inner=v.Inner.add(M),P.Outer=v.Outer.add(M)}this.GoOverOrderedPointsAndAddLabelObstacels(h,a,u,s);let f=this.getLabelInfo(e);f.innerPoints=a,f.outerPoints=u}GoOverOrderedPointsAndAddLabelObstacels(e,i,n,o){for(let s of e){let a=s.Center;i.push(s.Inner),n.push(s.Outer);let u=new So(D.mkSizeCenter(new nt(o.width*2,o.height*2),a),null);this.AddLabelObstacle(u)}}ProcessExpandingSearchOnSide(e,i,n,o,s,a,u,h,c,f){for(let P of xe.ExpandingSearch(e,0,i.length)){let[v,A]=i[P],O=n.derivative(v);if(Q(O.lengthSquared,0))continue;let M=O.rotate(Math.PI/2).normalize().mul(o),z=A.add(M.mul(s+a));if(this.Conflict(z,s,u))break;{let $=new fh;if($.Center=z,$.Inner=A.add(M.mul(a)),$.Outer=A.add(M.mul(2*s+a)),h.coveredLength=P<=e?c.AddFirst($):c.AddLast($),h.coveredLength>=f)break}}}GetSidesAndEdgeCurve(e,i,n,o){let s=i.curve.derivative(n[o][0]);return xe.GetPossibleSides(this.getLabelInfo(e).placementSide,s)}Conflict(e,i,n){return this.ConflictIndex(e,i,n)!==Number.MAX_VALUE}ConflictIndexRL(e,i){let n=i.parent,o=n.source,s=n.target;for(let a=0;a<this.obstacleMaps.length;a++)if(this.obstacleMaps[a]!=null){for(let u of this.obstacleMaps[a].GetAllIntersecting(e))if(!(a===1&&u instanceof So&&u.data instanceof ne&&(o.node.isDescendantOf(u.data.graph)||s.node.isDescendantOf(u.data))))return a}return Number.MAX_VALUE}ConflictIndex(e,i,n){let o=D.creatRectangleWithSize(new nt(n.width*2,n.height*2),e),s=i*i;for(let a=0;a<this.obstacleMaps.length;a++)if(this.obstacleMaps[a]!=null){for(let u=0;u<this.obstacleMaps.length;u++)if(this.obstacleMaps[u]!=null)for(let h of this.obstacleMaps[u].GetAllIntersecting(o))if(h instanceof Gl){if(e.sub(h.location).lengthSquared<s)return u}else return u;return Number.MAX_VALUE}}},xr=xe;xr.MinGranularity=5,xr.MaxGranularity=50,xr.LowerEdgeBound=500,xr.UpperEdgeBound=3e3;var wr=class extends Ni{constructor(e,i=null){super(e,Ae.AlgorithmDataIndex);this.data=i}clone(){throw new Error("Method not implemented.")}rebind(e){this.entity=e,this.bind(Ae.AlgorithmDataIndex)}static getAlgData(e){return e.getAttr(Ae.AlgorithmDataIndex)}};function na(l){let t=wr.getAlgData(l.node);return t==null?null:t.data}var Rl=class{constructor(t,e){this.force=new d(0,0);this.stayWeight=1;this.index=t,this.geomNode=e,this.ResetBounds()}get Center(){return this.center}set Center(t){this.geomNode.center=t,this.center=t}ResetBounds(){this.previousCenter=this.geomNode.center,this.center=this.geomNode.center,this.Width=this.geomNode.width,this.Height=this.geomNode.height}ToString(){return"FINode("+(this.index+("):"+this.geomNode))}};var Nl=class{constructor(t){this._length=1;this.mEdge=t,this.sourceFiNode=na(this.mEdge.source),this.targetFiNode=na(this.mEdge.target)}get source(){return this.sourceFiNode.index}get target(){return this.targetFiNode.index}get length(){return this._length}set length(t){this._length=t}vector(){return this.sourceFiNode.geomNode.center.sub(this.targetFiNode.geomNode.center)}};var Fd=he(Qr(),1);var kr=class{get Center(){return this.c}get Radius(){return this.r}Distance2(t){let e=this.c.y-t.y,i=this.c.x-t.x;return i*i+e*e}Contains(t){return this.Distance2(t)-1e-7<=this.r2}ContainsPN(t,e){for(let i=0;i<t.length;i++)if(e.findIndex(n=>n==i)==-1&&!this.Contains(t[i]))return!1;return!0}static constructorP(t){let e=new kr;return e.c=t,e.r=0,e.r2=0,e}static midPoint(t,e){return new d((e.x+t.x)/2,(e.y+t.y)/2)}static constructorPP(t,e){let i=new kr;return i.c=kr.midPoint(t,e),i.r2=i.Distance2(t),i.r=Math.sqrt(i.r2),le.assert(i.OnBoundary(t)),le.assert(i.OnBoundary(e)),i}OnBoundary(t){let e=this.Distance2(t);return Math.abs(e-this.r2)/(e+this.r2)<1e-5}static centre(t,e,i){le.assert(e.x!=t.x),le.assert(i.x!=e.x);let n=(e.y-t.y)/(e.x-t.x),o=(i.y-e.y)/(i.x-e.x);le.assert(o!=n);let s,a=(n*o*(t.y-i.y)+o*(t.x+e.x)-n*(e.x+i.x))/(2*(o-n));return Math.abs(n)>Math.abs(o)?s=(t.y+e.y)/2-(a-(t.x+e.x)/2)/n:s=(e.y+i.y)/2-(a-(e.x+i.x)/2)/o,new d(a,s)}static Collinear(t,e,i){return t.x*(e.y-i.y)+(e.x*(i.y-t.y)+i.x*(t.y-e.y))==0}static constructorPPP(t,e,i){kr.count++;let n=new kr;if(kr.Collinear(t,e,i)){let o=new d(Math.min(t.x,Math.min(e.x,i.x)),Math.min(t.y,Math.max(e.y,i.y))),s=new d(Math.max(t.x,Math.max(e.x,i.x)),Math.max(t.y,Math.max(e.y,i.y)));n.c=kr.midPoint(o,s),n.r2=n.Distance2(s),n.r=Math.sqrt(n.r2)}else{let o=e.x-t.x,s=i.x-e.x,a=i.x-t.x;o!=0?s!=0?n.c=kr.centre(t,e,i):(le.assert(a!=0),n.c=kr.centre(e,t,i)):(le.assert(s!=0),n.c=kr.centre(e,i,t)),n.r2=n.Distance2(t),n.r=Math.sqrt(n.r2),le.assert(n.OnBoundary(t)),le.assert(n.OnBoundary(e)),le.assert(n.OnBoundary(i))}return n}},ti=kr;ti.count=0;var Ph=class{constructor(t,e){switch(this.boundary=e,le.assert(e.length<=3),e.length){case 0:this.disc=null;break;case 1:this.disc=ti.constructorP(t[e[0]]);break;case 2:this.disc=ti.constructorPP(t[e[0]],t[e[1]]);break;case 3:this.disc=ti.constructorPPP(t[e[0]],t[e[1]],t[e[2]]);break}}contains(t){return this.disc==null?!1:this.disc.Contains(t)}},yh=class{constructor(t){this.ps=t,this.L=new Ti;for(let i=0;i<this.ps.length;i++)this.L.push(i);let e=this.mtf_md(null,new Array);this.disc=e.disc,this.boundary=e.boundary}collinear3(t){return t.length==3?ti.Collinear(this.ps[t[0]],this.ps[t[1]],this.ps[t[2]]):!1}mtf_md(t,e){le.assert(e.length<=3);let i=new Ph(this.ps,e);if(e.length==3)return i;let n=this.L.first;for(;n!=null&&n!=t;){let o=n.next,s=n.value;if(!i.contains(this.ps[s])){let a=Array.from(e);a.push(s),le.assert(!this.collinear3(a),"Collinear points on boundary of minimal enclosing disc"),i=this.mtf_md(n,a),this.L.deleteNode(n),this.L.insertNodeBefore(null,n)}n=o}return i}},Dl=class{static LinearComputation(t){return new yh(t).disc}static SlowComputation(t){let e=t.length,i=null,n=null;for(let o=0;o<e;o++)for(let s=0;s<e;s++){if(o!=s){let a=ti.constructorPP(t[o],t[s]);a.ContainsPN(t,[o,s])&&(i==null||i.Radius>a.Radius)&&(i=a,n=[o,s])}for(let a=0;a<e;a++)if(a!=o&&a!=s&&!ti.Collinear(t[o],t[s],t[a])){let u=ti.constructorPPP(t[o],t[s],t[a]);u.ContainsPN(t,[o,s,a])&&(i==null||i.Radius>u.Radius)&&(i=u,n=[o,s,a])}}return le.assert(n!=null),i}};var Jt=class{static constructorNPA(t,e,i){let n=new Jt;n.p=t,n.z0=new Ue(e.x,e.y),n.a=new Array(t);for(let o=0;o<t;o++)n.a[o]=n.compute(o,i);return n}static constructorPMM(t,e,i){let n=new Jt;le.assert(e.p==i.p),n.p=e.p,n.z0=new Ue(t.x,t.y);let o=i.shift(n.z0),s=e.shift(n.z0);n.a=new Array(n.p);for(let a=0;a<n.p;a++)n.a[a]=Sh(s[a],o[a]);return n}static factorial(t){let e=1;for(let i=2;i<=t;i++)e*=i;return e}static binomial(t,e){return Jt.factorial(t)/(Jt.factorial(e)*Jt.factorial(t-e))}sum(t,e){let i=Ue.constructorN(0);for(let n=1;n<=t;n++){let o=Ue.constructorN(Jt.binomial(t-1,n-1));i=Sh(i,Hn(this.a[n],Hn(Ue.Pow(e,t-n),o)))}return i}shift(t){let e=new Array(this.p),i=e[0]=this.a[0],n=oa(this.z0,t);for(let o=1;o<this.p;o++){let s=Ue.constructorN(o);e[o]=Sh(Hn(Bp(i),Ch(Ue.Pow(n,o),s)),this.sum(o,n))}return e}compute(t,e){let i=e.length,n=Ue.constructorN(0);if(t==0)n.re=i;else{for(let o=0;o<i;o++){let s=e[o],a=new Ue(s.x,s.y);n=oa(n,Ue.Pow(oa(a,this.z0),t))}n.divideBy(t)}return n}ApproximateForce(t){let e=new Ue(t.x,t.y),i=oa(e,this.z0),n=Ch(this.a[0],i),o=i,s=0;for(;n=oa(n,Ch(Op(this.a[s],s),o)),s++,s!=this.p;)o=Hn(o,i);return new d(n.re,-n.im)}static Force(t,e){let i=e.sub(t),n=i.lengthSquared;return n<.1?n!=0?i.div(.1):new d(1,0):i.div(n)}},Ue=class{constructor(t,e){this.re=t,this.im=e}static constructorN(t){return new Ue(t,0)}divideBy(t){this.re/=t,this.im/=t}static Pow(t,e){switch(le.assert(e>=0),e){case 0:return Ue.constructorN(1);case 1:return t;case 2:return Hn(t,t);case 3:return Hn(t,Hn(t,t));default:return Hn(Ue.Pow(t,e/2),Ue.Pow(t,e/2+e%2))}}};function Sh(l,t){return new Ue(l.re+t.re,l.im+t.im)}function Hn(l,t){return new Ue(l.re*t.re-l.im*t.im,l.re*t.im+t.re*l.im)}function Op(l,t){return new Ue(l.re*t,l.im*t)}function oa(l,t){return new Ue(l.re-t.re,l.im-t.im)}function Bp(l){return new Ue(-l.re,-l.im)}function Ch(l,t){let e=t.re*t.re+t.im*t.im;if(e==0)return Ue.constructorN(0);let i=l.re*t.re+l.im*t.im,n=l.im*t.re-l.re*t.im;return new Ue(i/e,n/e)}var Fl=class{intersects(t){return t.med.Center.sub(this.med.Center).length<t.med.Radius+this.med.Radius}},Eh=class extends Fl{constructor(e,i,n){super();this.med=e,this.parent=i.parent,this.parent!=null&&(this.parent.leftChild==i?this.parent.leftChild=this:this.parent.rightChild=this),this.leftChild=i,this.rightChild=n,i.parent=this,n.parent=this}computeMultipoleCoefficients(e){this.leftChild.computeMultipoleCoefficients(e),this.rightChild.computeMultipoleCoefficients(e),this.multipoleCoefficients=Jt.constructorPMM(this.med.Center,this.leftChild.multipoleCoefficients,this.rightChild.multipoleCoefficients)}},hs=class extends Fl{constructor(e){super();this.particles=e,this.ComputeMinimumEnclosingDisc()}computeMultipoleCoefficients(e){this.multipoleCoefficients=Jt.constructorNPA(e,this.med.Center,this.ps)}ComputeMinimumEnclosingDisc(){let e=this.Size();this.ps=new Array(e);for(let i=0;i<e;i++)this.ps[i]=this.particles[0][i].point;return this.med=Dl.LinearComputation(this.ps)}Min(e){return this.particles[e][0].pos(e)}Size(){return this.particles[0].length}Max(e){return this.particles[e][this.Size()-1].pos(e)}Dimension(e){return this.Max(e)-this.Min(e)}Split(e){let i=this.Dimension(0)>this.Dimension(1)?0:1,n=i==0?1:0,o=this.Size(),s=o>>1,a=o-s,u=[new Array(s),new Array(s)],h=[new Array(a),new Array(a)],c=0,f=0;for(let v=0;v<o;v++){let A=this.particles[i][v];v<s?(u[i][v]=A,A.splitLeft=!0):(h[i][v-s]=A,A.splitLeft=!1)}for(let v=0;v<o;v++){let A=this.particles[n][v];A.splitLeft?u[n][f++]=A:h[n][c++]=A}let P=this.med;return this.particles=u,this.ComputeMinimumEnclosingDisc(),e.rightSibling=new hs(h),new Eh(P,this,e.rightSibling)}ComputeForces(){for(let e of this.particles[0])for(let i of this.particles[0])e!=i&&(e.force=e.force.add(Jt.Force(e.point,i.point)))}},Vl=class{pos(t){return t==0?this.point.x:this.point.y}constructor(t){this.point=t,this.force=new d(0,0)}},kl=class{particlesBy(t){return this.particles.map(e=>e).sort((e,i)=>e.pos(t)-i.pos(t))}constructor(t,e){this.particles=t;let i=new Array;i.push(this.particlesBy(0)),i.push(this.particlesBy(1)),this.leaves=new Array;let n=new hs(i);this.leaves.push(n);let o={rightSibling:null};this.root=n.Split(o),this.leaves.push(o.rightSibling);let s=new vh(e);for(s.EnqueueLL(n,o.rightSibling);s.length>0;)n=s.dequeue(),n.Split(o),this.leaves.push(o.rightSibling),s.EnqueueLL(n,o.rightSibling)}ComputeForces(t){this.root.computeMultipoleCoefficients(t);for(let e of this.leaves){e.ComputeForces();let i=new Array;for(i.push(this.root);i.length>0;){let n=i.pop();if(e.intersects(n))if(n instanceof hs)for(let o of e.particles[0])for(let s of n.particles[0])o!=s&&(o.force=o.force.add(Jt.Force(o.point,s.point)));else{let o=n;i.push(o.leftChild),i.push(o.rightChild)}else for(let o of e.particles[0])o.force=o.force.sub(n.multipoleCoefficients.ApproximateForce(o.point))}}}},vh=class extends Fd.Queue{constructor(e){super();this.B=e}EnqueueLL(e,i){e.Size()>this.B&&this.enqueue(e),i.Size()>this.B&&this.enqueue(i)}};var Ki=class extends _{constructor(e,i,n){super(null);this.clustersInfo=new Map;this.clusterEdges=new Array;if(this.graph=e,this.settings=i,this.initFiNodesEdges(),this.edges=Array.from(this.graph.shallowEdges).map(o=>wr.getAlgData(o.edge).data),this.nodes=Array.from(this.graph.shallowNodes).map(o=>wr.getAlgData(o.node).data),this.components=new Array,this.settings.InterComponentForces)this.components.push(this.nodes);else{this.basicGraph=vt(this.edges,this.nodes.length);for(let o of Zr(this.basicGraph)){let s=new Array(o.length),a=0;for(let u of o)s[a++]=this.nodes[u];this.components.push(s)}}this.computeWeight(e),this.setCurrentConstraintLevel(n)}initFiNodesEdges(){let e=0;for(let i of this.graph.shallowNodes){let n=new Rl(e++,i);new wr(i.node,n)}for(let i of this.graph.shallowEdges){let n=new Nl(i);new wr(i.edge,n)}}getCurrentConstraintLevel(){return this.currentConstraintLevel}setCurrentConstraintLevel(e){this.currentConstraintLevel=e,this.settings.Unconverge()}ResetNodePositions(){for(let e of this.nodes)e.ResetBounds()}AddRepulsiveForce(e,i){e.force=i.mul(10*this.settings.RepulsiveForceConstant)}AddLogSpringForces(e,i,n){let o=i.length,s=7e-4*this.settings.AttractiveForceConstant*o*Math.log((o+.1)/(n+.1));e.sourceFiNode.force=e.sourceFiNode.force.add(i.mul(s)),e.targetFiNode.force=e.targetFiNode.force.sub(i.mul(s))}AddSquaredSpringForces(e,i,n){let o=i.length,s=n*n+.1,a=this.settings.AttractiveForceConstant*(o-n)/s;e.sourceFiNode.force=e.sourceFiNode.force.add(i.mul(a)),e.targetFiNode.force=e.targetFiNode.force.sub(i.mul(a))}AddSpringForces(e){let i;if(this.settings.RespectEdgePorts){let n=e.sourceFiNode.Center,o=e.targetFiNode.Center,s=e.mEdge.sourcePort;s instanceof dt&&(n=s.Location);let a=e.mEdge.targetPort;a instanceof dt&&(o=a.Location),i=n.sub(o)}else i=e.vector();this.settings.LogScaleEdgeForces?this.AddLogSpringForces(e,i,e.length):this.AddSquaredSpringForces(e,i,e.length)}static AddGravityForce(e,i,n){n!=null&&(n.force=n.force.sub(e.sub(n.Center).mul(i*1e-4)))}ComputeRepulsiveForces(e){let i=e.length;if(i>16&&this.settings.ApproximateRepulsion){let n=new Array(e.length),o=2*(Math.PI/i),s=0;for(let u=0;u<i;u++)n[u]=new Vl(e[u].Center.add(new d(Math.cos(s),Math.sin(s)).mul(1e-5))),s+=o;new kl(n,8).ComputeForces(5);for(let u=0;u<e.length;u++)this.AddRepulsiveForce(e[u],n[u].force)}else for(let n of e){let o=new d(0,0);for(let s of e)n!=s&&(o=o.add(Jt.Force(n.Center,s.Center)));this.AddRepulsiveForce(n,o)}}SetBarycenter(e){let i=this.clustersInfo.get(e);if(i!=null)return i.barycenter;let n=new d(0,0);if(e.shallowNodeCount||Lp(e)){let o=this.clustersInfo.get(e);if((o==null||o.weight==null)&&this.computeWeight(e),o.weight!=null){for(let s of e.shallowNodes)s instanceof Ke?n=n.add(s.center):n=n.add(this.SetBarycenter(s).mul(this.clustersInfo.get(s).weight));this.clustersInfo.get(e).barycenter=n=n.div(o.weight)}}else this.clustersInfo.get(e).barycenter=n;return n}computeWeight(e){let i=0;for(let o of e.shallowNodes)o.entity instanceof de?i+=this.computeWeight(o):i++;let n=this.clustersInfo.get(e);return n==null&&this.clustersInfo.set(e,n={barycenter:new d(0,0)}),n.weight=i,i}AddClusterForces(e){if(e!=null){this.SetBarycenter(e);for(let i of this.clusterEdges){let n=ie.getGeom(i.source),o=ie.getGeom(i.target),s=wr.getAlgData(i.source).data,a=wr.getAlgData(i.target).data,u=n.hasOwnProperty("shallowNodes"),h=u?this.clustersInfo.get(n).barycenter:n.center,c=o.hasOwnProperty("shallowNodes"),f=c?this.clustersInfo.get(o).barycenter:o.center,P=h.sub(f),v=P.length,A=1e-8*(this.settings.AttractiveInterClusterForceConstant*(v*Math.log(v+.1)));if(P=P.mul(A),u){let O=n;for(let M of O.shallowNodes){let z=wr.getAlgData(M.node).data;z.force=z.force.add(P)}}else s.force=s.force.add(P);if(c){let O=o;for(let M of O.shallowNodes){let z=wr.getAlgData(M.node).data;z.force=z.force.sub(P)}}else a.force=a.force.sub(P)}for(let i of e.subgraphsDepthFirst){let n=this.clustersInfo.get(i).barycenter;for(let o of i.shallowNodes)Ki.AddGravityForce(n,this.settings.ClusterGravity,na(o))}}}ComputeForces(){if(this.components!=null)for(let e of this.components)this.ComputeRepulsiveForces(e);else this.ComputeRepulsiveForces(this.nodes);this.edges.forEach(e=>this.AddSpringForces(e));for(let e of this.components){let i=new d(0,0);for(let o=0;o<e.length;o++)i=i.add(e[o].Center);i=i.div(e.length);let n=Number.NEGATIVE_INFINITY;for(let o=0;o<e.length;o++){let s=e[o];Ki.AddGravityForce(i,this.settings.GravityConstant,s),s.force.length>n&&(n=s.force.length)}if(n>100)for(let o=0;o<e.length;o++)e[o].force=e[o].force.mul(100/n)}this.AddClusterForces(this.graph)}VerletIntegration(){let e=this.energy;this.energy=this.ComputeDescentDirection(1),this.UpdateStepSize(e);let i=0;for(let n=0;n<this.nodes.length;n++){let o=this.nodes[n];i+=o.Center.sub(o.previousCenter).lengthSquared}return i}ComputeDescentDirection(e){this.ResetForceVectors(),this.settings.ApplyForces&&this.ComputeForces();let i=0;for(let n of this.nodes){i=i+n.force.lengthSquared;let o=n.Center.sub(n.previousCenter).mul(this.settings.Friction),s=n.force.mul(-this.stepSize*e);n.previousCenter=n.Center,le.assert(!Number.isNaN(s.x),"!double.IsNaN(a.X)"),le.assert(!Number.isNaN(s.y),"!double.IsNaN(a.Y)"),le.assert(Number.isFinite(s.x),"!double.IsInfinity(a.X)"),le.assert(Number.isFinite(s.y),"!double.IsInfinity(a.Y)"),o=o.add(s),o=o.div(n.stayWeight),n.Center=n.Center.add(o)}return i}ResetForceVectors(){for(let e of this.nodes)e.force=new d(0,0)}UpdateStepSize(e){this.energy<e?++this.progress>=3&&(this.progress=0,this.stepSize/=this.settings.Decay):(this.progress=0,this.stepSize*=this.settings.Decay)}RungeKuttaIntegration(){let e=new Array(this.nodes.length),i=new Array(this.nodes.length),n=new Array(this.nodes.length),o=new Array(this.nodes.length),s=new Array(this.nodes.length),a=this.energy;for(let h=0;h<this.nodes.length;h++)this.nodes[h].previousCenter=this.nodes[h].Center,e[h]=this.nodes[h].Center;let u=3;this.ComputeDescentDirection(u);for(let h=0;h<this.nodes.length;h++)i[h]=this.nodes[h].Center.sub(this.nodes[h].previousCenter),this.nodes[h].Center=e[h].add(i[h].mul(.5));this.ComputeDescentDirection(u);for(let h=0;h<this.nodes.length;h++)n[h]=this.nodes[h].Center.sub(this.nodes[h].previousCenter),this.nodes[h].previousCenter=e[h],this.nodes[h].Center=e[h].add(n[h].mul(.5));this.ComputeDescentDirection(u);for(let h=0;h<this.nodes.length;h++)o[h]=this.nodes[h].Center.sub(this.nodes[h].previousCenter),this.nodes[h].previousCenter=e[h],this.nodes[h].Center=e[h].add(o[h]);this.energy=this.ComputeDescentDirection(u);for(let h=0;h<this.nodes.length;h++){s[h]=this.nodes[h].Center.sub(this.nodes[h].previousCenter),this.nodes[h].previousCenter=e[h];let c=i[h].add(n[h].mul(2).add(o[h].mul(2)).add(s[h])).div(6);this.nodes[h].Center=e[h].add(c)}return this.UpdateStepSize(a),this.nodes.reduce((h,c)=>c.Center.sub(c.previousCenter).lengthSquared+h,0)}run(){this.settings.Converged=!1,this.settings.EdgeRoutesUpToDate=!1,this.settings.Iterations++==0&&(this.stepSize=this.settings.InitialStepSize,this.energy=Number.MAX_VALUE,this.progress=0);for(let e=0;e<this.settings.MinorIterations;e++){if((this.settings.RungeKuttaIntegration?this.RungeKuttaIntegration():this.VerletIntegration())<this.settings.DisplacementThreshold||this.settings.Iterations>this.settings.MaxIterations){this.settings.Converged=!0;break}this.ProgressStep()}}};function Lp(l){for(let t of l.Clusters)return!0;return!1}var kt=class{constructor(){this.commonSettings=new ei;this.maxIterations=100;this.clusterMargin=10;this.minorIterations=3;this.projectionIterations=5;this.approximateRepulsion=!0;this.RungeKuttaIntegration=!1;this.initialStepSize=1.4;this.decay=.9;this.friction=.8;this.repulsiveForceConstant=1;this.attractiveForceConstant=1;this.gravity=1;this.interComponentForces=!0;this.applyForces=!0;this.AvoidOverlaps=!0;this.approximateRouting=!0;this.logScaleEdgeForces=!0;this.displacementThreshold=.1;this.maxConstraintLevel=2;this.minConstraintLevel=0;this.attractiveInterClusterForceConstant=1;this.clusterGravity=1;this.commonSettings.NodeSeparation*=2}get edgeRoutingSettings(){return this.commonSettings.edgeRoutingSettings}set edgeRoutingSettings(t){this.commonSettings.edgeRoutingSettings=t}get PackingAspectRatio(){return this.commonSettings.PackingAspectRatio}set PackingAspectRatio(t){this.commonSettings.PackingAspectRatio=t}get NodeSeparation(){return this.commonSettings.NodeSeparation}set NodeSeparation(t){this.commonSettings.NodeSeparation=t}get MaxIterations(){return this.maxIterations}set MaxIterations(t){this.maxIterations=t}get MinorIterations(){return this.minorIterations}set MinorIterations(t){this.minorIterations=t}get Iterations(){return this.iterations}set Iterations(t){this.iterations=t}get ProjectionIterations(){return this.projectionIterations}set ProjectionIterations(t){this.projectionIterations=t}get ApproximateRepulsion(){return this.approximateRepulsion}set ApproximateRepulsion(t){this.approximateRepulsion=t}get InitialStepSize(){return this.initialStepSize}set InitialStepSize(t){if(t<=0||t>2)throw new Error("ForceScalar should be greater than 0 and less than 2 (if we let you set it to 0 nothing would happen, greater than 2 would most likely be very unstable!)");this.initialStepSize=t}get Decay(){return this.decay}set Decay(t){if(t<.1||t>1)throw new Error("Setting decay too small gives no progress.  1==no decay, 0.1==minimum allowed value");this.decay=t}get Friction(){return this.friction}set Friction(t){if(t<0||t>1)throw new Error("Setting friction less than 0 or greater than 1 would just be strange.  1==no friction, 0==no conservation of velocity");this.friction=t}get RepulsiveForceConstant(){return this.repulsiveForceConstant}set RepulsiveForceConstant(t){this.repulsiveForceConstant=t}get AttractiveForceConstant(){return this.attractiveForceConstant}set AttractiveForceConstant(t){this.attractiveForceConstant=t}get GravityConstant(){return this.gravity}set GravityConstant(t){this.gravity=t}get InterComponentForces(){return this.interComponentForces}set InterComponentForces(t){this.interComponentForces=t}get ApplyForces(){return this.applyForces}set ApplyForces(t){this.applyForces=t}ResetLayout(){this.Unconverge(),this.algorithm!=null&&this.algorithm.ResetNodePositions()}Unconverge(){this.iterations=0,this.converged=!1}InitializeLayoutGN(t,e){this.InitializeLayout(t,e)}InitializeLayout(t,e){this.algorithm=new Ki(t,this,e),this.ResetLayout()}Uninitialize(){this.algorithm=null}get IsInitialized(){return this.algorithm!=null}IncrementalRunG(t){this.IncrementalRunGF(t)}SetupIncrementalRun(t){this.IsInitialized?this.IsDone&&this.ResetLayout():this.InitializeLayout(t,this.MaxConstraintLevel)}IncrementalRunGF(t){this.SetupIncrementalRun(t),this.algorithm.run()}IncrementalRun(t,e){t!=null&&t.throwIfCanceled(),this.SetupIncrementalRun(e),this.algorithm.cancelToken=t,this.algorithm.run()}Clone(){return kt.ctorClone(this)}get ApproximateRouting(){return this.approximateRouting}set ApproximateRouting(t){this.approximateRouting=t}get LogScaleEdgeForces(){return this.logScaleEdgeForces}set LogScaleEdgeForces(t){this.logScaleEdgeForces=t}get DisplacementThreshold(){return this.displacementThreshold}set DisplacementThreshold(t){this.displacementThreshold=t}get Converged(){return this.converged}set Converged(t){this.converged=t}get PercentDone(){return this.Converged?100:100*this.iterations/this.MaxIterations}get IsDone(){return this.Converged||this.iterations>=this.MaxIterations}get Energy(){return this.algorithm!=null?this.algorithm.energy:0}get MaxConstraintLevel(){return this.maxConstraintLevel}set MaxConstraintLevel(t){this.maxConstraintLevel!=t&&(this.maxConstraintLevel=t,this.IsInitialized&&this.Uninitialize())}get MinConstraintLevel(){return this.minConstraintLevel}set MinConstraintLevel(t){this.minConstraintLevel=t}getCurrentConstraintLevel(){return this.algorithm==null?0:this.algorithm.getCurrentConstraintLevel()}setCurrentConstraintLevel(t){this.algorithm.setCurrentConstraintLevel(t)}get AttractiveInterClusterForceConstant(){return this.attractiveInterClusterForceConstant}set AttractiveInterClusterForceConstant(t){this.attractiveInterClusterForceConstant=t}static ctorClone(t){let e=new kt;return e.maxIterations=t.maxIterations,e.minorIterations=t.minorIterations,e.projectionIterations=t.projectionIterations,e.approximateRepulsion=t.approximateRepulsion,e.initialStepSize=t.initialStepSize,e.RungeKuttaIntegration=t.RungeKuttaIntegration,e.decay=t.decay,e.friction=t.friction,e.repulsiveForceConstant=t.repulsiveForceConstant,e.attractiveForceConstant=t.attractiveForceConstant,e.gravity=t.gravity,e.interComponentForces=t.interComponentForces,e.applyForces=t.applyForces,e.AvoidOverlaps=t.AvoidOverlaps,e.RespectEdgePorts=t.RespectEdgePorts,e.RouteEdges=t.RouteEdges,e.approximateRouting=t.approximateRouting,e.logScaleEdgeForces=t.logScaleEdgeForces,e.displacementThreshold=t.displacementThreshold,e.minConstraintLevel=t.minConstraintLevel,e.maxConstraintLevel=t.maxConstraintLevel,e.attractiveInterClusterForceConstant=t.attractiveInterClusterForceConstant,e.clusterGravity=t.clusterGravity,e.PackingAspectRatio=t.PackingAspectRatio,e.NodeSeparation=t.NodeSeparation,e.clusterMargin=t.clusterMargin,e}get ClusterGravity(){return this.clusterGravity}set ClusterGravity(t){this.clusterGravity=t}static CreateFastIncrementalLayoutSettings(){let t=new kt;return t.ApplyForces=!1,t.ApproximateRepulsion=!0,t.ApproximateRouting=!0,t.AttractiveForceConstant=1,t.AttractiveInterClusterForceConstant=1,t.AvoidOverlaps=!0,t.ClusterGravity=1,t.Decay=.9,t.DisplacementThreshold=5e-8,t.Friction=.8,t.GravityConstant=1,t.InitialStepSize=2,t.InterComponentForces=!1,t.Iterations=0,t.LogScaleEdgeForces=!1,t.MaxConstraintLevel=2,t.MaxIterations=20,t.MinConstraintLevel=0,t.MinorIterations=1,t.ProjectionIterations=5,t.RepulsiveForceConstant=2,t.RespectEdgePorts=!1,t.RouteEdges=!1,t.RungeKuttaIntegration=!0,t.NodeSeparation=20,t}};var Ml=class{constructor(t){this.topNodes=t}get nodesBreadthFirst(){return this.nodesBreadthFirst_()}*nodesBreadthFirst_(){for(let t of this.topNodes)if(yield Ke.getGeom(t),t instanceof de)for(let e of t.nodesBreadthFirst)yield Ke.getGeom(e)}get Clusters(){return this.clusters()}*clusters(){for(let t of this.topNodes)t instanceof de&&(yield ne.getGeom(t))}get subgraphsDepthFirst(){return this.subgraphsDepthFirst_()}*subgraphsDepthFirst_(){for(let t of this.topNodes)if(t instanceof de){let e=ne.getGeom(t);yield*e.subgraphsDepthFirst,yield e}}get shallowEdges(){return this.edges_()}*edges_(){for(let t of this.topNodes){for(let e of t.outEdges)yield Re.getGeom(e);for(let e of t.selfEdges)yield Re.getGeom(e)}}get shallowNodes(){return this.shallowNodes_()}*shallowNodes_(){for(let t of this.topNodes)yield Ke.getGeom(t)}pumpTheBoxToTheGraphWithMargins(){let t={b:D.mkEmpty()};return Wa(this,t),this.boundingBox=t.b}get shallowNodeCount(){return this.topNodes.length}translate(t){this.boundingBox&&(this.boundingBox.center=this.boundingBox.center.add(t));for(let e of this.topNodes)Ke.getGeom(e).translate(t)}};var sa=class{static LinearInterpolation(t,e,i,n,o){if(t<e)return n;if(t>i)return o;let s=(t-e)/(i-e);return n+s*(o-n)}static NegativeLinearInterpolation(t,e,i,n,o){if(t<e)return o;if(t>i)return n;let s=(t-e)/(i-e);return n+(1-s)*(o-n)}};var Wl=class extends _{constructor(e,i){super(null);this.SingleComponent=!1;this.graph=e,this.settings=kt.ctorClone(i),this.settings.ApplyForces=!0,this.settings.InterComponentForces=!0,this.settings.RungeKuttaIntegration=!1,this.settings.RespectEdgePorts=!1}run(){if(this.SingleComponent)this.componentCount=1,this.LayoutComponent(this.graph);else{let e=Array.from(this.graph.graph.getClusteredConnectedComponents()).map(i=>new Ml(i));this.componentCount=e.length;for(let i of e)this.LayoutComponent(i);this.graph.boundingBox=Ji.PackGraphs(e,this.settings.commonSettings)}}LayoutComponent(e){if(e.shallowNodeCount>1){if(this.settings.MaxIterations=sa.NegativeLinearInterpolation(e.shallowNodeCount,50,500,5,10),this.settings.MinorIterations=sa.NegativeLinearInterpolation(e.shallowNodeCount,50,500,3,20),this.settings.MinConstraintLevel==0){let n=new Ir;n.removeOverlaps=!1,n.IterationsWithMajorization=0,new po(e,null,()=>1,new Ir).run()}let i=new Ki(e,this.settings,this.settings.MinConstraintLevel);for(let n of this.GetConstraintLevels(e)){if(n>this.settings.MaxConstraintLevel)break;n>this.settings.MinConstraintLevel&&i.setCurrentConstraintLevel(n);do i.run();while(!this.settings.IsDone)}this.settings.AvoidOverlaps&&Xt.RemoveOverlaps(Array.from(this.graph.shallowNodes),this.settings.NodeSeparation)}e.pumpTheBoxToTheGraphWithMargins(),e.uniformMargins=this.settings.NodeSeparation,e.translate(e.boundingBox.leftBottom.mul(-1))}GetConstraintLevels(e){let i=new Set;return i.add(0),this.settings.AvoidOverlaps&&e.shallowNodeCount<2e3&&i.add(2),i}};function Vd(l){l.layoutSettings||(l.layoutSettings=kd(l))}function Gp(l){let t=l.parent;for(;t;){if(t.layoutSettings)return t.layoutSettings;t=t.parent}return null}function kd(l){let t=Gp(l);if(t)return t;if(l.graph.shallowNodeCount>2e3||l.graph.deepEdgesCount>4e3)return new kt;let i=!1;for(let n of l.deepEdges)if(n.sourceArrowhead!=null||n.targetArrowhead!=null){i=!0;break}return i?new _e:new kt}function Rp(l,t,e=()=>1){if(Vd(l),l.layoutSettings instanceof _e)new cs(l,l.layoutSettings,t).run();else if(l.layoutSettings instanceof Ir)new po(l,t,e,l.layoutSettings).run();else if(l.layoutSettings instanceof kt){let i=new Wl(l,l.layoutSettings);i.SingleComponent=!0,i.run()}else throw new Error("not implemented")}function Hl(l,t=null){Vd(l),ra(l,t,Rp,bo,Ma)}function Ah(l){do{if(l.layoutSettings&&l.layoutSettings.commonSettings.edgeRoutingSettings)return l.layoutSettings.commonSettings.edgeRoutingSettings;let e=l.graph.parent;if(e)l=ie.getGeom(e);else break}while(!0);let t=new wi;return t.EdgeRoutingMode=0,t}function bo(l,t,e){let i=Ah(l);i.EdgeRoutingMode===4?Md(l,t,e):i.EdgeRoutingMode===0||i.EdgeRoutingMode===1?Hd(l,t,e):i.EdgeRoutingMode===2?Ll(l,t,e):i.EdgeRoutingMode!==6&&new fe(l,t).run(),Wd(l,t)}function ra(l,t,e,i,n,o=1,s=()=>1){if(l.graph.isEmpty())return;l.parent==null&&(yn(o),Fp(l));let a=P();f(l);let u=Np(l.graph),h=Dp(l);if(v(),u.forEach(A=>{A[0].edge.remove(),A[1].add()}),h.forEach(A=>{for(let O of A.graph.shallowNodes)O.parent=l.graph}),a.forEach(A=>A.add()),l.graph.parent==null){let A=c(l);i(l,A,t),Wd(l,A),l.pumpTheBoxToTheGraphWithMargins()}function c(A){let O=[];for(let M of A.nodesBreadthFirst){for(let z of M.outEdges())z.curve==null&&O.push(z);for(let z of M.selfEdges())z.curve==null&&O.push(z)}return O}function f(A){for(let O of A.shallowNodes)O instanceof ne&&ra(O,t,e,i,n)}function P(){let A=new Set,O=l.graph;if(O.parent==null)return A;for(let M of O.shallowNodes){for(let z of M.outEdges){let $=O.liftNode(z.target);($==null||$===M)&&A.add(z)}for(let z of M.inEdges){let $=O.liftNode(z.source);($==null||$===M)&&A.add(z)}}for(let M of A)M.remove();return A}function v(){if(h.length===1)e(l,t,s);else{for(let A of h)e(A,t,s),A.boundingBox=A.pumpTheBoxToTheGraphWithMargins();n(l,h)}}}function Np(l){let t=new Array;for(let e of l.nodesBreadthFirst){let i=l.liftNode(e);if(i!=null)for(let n of e.outEdges.values()){let o=n.target,s=l.liftNode(o);if(s==null||i===e&&s===o||i===s)continue;n.remove();let a=new sr(i,s),u=new Re(a);t.push([u,n])}}return t}function Dp(l){var o;let t=l.graph,e=Fc(t),i=[],n=0;for(let s of e){let a=new de(t.id+n++);a.parent=t;let u=new ne(a);u.layoutSettings=(o=l.layoutSettings)!=null?o:kd(l);for(let h of s)h.parent=a,a.addNode(h);i.push(u)}return i}function Md(l,t,e,i=1,n=3,o=3){let s=Dn.constructorGNAN(l,t,i,n);s.edgeSeparatian=o,s.run()}function Wd(l,t){if(t.length===0)return;xr.constructorGA(l,t).run()}function Fp(l){for(let t of l.deepEdges)t.label&&(t.label.isPositioned=!1)}var ds=class{static constructorStatic(t,e){let i=new ds;i.edges=t,i.nodeBoundaries=e,i.boundingBox=D.mkEmpty();for(let n of i.nodeBoundaries)i.boundingBox=i.boundingBox.addRec(n.boundingBox);return i}AddGraph(t){this.edges=this.edges.concat(t.edges),this.nodeBoundaries=Ur(this.nodeBoundaries,t.nodeBoundaries),this.boundingBox.addRec(t.boundingBox)}AddNodeBoundary(t){this.nodeBoundaries.add(t),this.boundingBox.addRec(t.boundingBox)}};var zd=he(Gr(),1);var zn=class{get CurrentPiercedEdge(){return this.currentPiercedEdge}get CurrentTriangle(){return this.currentTriangle}constructor(t,e,i){this.currentTriangle=t,this.start=e,this.end=i}FindFirstPiercedEdge(){let t=this.GetHyperplaneSign(this.currentTriangle.Sites.item0),e=this.GetHyperplaneSign(this.currentTriangle.Sites.item1);if(t!==e&&d.getTriangleOrientation(this.end,this.currentTriangle.Sites.item0.point,this.currentTriangle.Sites.item1.point)==0)return this.positiveSign=t,this.negativeSign=e,this.currentTriangle.Edges.item0;let i=this.GetHyperplaneSign(this.currentTriangle.Sites.item2);return e!==i&&d.getTriangleOrientation(this.end,this.currentTriangle.Sites.item1.point,this.currentTriangle.Sites.item2.point)==0?(this.positiveSign=e,this.negativeSign=i,this.currentTriangle.Edges.item1):(this.positiveSign=i,this.negativeSign=t,this.currentTriangle.Edges.item2)}FindNextPierced(){if(this.currentTriangle=this.currentPiercedEdge.GetOtherTriangle_T(this.currentTriangle),this.currentTriangle==null){this.currentPiercedEdge=null;return}let t=this.currentTriangle.Edges.index(this.currentPiercedEdge),e,i=this.currentTriangle.Sites.getItem(t+2),n=this.GetHyperplaneSign(i);this.negativeSign===0?n===-1||n===0?(this.negativeSign=n,e=t+1):e=t+2:this.positiveSign===0?n===1||n===0?(this.positiveSign=n,e=t+2):e=t+1:n!==this.positiveSign?(this.negativeSign=n,e=t+1):(this.positiveSign=n,e=t+2),this.currentPiercedEdge=d.signedDoubledTriangleArea(this.end,this.currentTriangle.Sites.getItem(e).point,this.currentTriangle.Sites.getItem(e+1).point)<-C.distanceEpsilon?this.currentTriangle.Edges.getItem(e):null}GetHyperplaneSign(t){let e=d.signedDoubledTriangleArea(this.start,t.point,this.end);return e>C.distanceEpsilon?1:e<-C.distanceEpsilon?-1:0}MoveNext(){return this.currentPiercedEdge==null?this.currentPiercedEdge=this.FindFirstPiercedEdge():this.FindNextPierced(),this.currentPiercedEdge!=null}};var gs=class{constructor(t,e){this.ComputeForcesForBundles=!1;this.metroGraphData=t,this.bundlingSettings=e}EdgeIsLegal_(t,e,i,n){if(Ee.PointIsInsideOfTriangle(e,i))return!0;let o=new zn(i,t,e);for(;o.MoveNext();){let s=o.CurrentPiercedEdge;if(s.constrained){let a=s.lowerSite.Owner;if(!n.has(a))return!1}}return!0}BundleAvoidsObstacles(t,e,i,n,o,s){s.closestDist=new Array;let a=this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(t,e),u=this.FindCloseObstaclesForBundle(e.cdtTriangle,n,i,a,o);if(u==null)return!1;for(let h of u){let c=h[1];s.closestDist.push(c)}return!0}FindCloseObstaclesForBundle(t,e,i,n,o){let s=new Map,a=[];if(!this.ThreadLineSegmentThroughTriangles(t,e,i,n,a))return null;if(!this.ComputeForcesForBundles&&!this.bundlingSettings.HighestQuality)return s;let u=new $i;for(let h of a)for(let c of h.Sites){if(u.has(c))continue;u.add(c);let f=c.Owner;if(n.has(f))continue;let P=gs.FindPolylinePoint(f,c.point),v=w.minDistBetweenLineSegments(P.point,P.nextOnPolyline.point,e,i),A=v.dist,O=v.parab,M=v.parcd,z=w.minDistBetweenLineSegments(P.point,P.prevOnPolyline.point,e,i),$=z.dist,N=z.parab,q=z.parcd,Te,ve,Wt;if(A<$){if(Wt=A,Wt>o)continue;Te=P.point.add(P.nextOnPolyline.point.sub(P.point).mul(O)),ve=e.add(i.sub(e).mul(M))}else{if(Wt=$,Wt>o)continue;Te=P.point.add(P.prevOnPolyline.point.sub(P.point).mul(N)),ve=e.add(i.sub(e).mul(q))}s.get(f)||s.set(f,[Te,ve])}return s}ThreadLineSegmentThroughTriangles(t,e,i,n,o){if(Ee.PointIsInsideOfTriangle(i,t))return o.push(t),!0;let s=new zn(t,e,i);for(o.push(t);s.MoveNext();){o.push(s.CurrentTriangle);let a=s.CurrentPiercedEdge;if(a.constrained){let u=a.lowerSite.Owner;if(!n.has(u))return!1}}return s.CurrentTriangle!=null&&o.push(s.CurrentTriangle),!0}static PointLocationInsideTriangle(t,e){let i=!1;for(let n=0;n<3;n++){let o=d.signedDoubledTriangleArea(t,e.Sites.getItem(n).point,e.Sites.getItem(n+1).point);if(o<C.distanceEpsilon*-1)return 0;o<C.distanceEpsilon&&(i=!0)}return i?1:2}static FindPolylinePoint(t,e){for(let i of t.polylinePoints())if(i.point.equal(e))return i;throw new Error("polyline point "+e+" not found")}EdgeIsLegal(t,e,i,n){let o=[],s=this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(t,e);return this.ThreadLineSegmentThroughTriangles(t.cdtTriangle,i,n,s,o)}EdgeIsLegalSSPPS(t,e,i){let n=t.Position,o=t.cdtTriangle,s=e.Position;if(Ee.PointIsInsideOfTriangle(s,o))return!0;let a=new zn(o,n,s);for(;a.MoveNext();){let u=a.CurrentPiercedEdge;if(u.constrained){let h=u.lowerSite.Owner;if(!i.has(h))return!1}}return!0}};var $t=class{constructor(t,e,i,n){this.metroGraphData=t,this.obstaclesToIgnoreLambda=n,this.bundlingSettings=e,this.obstacleTree=i}ObstaclesToIgnoreForBundle(t,e){return t!=null&&e!=null?Ur(this.obstaclesToIgnoreLambda(t),this.obstaclesToIgnoreLambda(e)):t==null&&e==null?new Set:t!=null?this.obstaclesToIgnoreLambda(t):this.obstaclesToIgnoreLambda(e)}HubAvoidsObstaclesSPNBA(t,e,i,n){let o={minimalDistance:i};return $t.IntersectCircleWithTree(this.obstacleTree,e,i,this.obstaclesToIgnoreLambda(t),n.touchedObstacles,o)}HubAvoidsObstaclesPNS__(t,e,i){let n={touchedObstacles:Array()},o={minimalDistance:0};return this.HubAvoidsObstaclesPNSTT(t,e,i,n,o)}GetMinimalDistanceToObstacles(t,e,i){let n=new Array,o={minimalDistance:i};return $t.IntersectCircleWithTree(this.obstacleTree,e,i,this.obstaclesToIgnoreLambda(t),n,o)?o.minimalDistance:0}HubAvoidsObstaclesPNSTT(t,e,i,n,o){return n.touchedObstacles=new Array,o.minimalDistance=e,$t.IntersectCircleWithTree(this.obstacleTree,t,e,i,n.touchedObstacles,o)}static IntersectCircleWithTree(t,e,i,n,o,s){if(!t.irect.contains_point_radius(e,i))return!0;if(t.UserData==null){let a=$t.IntersectCircleWithTree(t.Left,e,i,n,o,s);if(!a||(a=$t.IntersectCircleWithTree(t.Right,e,i,n,o,s),!a))return!1}else{let a=t.UserData;if(n.has(a))return!0;if(E.PointRelativeToCurveLocation(e,a)!==0)return $t.containingPoly=a,!1;let h=a.value(a.closestParameter(e)),c=h.sub(e).length;c<=i&&o.push([a,h]),s.minimalDistance=Math.min(c,s.minimalDistance)}return!0}static Create4gon(t,e,i,n){let o=e.sub(t).normalize();return o=new d(o.y,o.x*-1),j.mkFromPoints([t.add(o.mul(i/2)),t.sub(o.mul(i/2)),e.sub(o.mul(n/2)),e.add(o.mul(n/2))])}};var zl=class{constructor(t,e,i,n){this.Width=e,this.Polyline=t,this.sourceAndTargetLoosePolylines=i,this.Index=n}UpdateLengths(){let t=0;for(let e=this.Polyline.startPoint;e.next!=null;e=e.next)t+=e.next.point.sub(e.point).length;this.Length=t,this.IdealLength=this.Polyline.end.sub(this.Polyline.start).length}};var ql=class{constructor(t,e,i){this.metroline=t,this.station=e,this.polyPoint=i}get Metroline(){return this.metroline}get PolyPoint(){return this.polyPoint}};var Ul=class{constructor(t,e,i){this.Radius=0;this.BundleBases=new Map;this.MetroNodeInfos=new Array;this._cachedIdealRadius=0;this.SerialNumber=t,this.IsReal=e,this.Position=i}debStop(){return this.SerialNumber===28&&this.Position.sub(new d(841.2662778763244,303.3817005853006)).length<.001}get Position(){return this._Position}set Position(t){this._Position=t}getELP(){return this.EnterableLoosePolylines}setELP(t){this.EnterableLoosePolylines=t}addEL(t){this.EnterableLoosePolylines.add(t)}get cachedIdealRadius(){return this._cachedIdealRadius}set cachedIdealRadius(t){this._cachedIdealRadius=t}AddEnterableLoosePolyline(t){this.EnterableLoosePolylines==null&&(this.EnterableLoosePolylines=new Set),this.EnterableLoosePolylines.add(t)}AddEnterableTightPolyline(t){this.EnterableTightPolylines==null&&(this.EnterableTightPolylines=new Set),this.EnterableTightPolylines.add(t)}};var jl=class{constructor(){this.Width=0;this.Metrolines=new Array;this.cachedBundleCost=0}get Count(){return this.Metrolines.length}};var et=class{constructor(t,e){this.metroGraphData=t,this.bundlingSettings=e}CreateNodeRadii(){for(let t of this.metroGraphData.VirtualStations())t.Radius=0,t.cachedIdealRadius=et.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData,this.bundlingSettings,t);this.GrowHubs(!1),this.GrowHubs(!0);for(let t of this.metroGraphData.VirtualStations())t.Radius=Math.max(t.Radius,this.bundlingSettings.MinHubRadius)}GrowHubs(t){let e=new At(ce);for(let n of this.metroGraphData.VirtualStations())e.Enqueue(n,-this.CalculatePotential(n,t));let i=!1;for(;!e.IsEmpty();){let n={priority:0},o=e.DequeueAndGetPriority(n);if(n.priority>=0)break;this.TryGrowHub(o,t)&&(e.Enqueue(o,-this.CalculatePotential(o,t)),i=!0)}return i}TryGrowHub(t,e){let i=this.CalculateAllowedHubRadius(t);if(t.Radius>=i)return!1;let n=e?et.CalculateIdealHubRadiusWithAdjacentEdges(this.bundlingSettings,t):t.cachedIdealRadius;if(t.Radius>=n)return!1;let s=.05*(n-t.Radius);s<1&&(s=1);let a=Math.min(t.Radius+s,i);return a<=t.Radius?!1:(t.Radius=a,!0)}CalculatePotential(t,e){let i=e?et.CalculateIdealHubRadiusWithAdjacentEdges(this.bundlingSettings,t):t.cachedIdealRadius;return i<=t.Radius?0:(i-t.Radius)/i}CalculateAllowedHubRadius(t){let e=this.bundlingSettings.MaxHubRadius;for(let n of t.Neighbors){let o=n.Position.sub(t.Position).length;e=Math.min(e,o/1.05-n.Radius)}let i=this.metroGraphData.tightIntersections.GetMinimalDistanceToObstacles(t,t.Position,e);return i<e&&(e=i-.001),Math.max(e,.1)}static CalculateIdealHubRadius(t,e,i){let n=1;for(let o of i.Neighbors){let a=t.GetWidthSSN(o,i,e.EdgeSeparation)/2+e.EdgeSeparation;n=Math.max(n,a)}return n=Math.min(n,2*e.MaxHubRadius),n}static CalculateIdealHubRadiusWithNeighborsMBS(t,e,i){return et.CalculateIdealHubRadiusWithNeighborsMBNP(t,e,i,i.Position)}static CalculateIdealHubRadiusWithNeighborsMBNP(t,e,i,n){let o=et.CalculateIdealHubRadius(t,e,i);if(i.Neighbors.length>1){let s=i.Neighbors;for(let a=0;a<s.length;a++){let u=s[a],h=s[(a+1)%s.length];o=Math.max(o,et.GetMinRadiusForTwoAdjacentBundles(o,i,n,u,h,t,e))}}return o=Math.min(o,2*e.MaxHubRadius),o}static CalculateIdealHubRadiusWithAdjacentEdges(t,e){let i=t.MaxHubRadius;for(let n of e.Neighbors)i=Math.min(i,e.Position.sub(n.Position).length/2);return i}static GetMinRadiusForTwoAdjacentBundles(t,e,i,n,o,s,a){let u=s.GetWidthSSN(e,n,a.EdgeSeparation),h=s.GetWidthSSN(e,o,a.EdgeSeparation);return et.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(t,i,n.Position,o.Position,u,h,a)}static GetMinRadiusForTwoAdjacentBundlesNPPPNNB(t,e,i,n,o,s,a){if(o<C.distanceEpsilon||s<C.distanceEpsilon)return t;let u=d.anglePCP(i,e,n);if(u=Math.min(u,Math.PI*2-u),u<C.distanceEpsilon)return 2*a.MaxHubRadius;if(u>=Math.PI/2)return t*1.05;let h=Math.sin(u),c=Math.cos(u),f=o/(4*h),P=s/(4*h),v=2*Math.sqrt(f*f+(P*P+2*(f*(P*c))));return v=Math.min(v,2*a.MaxHubRadius),v=Math.max(v,t),v}};var qn=class{constructor(t,e,i,n){this.metroGraphData=t,this.bundlingSettings=e,this.costCalculator=i,this.cdt=n}InitializeCostCache(){for(let t of this.metroGraphData.VirtualStations())t.cachedIdealRadius=et.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData,this.bundlingSettings,t),t.cachedRadiusCost=this.costCalculator.RadiusCost(t,t.Position),t.cachedBundleCost=0;for(let t of this.metroGraphData.VirtualEdges()){let e=t[0],i=t[1],n=this.metroGraphData.GetIjInfo(e,i);n.cachedBundleCost=this.costCalculator.BundleCost(e,i,e.Position),e.cachedBundleCost+=n.cachedBundleCost,i.cachedBundleCost+=n.cachedBundleCost}}UpdateCostCache(t){let e=this.cdt.getRectangleNodeOnTriangles();t.cdtTriangle=e.FirstHitNodeWithPredicate(t.Position,qn.testPointInside).UserData,t.cachedIdealRadius=et.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData,this.bundlingSettings,t),t.cachedRadiusCost=this.costCalculator.RadiusCost(t,t.Position),t.cachedBundleCost=0;for(let i of t.Neighbors){i.IsReal||(i.cachedIdealRadius=et.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData,this.bundlingSettings,i),i.cachedRadiusCost=this.costCalculator.RadiusCost(i,i.Position));let n=this.metroGraphData.GetIjInfo(t,i);i.cachedBundleCost-=n.cachedBundleCost,n.cachedBundleCost=this.costCalculator.BundleCost(t,i,t.Position),t.cachedBundleCost+=n.cachedBundleCost,i.cachedBundleCost+=n.cachedBundleCost}}static testPointInside(t,e){return Ee.PointIsInsideOfTriangle(t,e)?1:0}};var ms=class{constructor(){this.mainMap=new Map}get isEmpty(){return this.mainMap.size===0||this.everyMapIsEmpty()}everyMapIsEmpty(){for(let t of this.mainMap.values())if(t.size)return!1;return!0}get(t,e){let i=this.mainMap.get(t);if(i)return i.get(e)}has(t,e){let i=this.mainMap.get(t);return i?i.has(e):!1}set(t,e,i){let n=this.mainMap.get(t);n||(n=new Map,this.mainMap.set(t,n)),n.set(e,i)}*[Symbol.iterator](){for(let[t,e]of this.mainMap)for(let[i,n]of e)yield[t,i,n]}*keys(){for(let[t,e]of this.mainMap)for(let[i]of e)yield[t,i]}};var Ql=class{constructor(t,e,i,n,o,s,a,u){this.cachedEnterableLooseForEnd=new qe;this.bundlingSettings=n,this.regularEdges=t,o!=null?this.cdt=o:this.cdt=Ol(e),this.EdgeLooseEnterable=s,this.EdgeTightEnterable=a,this.LoosePolylineOfPort=u,this.looseIntersections=new $t(this,n,e,h=>h.getELP()),this.tightIntersections=new $t(this,n,i,h=>h.EnterableTightPolylines),this.cdtIntersections=new gs(this,n),this.Initialize(!1)}get Ink(){return this.ink}get Edges(){return this.regularEdges}VirtualStations(){return Array.from(this.Stations).filter(t=>!t.IsReal)}get Metrolines(){return this.metrolines}get LooseTree(){return this.looseIntersections.obstacleTree}get TightTree(){return this.tightIntersections.obstacleTree}*VirtualEdges(){for(let t of this.edgeInfoDictionary.keys())yield t}RealEdgeCount(t,e){let i=t.SerialNumber<e.SerialNumber?[t,e]:[e,t],n=this.edgeInfoDictionary.get(i[0],i[1]);return n?n.Count:0}MetroNodeInfosOfNode(t){return t.MetroNodeInfos}GetIjInfo(t,e){let i=t.SerialNumber<e.SerialNumber?[t,e]:[e,t];return this.edgeInfoDictionary.get(i[0],i[1])}MoveNode(t,e){let i=t.Position;this.PointToStations.deleteP(i),this.PointToStations.set(e,t),t.Position=e;for(let n of this.MetroNodeInfosOfNode(t))n.PolyPoint.point=e;for(let n of this.MetroNodeInfosOfNode(t)){let o=n.Metroline,s=n.PolyPoint.prev.point,a=n.PolyPoint.next.point;o.Length+=a.sub(e).length+s.sub(e).length-a.sub(i).length-s.sub(i).length}for(let n of t.Neighbors)this.ink+=e.sub(n.Position).length-i.sub(n.Position).length;this.SortNeighbors(t);for(let n of t.Neighbors)this.SortNeighbors(n)}GetWidthSSN(t,e,i){let n=t.SerialNumber<e.SerialNumber?[t,e]:[e,t],o=this.edgeInfoDictionary.get(n[0],n[1]);return o?o.Width+(o.Count-1)*i:0}GetWidthAN(t,e){let i=0;for(let o of t)i+=o.Width;let n=t.length;return i+=n>0?(n-1)*e:0,i}Initialize(t){this.SimplifyRegularEdges(),this.InitializeStationData(),this.InitializeEdgeData(),this.InitializeVirtualGraph(),this.InitializeEdgeNodeInfo(t),this.InitializeCdtInfo()}SimplifyRegularEdges(){for(let t of this.regularEdges)this.SimplifyRegularEdge(t)}SimplifyRegularEdge(t){let e=t.curve,i=new zd.Stack,n=new Se;for(let o=e.endPoint;o!=null;o=o.prev){let s=o.point;if(n.has(o.point)){let a=o.next;do{let u=i.top;if(!u.equal(s))n.delete(u),i.pop(),a=a.next;else break}while(!0);a.prev=o.prev,a.prev.next=a}else i.push(s),n.add(s)}}InitializeStationData(){this.Stations=[],this.PointToStations=new qe;for(let t of this.regularEdges){let e=t.curve;this.ProcessPolylinePoints(e)}}ProcessPolylinePoints(t){let e=t.startPoint;for(this.RegisterStation(e,!0),e=e.next;e!==t.endPoint;e=e.next)this.RegisterStation(e,!1);this.RegisterStation(e,!0)}RegisterStation(t,e){if(!this.PointToStations.has(t.point)){let i=new Ul(this.Stations.length,e,t.point);this.PointToStations.set(t.point,i),this.Stations.push(i)}}InitializeEdgeData(){this.metrolines=new Array;for(let t=0;t<this.regularEdges.length;t++){let e=this.regularEdges[t];this.InitEdgeData(e,t)}}InitEdgeData(t,e){let i=new zl(t.curve,this.bundlingSettings.ActualEdgeWidth(t),this.EdgeSourceAndTargetFunc(t),e);this.metrolines.push(i),this.PointToStations.get(i.Polyline.start).BoundaryCurve=t.sourcePort.Curve,this.PointToStations.get(i.Polyline.end).BoundaryCurve=t.targetPort.Curve}EdgeSourceAndTargetFunc(t){return()=>[this.LoosePolylineOfPort(t.sourcePort),this.LoosePolylineOfPort(t.targetPort)]}InitializeVirtualGraph(){let t=new Map;for(let e of this.metrolines){let i=this.PointToStations.get(e.Polyline.start),n;for(let o=e.Polyline.startPoint;o.next!=null;o=o.next,i=n)n=this.PointToStations.get(o.next.point),Kn(t,i,n),Kn(t,n,i)}for(let e of this.Stations)e.Neighbors=Array.from(t.get(e))}GetUnorderedIjInfo(t,e){return t.SerialNumber<e.SerialNumber?this.GetCreateOrderedIjInfo(t,e):this.GetCreateOrderedIjInfo(e,t)}static closedeb(t,e){return t.Position.sub(new d(360.561,428.416)).length<.1&&e.Position.sub(new d(414.281,440.732)).length<.1}GetCreateOrderedIjInfo(t,e){let i=this.edgeInfoDictionary.get(t,e);return i||(i=new jl,this.edgeInfoDictionary.set(t,e,i),i)}InitializeEdgeNodeInfo(t){this.edgeInfoDictionary=new ms,this.InitAllMetroNodeInfos(t),this.SortAllNeighbors(),this.InitEdgeIjInfos(),this.ink=0;for(let e of this.VirtualEdges())this.ink+=e[0].Position.sub(e[1].Position).length}InitAllMetroNodeInfos(t){for(let e=0;e<this.metrolines.length;e++){let i=this.metrolines[e];this.InitMetroNodeInfos(i),this.InitNodeEnterableLoosePolylines(i,this.regularEdges[e]),t&&this.InitNodeEnterableTightPolylines(i,this.regularEdges[e]),i.UpdateLengths()}}InitMetroNodeInfos(t){for(let e=t.Polyline.startPoint;e!=null;e=e.next){let i=this.PointToStations.get(e.point);i.MetroNodeInfos.push(new ql(t,i,e))}}InitNodeEnterableLoosePolylines(t,e){let i=this.EdgeLooseEnterable!=null?this.EdgeLooseEnterable.get(e):new Set;for(let n=t.Polyline.startPoint.next;n!=null&&n.next!=null;n=n.next){let o=this.PointToStations.get(n.point);o.getELP()!=null?o.setELP(jr(o.getELP(),i)):o.setELP(new Set(i))}this.AddLooseEnterableForMetrolineStartEndPoints(t)}AddLooseEnterableForMetrolineStartEndPoints(t){this.AddLooseEnterableForEnd(t.Polyline.start),this.AddLooseEnterableForEnd(t.Polyline.end)}AddTightEnterableForMetrolineStartEndPoints(t){this.AddTightEnterableForEnd(t.Polyline.start),this.AddTightEnterableForEnd(t.Polyline.end)}AddLooseEnterableForEnd(t){let e=this.PointToStations.get(t);if(this.cachedEnterableLooseForEnd.has(t))e.setELP(this.cachedEnterableLooseForEnd.get(t));else{for(let i of this.LooseTree.AllHitItems_(t))E.PointRelativeToCurveLocation(t,i)===2&&e.AddEnterableLoosePolyline(i);this.cachedEnterableLooseForEnd.set(t,e.getELP())}}AddTightEnterableForEnd(t){let e=this.PointToStations.get(t);for(let i of this.TightTree.AllHitItems_(t))E.PointRelativeToCurveLocation(t,i)===2&&e.AddEnterableTightPolyline(i)}InitNodeEnterableTightPolylines(t,e){let i=this.EdgeTightEnterable!=null?this.EdgeTightEnterable.get(e):new Set;for(let n=t.Polyline.startPoint.next;n!=null&&n.next!=null;n=n.next){let o=this.PointToStations.get(n.point),s=o.EnterableTightPolylines;s!=null?o.EnterableTightPolylines=jr(s,i):o.EnterableTightPolylines=new Set(i)}this.AddTightEnterableForMetrolineStartEndPoints(t)}SortAllNeighbors(){for(let t of this.Stations)this.SortNeighbors(t)}SortNeighbors(t){if(t.Neighbors.length<=2)return;let e=t.Neighbors[0].Position,i=t.Position;t.Neighbors.sort((n,o)=>Oi(e.sub(i),n.Position.sub(i),o.Position.sub(i)))}InitEdgeIjInfos(){for(let t of this.metrolines){let e=t.Polyline,i=this.PointToStations.get(e.start),n;for(let o=t.Polyline.startPoint;o.next!=null;o=o.next,i=n){n=this.PointToStations.get(o.next.point);let s=this.GetUnorderedIjInfo(i,n);s.Width+=t.Width,s.Metrolines.push(t)}}}InitializeCdtInfo(){let t=this.cdt.getRectangleNodeOnTriangles();for(let e of this.Stations)e.cdtTriangle=t.FirstHitNodeWithPredicate(e.Position,qn.testPointInside).UserData}PointIsAcceptableForEdge(t,e){if(this.LoosePolylineOfPort==null)return!0;let i=t.sourceAndTargetLoosePolylines();return E.PointRelativeToCurveLocation(e,i[0])===0&&E.PointRelativeToCurveLocation(e,i[1])===0}};function Oi(l,t,e){let i=d.crossProduct(l,e),n=l.dot(e),o=d.crossProduct(l,t),s=l.dot(t);return Q(o,0)&&aa(s,0)?Q(i,0)&&aa(n,0)?0:1:Q(i,0)&&aa(n,0)?-1:Q(o,0)||Q(i,0)||o*i>0?As(d.crossProduct(e,t),0):-As(Math.sign(o),0)}function aa(l,t){return As(l,t)>=0}var Ud=he(Gr(),1);var Bi=class{constructor(t,e){this.metroGraphData=t,this.bundlingSettings=e}static InkError(t,e,i){return(t-e)*i.InkImportance}static PathLengthsError(t,e,i,n){return(t-e)*(n.PathLengthImportance/i)}static RError(t,e,i){return t<=e?0:i.HubRepulsionImportance*((1-e/t)*(t-e))}static BundleError(t,e,i){return t<=e?0:i.BundleRepulsionImportance*((1-e/t)*(t-e))}static Cost(t,e){let i=e.InkImportance*t.Ink;for(let n of t.Metrolines)i+=e.PathLengthImportance*n.Length/n.IdealLength;return i+=this.CostOfForces(t),i}static CostOfForces(t){let e=0;for(let i of t.VirtualStations())e=e+i.cachedRadiusCost;for(let i of t.VirtualEdges()){let n=i[0],o=i[1];e+=t.GetIjInfo(n,o).cachedBundleCost}return e}InkGain(t,e){let i=this.metroGraphData.Ink,n=this.metroGraphData.Ink;for(let o of t.Neighbors){let s=o.Position;n-=s.sub(t.Position).length,n+=s.sub(e).length}return Bi.InkError(i,n,this.bundlingSettings)}PathLengthsGain(t,e){let i=0;for(let n of this.metroGraphData.MetroNodeInfosOfNode(t)){let o=n.Metroline.Length,s=n.PolyPoint.prev.point,a=n.PolyPoint.next.point,u=n.Metroline.Length+a.sub(e).length+s.sub(e).length-a.sub(t.Position).length-s.sub(t.Position).length;i+=Bi.PathLengthsError(o,u,n.Metroline.IdealLength,this.bundlingSettings)}return i}RadiusGain(t,e){let i=0;return i=i+t.cachedRadiusCost,i=i-this.RadiusCost(t,e),i}RadiusCost(t,e){let i;d.closeDistEps(t.Position,e)?i=t.cachedIdealRadius:i=et.CalculateIdealHubRadiusWithNeighborsMBNP(this.metroGraphData,this.bundlingSettings,t,e);let n={touchedObstacles:[]};if(!this.metroGraphData.looseIntersections.HubAvoidsObstaclesSPNBA(t,e,i,n))return Bi.Inf;let o=0;for(let s of n.touchedObstacles){let a=s[1].sub(e).length;o+=Bi.RError(i,a,this.bundlingSettings)}return o}BundleGain(t,e){let i=t.cachedBundleCost;for(let n of t.Neighbors){let o=this.BundleCost(t,n,e);if(aa(o,Bi.Inf))return-Bi.Inf;i-=o}return i}BundleCost(t,e,i){let n=this.metroGraphData.GetWidthSSN(t,e,this.bundlingSettings.EdgeSeparation),o={closestDist:[]};if(!this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(t,e,i,e.Position,n,o))return Bi.Inf;let s=0;for(let a of o.closestDist){let u=a[0].sub(a[1]).length;s+=Bi.BundleError(n/2,u,this.bundlingSettings)}return s}},Lt=Bi;Lt.Inf=1e9;var qd=he(Qr(),1);var Xl=class{constructor(t){this.polylineToEdgeGeom=new Map;this.pathsThroughPoints=new qe;this.interestingPoints=new Se;this.metroGraphData=t}get Polylines(){return Array.from(this.polylineToEdgeGeom.keys())}Run(){this.Init(),this.SwitchFlips()}Init(){for(let t of this.metroGraphData.Edges)this.polylineToEdgeGeom.set(t.curve,t);for(let t of this.Polylines)this.RegisterPolylinePointInPathsThrough(t.polylinePoints())}RegisterPolylinePointInPathsThrough(t){for(let e of t)this.RegisterPolylinePointInPathsThroughP(e)}RegisterPolylinePointInPathsThroughP(t){Vp(this.pathsThroughPoints,t.point,t)}UnregisterPolylinePointsInPathsThrough(t){for(let e of t)this.UnregisterPolylinePointInPathsThrough(e)}UnregisterPolylinePointInPathsThrough(t){kp(this.pathsThroughPoints,t.point,t)}SwitchFlips(){let t=new Set(this.Polylines),e=new qd.Queue;for(let i of this.Polylines)e.enqueue(i);for(;e.length>0;){let i=e.dequeue();t.delete(i);let n=this.ProcessPolyline(i);n!=null&&(t.has(i)||(t.add(i),e.enqueue(i)),t.has(n)||(t.add(n),e.enqueue(n)))}}ProcessPolyline(t){let e=new Map;for(let i=t.startPoint.next;i!=null;i=i.next){this.FillDepartedPolylinePoints(i,e);for(let n of this.pathsThroughPoints.get(i.point)){let o=e.get(n.polyline);if(o){if(this.ProcessFlip(i,o))return n.polyline;e.delete(n.polyline)}}}return null}FillDepartedPolylinePoints(t,e){let i=t.prev.point;for(let n of this.pathsThroughPoints.get(i))this.IsNeighborOnTheSamePolyline(n,t)||e.has(n.polyline)||e.set(n.polyline,n)}ProcessFlip(t,e){let i=t.polyline,n=e.polyline,o=t.point,s=e.point,a=this.polylineToEdgeGeom.get(i),u=this.polylineToEdgeGeom.get(n);if(a.lineWidth!==u.lineWidth||this.metroGraphData.EdgeLooseEnterable==null||!$n(this.metroGraphData.EdgeLooseEnterable.get(a),this.metroGraphData.EdgeLooseEnterable.get(u)))return!1;let h=this.FindPointsOnPolyline(i,o,s),c=h[0],f=h[1],P=h[2];h=this.FindPointsOnPolyline(n,o,s);let v=h[0],A=h[1],O=h[2],M=this.FindRelationOnFirstPoint(c,v,P,O),z=this.FindRelationOnLastPoint(f,A,P,O);return M!==2&&z!==2||M===1||z===1?!1:(this.UnregisterPolylinePointsInPathsThrough(i.polylinePoints()),this.UnregisterPolylinePointsInPathsThrough(n.polylinePoints()),this.Swap(c,v,f,A,P,O),this.RegisterPolylinePointInPathsThrough(i.polylinePoints()),this.RegisterPolylinePointInPathsThrough(n.polylinePoints()),this.RegisterInterestingPoint(c.point),this.RegisterInterestingPoint(f.point),this.numberOfReducedCrossings++,!0)}FindPointsOnPolyline(t,e,i){let n,o;for(let s=t.startPoint;s!=null;s=s.next)if(n==null)if(s.point.equal(e)){if(o!=null)return[s,o,!1];n=s}else o==null&&s.point.equal(i)&&(o=s);else if(s.point.equal(i))return[n,s,!0]}PolylinePointsAreInForwardOrder(t,e){for(let i=t;i!=null;i=i.next)if(i===e)return!0;return!1}Next(t,e){return e?t.next:t.prev}Prev(t,e){return e?t.prev:t.next}FindRelationOnFirstPoint(t,e,i,n){let o=t,s=e;for(;;){let a=this.Prev(t,i),u=this.Prev(e,n);if(a==null||u==null)return 0;if(!a.point.equal(u.point))break;t=a,e=u}return this.PolylinesIntersect(o,s,t,e,i,n)}FindRelationOnLastPoint(t,e,i,n){let o=t,s=e;for(;;){let a=this.Next(t,i),u=this.Next(e,n);if(a==null||u==null)return 0;if(!a.point.equal(u.point))break;t=a,e=u}for(;this.Next(t,i).point.equal(this.Prev(e,n).point);)t=this.Next(t,i),e=this.Prev(e,n);return this.PolylinesIntersect(t,e,o,s,i,n)}PolylinesIntersect(t,e,i,n,o,s){let a=this.Prev(t,o),u=this.Next(t,o),h=this.Next(i,o),c=this.Prev(i,o),f=this.Next(e,s),P=this.Prev(n,s);if(t.point.equal(i.point)){let v=t.point,A=Oi(c.point.sub(v),P.point.sub(v),u.point.sub(v)),O=Oi(c.point.sub(v),f.point.sub(v),u.point.sub(v));return A===O?1:2}else{let v=Oi(a.point.sub(t.point),u.point.sub(t.point),f.point.sub(t.point)),A=Oi(h.point.sub(i.point),P.point.sub(i.point),c.point.sub(i.point));return v===A?1:2}}Swap(t,e,i,n,o,s){let a=this.GetRangeOnPolyline(this.Next(t,o),i,o),u=this.GetRangeOnPolyline(this.Next(e,s),n,s);this.ChangePolylineSegment(t,i,o,u),this.ChangePolylineSegment(e,n,s,a),Yi.RemoveSelfCyclesFromPolyline(t.polyline),Yi.RemoveSelfCyclesFromPolyline(e.polyline)}ChangePolylineSegment(t,e,i,n){let o=t;for(let s of n){let a=it.mkFromPoint(s.point);a.polyline=o.polyline,i?(a.prev=o,o.next=a):(a.next=o,o.prev=a),o=a}i?(o.next=e,e.prev=o):(o.prev=e,e.next=o)}GetRangeOnPolyline(t,e,i){let n=new Array;for(let o=t;o!==e;o=this.Next(o,i))n.push(o);return n}IsNeighborOnTheSamePolyline(t,e){return t.prev!=null&&t.prev.point.equal(e.point)||t.next!=null&&t.next.point.equal(e.point)}RegisterInterestingPoint(t){this.interestingPoints.has(t)||this.interestingPoints.add(t)}GetChangedHubs(){return this.interestingPoints}NumberOfReducedCrossings(){return this.numberOfReducedCrossings}PolylineIsOK(t){let e=new Se;for(let i=t.startPoint;i!=null;i=i.next){if(i===t.startPoint){if(i.prev!=null)return!1}else if(i.prev.next!==i)return!1;if(i===t.endPoint){if(i.next!=null)return!1}else if(i.next.prev!==i)return!1;if(e.has(i.point))return!1;e.add(i.point)}return!(t.startPoint.prev!=null||t.endPoint.next!=null)}};function Vp(l,t,e){let i=l.get(t);i||(i=new Set,l.set(t,i)),i.add(e)}function kp(l,t,e){let i=l.get(t);!i||(i.delete(e),i.size===0&&l.deleteP(t))}var Yi=class{constructor(t,e){this.foundCrossings=new Se;this.crossingsThatShouldBecomeHubs=new Se;this.metroGraphData=t,this.polylineAcceptsPoint=e}*Vertices(){for(let t of this.Polylines)for(let e of t.polylinePoints())yield e}get Polylines(){return this.metroGraphData.Edges.map(t=>t.curve)}Edges(){let t=new Nr;for(let e of this.Vertices())e.next&&t.set(new ke(e.point,e.next.point),0);return Array.from(t.keys())}run(){if(this.metroGraphData.Edges.length===0)return!1;let t=new Nr,e=new mi(null);for(let a of this.Vertices()){let u=D.mkOnPoints([a.point]);u.pad(C.intersectionEpsilon),e.Add(u,a.point)}let i=Di(this.Edges(),a=>D.mkPP(a.first,a.second));tt(i,i,(a,u)=>this.IntersectTwoEdges.bind(a,u,t,e)),this.SortInsertedPoints(t);let n=this.InsertPointsIntoPolylines(t),o=this.FixPaths(),s=this.RemoveUnimportantCrossings();return o||n||s}FixPaths(){let t=!1;return this.RemoveSelfCycles()&&(t=!0),this.ReduceEdgeCrossings()&&(t=!0),t}SortInsertedPoints(t){for(let e of t)this.SortInsideSegment(e[0],e[1])}SortInsideSegment(t,e){e.sort((i,n)=>ce(pe(i,t.first),pe(n,t.first)))}InsertPointsIntoPolylines(t){let e=!1;for(let i of this.metroGraphData.Metrolines)return this.InsertPointsIntoPolyline(i,t)&&(e=!0),e}InsertPointsIntoPolyline(t,e){let i=!1;for(let n=t.Polyline.startPoint;n.next!=null;n=n.next)this.InsertPointsOnPolypoint(n,e,t)&&(i=!0);return i}InsertPointsOnPolypoint(t,e,i){let n=new ke(t.point,t.next.point),o=t.point!==n.first,s=e.get(n);if(!s)return!1;let a=t.next,u=t.polyline;if(o)for(let h=s.length-1;h>=0;h--){if(this.polylineAcceptsPoint!=null&&!this.polylineAcceptsPoint(i,s[h]))continue;let c=it.mkFromPoint(s[h]);c.prev=t,c.polyline=u,t.next=c,t=c}else for(let h=0;h<s.length;h++){if(this.polylineAcceptsPoint!=null&&!this.polylineAcceptsPoint(i,s[h]))continue;let c=it.mkFromPoint(s[h]);c.prev=t,c.polyline=u,t.next=c,t=c}return t.next=a,a.prev=t,!0}RemoveSelfCycles(){let t=!1;for(let e of this.Polylines)Yi.RemoveSelfCyclesFromPolyline(e)&&(t=!0);return t}static RemoveSelfCyclesFromPolyline(t){let e=!1,i=new qe;for(let n=t.startPoint;n!=null;n=n.next){let o=n.point,s=i.get(o);if(s){for(let a=s.next;a!==n.next;a=a.next)i.deleteP(a.point);s.next=n.next,n.next.prev=s,e=!0}else i.set(n.point,n)}return e}ReduceEdgeCrossings(){let t=new Xl(this.metroGraphData);t.Run();for(let e of t.GetChangedHubs())this.crossingsThatShouldBecomeHubs.add(e);return t.NumberOfReducedCrossings()>0}RemoveUnimportantCrossings(){let t=!1;this.pointsToDelete=Rc(this.foundCrossings,this.crossingsThatShouldBecomeHubs);for(let e of this.Polylines)this.RemoveUnimportantCrossingsFromPolyline(e)&&(t=!0);return t}RemoveUnimportantCrossingsFromPolyline(t){let e=!1;for(let i=t.startPoint.next;i!=null&&i.next!=null;i=i.next)if(this.pointsToDelete.has(i.point)&&d.getTriangleOrientation(i.prev.point,i.point,i.next.point)===2){let n=i.prev,o=i.next;n.next=o,o.prev=n,i=n,e=!0}return e}IntersectTwoEdges(t,e,i,n){let o=w.IntersectPPPP(t.first,t.second,e.first,e.second);if(o){let s=this.FindExistingVertexOrCreateNew(n,o);(this.AddVertexToSplittingList(t,i,s)||this.AddVertexToSplittingList(e,i,s))&&this.foundCrossings.add(s)}}FindExistingVertexOrCreateNew(t,e){let i=t.RootNode.FirstHitNode(e);if(i!=null)return i.UserData;let n=D.mkOnPoints([e]);return n.pad(C.intersectionEpsilon),t.Add(n,e),e}AddVertexToSplittingList(t,e,i){if(!E.closeIntersectionPoints(i,t.first)&&!E.closeIntersectionPoints(i,t.second)){let n=e.get(t);if(n||(n=new Array,e.set(t,n)),!n.find(o=>o.equal(i)))return n.push(i),!0}return!1}};var la=class{isCorrectlyOrienected(){return d.getTriangleOrientation(this.Curve.boundingBox.center,this.Curve.value(this.parEnd),this.Curve.value(this.parStart))!==1}get Count(){return this.points.length}constructor(t,e,i,n){this.BelongsToRealNode=n,this.Curve=e,this.Position=i,this.points=new Array(t),this.tangents=new Array(t),this.OrientedHubSegments=new Array(t)}get CurveCenter(){return this.Curve.boundingBox.center}get OppositeBase(){return this.OutgoingBundleInfo!=null?this.OutgoingBundleInfo.TargetBase:this.IncomingBundleInfo.SourceBase}get length(){return this.points.length}get Points(){return this.points}get Tangents(){return this.tangents}get InitialMidParameter(){return this.initialMidParameter}set InitialMidParameter(t){this.initialMidParameter=t,this.InitialMidPoint=this.Curve.value(t)}get ParStart(){return this.parStart}set ParStart(t){this.parStart=t,this.StartPoint=this.Curve.value(this.parStart)}get ParEnd(){return this.parEnd}set ParEnd(t){this.parEnd=t,this.EndPoint=this.Curve.value(this.parEnd)}get ParMid(){return(this.parStart+this.parEnd)/2}get MidPoint(){return d.middle(this.StartPoint,this.EndPoint)}get Span(){return this.SpanBetweenTwoParameters(this.parStart,this.parEnd)}SpanBetweenTwoParameters(t,e){return t<=e?e-t:e-t+Br(this.Curve)}RotateLeftPoint(t,e){return t===0?this.EndPoint:this.RotatePoint(t,this.parEnd,e)}RotateRigthPoint(t,e){return t===0?this.StartPoint:this.RotatePoint(t,this.parStart,e)}RotatePoint(t,e,i){let n=Br(this.Curve)*i;return e+=t*n,e=this.AdjustParam(e),this.Curve.value(e)}AdjustParam(t){return t>this.Curve.parEnd?t=this.Curve.parStart+(t-this.Curve.parEnd):t<this.Curve.parStart&&(t=this.Curve.parEnd-(this.Curve.parStart-t)),t}RotateBy(t,e,i){let n=Br(this.Curve)*i;t!==0&&(this.ParStart=this.AdjustParam(this.ParStart+t*n)),e!==0&&(this.ParEnd=this.AdjustParam(this.ParEnd+e*n))}RelativeOrderOfBasesIsPreserved(t,e,i){let n=Br(this.Curve)*i,o=this.parStart+t*n,s=this.parStart<this.parEnd?this.parEnd+e*n:this.parEnd+Br(this.Curve)+e*n;if(o>s||this.SpanBetweenTwoParameters(o,s)>Br(this.Curve)/2)return!1;if(this.Prev==null||this.SpanBetweenTwoParameters(this.Prev.ParMid,this.ParMid)>n&&this.SpanBetweenTwoParameters(this.ParMid,this.Next.ParMid)>n)return!0;let a=this.RotateLeftPoint(e,i),u=this.RotateRigthPoint(t,i),h=d.middle(a,u),c=this.MidPoint;return!(d.getTriangleOrientation(this.CurveCenter,this.Prev.MidPoint,c)!=d.getTriangleOrientation(this.CurveCenter,this.Prev.MidPoint,h)||d.getTriangleOrientation(this.CurveCenter,this.Next.MidPoint,c)!=d.getTriangleOrientation(this.CurveCenter,this.Next.MidPoint,h))}};var Co=class{constructor(t,e,i,n){this.SourceBase=t,this.TargetBase=e,this.obstaclesToIgnore=i,this.HalfWidthArray=n,this.TotalRequiredWidth=this.HalfWidthArray.reduce((s,a)=>s+a,0)*2,this.longEnoughSideLength=t.Curve.boundingBox.addRec(e.Curve.boundingBox).diagonal;let o=Math.max(t.Curve.boundingBox.diagonal,e.Curve.boundingBox.diagonal);if(this.TotalRequiredWidth>o){let s=this.TotalRequiredWidth/o;for(let a=0;a<this.HalfWidthArray.length;a++)this.HalfWidthArray[a]/=s;this.TotalRequiredWidth/=s}}SetParamsFeasiblySymmetrically(t){this.CalculateTightObstaclesForBundle(t,this.obstaclesToIgnore),this.SetEndParamsSymmetrically()}CalculateTightObstaclesForBundle(t,e){let i=this.SourceBase.Curve.boundingBox.diagonal/2,n=this.TargetBase.Curve.boundingBox.diagonal/2,o=$t.Create4gon(this.SourceBase.Position,this.TargetBase.Position,i*2,n*2);this.tightObstaclesInTheBoundingBox=Array.from(t.AllHitItems(o.boundingBox,s=>!e.has(s)&&E.ClosedCurveInteriorsIntersect(o,s)))}SetEndParamsSymmetrically(){let t=this.TargetBase.Position,e=this.SourceBase.Position,i=t.sub(e).normalize(),n=i.rotate90Ccw(),o=d.middle(t,e),s=i.mul(this.longEnoughSideLength),a=o.add(s),u=o.sub(s);if(this.SetRLParamsIfWidthIsFeasible(n.mul(this.TotalRequiredWidth/2),a,u)){this.SetInitialMidParams();return}let h=this.TotalRequiredWidth,c=0,f=h/2;for(;h-c>Co.FeasibleWidthEpsilon;)this.SetRLParamsIfWidthIsFeasible(n.mul(f/2),a,u)?c=f:h=f,f=.5*(h+c);f<=Co.FeasibleWidthEpsilon&&(this.SetRLParamsIfWidthIsFeasible_(n.mul(Co.FeasibleWidthEpsilon),new d(0,0),a,u)||this.SetRLParamsIfWidthIsFeasible_(new d(0,0),n.mul(-Co.FeasibleWidthEpsilon),a,u))&&(f=2*Co.FeasibleWidthEpsilon),this.SourceBase.InitialMidParameter=this.SourceBase.AdjustParam(this.SourceBase.ParStart+this.SourceBase.Span/2),this.TargetBase.InitialMidParameter=this.TargetBase.AdjustParam(this.TargetBase.ParStart+this.TargetBase.Span/2)}mkNameFromLRST(){return"./tmp/leftRight"+this.SourceBase.Position.toString()+"_"+this.TargetBase.Position.toString()+".svg"}SetRLParamsIfWidthIsFeasible(t,e,i){return this.SetRLParamsIfWidthIsFeasible_(t,t.neg(),e,i)}SetRLParamsIfWidthIsFeasible_(t,e,i,n){let o={par:0},s={par:0},a={par:0},u={par:0},h=this.TrimSegWithBoundaryCurves(w.mkPP(i.add(t),n.add(t)),s,a);return h==null||this.tightObstaclesInTheBoundingBox.find(f=>E.intersectionOne(h,f,!1)!=null)||(h=this.TrimSegWithBoundaryCurves(w.mkPP(i.add(e),n.add(e)),u,o),h==null)||this.tightObstaclesInTheBoundingBox.find(f=>E.intersectionOne(h,f,!1)!=null)?!1:(this.SourceBase.IsParent?(this.SourceBase.ParStart=s.par,this.SourceBase.ParEnd=u.par):(this.SourceBase.ParStart=u.par,this.SourceBase.ParEnd=s.par),this.TargetBase.IsParent?(this.TargetBase.ParStart=o.par,this.TargetBase.ParEnd=a.par):(this.TargetBase.ParStart=a.par,this.TargetBase.ParEnd=o.par),!0)}SetInitialMidParams(){let t={par:0},e={par:0};this.TrimSegWithBoundaryCurves(w.mkPP(this.TargetBase.CurveCenter,this.TargetBase.CurveCenter),e,t)!=null?(this.SourceBase.InitialMidParameter=e.par,this.TargetBase.InitialMidParameter=t.par):(this.SourceBase.InitialMidParameter=this.SourceBase.AdjustParam(this.SourceBase.ParStart+this.SourceBase.Span/2),this.TargetBase.InitialMidParameter=this.TargetBase.AdjustParam(this.TargetBase.ParStart+this.TargetBase.Span/2))}mkNameFromST(){return"./tmp/mparam"+this.SourceBase.Position.toString()+"_"+this.TargetBase.Position.toString()+".svg"}TrimSegWithBoundaryCurves(t,e,i){let n=E.getAllIntersections(t,this.SourceBase.Curve,!0);if(n.length===0)return i.par=0,e.par=0,null;let o;if(n.length===1?o=n[0]:this.SourceBase.IsParent?o=n[0].par0<n[1].par0?n[1]:n[0]:o=n[0].par0<n[1].par0?n[0]:n[1],n=E.getAllIntersections(t,this.TargetBase.Curve,!0),n.length===0)return i.par=0,e.par=0,null;let s;return n.length===1?s=n[0]:this.TargetBase.IsParent?s=n[0].par0>n[1].par0?n[1]:n[0]:s=n[0].par0>n[1].par0?n[0]:n[1],e.par=o.par1,i.par=s.par1,w.mkPP(o.x,s.x)}RotateBy(t,e,i,n,o){let s=t!==0||e!==0,a=i!==0||n!==0;s&&this.SourceBase.RotateBy(t,e,o),a&&this.TargetBase.RotateBy(i,n,o),this.UpdateSourceAndTargetBases(s,a)}UpdateSourceAndTargetBases(t,e){t&&this.UpdatePointsOnBundleBase(this.SourceBase),e&&this.UpdatePointsOnBundleBase(this.TargetBase),this.UpdateTangentsOnBases()}UpdateTangentsOnBases(){let t=this.TargetBase.length;for(let e=0;e<t;e++){let i=this.TargetBase.Points[e].sub(this.SourceBase.Points[t-1-e]),n=i.length;n>=C.tolerance&&(i=i.div(n),this.TargetBase.Tangents[e]=i,this.SourceBase.Tangents[t-1-e]=i.neg())}}UpdatePointsOnBundleBase(t){let e=t.length,i=t.Points,n=w.mkPP(t.EndPoint,t.StartPoint),o=1/this.TotalRequiredWidth,s=this.HalfWidthArray[0];i[0]=n.value(s*o);for(let a=1;a<e;a++)s+=this.HalfWidthArray[a-1]+this.HalfWidthArray[a],i[a]=n.value(s*o)}RotationIsLegal(t,e,i,n,o){if(!this.SourceBase.IsParent&&!this.TargetBase.IsParent){if(e!==0||i!==0){let s=this.SourceBase.RotateLeftPoint(e,o),a=this.TargetBase.RotateRigthPoint(i,o);if(!this.LineIsLegal(s,a))return!1}if(t!==0||n!==0){let s=this.SourceBase.RotateRigthPoint(t,o),a=this.TargetBase.RotateLeftPoint(n,o);if(!this.LineIsLegal(s,a))return!1}}else{if(e!==0||n!==0){let s=this.SourceBase.RotateLeftPoint(e,o),a=this.TargetBase.RotateLeftPoint(n,o);if(!this.LineIsLegal(s,a))return!1}if(t!==0||i!==0){let s=this.SourceBase.RotateRigthPoint(t,o),a=this.TargetBase.RotateRigthPoint(i,o);if(!this.LineIsLegal(s,a))return!1}}return!((t!==0||e!==0)&&!this.SourceBase.RelativeOrderOfBasesIsPreserved(t,e,o)||(i!==0||n!==0)&&!this.TargetBase.RelativeOrderOfBasesIsPreserved(i,n,o))}LineIsLegal(t,e){return this.tightObstaclesInTheBoundingBox.find(i=>E.intersectionOne(w.mkPP(t,e),i,!1)!=null)==null}},ua=Co;ua.FeasibleWidthEpsilon=.1;var ha=class{get Segment(){return this.segment}set Segment(t){this.segment=t}constructor(t,e,i,n){this.Segment=t,this.Reversed=e,this.Index=i,this.BundleBase=n}value(t){return this.Reversed?this.Segment.value(this.Segment.parEnd-t):this.Segment.value(t)}};var we=class{constructor(t,e,i){this.fixedBundles=new $i;this.stepsWithProgress=0;this.metroOrdering=t,this.metroGraphData=e,this.bundlingSettings=i}Run(){this.AllocateBundleBases(),this.SetBasesRightLeftParamsToTheMiddles(),this.bundlingSettings.KeepOverlaps?(this.UpdateSourceAndTargetBases(),this.CreateOrientedSegs()):(this.SetRightLeftParamsFeasiblySymmetrically(),this.AdjustStartEndParamsToAvoidBaseOverlaps(),this.UpdateSourceAndTargetBases(),this.CreateOrientedSegs(),this.bundlingSettings.RotateBundles&&this.RotateBundlesToDiminishCost(),this.AdjustStartEndParamsToAvoidBaseOverlaps(),this.UpdateSourceAndTargetBases())}AllocateBundleBases(){this.externalBases=new Map,this.internalBases=new Map,this.Bundles=new Array;for(let t of this.metroGraphData.Stations)t.BoundaryCurve==null&&(t.BoundaryCurve=ee.mkCircle(t.Radius,t.Position));for(let t of this.metroGraphData.Stations)for(let e of t.Neighbors)if(t.SerialNumber<e.SerialNumber){let i=new la(this.metroGraphData.RealEdgeCount(t,e),t.BoundaryCurve,t.Position,t.IsReal);t.BundleBases.set(e,i);let n=new la(this.metroGraphData.RealEdgeCount(t,e),e.BoundaryCurve,e.Position,e.IsReal);e.BundleBases.set(t,n),E.PointRelativeToCurveLocation(e.Position,t.BoundaryCurve)!==0?(i.IsParent=!0,Yn(this.internalBases,t,i),Yn(this.externalBases,e,n)):E.PointRelativeToCurveLocation(t.Position,e.BoundaryCurve)!==0?(n.IsParent=!0,Yn(this.externalBases,t,i),Yn(this.internalBases,e,n)):(Yn(this.externalBases,t,i),Yn(this.externalBases,e,n));let o=this.metroGraphData.tightIntersections.ObstaclesToIgnoreForBundle(t,e),s=new ua(i,n,o,Array.from(this.metroOrdering.GetOrder(t,e)).map(a=>a.Width/2));i.OutgoingBundleInfo=n.IncomingBundleInfo=s,this.Bundles.push(s)}this.SetBundleBaseNeighbors()}SetBundleBaseNeighbors(){for(let t of this.externalBases.keys()){let e=this.externalBases.get(t);this.SortBundlesCounterClockwise(e),this.SetLeftRightBases(e)}for(let t of this.internalBases.keys()){let e=this.internalBases.get(t);this.SortBundlesCounterClockwise(e),this.SetLeftRightBases(e)}}SortBundlesCounterClockwise(t){if(t.length>2){let e=t[0].OppositeBase.Position,i=t[0].CurveCenter;t.sort((n,o)=>Oi(e.sub(i),n.OppositeBase.Position.sub(i),o.OppositeBase.Position.sub(i)))}}SetLeftRightBases(t){let e=t.length;if(!(e<=1))for(let i=0;i<e;i++)t[i].Prev=t[(i-1+e)%e],t[i].Next=t[(i+1)%e]}CreateOrientedSegs(){for(let t of this.metroGraphData.Metrolines)this.CreateOrientedSegsOnLine(t)}CreateOrientedSegsOnLine(t){for(let e=t.Polyline.startPoint.next;e.next!=null;e=e.next)this.CreateOrientedSegsOnLineVertex(t,e)}CreateOrientedSegsOnLineVertex(t,e){let i=this.metroGraphData.PointToStations.get(e.prev.point),n=this.metroGraphData.PointToStations.get(e.point),o=this.metroGraphData.PointToStations.get(e.next.point),s=n.BundleBases.get(i),a=n.BundleBases.get(o),u=this.metroOrdering.GetLineIndexInOrder(i,n,t),h=this.metroOrdering.GetLineIndexInOrder(o,n,t),c=s.OrientedHubSegments[u]=new ha(null,!1,u,s),f=a.OrientedHubSegments[h]=new ha(null,!0,h,a);f.Other=c,c.Other=f}UpdateSourceAndTargetBases(){for(let t of this.Bundles)t.UpdateSourceAndTargetBases(!0,!0)}SetBasesRightLeftParamsToTheMiddles(){for(let t of this.Bundles){let e=t.SourceBase,i=t.TargetBase;e.ParEnd=e.ParStart=this.GetBaseMiddleParamInDirection(e,e.Position,i.Position),i.ParEnd=i.ParStart=this.GetBaseMiddleParamInDirection(i,i.Position,e.Position)}}GetBaseMiddleParamInDirection(t,e,i){let n=t.Curve;if(n instanceof ee){let a=n;if(a.isArc())return d.angle(a.aAxis,i.sub(e))}let s=E.getAllIntersections(n,w.mkPP(e,i),!0);for(let a of s){let u=a.x;if(u.sub(e).dot(u.sub(i))<=0)return a.par0}throw new Error}SetRightLeftParamsFeasiblySymmetrically(){for(let t of this.Bundles)t.SetParamsFeasiblySymmetrically(this.metroGraphData.TightTree)}AdjustStartEndParamsToAvoidBaseOverlaps(){for(let t of this.externalBases.values())this.AdjustCurrentBundleWidthsOnCurve(t);for(let t of this.internalBases.values())this.AdjustCurrentBundleWidthsOnCurve(t)}AdjustCurrentBundleWidthsOnCurve(t){let e=t.length;if(!(e<=1))for(let i=0;i<e;i++){let n=t[i],o=n.Next;this.ShrinkBasesToMakeTwoConsecutiveNeighborsHappy(n,o)}}ShrinkBasesToMakeTwoConsecutiveNeighborsHappy(t,e){let i=Mp(t,e);if(i==null||Q(i.start,i.end))return;let n=i.rbaseMiddle,o=i.lbaseMiddle;if(n<o){let h=t;t=e,e=h}let s=t.Span,a=e.Span,u=(i.end*s+i.start*a)/(a+s);t.ParStart=t.AdjustParam(u+C.distanceEpsilon),e.ParEnd=e.AdjustParam(u-C.distanceEpsilon)}RegularCut(t,e,i,n,o,s){let a=(o*n+s*t)/(o+s),u=Math.min(e,n),h=Math.max(t,i);return a<h&&(a=h),a>u&&(a=u),a}RotateBundlesToDiminishCost(){let t=we.MaxParameterChange,e={cost:this.Cost()},i=0;for(;i++<we.MaxIterations;){let n=e.cost;if(this.RotateBundlesToDiminishCostOneIteration(t,e),t=this.UpdateParameterChange(t,n,e.cost),t<we.MinParameterChange)break}}UpdateParameterChange(t,e,i){return i+1<e?(this.stepsWithProgress++,this.stepsWithProgress>=5&&(this.stepsWithProgress=0,this.fixedBundles.clear())):(this.stepsWithProgress=0,t*=.8,this.fixedBundles.clear()),t}RotateBundlesToDiminishCostOneIteration(t,e){let i=!1;for(let n of this.Bundles)this.fixedBundles.has(n)||(this.OptimizeBundle(n,t,e)?i=!0:this.fixedBundles.add(n));return i}OptimizeBundle(t,e,i){let n=this.CostBi(t);if(n<we.CostThreshold)return!1;let o=0,s=-1,a=-1;for(let u=0;u<we.Deltas.length-1;u++){let h=this.DeltaWithChangedAngles(we.Deltas[u][0],we.Deltas[u][1],0,0,t,n,e);h>we.CostDeltaThreshold&&h>o&&(a=u,s=we.Deltas.length-1,o=h),h=this.DeltaWithChangedAngles(0,0,we.Deltas[u][0],we.Deltas[u][1],t,n,e),h>we.CostDeltaThreshold&&h>o&&(a=we.Deltas.length-1,s=u,o=h)}return o<we.CostDeltaThreshold?!1:(i.cost-=o,t.RotateBy(we.Deltas[a][0],we.Deltas[a][1],we.Deltas[s][0],we.Deltas[s][1],e),!0)}DeltaWithChangedAngles(t,e,i,n,o,s,a){if(!o.RotationIsLegal(t,e,i,n,a))return 0;o.RotateBy(t,e,i,n,a);let u=this.CostBN(o,s);return o.RotateBy(t*-1,e*-1,i*-1,n*-1,a),s-u}CostBi(t){return we.SeparationCoeff*this.SeparationCost(t)+(we.SqueezeCoeff*this.SqueezeCost(t)+(we.AssymetryCoeff*this.AssymetryCost(t)+we.CenterCoeff*this.CenterCostBi(t)))}CostBN(t,e){let i=0;return i=i+we.CenterCoeff*this.CenterCostBi(t),i>e||(i=i+we.SeparationCoeff*this.SeparationCost(t),i>e)||(i=i+we.SqueezeCoeff*this.SqueezeCost(t),i>e)||(i=i+we.AssymetryCoeff*this.AssymetryCost(t)),i}SqueezeCost(t){let i=t.TargetBase.MidPoint.sub(t.SourceBase.MidPoint).normalize().rotate90Ccw(),n=Math.abs(t.SourceBase.StartPoint.sub(t.SourceBase.EndPoint).dot(i)),o=Math.abs(t.TargetBase.StartPoint.sub(t.TargetBase.EndPoint).dot(i)),s=Math.abs(t.TotalRequiredWidth-n)/t.TotalRequiredWidth,a=Math.abs(t.TotalRequiredWidth-o)/t.TotalRequiredWidth,u=Math.abs(n-o)/t.TotalRequiredWidth;return Math.exp(s*10)-1+(Math.exp(a*10)-1)+u}CenterCostBi(t){return!t.SourceBase.BelongsToRealNode&&!t.TargetBase.BelongsToRealNode?0:this.CenterCostBb(t.SourceBase)+this.CenterCostBb(t.TargetBase)}CenterCostBb(t){if(!t.BelongsToRealNode)return 0;let e=t.ParMid,i=Math.min(t.InitialMidParameter,e),n=Math.max(t.InitialMidParameter,e),o=Math.min(n-i,i+(Br(t.Curve)-n));return t.CurveCenter.equal(t.Position)||t.IsParent?25*(o*o):500*(o*o)}AssymetryCost(t){return this.GetAssymetryCostForBase(t.SourceBase)+this.GetAssymetryCostForBase(t.TargetBase)}GetAssymetryCostForBase(t){if(t.BelongsToRealNode)return 0;let e=t.OppositeBase.BelongsToRealNode?200:500,i=0;for(let n of t.OrientedHubSegments){let o=n.Index,s=n.Other.Index,a=t.Points[o],u=t.Tangents[o],h=n.Other.BundleBase,c=h.Points[s],f=h.Tangents[s],P=t.Count+h.Count;i+=this.GetAssymetryCostOnData(a,u,c,f,e)/P}return i}GetAssymetryCostOnData(t,e,i,n,o){let s=t.sub(i),a=s.length;if(a<C.distanceEpsilon)return 0;let u=e.add(n).dot(s),h=d.crossProduct(s,e),c=d.crossProduct(s,n),f=h-c,P=u*u+f*f,v=h*h+c*c;return 10*P+o*v}SeparationCost(t){return this.SeparationCostForBundleBase(t.SourceBase)+this.SeparationCostForBundleBase(t.TargetBase)}SeparationCostForBundleBase(t){return t.Prev==null?0:this.SeparationCostForAdjacentBundleBases(t,t.Prev)+this.SeparationCostForAdjacentBundleBases(t,t.Next)}SeparationCostForAdjacentBundleBases(t,e){let i=t.Curve,n=this.IntervalsOverlapLength(t.ParStart,t.ParEnd,e.ParStart,e.ParEnd,i),o=Math.min(t.Span,e.Span);return Math.exp(n/(o*10))-1}IntervalsOverlapLength(t,e,i,n,o){let s=o.parStart,a=o.parEnd;return t<e?i<n?this.IntersectRegularIntervals(t,e,i,n):this.IntersectRegularIntervals(t,e,i,a)+this.IntersectRegularIntervals(t,e,s,n):i<n?this.IntersectRegularIntervals(t,a,i,n)+this.IntersectRegularIntervals(s,e,i,n):this.IntersectRegularIntervals(t,a,i,a)+this.IntersectRegularIntervals(s,e,s,n)}IntersectRegularIntervals(t,e,i,n){let o=Math.max(t,i),s=Math.min(e,n);return o<s?s-o:0}Cost(){let t=0;for(let e of this.Bundles){let i=we.SeparationCoeff*this.SeparationCost(e),n=we.AssymetryCoeff*this.AssymetryCost(e),o=we.SqueezeCoeff*this.SqueezeCost(e),s=we.CenterCoeff*this.CenterCostBi(e);t+=(i+n)/2+o+s}return t}},mr=we;mr.Deltas=[[1,-1],[1,-1]],mr.SeparationCoeff=1,mr.SqueezeCoeff=1,mr.CenterCoeff=10,mr.AssymetryCoeff=1,mr.MaxIterations=200,mr.MaxParameterChange=8/360,mr.MinParameterChange=.1/360,mr.CostThreshold=1e-5,mr.CostDeltaThreshold=.01;function Mp(l,t){let e=Br(l.Curve),i=l.ParEnd,n=l.ParStart<l.ParEnd?l.ParStart:l.ParStart-e,o=t.ParEnd,s=t.ParStart<t.ParEnd?t.ParStart:t.ParStart-e;i>o?i-s>e&&(s+=e,o+=e):o-n>e&&(n+=e,i+=e);let a=Math.min(i,o),u=Math.max(n,s);return u<=a?{start:u,end:a,rbaseMiddle:(n+i)/2,lbaseMiddle:(s+o)/2}:null}var Jl=class{constructor(){this.Metrolines=new Array}Add(t){this.Metrolines.push(t)}};var Eo=class{constructor(t){this.Metrolines=t,this.BuildOrder()}*GetOrder(t,e){let i=new ke(t.Position,e.Position),n=this.bundles.get(i).Metrolines;if(t.Position===i.first)for(let o=0;o<n.length;o++)yield n[o];else for(let o=n.length-1;o>=0;o--)yield n[o]}GetLineIndexInOrder(t,e,i){let n=new ke(t.Position,e.Position),o=t.Position!==n.first,s=this.bundles.get(n).LineIndexInOrder;return o?s.size-1-s.get(i):s.get(i)}BuildOrder(){this.bundles=new Nr;for(let t of this.Metrolines)for(let e=t.Polyline.startPoint;e.next!=null;e=e.next){let i=new ke(e.point,e.next.point),n=this.bundles.get(i);n||this.bundles.set(i,n=new Jl),n.Add(t)}for(let t of this.bundles)this.BuildOrderPP(t[0],t[1])}BuildOrderPP(t,e){if(!e.orderFixed){e.Metrolines.sort((i,n)=>this.CompareLines(i,n,t.first,t.second)),e.orderFixed=!0,e.LineIndexInOrder=new Map;for(let i=0;i<e.Metrolines.length;i++)e.LineIndexInOrder.set(e.Metrolines[i],i)}}CompareLines(t,e,i,n){let o={polyPoint:null,next:null,prev:null};this.FindStationOnLine(i,n,t,o);let s=o.polyPoint,a=o.next,u=o.prev;this.FindStationOnLine(i,n,e,o);let h=o.polyPoint,c=o.next,f=o.prev,P=s,v=h,A,O;for(;(O=u(P))!=null&&(A=f(v))!=null&&O.point.equal(A.point);){let M=new ke(O.point,P.point);if(this.bundles.get(M).orderFixed)return this.CompareOnFixedOrder(M,t,e,!O.point.equal(M.first));P=O,v=A}if(O!=null&&A!=null){let M=P.point;return-Eo.IsLeft(a(P).point.sub(M),O.point.sub(M),A.point.sub(M))}for(P=s,v=h;(O=a(P))!=null&&(A=c(v))!=null&&O.point.equal(A.point);){let M=new ke(O.point,P.point);if(this.bundles.get(M).orderFixed)return this.CompareOnFixedOrder(M,t,e,!P.point.equal(M.first));P=O,v=A}if(O!=null&&A!=null){let M=P.point;return Eo.IsLeft(u(P).point.sub(M),O.point.sub(M),A.point.sub(M))}return ce(t.Index,e.Index)}CompareOnFixedOrder(t,e,i,n){let o=this.bundles.get(t).LineIndexInOrder;return(n?-1:1)*ce(o.get(e),o.get(i))}FindStationOnLine(t,e,i,n){for(let o=i.Polyline.startPoint;o.next!=null;o=o.next){if(o.point.equal(t)&&o.next.point.equal(e)){n.next=s=>s.next,n.prev=s=>s.prev,n.polyPoint=o;return}if(o.point.equal(e)&&o.next.point.equal(t)){n.next=s=>s.prev,n.prev=s=>s.next,n.polyPoint=o.next;return}}throw new Error}static IsLeft(t,e,i){return Oi(t,e,i)}};var Le=class extends _{constructor(e,i){super(null);this.metroGraphData=e,this.bundlingSettings=i}run(){this.CreateMetroOrdering(),this.InitRadii(),this.FinalizePaths()}InitRadii(){new et(this.metroGraphData,this.bundlingSettings).CreateNodeRadii()}CreateMetroOrdering(){this.metroOrdering=new Eo(this.metroGraphData.Metrolines)}FinalizePaths(){this.CreateBundleBases(),this.CreateSegmentsInsideHubs(),this.CreateCurves()}CreateBundleBases(){new mr(this.metroOrdering,this.metroGraphData,this.bundlingSettings).Run()}CreateCurves(){for(let e=0;e<this.metroGraphData.Metrolines.length;e++)this.CreateCurveLine(this.metroGraphData.Metrolines[e],this.metroGraphData.Edges[e])}CreateCurveLine(e,i){let n=new E,s=Le.FindCurveStart(this.metroGraphData,this.metroOrdering,e),a=Le.HubSegsOfLine(this.metroGraphData,this.metroOrdering,e);for(let u of a)u!=null&&(n.addSegment(w.mkPP(s,u.start)),n.addSegment(u),s=u.end);n.addSegment(w.mkPP(s,Le.FindCurveEnd(this.metroGraphData,this.metroOrdering,e))),i.curve=n}static FindCurveStart(e,i,n){let o=e.PointToStations.get(n.Polyline.startPoint.point),s=e.PointToStations.get(n.Polyline.startPoint.next.point),a=o.BundleBases.get(s),u=a.IsParent?i.GetLineIndexInOrder(o,s,n):i.GetLineIndexInOrder(s,o,n);return a.Points[u]}static FindCurveEnd(e,i,n){let o=e.PointToStations.get(n.Polyline.endPoint.prev.point),s=e.PointToStations.get(n.Polyline.endPoint.point),a=s.BundleBases.get(o),u=a.IsParent?i.GetLineIndexInOrder(s,o,n):i.GetLineIndexInOrder(o,s,n);return a.Points[u]}static*HubSegsOfLine(e,i,n){for(let o=n.Polyline.startPoint.next;o.next!=null;o=o.next)yield Le.SegOnLineVertex(e,i,n,o)}static SegOnLineVertex(e,i,n,o){let s=e.PointToStations.get(o.prev.point),a=e.PointToStations.get(o.point),u=a.BundleBases.get(s),h=i.GetLineIndexInOrder(s,a,n);if(u.OrientedHubSegments[h]==null||u.OrientedHubSegments[h].Segment==null){let c=e.PointToStations.get(o.next.point),f=a.BundleBases.get(c),P=i.GetLineIndexInOrder(c,a,n);return w.mkPP(u.Points[h],f.Points[P])}return u.OrientedHubSegments[h].Segment}CreateSegmentsInsideHubs(){for(let e of this.metroGraphData.Metrolines)this.CreateOrientedSegsOnLine(e);this.bundlingSettings.UseCubicBezierSegmentsInsideOfHubs&&this.FanBezierSegs()}CreateOrientedSegsOnLine(e){for(let i=e.Polyline.startPoint.next;i.next!=null;i=i.next)this.CreateICurveForOrientedSeg(e,i)}CreateICurveForOrientedSeg(e,i){let n=this.metroGraphData.PointToStations.get(i.prev.point),o=this.metroGraphData.PointToStations.get(i.point),s=this.metroGraphData.PointToStations.get(i.next.point),a=o.BundleBases.get(n),u=o.BundleBases.get(s),h=this.metroOrdering.GetLineIndexInOrder(n,o,e),c=this.metroOrdering.GetLineIndexInOrder(s,o,e),f=this.bundlingSettings.UseCubicBezierSegmentsInsideOfHubs?Le.StandardBezier(a.Points[h],a.Tangents[h],u.Points[c],u.Tangents[c]):Le.BiArc(a.Points[h],a.Tangents[h],u.Points[c],u.Tangents[c]);a.OrientedHubSegments[h].Segment=f,u.OrientedHubSegments[c].Segment=f}static ShowHubs(e,i,n,o,s=[]){let a=Le.GetAllDebugCurves(i,e);n!=null&&a.push(oe.mkDebugCurveTWCI(255,1,"red",me.mkDiamond(5,25,n.Position))),a=a.concat(s)}static GetAllDebugCurves(e,i){return Le.GraphNodes(i).concat(Le.VertexDebugCurves(e,i)).concat(Le.DebugEdges(i))}static DebugEdges(e){return e.Edges.map(i=>oe.mkDebugCurveTWCI(40,.1,"gray",i.curve))}static VertexDebugCurves(e,i){return Le.DebugCircles(i).concat(Le.DebugHubBases(i)).concat(Le.DebugSegs(i)).concat(Le.BetweenHubs(e,i))}static BetweenHubs(e,i){let n=[];for(let o of i.Metrolines){let s=Le.GetInterestingSegs(i,e,o),a=Le.GetMonotoneColor(o.Polyline.start,o.Polyline.end,s);for(let u of s)n.push(oe.mkDebugCurveTWCI(100,o.Width,a,w.mkPP(u[0],u[1])))}return n}static GetInterestingSegs(e,i,n){let o=new Array;if(e.Stations.length===0||e.Stations[0].BundleBases==null||e.Stations[0].BundleBases.size===0)return[];let s=Le.FindCurveStart(e,i,n),a=Le.HubSegsOfLine(e,i,n);for(let u of a)u!=null&&(o.push([s,u.start]),s=u.end);return o.push([s,Le.FindCurveEnd(e,i,n)]),o}static GetMonotoneColor(e,i,n){return"green"}static DebugHubBases(e){let i=new Array;for(let n of e.Stations)for(let o of n.BundleBases.values())i.push(oe.mkDebugCurveTWCI(100,1,"red",w.mkPP(o.EndPoint,o.StartPoint)));return i}static DebugCircles(e){return e.Stations.map(i=>oe.mkDebugCurveTWCI(100,.1,"blue",me.mkCircle(i.Radius,i.Position)))}static DebugSegs(e){let i=new Array;for(let n of e.VirtualStations())for(let o of n.BundleBases.values())for(let s of o.OrientedHubSegments)if(s!=null)if(s.Segment==null){let a=s.Other.BundleBase,u=s.Index,h=s.Other.Index;i.push(w.mkPP(o.Points[u],a.Points[h]))}else i.push(s.Segment);return i.map(n=>oe.mkDebugCurveTWCI(100,.01,"green",n))}static GraphNodes(e){return e.Edges.map(n=>n.sourcePort.Curve).concat(e.Edges.map(n=>n.targetPort.Curve)).map(n=>oe.mkDebugCurveTWCI(40,1,"black",n))}static BiArc(e,i,n,o){let s=e.sub(n);if(s.length<C.distanceEpsilon)return null;let a=s.dot(i.sub(o)),u=-i.dot(o);if(i.dot(n.sub(e))<=0&&i.dot(o)<=0)return Le.StandardBezier(e,i,n,o);let h=2*(u-1),c=2*a,f=s.dot(s),P;if(Math.abs(h)<C.distanceEpsilon)if(Math.abs(c)>C.distanceEpsilon)P=-f/c;else return null;else{let N=c*c-4*h*f;N<0&&(N=0),N=Math.sqrt(N),P=(-c+N)/(2*h),P<0&&(P=(-c-N)/(2*h))}let v=e.add(i.mul(P)),A=n.add(o.mul(P)),O=d.middle(v,A),M=d.getTriangleOrientation(e,v,O),z=d.getTriangleOrientation(O,A,n);if(M!==z)return Le.StandardBezier(e,i,n,o);let $=new E;return $.addSegs([Le.ArcOn(e,v,O),Le.ArcOn(O,A,n)]),$}static ArcOn(e,i,n){let o={center:null};if(Math.abs(d.signedDoubledTriangleArea(e,i,n))<1e-4||!Le.FindArcCenter(e,i,n,o))return w.mkPP(e,n);let s=o.center,a=pe(e,s);if(pe(e,i)/a<1e-4)return w.mkPP(e,n);let h=e.sub(s),c=Math.atan2(h.y,h.x),f=n.sub(s),P=Math.atan2(f.y,f.x),v=P-c;if(v<0&&(v+=2*Math.PI,P+=2*Math.PI),v<=Math.PI)return new ee(c,P,new d(a,0),new d(0,a),s);for(P>2*Math.PI&&(P-=2*Math.PI),c=Math.PI-c,P=Math.PI-P,c<0&&(c+=2*Math.PI);P<c;)P+=2*Math.PI;return v=P-c,new ee(c,P,new d(-a,0),new d(0,a),s)}static FindArcCenter(e,i,n,o){let s=i.sub(e).rotate90Cw(),a=i.sub(n).rotate90Cw();return o.center=d.lineLineIntersection(e,e.add(s),n,n.add(a)),o.center!=null}static StandardBezier(e,i,n,o){let s=pe(e,n)/4;return be.mkBezier([e,e.add(i.mul(s)),n.add(o.mul(s)),n])}FanBezierSegs(){let e=!0,i=5,n=0;for(;e&&n++<i;){e=!1;for(let o of this.metroGraphData.Stations)for(let s of o.BundleBases.values())e||(e=this.FanEdgesOfHubSegment(s))}}FanEdgesOfHubSegment(e){let i=!1;for(let n=0;n<e.Count-1;n++)i||(i=this.FanCouple(e,n,e.CurveCenter,e.Curve.boundingBox.diagonal/2));return i}FanCouple(e,i,n,o){let s=e.OrientedHubSegments[i],a=e.OrientedHubSegments[i+1];if(s==null||La(s.Segment.start,s.Segment.end,a.Segment.start,a.Segment.end)||d.getTriangleOrientation(s.value(0),s.value(.5),s.value(1))!=d.getTriangleOrientation(a.value(0),a.value(.5),a.value(1)))return!1;let h=this.BaseLength(s),c=this.BaseLength(a);return Math.abs(h-c)<C.intersectionEpsilon?!1:h>c?this.AdjustLongerSeg(s,a,n,o):this.AdjustLongerSeg(a,s,n,o)}AdjustLongerSeg(e,i,n,o){let s=e.value(0).sub(i.value(0)),a=e.value(1).sub(i.value(1)),u=Math.min(s.length,a.length),h=i.value(.5),c=Math.max(s.length,a.length);return this.NicelyAligned(e.Segment,s,a,h,u,c)===0?!1:this.FitLonger(e,s,a,h,u,c,n,o)}FitLonger(e,i,n,o,s,a,u,h){let c=e.Segment,f=c.start,P=c.end,v=0,A=10,O=c.start.mul(1-Le.SqueezeBound).add(c.B(1).mul(Le.SqueezeBound)),M=c.end.mul(1-Le.SqueezeBound).add(c.B(2).mul(Le.SqueezeBound)),z=c.B(1).mul(2).sub(c.start),$=c.B(2).mul(2).sub(c.end),N={highP:z};this.PullControlPointToTheCircle(c.start,N,u,h),z=N.highP;let q=this.NicelyAligned(c,i,n,o,s,a);do{if(q===-1){let Te=d.middle(c.B(1),O),ve=d.middle(c.B(2),M);z=c.B(1),$=c.B(2),c=new be(f,Te,ve,P)}else{let Te=d.middle(c.B(1),z),ve=(c.B(2),$);O=c.B(1),M=c.B(2),c=new be(f,Te,ve,P)}if((q=this.NicelyAligned(c,i,n,o,s,a))===0)return e.Segment=c,e.Other.Segment=c,!0;if(v++>A)return!1}while(!0)}PullControlPointToTheCircle(e,i,n,o){let s=d.ProjectionToLine(e,i.highP,n),a=Math.sqrt(o*o-s.sub(n).lengthSquared),u=i.highP.sub(s),h=u.length;h>a&&(i.highP=s.add(u.mul(a/h)))}NicelyAligned(e,i,n,o,s,a){let h=e.value(.5).sub(o),c=h.length;return i.dot(h)<0||n.dot(h)<0||c<s-.001?1:c>a+.001?-1:0}BaseLength(e){return e.value(0).sub(e.value(1)).lengthSquared}},Un=Le;Un.SqueezeBound=.2;var Mr=class{constructor(t,e){this.stepsWithProgress=0;this.metroGraphData=t,this.bundlingSettings=e,this.costCalculator=new Lt(this.metroGraphData,this.bundlingSettings),this.cache=new qn(this.metroGraphData,this.bundlingSettings,this.costCalculator,this.metroGraphData.cdt)}static FixRouting(t,e){return this.FixRoutingMBP(t,e,null)}static FixRoutingMBP(t,e,i){return new Mr(t,e).FixRoutingP(i)}FixRoutingP(t){this.stationsForOptimizations=this.GetStationsForOptimizations(t),this.cache.InitializeCostCache();let e=Mr.MaxStep,i=Number.POSITIVE_INFINITY,n=this.metroGraphData.VirtualStations().map(s=>s.Position),o=0;for(;o++<Mr.MaxIterations;){let s=this.TryMoveStations();if(o<=1&&!s)return!1;if(!s)break;let a=i;i=Lt.Cost(this.metroGraphData,this.bundlingSettings),e=this.UpdateMaxStep(e,a,i);let u=n;if(n=this.metroGraphData.VirtualStations().map(h=>h.Position),e<Mr.MinStep||this.Converged(e,u,n))break}return!0}static stationsArePositionedCorrectly(t){for(let e of t.VirtualEdges())if(!this.edgeIsPositionedCorrectly(e,t))return!1;return!0}static edgeIsPositionedCorrectly(t,e){let i=t[0],n=t[1],o=e.looseIntersections.ObstaclesToIgnoreForBundle(i,n),s=w.mkPP(i.Position,n.Position),a=Array.from(e.looseIntersections.obstacleTree.GetNodeItemsIntersectingRectangle(s.boundingBox)).filter(u=>!o.has(u)).filter(u=>E.CurvesIntersect(s,u));return a.length>0?(Un.ShowHubs(e,null,null,"./tmp/badcross.svg",[oe.mkDebugCurveTWCI(200,1,"Brown",s),oe.mkDebugCurveTWCI(200,1,"Red",me.mkCircle(2,i.Position)),oe.mkDebugCurveTWCI(200,1,"Blue",me.mkCircle(5,n.Position)),oe.mkDebugCurveTWCI(100,1,"Blue",me.mkCircle(5,n.Position))].concat(a.map(u=>oe.mkDebugCurveTWCI(100,1,"Pink",u)))),!1):!0}GetStationsForOptimizations(t){if(t==null)return new Set(this.metroGraphData.VirtualStations());{let e=new Set;for(let i of t){let n=this.metroGraphData.PointToStations.get(i);n&&!n.IsReal&&e.add(n)}return e}}Converged(t,e,i){let n=0,o=0;for(let a=0;a<e.length;a++)o+=e[a].sub(i[a]).lengthSquared,n+=e[a].lengthSquared;return Math.sqrt(o/n)<Mr.MinRelativeChange}UpdateMaxStep(t,e,i){return i+1<e?(this.stepsWithProgress++,this.stepsWithProgress>=5&&(this.stepsWithProgress=0,t=Math.min(Mr.MaxStep,t/.8))):(this.stepsWithProgress=0,t*=.8),t}TryMoveStations(){let t=!1,e=new Set;for(let i of this.stationsForOptimizations)if(this.TryMoveStation(i)){t=!0,e.add(i);for(let n of i.Neighbors)n.IsReal||e.add(n)}return this.stationsForOptimizations=e,t}TryMoveStation(t){let e=this.BuildDirection(t);if(e.length===0)return!1;let i=this.BuildStepLength(t,e);if(i<Mr.MinStep&&(e=Wp(),i=this.BuildStepLength(t,e),i<Mr.MinStep))return!1;let n=e.mul(i),o=t.Position.add(n);return this.metroGraphData.PointToStations.has(o)||!this.moveIsLegalForAdjacentBundles(t,o)?!1:(this.metroGraphData.MoveNode(t,o),this.cache.UpdateCostCache(t),!0)}moveIsLegalForAdjacentBundles(t,e){for(let i of this.metroGraphData.looseIntersections.obstacleTree.AllHitItems(D.mkOnPoints([e]),n=>E.PointRelativeToCurveLocation(e,n)!==0))if(t.getELP().has(i)===!1)return!1;for(let i of t.Neighbors){let n=this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(i,t);if(!this.metroGraphData.cdtIntersections.EdgeIsLegal_(i.Position,e,i.cdtTriangle,n))return!1}return!0}BuildDirection(t){let e=this.BuildForceForInk(t),i=this.BuildForceForPathLengths(t),n=this.BuildForceForRadius(t),o=this.BuildForceForBundle(t),s=e.add(i.add(n.add(o)));return s.length<.1?new d(0,0):s.normalize()}BuildStepLength(t,e){let i=Mr.MinStep,n=this.CostGain(t,t.Position.add(e.mul(i)));if(n<.01)return 0;for(;2*i<=Mr.MaxStep;){let o=this.CostGain(t,t.Position.add(e.mul(i*2)));if(o<=n)break;i*=2,n=o}return i}CostGain(t,e){let n=this.costCalculator.RadiusGain(t,e);if(n<-12345678)return-12345678;let o=this.costCalculator.BundleGain(t,e);if(o<-12345678)return-12345678;let s=this.costCalculator.InkGain(t,e),a=this.costCalculator.PathLengthsGain(t,e);return n+s+a+o}BuildForceForInk(t){let e=new d(0,0);for(let n of t.Neighbors){let o=n.Position.sub(t.Position);e=e.add(o.normalize())}return e.mul(this.bundlingSettings.InkImportance)}BuildForceForPathLengths(t){let e=new d(0,0);for(let n of this.metroGraphData.MetroNodeInfosOfNode(t)){let o=n.Metroline,s=n.PolyPoint.next.point,a=n.PolyPoint.prev.point,u=s.sub(t.Position),h=a.sub(t.Position);e=e.add(u.div(u.length*o.IdealLength)),e=e.add(h.div(h.length*o.IdealLength))}return e.mul(this.bundlingSettings.PathLengthImportance)}BuildForceForRadius(t){let e=new d(0,0),i=t.cachedIdealRadius,n={touchedObstacles:[]};if(!this.metroGraphData.looseIntersections.HubAvoidsObstaclesSPNBA(t,t.Position,i,n))throw Un.ShowHubs(this.metroGraphData,null,t,"./tmp/hubs.svg",[oe.mkDebugCurveTWCI(255,1,"Brown",$t.containingPoly),oe.mkDebugCurveTWCI(100,1,"Blue",me.mkCircle(i,t.Position))]),new Error;for(let a of n.touchedObstacles){let u=a[1].sub(t.Position).length,h=2*(1-u/i),c=t.Position.sub(a[1]).normalize();e=e.add(c.mul(h))}return e.mul(this.bundlingSettings.HubRepulsionImportance)}BuildForceForBundle(t){let e=new d(0,0);for(let n of t.Neighbors){let o=this.metroGraphData.GetWidthSSN(t,n,this.bundlingSettings.EdgeSeparation),s={closestDist:[]},a=this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(t,n,t.Position,n.Position,o/2,s);for(let u of s.closestDist){let h=u[0].sub(u[1]).length,c=2*(1-h/(o/2)),f=u[0].sub(u[1]).normalize().neg();e=e.add(f.mul(c))}}return e.mul(this.bundlingSettings.BundleRepulsionImportance)}},Wr=Mr;Wr.MaxIterations=100,Wr.MaxStep=50,Wr.MinStep=1,Wr.MinRelativeChange=5e-4;function Wp(){return new d(1+2*Si(),1+2*Si())}var Li=class{constructor(t,e){this.metroGraphData=t,this.bundlingSettings=e}static FixRouting(t,e){let i=new Li(t,e);i.GlueConflictingStations(),i.UnglueEdgesFromBundleToSaveInk(!0);let n=0,o=10;for(;++n<o;){let s=i.GlueConflictingStations();if(s||(s=i.RelaxConstrainedEdges()),s||(s=n<=3&&i.UnglueEdgesFromBundleToSaveInk(!1)),s||(s=i.GlueCollinearNeighbors(n)),s||(s=n===3&&i.RemoveDoublePathCrossings()),!s)break}for(t.cdtIntersections.ComputeForcesForBundles=!0,i.RemoveDoublePathCrossings(),i.UnglueEdgesFromBundleToSaveInk(!0);i.GlueConflictingStations(););t.Initialize(!0)}GlueConflictingStations(){let t=this.GetCirclesHierarchy();if(t==null)return!1;let e=new Map,i=new Set;if(tt(t,t,(o,s)=>this.TryToGlueStations(o,s,e,i)),e.size===0)return!1;for(let o=0;o<this.metroGraphData.Edges.length;o++)this.RegenerateEdge(e,o);let n=new Se;for(let o of i){n.add(o.Position);for(let s of o.Neighbors)s.IsReal||n.add(s.Position)}return this.metroGraphData.Initialize(!1),Wr.FixRoutingMBP(this.metroGraphData,this.bundlingSettings,n),!0}GetCirclesHierarchy(){for(let i of this.metroGraphData.VirtualStations())i.Radius=this.GetCurrentHubRadius(i);let t=this.metroGraphData.VirtualStations().map(e);return Oe(t);function e(i){let n=i.Position,o=Math.max(i.Radius,5),s=new d(o,o),a=D.mkPP(n.add(s),n.sub(s));return Fe(i,a)}}GetCurrentHubRadius(t){if(t.IsReal)return t.BoundaryCurve.boundingBox.diagonal/2;{let e=t.cachedIdealRadius,i=this.metroGraphData.looseIntersections.GetMinimalDistanceToObstacles(t,t.Position,e);for(let n of t.Neighbors)i=Math.min(i,t.Position.sub(n.Position).length);return i}}TryToGlueStations(t,e,i,n){if(!$n(t.getELP(),e.getELP()))return!1;let o=t.Position.sub(e.Position).length,s=Math.max(t.Radius,5),a=Math.max(e.Radius,5);o>=s+a||this.TryGlueOrdered(t,e,n,i)||this.TryGlueOrdered(e,t,n,i)}TryGlueOrdered(t,e,i,n){return!n.has(t)&&!i.has(t)&&this.StationGluingIsAllowed(t,e,n)?(this.Map(t,e,i,n),!0):!1}Map(t,e,i,n){n.set(t,e),i.add(e)}StationGluingIsAllowed(t,e,i){for(let o of t.Neighbors){let s=Li.Glued(o,i),a=this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(s,t);if(!this.metroGraphData.cdtIntersections.EdgeIsLegalSSPPS(s,e,a))return!1}return!(this.ComputeCostDeltaAfterStationGluing(t,e,i)<0)}ComputeCostDeltaAfterStationGluing(t,e,i){let n=t.Position.sub(e.Position).length;if(t.Radius>=n||e.Radius>=n)return 1;let o=0,s=this.metroGraphData.Ink,a=this.metroGraphData.Ink-e.Position.sub(t.Position).length;for(let u of t.Neighbors){let h=Li.Glued(u,i);a-=h.Position.sub(t.Position).length,a+=this.metroGraphData.RealEdgeCount(h,e)===0?h.Position.sub(e.Position).length:0}o+=Lt.InkError(s,a,this.bundlingSettings);for(let u of this.metroGraphData.MetroNodeInfosOfNode(t)){let h=u.Metroline.Length,c=u.Metroline.Length,f=u.PolyPoint,P=f.prev,v=f.next;c-=P.point.sub(t.Position).length+v.point.sub(t.Position).length,c+=P.point.sub(e.Position).length+v.point.sub(e.Position).length,o+=Lt.PathLengthsError(h,c,u.Metroline.IdealLength,this.bundlingSettings)}return o}RegenerateEdge(t,e){let i=this.metroGraphData.Metrolines[e].Polyline;for(let s of i)if(!this.metroGraphData.PointToStations.has(s))return;let n=!1;for(let s of i)if(t.has(this.metroGraphData.PointToStations.get(s))){n=!0;break}if(!n)return;let o=Array.from(i).map(s=>this.metroGraphData.PointToStations.get(s));this.metroGraphData.Edges[e].curve=j.mkFromPoints(Li.GluedPolyline(o,t))}static GluedPolyline(t,e){let i,n=new Ud.Stack;n.push(t[0]);let o=new Set;for(i=1;i<t.length-1;i++){let s=Li.Glued(t[i],e);if(o.has(s)){for(;n.top!==s;)o.delete(n.pop());continue}d.closeDistEps(s.Position,n.top.Position)||(o.add(s),n.push(s))}return n.push(t[i]),Array.from(n).reverse().map(s=>s.Position)}static Glued(t,e){var i;return(i=e.get(t))!=null?i:t}UnglueEdgesFromBundleToSaveInk(t){let e=new Nr;this.ink=this.metroGraphData.Ink,this.polylineLength=new Map;for(let o of this.metroGraphData.Metrolines){this.polylineLength.set(o,o.Length);for(let s=o.Polyline.startPoint;s.next!=null;s=s.next){let a=new ke(s.point,s.next.point);ku(e,a,o)}}let i=new Se,n=!1;for(let o of this.metroGraphData.Metrolines){let s=jr(this.metroGraphData.PointToStations.get(o.Polyline.start).getELP(),this.metroGraphData.PointToStations.get(o.Polyline.end).getELP());this.TrySeparateOnPolyline(o,e,i,s)&&(n=!0)}return n&&this.metroGraphData.Initialize(!1),(t||n)&&Wr.FixRoutingMBP(this.metroGraphData,this.bundlingSettings,t?null:i),n}TrySeparateOnPolyline(t,e,i,n){let o=!1,s=!0;for(;s;){s=!1;for(let a=t.Polyline.startPoint;a.next!=null&&a.next.next!=null;a=a.next)this.TryShortcutPolypoint(a,e,i,n)&&(s=!0);s&&(o=!0)}return o}TryShortcutPolypoint(t,e,i,n){return this.SeparationShortcutAllowed(t,e,n)?(i.add(t.point),i.add(t.next.point),i.add(t.next.next.point),this.RemoveShortcuttedPolypoint(t,e),!0):!1}SeparationShortcutAllowed(t,e,i){let n=t.point,o=t.next.point,s=t.next.next.point,a=this.metroGraphData.PointToStations.get(n),u=this.metroGraphData.PointToStations.get(o),h=this.metroGraphData.PointToStations.get(s),c=Ur(a.getELP(),h.getELP()),f=Nc([i,u.getELP(),c]);return!(!this.metroGraphData.cdtIntersections.EdgeIsLegalSSPPS(a,h,f)||this.GetInkgain(t,e,n,o,s)<0)}GetInkgain(t,e,i,n,o){let[s,a,u]=this.FindPolylines(t,e),h=0,c=this.ink,f=this.ink,P=i.sub(n).length,v=n.sub(o).length,A=i.sub(o).length;s.size===u.size&&(f-=P),a.size===u.size&&(f-=v);let O=e.get(new ke(i,o));(!O||O.size===0)&&(f+=A),h+=Lt.InkError(c,f,this.bundlingSettings);for(let Te of u){let ve=this.polylineLength.get(Te),Wt=ve-(P+v-A);h+=Lt.PathLengthsError(ve,Wt,Te.IdealLength,this.bundlingSettings)}let M=this.GetCurrentHubRadius(this.metroGraphData.PointToStations.get(i)),z=this.metroGraphData.GetWidthAN(Array.from(u),this.bundlingSettings.EdgeSeparation),$=this.metroGraphData.GetWidthAN(Array.from(Fi(s,u)),this.bundlingSettings.EdgeSeparation),N=et.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(M,i,o,n,z,$,this.bundlingSettings);N>M&&(h-=Lt.RError(N,M,this.bundlingSettings)),M=this.GetCurrentHubRadius(this.metroGraphData.PointToStations.get(o));let q=this.metroGraphData.GetWidthAN(Array.from(Fi(a,u)),this.bundlingSettings.EdgeSeparation);return N=et.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(M,o,n,i,q,z,this.bundlingSettings),N>M&&(h-=Lt.RError(N,M,this.bundlingSettings)),h}RemoveShortcuttedPolypoint(t,e){let i=t.point,n=t.next.point,o=t.next.next.point,[s,a,u]=this.FindPolylines(t,e),h=pe(i,n),c=pe(n,o),f=pe(i,o);s.size===u.size&&(this.ink-=h),a.size===u.size&&(this.ink-=c);let P=e.get(new ke(i,o));(!P||P.size===0)&&(this.ink+=f);for(let v of u){let A=this.polylineLength.get(v);this.polylineLength.set(v,A-(h+c-f))}for(let v of u){let A=Array.from(v.Polyline.polylinePoints()).find(O=>O.point.equal(n));this.RemovePolypoint(A),Mu(e,[i,n],v),Mu(e,[n,o],v),Dc(e,[i,o],v)}}FindPolylines(t,e){let i=t.point,n=t.next.point,o=t.next.next.point,s=e.getPP(i,n),a=e.getPP(n,o),u=jr(s,a);return[s,a,u]}RemovePolypoint(t){let e=t.prev,i=t.next;e.next=i,i.prev=e}GlueCollinearNeighbors(t){let e=new Se,i=!1;for(let n of this.metroGraphData.Stations)this.GlueCollinearNeighborsSPN(n,e,t)&&(i=!0);return i&&(this.metroGraphData.Initialize(!1),Wr.FixRoutingMBP(this.metroGraphData,this.bundlingSettings,e)),i}GlueCollinearNeighborsSPN(t,e,i){if(t.Neighbors.length<=1)return!1;let n=new ms,o=t.Neighbors;for(let s=0;s<o.length;s++)this.TryToGlueEdges(t,o[s],o[(s+1)%o.length],n,i);if(n.isEmpty)return!1;for(let s of n)this.GlueEdge(s),e.add(s[0].Position),e.add(s[1].Position),e.add(s[2]);return!0}TryToGlueEdges(t,e,i,n,o){if(d.anglePCP(e.Position,t.Position,i.Position)<this.bundlingSettings.AngleThreshold){let a=pe(e.Position,t.Position),u=pe(i.Position,t.Position),h=Math.min(a,u)/Math.max(a,u);if(h<.05)return;if(a<u){if(this.EdgeGluingIsAllowedSSS(t,e,i)){this.AddEdgeToGlue(t,i,e,e.Position,n);return}}else if(this.EdgeGluingIsAllowedSSS(t,i,e)){this.AddEdgeToGlue(t,e,i,i.Position,n);return}if(o<5&&h>.5){let c=this.ConstructGluingPoint(t,e,i);this.EdgeGluingIsAllowedSSSP(t,e,i,c)&&this.AddEdgeToGlue(t,i,e,c,n)}}}ConstructGluingPoint(t,e,i){let n=Math.min(pe(e.Position,t.Position),pe(i.Position,t.Position)/2),o=e.Position.sub(t.Position).normalize().add(i.Position.sub(t.Position).normalize());return t.Position.add(o.mul(n/2))}EdgeGluingIsAllowedSSS(t,e,i){if(e.IsReal||i.IsReal||!$n(e.getELP(),i.getELP())||!this.metroGraphData.cdtIntersections.EdgeIsLegal(e,i,e.Position,i.Position))return!1;let n=this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(t,i);return!(Ce.IntersectionsOfLineAndRectangleNodeOverPolylineLR(w.mkPP(t.Position,e.Position),this.metroGraphData.LooseTree).find(u=>!n.has(u.seg1))||Ce.IntersectionsOfLineAndRectangleNodeOverPolylineLR(w.mkPP(e.Position,i.Position),this.metroGraphData.LooseTree).find(u=>!n.has(u.seg1))||this.ComputeCostDeltaAfterEdgeGluing(t,e,i,e.Position)<0)}EdgeGluingIsAllowedSSSP(t,e,i,n){return!(!this.metroGraphData.looseIntersections.HubAvoidsObstaclesPNS__(n,0,jr(e.getELP(),i.getELP()))||!this.metroGraphData.cdtIntersections.EdgeIsLegal(t,null,t.Position,n)||!this.metroGraphData.cdtIntersections.EdgeIsLegal(e,null,e.Position,n)||!this.metroGraphData.cdtIntersections.EdgeIsLegal(i,null,i.Position,n)||this.ComputeCostDeltaAfterEdgeGluing(t,e,i,n)<0)}ComputeCostDeltaAfterEdgeGluing(t,e,i,n){let o=0,s=this.metroGraphData.Ink,a=this.metroGraphData.Ink-pe(t.Position,i.Position)-pe(t.Position,e.Position)+pe(t.Position,n)+pe(n,e.Position)+pe(n,i.Position);o+=Lt.InkError(s,a,this.bundlingSettings);for(let f of this.metroGraphData.GetIjInfo(t,i).Metrolines){let P=f.Length,v=f.Length-pe(t.Position,i.Position)+pe(t.Position,n)+pe(n,i.Position);o+=Lt.PathLengthsError(P,v,f.IdealLength,this.bundlingSettings)}for(let f of this.metroGraphData.GetIjInfo(t,e).Metrolines){let P=f.Length,v=f.Length-pe(t.Position,e.Position)+pe(t.Position,n)+pe(n,e.Position);o+=Lt.PathLengthsError(P,v,f.IdealLength,this.bundlingSettings)}let u=t.cachedIdealRadius,h=this.GetCurrentHubRadius(t),c=et.GetMinRadiusForTwoAdjacentBundles(h,t,t.Position,e,i,this.metroGraphData,this.bundlingSettings);return c>h&&(o+=Lt.RError(c,h,this.bundlingSettings)),u>pe(t.Position,n)&&!t.IsReal&&(o-=Lt.RError(u,pe(t.Position,n),this.bundlingSettings)),o}AddEdgeToGlue(t,e,i,n,o){o.has(i,t)||o.has(e,t)||o.has(t,i)||o.has(t,e)||(o.set(t,i,n),o.set(t,e,n))}GlueEdge(t){let e=t[0],i=t[1],n=t[2];for(let o of e.MetroNodeInfos.map(s=>s.PolyPoint))o.next!=null&&o.next.point.equal(i.Position)?this.SplitPolylinePoint(o,n):o.prev!=null&&o.prev.point.equal(i.Position)&&this.SplitPolylinePoint(o.prev,n)}SplitPolylinePoint(t,e){if(t.point===e||t.next.point===e)return;let i=it.mkFromPoint(e);i.polyline=t.polyline,i.next=t.next,i.prev=t,i.next.prev=i,i.prev.next=i}RelaxConstrainedEdges(){let t=new Se,e=!1;for(let i of this.metroGraphData.VirtualEdges())this.RelaxConstrainedEdge(i[0],i[1],t)&&(e=!0);return e&&(this.metroGraphData.Initialize(!1),Wr.FixRoutingMBP(this.metroGraphData,this.bundlingSettings,t)),e}RelaxConstrainedEdge(t,e,i){let n=this.metroGraphData.GetWidthSSN(t,e,this.bundlingSettings.EdgeSeparation),o={closestDist:new Array};this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(t,e,t.Position,e.Position,.99*n/2,o);let s=o.closestDist;if(s.length>0){let a=-1,u;for(let h of s){let c=Math.min(pe(t.Position,h[1]),pe(e.Position,h[1])),f=pe(t.Position,e.Position);if(c/f<.1)continue;let v=pe(h[0],h[1]);(a===-1||v<a)&&(a=v,u=h[1])}if(a===-1||!this.metroGraphData.looseIntersections.HubAvoidsObstaclesPNS__(u,0,jr(t.getELP(),e.getELP())))return!1;i.add(u),i.add(t.Position),i.add(e.Position);for(let h of this.metroGraphData.GetIjInfo(t,e).Metrolines){let c=null;for(let f of h.Polyline.polylinePoints())if(f.point.equal(t.Position)){c=f;break}c.next!=null&&c.next.point.equal(e.Position)?this.SplitPolylinePoint(c,u):this.SplitPolylinePoint(c.prev,u)}return!0}return!1}RemoveDoublePathCrossings(){let t=new Yi(this.metroGraphData,this.metroGraphData.PointIsAcceptableForEdge.bind(this)).run();return t&&(this.metroGraphData.Initialize(!1),Wr.FixRouting(this.metroGraphData,this.bundlingSettings)),t}};var vo=class{constructor(t,e,i){this.upperBound=Number.POSITIVE_INFINITY;this._visGraph=i,i.ClearPrevEdgesTable();for(let n of i.Vertices())n.Distance=Number.POSITIVE_INFINITY;this.sources=t,this.targets=new Set(e)}GetPath(){let t=new At;for(let e of this.sources)e.Distance=0,t.Enqueue(e,0);for(;!t.IsEmpty()&&(this._current=t.Dequeue(),!this.targets.has(this._current));){for(let e of this._current.OutEdges)this.PassableOutEdge(e)&&this.ProcessNeighbor(t,e,e.Target);for(let e of this._current.InEdges.filter(this.PassableInEdge.bind))this.ProcessNeighbor(t,e,e.Source)}return this._visGraph.PreviosVertex(this._current)==null?null:this.CalculatePath()}PassableOutEdge(t){return this.targets.has(t.Target)||!vo.IsForbidden(t)}PassableInEdge(t){return this.targets.has(t.Source)||!vo.IsForbidden(t)}static IsForbidden(t){return(t.IsPassable!=null&&!t.IsPassable()||t)instanceof mt}ProcessNeighbor(t,e,i){let n=e.Length,o=this._current.Distance+n;o>=this.upperBound||(this.targets.has(i)&&(this.upperBound=o,this.closestTarget=i),this._visGraph.PreviosVertex(i)==null?(i.Distance=o,this._visGraph.SetPreviousEdge(i,e),t.Enqueue(i,o)):o<i.Distance&&(i.Distance=o,this._visGraph.SetPreviousEdge(i,e),t.DecreasePriority(i,o)))}CalculatePath(){if(this.closestTarget==null)return null;let t=new Array,e=this.closestTarget;do t.push(e),e=this._visGraph.PreviosVertex(e);while(e.Distance>0);return t.push(e),t.reverse()}};var Zi=class extends _{constructor(e,i,n,o,s,a,u,h,c,f){super(null);this.bundlingSettings=o,this.bundlingSettings.edgeWidthShrinkCoeff=1,this.edgesToRoute=e,this.regularEdges=e.filter(P=>P.source!==P.target),this.VisibilityGraph=n,this.shortestPathRouter=i,this.LoosePadding=s,this.LooseHierarchy=u,this.TightHierarchy=a,this.EdgeLooseEnterable=h,this.EdgeTightEnterable=c,this.loosePolylineOfPort=f,yn(0)}ThereAreOverlaps(e){return yr(e,e,E.CurvesIntersect)}run(){if(this.ThereAreOverlaps(this.TightHierarchy)){this.Status=1;return}this.FixLocationsForHookAnywherePorts(this.edgesToRoute),this.RoutePathsWithSteinerDijkstra(),this.FixChildParentEdges(),this.bundlingSettings.StopAfterShortestPaths||this.OrderOptimizeNudgeEtc(),this.RouteSelfEdges(),this.FixArrowheads()}OrderOptimizeNudgeEtc(){let e=new Ql(this.regularEdges,this.LooseHierarchy,this.TightHierarchy,this.bundlingSettings,this.shortestPathRouter.cdt,this.EdgeLooseEnterable,this.EdgeTightEnterable,this.loosePolylineOfPort);Li.FixRouting(e,this.bundlingSettings),new Un(e,this.bundlingSettings).run()}FixChildParentEdges(){for(let e of this.regularEdges){let i=e.sourcePort,n=e.targetPort;if(i.Curve.boundingBox.containsRect(n.Curve.boundingBox)){let o=E.intersectionOne(i.Curve,w.mkPP(e.curve.start,e.curve.end),!1),s=e.curve;s.startPoint.point=o.x}if(n.Curve.boundingBox.containsRect(i.Curve.boundingBox)){let o=E.intersectionOne(n.Curve,w.mkPP(e.curve.start,e.curve.end),!0),s=e.curve;s.endPoint.point=o.x}}}FixLocationsForHookAnywherePorts(e){for(let i of e){let n=i.sourcePort instanceof Ze;if(n){let o=i.sourcePort;o.SetLocation(this.FigureOutHookLocation(o.LoosePolyline,i.targetPort,i))}else if(n=i.targetPort instanceof Ze,n){let o=i.targetPort;o.SetLocation(this.FigureOutHookLocation(o.LoosePolyline,i.sourcePort,i))}}}FigureOutHookLocation(e,i,n){return i instanceof St?this.FigureOutHookLocationForClusterOtherPort(e,i,n):this.FigureOutHookLocationForSimpleOtherPort(e,i,n)}FigureOutHookLocationForClusterOtherPort(e,i,n){let o=this.shortestPathRouter.MakeTransparentShapesOfEdgeGeometry(n),a=new vo(Array.from(i.LoosePolyline).map(this.VisibilityGraph.FindVertex.bind),Array.from(e).map(this.VisibilityGraph.FindVertex.bind),this.VisibilityGraph).GetPath();for(let u of o)u.IsTransparent=!1;return a[a.length-1].point}FigureOutHookLocationForSimpleOtherPort(e,i,n){let o=i.Location,s=this.shortestPathRouter.MakeTransparentShapesOfEdgeGeometry(n),u=new Hi(this.VisibilityGraph.FindVertex(o),Array.from(e).map(h=>this.VisibilityGraph.FindVertex(h)),this.VisibilityGraph).GetPath();for(let h of s)h.IsTransparent=!1;return u[u.length-1].point}RoutePathsWithSteinerDijkstra(){this.shortestPathRouter.VisibilityGraph=this.VisibilityGraph,this.shortestPathRouter.BundlingSettings=this.bundlingSettings,this.shortestPathRouter.geomEdges=this.regularEdges,this.shortestPathRouter.ObstacleHierarchy=this.LooseHierarchy,this.shortestPathRouter.RouteEdges(),this.shortestPathRouter.cdt!=null&&this.AdjustEdgeSeparation()}AdjustEdgeSeparation(){let e=new Map;this.shortestPathRouter.FillCrossedCdtEdges(e);let i=this.GetPathsOnCdtEdge(e);this.bundlingSettings.edgeWidthShrinkCoeff=this.CalculateEdgeWidthShrinkCoeff(i)}GetPathsOnCdtEdge(e){let i=new Map;for(let n of e.keys())for(let o of e.get(n))Kn(i,o,n);return i}CalculateEdgeWidthShrinkCoeff(e){let i=0,n=this.bundlingSettings.edgeWidthShrinkCoeff;if(this.EdgeSeparationIsOkMN(e,n))return n;let o=!1;for(;!o||Math.abs(n-i)>.01;){let s=(i+n)/2;this.EdgeSeparationIsOkMN(e,s)?(i=s,o=!0):n=s}return i}EdgeSeparationIsOkMN(e,i){for(let n of e.keys())if(!this.EdgeSeparationIsOk(n,e.get(n),i))return!1;return!0}EdgeSeparationIsOk(e,i,n){return Array.from(i).map(s=>this.bundlingSettings.ActualEdgeWidth(s,n)).reduce((s,a)=>s+a,0)<=e.Capacity}RouteSelfEdges(){for(let e of this.edgesToRoute)if(e.source===e.target){let i={smoothedPolyline:null};e.curve=Re.RouteSelfEdge(e.source.boundaryCurve,this.LoosePadding*2,i)}}FixArrowheads(){for(let e of this.edgesToRoute)We.trimSplineAndCalculateArrowheadsII(e,e.source.boundaryCurve,e.target.boundaryCurve,e.curve,!1)}};Zi.SuperLoosePaddingCoefficient=1.1;var $l=class{constructor(t,e,i){this.numberOfPassedPaths=0;this.VisibilityEdge=t,this.Source=e,this.Target=i}get TargetPoint(){return this.Target.Point}get SourcePoint(){return this.Source.Point}get IsOccupied(){return this.numberOfPassedPaths>0}get IsPassable(){return this.Target.IsTargetOfRouting||this.Source.IsSourceOfRouting||this.VisibilityEdge.IsPassable==null||this.VisibilityEdge.IsPassable()}AddOccupiedEdge(){this.numberOfPassedPaths++}RemoveOccupiedEdge(){this.numberOfPassedPaths--}};var Kl=class{constructor(t){this.InBoneEdges=new Array;this.OutBoneEdges=new Array;this.VisibilityVertex=t}get Prev(){return this.PrevEdge==null?null:this.PrevEdge.Source===this?this.PrevEdge.Target:this.PrevEdge.Source}get Point(){return this.VisibilityVertex.point}get Cost(){return this.IsSourceOfRouting?this.cost:this.Prev==null?Number.POSITIVE_INFINITY:this.cost}set Cost(t){this.cost=t}SetPreviousToNull(){this.PrevEdge=null}};var Hr=class{constructor(t,e,i){this.EdgesToRoutes=new Map;this.EdgesToRouteSources=new Map;this.MakeTransparentShapesOfEdgeGeometry=t,this.cdt=e,this.Gates=i}CreateGraphElements(){for(let t of this.vertexArray){let e=t.VisibilityVertex;for(let i of e.InEdges){let n=new $l(i,this.VisibilityVerticesToSdVerts.get(i.Source),this.VisibilityVerticesToSdVerts.get(i.Target)),o=this.VisibilityVerticesToSdVerts.get(i.Source);t.InBoneEdges.push(n),o.OutBoneEdges.push(n)}}}CreateRoutingGraph(){this.vertexArray=[],this.VisibilityVerticesToSdVerts=new Map;for(let t of this.VisibilityGraph.Vertices()){let e=new Kl(t);this.vertexArray.push(e),this.VisibilityVerticesToSdVerts.set(t,e)}this.CreateGraphElements()}RouteEdges(){this.Initialize(),this.RestoreCapacities();for(let t of this.geomEdges)this.EdgesToRoutes.set(t,this.RouteEdge(t));this.RerouteEdges();for(let t of this.geomEdges)this.SetEdgeGeometryCurve(t)}SetEdgeGeometryCurve(t){let e=new j,i=this.EdgesToRouteSources.get(t);e.addPoint(i.Point);for(let s of this.EdgesToRoutes.get(t))s.SourcePoint.equal(i.Point)?(e.addPoint(s.TargetPoint),i=s.Target):(e.addPoint(s.SourcePoint),i=s.Source);t.curve=e,t.sourcePort instanceof St&&Hr.ExtendPolylineStartToClusterBoundary(e,t.sourcePort.Curve),t.targetPort instanceof St&&Hr.ExtendPolylineEndToClusterBoundary(e,t.targetPort.Curve)}static ExtendPolylineEndToClusterBoundary(t,e){let i=e.closestParameter(t.end);t.addPoint(e.value(i))}static ExtendPolylineStartToClusterBoundary(t,e){let i=e.closestParameter(t.start);t.PrependPoint(e.value(i))}RerouteEdges(){this.RestoreCapacities();for(let t of this.geomEdges){let e=this.RerouteEdge(t);this.EdgesToRoutes.set(t,e)}}RestoreCapacities(){this.cdt!=null&&this.cdt.RestoreEdgeCapacities()}RerouteEdge(t){let e=this.EdgesToRoutes.get(t);for(let i of e)i.RemoveOccupiedEdge();return this.RouteEdge(t)}RouteEdge(t){this.CurrentEdgeGeometry=t;for(let n=0;n<this.vertexArray.length;n++){let o=this.vertexArray[n];o.SetPreviousToNull(),o.IsTargetOfRouting=o.IsSourceOfRouting=!1}let e=this.MakeTransparentShapesOfEdgeGeometry(t),i=this.RouteEdgeWithGroups();for(let n of e)n.IsTransparent=!1;return i}RouteEdgeWithGroups(){for(let t=0;t<2;t++){this.SetLengthCoefficient(),this.Queue=new At,this.sourceLoosePoly=this.SetPortVerticesAndObstacles(this.CurrentEdgeGeometry.sourcePort,!0),this.targetLoosePoly=this.SetPortVerticesAndObstacles(this.CurrentEdgeGeometry.targetPort,!1);let e=this.RouteOnKnownSourceTargetVertices(this.CurrentEdgeGeometry.targetPort.Location.sub(this.CurrentEdgeGeometry.sourcePort.Location).normalize(),t===0);if(e!=null)return e;for(let i=0;i<this.vertexArray.length;i++)this.vertexArray[i].SetPreviousToNull()}throw new Error}RouteOnKnownSourceTargetVertices(t,e){for(this.LowestCostToTarget=Number.POSITIVE_INFINITY,this.ClosestTargetVertex=null;this.Queue.count>0;){let i={priority:0},n=this.Queue.DequeueAndGetPriority(i);if(!(i.priority>=this.LowestCostToTarget)){for(let o=0;o<n.OutBoneEdges.length;o++){let s=n.OutBoneEdges[o];s.IsPassable&&this.ProcessOutcomingBoneEdge(n,s,t,e)}for(let o=0;o<n.InBoneEdges.length;o++){let s=n.InBoneEdges[o];s.IsPassable&&this.ProcessIncomingBoneEdge(n,s,t,e)}}}return this.GetPathAndUpdateRelatedCosts()}ProcessOutcomingBoneEdge(t,e,i,n){n&&i.dot(e.TargetPoint.sub(e.SourcePoint))<0||this.ProcessBoneEdge(t,e.Target,e)}ProcessIncomingBoneEdge(t,e,i,n){n&&i.dot(e.SourcePoint.sub(e.TargetPoint))<0||this.ProcessBoneEdge(t,e.Source,e)}ProcessBoneEdge(t,e,i){let n=this.GetEdgeAdditionalCost(i,t.Cost);if(!(e.Cost<=n))if(e.Cost=n,e.PrevEdge=i,this.Queue.ContainsElement(e))this.Queue.DecreasePriority(e,n);else{if(e.IsTargetOfRouting){let o=0;this.CurrentEdgeGeometry.targetPort instanceof St&&(o=this.LengthCoefficient*e.Point.sub(this.CurrentEdgeGeometry.targetPort.Location).length),n+o<this.LowestCostToTarget&&(this.LowestCostToTarget=n+o,this.ClosestTargetVertex=e);return}this.Enqueue(e)}}GetPathAndUpdateRelatedCosts(){let t=this.ClosestTargetVertex;if(t==null)return null;let e=new Array;for(;t.PrevEdge!=null;)e.push(t.PrevEdge),this.RegisterPathInBoneEdge(t.PrevEdge),t=t.Prev;return this.EdgesToRouteSources.set(this.CurrentEdgeGeometry,t),e.reverse(),e}RegisterPathInBoneEdge(t){t.AddOccupiedEdge(),this.cdt!=null&&this.BundlingSettings.CapacityOverflowCoefficient!==0&&this.UpdateResidualCostsOfCrossedCdtEdges(t)}UpdateResidualCostsOfCrossedCdtEdges(t){for(let e of t.CrossedCdtEdges)this.AdjacentToSourceOrTarget(e)||(e.ResidualCapacity===e.Capacity?e.ResidualCapacity-=this.BundlingSettings.edgeWidthShrinkCoeff*this.CurrentEdgeGeometry.lineWidth:e.ResidualCapacity-=this.BundlingSettings.ActualEdgeWidth(this.CurrentEdgeGeometry))}H(t){return t.Cost+this.LengthCoefficient*t.Point.sub(this.CurrentEdgeGeometry.targetPort.Location).length}GetEdgeAdditionalCost(t,e){let i=t.TargetPoint.sub(t.SourcePoint).length;return this.LengthCoefficient*i+e+(t.IsOccupied?0:this.BundlingSettings.InkImportance*i)+this.CapacityOverflowCost(t)}CapacityOverflowCost(t){if(this.cdt==null||this.BundlingSettings.CapacityOverflowCoefficient===0)return 0;let e=0;for(let i of this.CrossedCdtEdgesOfBoneEdge(t))e+=this.CostOfCrossingCdtEdgeLocal(this.capacityOverlowPenaltyMultiplier,this.BundlingSettings,this.CurrentEdgeGeometry,i);return e}CrossedCdtEdgesOfBoneEdge(t){return t.CrossedCdtEdges!=null?Array.from(t.CrossedCdtEdges):Array.from(t.CrossedCdtEdges=this.ThreadBoneEdgeThroughCdt(t))}ThreadBoneEdgeThroughCdt(t){let e=t.SourcePoint,i=t.Source.Triangle,n=new Set,o=t.TargetPoint;if(Ee.PointIsInsideOfTriangle(o,i))return n;let s=new zn(i,e,o);for(;s.MoveNext();){let a=s.CurrentPiercedEdge;this.Gates.has(a)&&n.add(a)}return n}static CostOfCrossingCdtEdge(t,e,i,n){let o=i.lineWidth*e.edgeWidthShrinkCoeff;n.Capacity!==n.ResidualCapacity&&(o+=e.EdgeSeparation*e.edgeWidthShrinkCoeff);let s=n.ResidualCapacity-o;return s>=0?0:-s*t}CostOfCrossingCdtEdgeLocal(t,e,i,n){return this.AdjacentToSourceOrTarget(n)?0:Hr.CostOfCrossingCdtEdge(t,e,i,n)}AdjacentToSourceOrTarget(t){return t.upperSite.Owner===this.sourceLoosePoly||t.lowerSite.Owner===this.sourceLoosePoly||t.upperSite.Owner===this.targetLoosePoly||t.lowerSite.Owner===this.targetLoosePoly}SetLengthCoefficient(){let t=this.GetIdealDistanceBetweenSourceAndTarget(this.CurrentEdgeGeometry);this.LengthCoefficient=this.BundlingSettings.PathLengthImportance/t}GetIdealDistanceBetweenSourceAndTarget(t){return t.sourcePort.Location.sub(t.targetPort.Location).length}SetPortVerticesAndObstacles(t,e){let i;if(t instanceof St){i=t.LoosePolyline;for(let o of i){let s=0;e&&(s=this.LengthCoefficient*o.sub(this.CurrentEdgeGeometry.sourcePort.Location).length),this.AddAndEnqueueVertexToEnds(o,e,s)}}else if(t instanceof Ze){i=t.LoosePolyline;for(let o of i)this.AddAndEnqueueVertexToEnds(o,e,0)}else{this.AddAndEnqueueVertexToEnds(t.Location,e,0);let n=Array.from(this.ObstacleHierarchy.GetNodeItemsIntersectingRectangle(t.Curve.boundingBox)),o=n[0].boundingBox.diagonal;i=n[0];for(let s=1;s<n.length;s++){let a=n[s],u=a.boundingBox.diagonal;u<o&&(o=u,i=a)}}return i}Enqueue(t){this.Queue.Enqueue(t,this.H(t))}AddAndEnqueueVertexToEnds(t,e,i){let n=this.FindVertex(t),o=this.VisibilityVerticesToSdVerts.get(n);e?(o.IsSourceOfRouting=!0,o.Cost=i,this.Enqueue(o)):o.IsTargetOfRouting=!0}FindVertex(t){return this.VisibilityGraph.FindVertex(t)}Initialize(){this.CreateRoutingGraph(),this.cdt!=null&&(this.capacityOverlowPenaltyMultiplier=Hr.CapacityOverflowPenaltyMultiplier(this.BundlingSettings),this.SetVertexTriangles(),this.CalculateCapacitiesOfTrianglulation())}CalculateCapacitiesOfTrianglulation(){for(let t of this.Gates)Hr.CalculateCdtEdgeCapacityForEdge(t)}static CalculateCdtEdgeCapacityForEdge(t){if(t.constrained||t.CwTriangle==null||t.CcwTriangle==null)return;let e=t.upperSite.Owner,i=t.lowerSite.Owner;if(e!==i){let n=at.DistancePoint(new at(e),t.lowerSite.point),o=at.DistancePoint(new at(i),t.upperSite.point);t.Capacity=(n+o)/2}}SetVertexTriangles(){let t=Oe(Array.from(this.cdt.GetTriangles()).map(i=>Fe(i,i.BoundingBox()))),e=Oe(this.vertexArray.map(i=>Fe(i,D.mkOnPoints([i.Point]))));Et(t,e,(i,n)=>this.TryToAssigenTriangleToVertex(i,n))}TryToAssigenTriangleToVertex(t,e){e.Triangle==null&&Ee.PointIsInsideOfTriangle(e.Point,t)&&(e.Triangle=t)}static CapacityOverflowPenaltyMultiplier(t){return t.CapacityOverflowCoefficient*(t.PathLengthImportance+t.InkImportance)}FillCrossedCdtEdges(t){for(let e of this.geomEdges){this.sourceLoosePoly=this.SetPortVerticesAndObstacles(e.sourcePort,!0),this.targetLoosePoly=this.SetPortVerticesAndObstacles(e.targetPort,!1);for(let i of this.EdgesToRoutes.get(e))for(let n of this.CrossedCdtEdgesOfBoneEdge(i))this.AdjacentToSourceOrTarget(n)||Kn(t,e,n)}}};var Ao=class{constructor(t,e,i,n,o){this.multiEdges=t,this.interactiveEdgeRouter=e,this.bundlingSettings=n,this.bundlingSettings.edgeWidthShrinkCoeff=1,this.transparentShapeSetter=o,this.nodeTree=Di(i,s=>s.boundingBox)}run(){for(let t of this.GetIndependantPreGraphs())new Zi(t.edges,new Hr(this.transparentShapeSetter,null,null),this.interactiveEdgeRouter.VisibilityGraph,this.bundlingSettings,this.interactiveEdgeRouter.LoosePadding,this.interactiveEdgeRouter.TightHierarchy,this.interactiveEdgeRouter.LooseHierarchy,null,null,null).run()}GetPortCurve(t){return this.nodeTree.FirstHitNodeWithPredicate(t.Location,(i,n)=>E.PointRelativeToCurveLocation(i,n)!==0?1:0).UserData}GetIndependantPreGraphs(){let t=this.CreateInitialPregraphs();do{let e=t.length,i={preGraphs:t};if(this.UniteConnectedPreGraphs(i),e<=t.length)break}while(!0);return t}UniteConnectedPreGraphs(t){let e=Ao.GetIntersectionGraphOfPreGraphs(t.preGraphs);if(e==null)return;let i=Zr(e),n=new Array;for(let o of i){let s=null;for(let a of o)s==null?(s=t.preGraphs[a],n.push(s)):s.AddGraph(t.preGraphs[a])}t.preGraphs=n;for(let o of t.preGraphs)this.AddIntersectingNodes(o)}AddIntersectingNodes(t){let e=t.boundingBox;for(let i of this.nodeTree.GetNodeItemsIntersectingRectangle(e))t.AddNodeBoundary(i)}static GetIntersectionGraphOfPreGraphs(t){let e=Ao.EnumeratePairsOfIntersectedPreGraphs(t);return e.length?vt(e,t.length):null}static EnumeratePairsOfIntersectedPreGraphs(t){let e=Array.from(Array(t.length).keys()),i=Di(e,o=>t[o].boundingBox),n=new Array;return tt(i,i,(o,s)=>n.push(new Z(o,s))),n}CreateInitialPregraphs(){return this.multiEdges.map(t=>this.CreatePregraphFromSetOfEdgeGeometries(t))}CreatePregraphFromSetOfEdgeGeometries(t){let e=new Set,i=t[0],n=this.GetPortCurve(i.sourcePort),o=n.boundingBox;e.add(n),e.add(i.targetPort.Curve),o.addRec(i.targetPort.Curve.boundingBox);let s=this.nodeTree.GetNodeItemsIntersectingRectangle(o);for(let a of s)e.add(a);return ds.constructorStatic(t,e)}};var ca=he(Qr(),1);var Yl=class{constructor(){this.triangles=new Set;this.front=new ca.Queue;this.passedTrs=new Set;this.visitedInThreader=new Set}setCdt(t){this.cdt=t,this.cdt.SetInEdges();let e=new Set;for(let i of t.GetTriangles())for(let n of i.Sites)n.Owner!=null&&e.add(n.Owner)}findChannelTriangles(){this.passedTrs.clear();for(let t=this.poly.startPoint;t.next!=null;t=t.next)this.addPiercedTrianglesOnSegment(t.point,t.next.point);this.addSourceTargetTriangles()}addSourceTargetTriangles(){this.addPolyTrianglesForEndStart(this.poly.start),this.addPolyTrianglesForEndStart(this.poly.end)}findSiteTriangle(t){let e=this.cdt.FindSite(t);if(e.Edges)for(let i of e.Edges){let n=i.CcwTriangle;if(n&&fs(n)||(n=i.CwTriangle,n&&fs(n)))return n}if(e.InEdges)for(let i of e.InEdges){let n=i.CcwTriangle;if(n&&fs(n)||(n=i.CwTriangle,n&&fs(n)))return n}return null}addPolyTrianglesForEndStart(t){let e=new Set,i=new ca.Queue(this.findSiteTriangle(t));for(;i.length;){let n=i.dequeue();for(let o of n.Edges){let s=o.GetOtherTriangle_T(n);s&&!e.has(s)&&fs(s)&&(i.enqueue(s),e.add(s))}}for(let n of e)this.triangles.add(n)}addPiercedTrianglesOnSegment(t,e){if(this.extendPassedTrsByContainingPoint(t),this.createThreader(t,e),this.passedTrs.size){this.front=new ca.Queue;return}for(let i of this.threadThrough())this.triangles.add(i)}edgeCanBePierced(t){let e=t.lowerSite.Owner,i=t.upperSite.Owner;return e==this.sourcePoly||i==this.targetPoly||i==this.sourcePoly||e==this.targetPoly||e!=i&&e!==null&&i!==null}padTriangle(t,e){let i=t.Sites.item0.point.add(t.Sites.item1.point).add(t.Sites.item2.point).mul(.3333333333333333),n=new fo;return n.setItem(0,o(t.Sites.item0)),n.setItem(1,o(t.Sites.item1)),n.setItem(2,o(t.Sites.item2)),n;function o(s){let a=s.point.sub(i),u=a.length;return i.add(a.mul((u+e)/u))}}insideSourceOrTargetPoly(t){let e=t.Sites.item0.Owner;return(e===this.sourcePoly||e===this.targetPoly)&&e===t.Sites.item1.Owner&&e===t.Sites.item2.Owner}outsideOfObstacles(t){var i;if(t==null)return!1;let e=(i=t.Sites.item0.Owner)!=null?i:t.Sites.item1.Owner;return e===this.sourcePoly||e===this.targetPoly||!fs(t)}run(t){if(this.triangles.clear(),this.poly=t,this.d=[],t.count<=2||this.cdt==null)return;this.sourcePoly=this.findPoly(t.start),this.targetPoly=this.findPoly(t.end),this.findChannelTriangles();let e=this.getPerimeterEdges();e=this.fillTheCollapedSites(e);let i=new Ee([],[],Array.from(e).map(o=>({A:o.lowerSite.point,B:o.upperSite.point})));i.run();let n=this.getSleeve(this.findSourceTriangle(i));if(n==null){console.log("failed to create sleeve");return}if(n.length==0){this.poly=j.mkFromPoints([t.start,t.end]);return}this.initDiagonals(n),this.refineFunnel()}findPoly(t){var i;let e=this.cdt.FindSite(t);for(let n of e.Edges)return(i=n.lowerSite.Owner)!=null?i:n.upperSite.Owner}fillTheCollapedSites(t){let e=new Map;for(let o of t)n(o.lowerSite,o),n(o.upperSite,o);let i=[];for(let[o,s]of e)s.length>2&&i.push(o);if(i.length==0)return t;for(let o of i)for(let s of o.Triangles())this.outsideOfObstacles(s)&&this.triangles.add(s);return this.getPerimeterEdges();function n(o,s){let a=e.get(o);a==null&&e.set(o,a=[]),a.push(s)}}findSourceTriangle(t){let e;for(let i of t.GetTriangles())if(i.containsPoint(this.poly.start)){e=i;break}return e}refineFunnel(){let t=[],e=this.poly.start,i={point:e},n={point:e},o={point:this.d[0].left,prev:i},s={point:this.d[0].right,prev:n};i.next=o,n.next=s;let a;for(let N=1;N<this.d.length;N++)h(N,this.d);this.d.push({right:this.poly.end,left:o.point}),h(this.d.length-1,this.d);let u=j.mkFromPoints(t);for(let N=n;N!=null;N=N.next)u.addPoint(N.point);this.poly=u;function h(N,q){if(q[N-1].left!==q[N].left){a=q[N].left;let ve=o;for(;!(M(ve)||P(ve));ve=ve.prev);M(ve)?A():$(ve)}else{a=q[N].right;let ve=s;for(;!(M(ve)||v(ve));ve=ve.prev);M(ve)?O():z(ve)}}function c(N){return N.next==null?!0:d.pointToTheLeftOfLineOrOnLine(a,N.point,N.next.point)}function f(N){return N.next==null?!0:d.pointToTheRightOfLineOrOnLine(a,N.point,N.next.point)}function P(N){return d.pointToTheLeftOfLine(a,N.prev.point,N.point)}function v(N){return d.pointToTheRightOfLine(a,N.prev.point,N.point)}function A(){let N=n;for(;!c(N);)N=N.next;if(!M(N)){let q=n;for(;!q.point.equal(N.point);q=q.next)t.push(q.point);n.point=q.point,n.next=q.next,e=q.point,s.point.equal(n.point)&&(s.prev=s.next=null)}i.point=e,o.point=a,o.prev=i,i.next=o}function O(){let N=i;for(;!f(N);)N=N.next;if(!M(N)){let q=i;for(;!q.point.equal(N.point);q=q.next)t.push(q.point);i.point=q.point,i.next=q.next,e=q.point,o.point.equal(i.point)&&(o.prev=i.next=null)}n.point=e,s.point=a,s.prev=n,n.next=s}function M(N){return N.point==e}function z(N){N!=s?(s.point=a,s.prev=N,N.next=s):(s={point:a,prev:N},N.next=s)}function $(N){N!=o?(o.point=a,o.prev=N,N.next=o):(o={point:a,prev:N},N.next=o)}}initDiagonals(t){for(let e of t){let i=e.edge,n=e.source.OppositeSite(i);d.getTriangleOrientation(n.point,i.lowerSite.point,i.upperSite.point)==1?this.d.push({left:i.upperSite.point,right:i.lowerSite.point}):this.d.push({right:i.upperSite.point,left:i.lowerSite.point})}}getSleeve(t){let e=new ca.Queue;e.enqueue(t);let i=new Map;for(i.set(t,void 0);e.length>0;){let n=e.dequeue(),o=i.get(n);if(n.containsPoint(this.poly.end))return this.recoverPath(t,i,n);for(let s of n.Edges){if(s.constrained||o!==void 0&&s===o)continue;let a=s.GetOtherTriangle_T(n);a!=null&&(i.has(a)||(i.set(a,s),e.enqueue(a)))}}}recoverPath(t,e,i){let n=[];for(let o=i;o!=t&&o!==t;){let s=e.get(o);o=s.GetOtherTriangle_T(o),n.push({source:o,edge:s})}return n.reverse()}getPerimeterEdges(){let t=new Set;for(let e of this.triangles)for(let i of e.Edges)this.triangles.has(i.GetOtherTriangle_T(e))||t.add(i);return t}canPierce(t,e){return t&&!this.visitedInThreader.has(e.GetOtherTriangle_T(t))&&this.edgeCanBePierced(e)}createThreader(t,e){this.start=t,this.end=e,this.visitedInThreader.clear();let i=Array.from(this.passedTrs).map(n=>n);this.passedTrs.clear();for(let n of i)this.initFront(n)}initFront(t){t.containsPoint(this.end)&&(this.passedTrs.add(t),this.triangles.add(t));let e=this.GetHyperplaneSign(t.Sites.item0),i=this.GetHyperplaneSign(t.Sites.item1);if(this.canPierce(t,t.Edges.item0)&&e!==i&&d.getTriangleOrientation(this.end,t.Sites.item0.point,t.Sites.item1.point)==0){let o={source:t,edge:t.Edges.item0,rightSign:e,leftSign:i};this.enqueueInFront(o)}let n=this.GetHyperplaneSign(t.Sites.item2);if(this.canPierce(t,t.Edges.item1)&&i!==n&&d.getTriangleOrientation(this.end,t.Sites.item1.point,t.Sites.item2.point)==0){let o={source:t,edge:t.Edges.item1,rightSign:i,leftSign:n};this.enqueueInFront(o)}if(this.canPierce(t,t.Edges.item2)&&e!==n&&d.getTriangleOrientation(this.end,t.Sites.item2.point,t.Sites.item0.point)==0){let o={source:t,edge:t.Edges.item2,rightSign:n,leftSign:e};this.enqueueInFront(o)}}enqueueInFront(t){this.front.enqueue(t)}processFrontEdge(t){let e=Hp(t);if(e==null)return;if(this.visitedInThreader.add(e),e.containsPoint(this.end)){this.passedTrs.add(e);return}let i=e.Edges.index(t.edge),n=e.Sites.getItem(i+2),o=this.canPierce(e,e.Edges.getItem(i+1)),s=this.canPierce(e,e.Edges.getItem(i+2));if(!o&&!s)return;let a=this.GetHyperplaneSign(n);o&&a<t.rightSign&&this.enqueueInFront({source:e,edge:e.Edges.getItem(i+1),leftSign:a,rightSign:t.rightSign}),s&&a>t.leftSign&&this.enqueueInFront({source:e,edge:e.Edges.getItem(i+2),leftSign:t.leftSign,rightSign:a})}extendPassedTrsByContainingPoint(t){let e=this.cdt.FindSite(t);if(e)for(let i of e.Triangles())this.outsideOfObstacles(i)&&(this.passedTrs.add(i),this.triangles.add(i));else{let i=this.passedTrs.values().next().value;for(let n of i.Edges){let o=n.GetOtherTriangle_T(i);if(this.outsideOfObstacles(o)&&o.containsPoint(t)){this.passedTrs.add(o),this.triangles.add(o);break}}}}*neigborsInChannel(t){for(let e of t.Edges){if(this.edgeCanBePierced(e)===!1)continue;let i=e.GetOtherTriangle_T(t);this.visitedInThreader.has(i)||(yield i)}}GetHyperplaneSign(t){let e=d.signedDoubledTriangleArea(this.start,t.point,this.end);return e>C.distanceEpsilon?1:e<-C.distanceEpsilon?-1:0}*threadThrough(){for(;this.front.length;){let t=this.front.dequeue();this.processFrontEdge(t)}for(let t of this.visitedInThreader)yield t}};function fs(l){return l.Sites.item0.Owner==null||l.Sites.item1.Owner==null||l.Sites.item2.Owner==null?!0:l.Sites.item0.Owner==l.Sites.item1.Owner&&l.Sites.item0.Owner==l.Sites.item2.Owner}function Hp(l){return l.edge.GetOtherTriangle_T(l.source)}var fe=class extends _{constructor(e,i,n=1,o=2,s=30*(Math.PI/180),a=null,u=null){super(u);this.continueOnOverlaps=!0;this.shapesToTightLooseCouples=new Map;this.multiEdgesSeparation=.5;this.routeMultiEdgesAsBundles=!0;this.UsePolylineEndShortcutting=!0;this.UseInnerPolylingShortcutting=!0;this.AllowedShootingStraightLines=!0;this._overlapsDetected=!1;this.edges=i,this.BundlingSettings=a,this.geomGraph=e,this.LoosePadding=o,this.tightPadding=n,this.coneAngle=s,this.routeMultiEdgesAsBundles=i.length<1e3&&e.deepNodeCount<1e3}get ContinueOnOverlaps(){return this.continueOnOverlaps}set ContinueOnOverlaps(e){this.continueOnOverlaps=e}get LoosePadding(){return this.loosePadding}set LoosePadding(e){this.loosePadding=e}get MultiEdgesSeparation(){return this.multiEdgesSeparation}set MultiEdgesSeparation(e){this.multiEdgesSeparation=e}static mk2(e,i){return fe.mk5(e,i.Padding,i.PolylinePadding,i.ConeAngle,i.bundlingSettings)}static mk4(e,i,n,o){return new fe(e,Array.from(e.deepEdges),i,n,o,null)}static mk5(e,i,n,o,s){return new fe(e,Array.from(e.deepEdges),i,n,o,s)}static mk6(e,i,n,o,s,a){let u=fe.mk4(e,i,n,o),h=hr.GetShapes(s,a);return u.Initialize(h,o),u}Initialize(e,i){this.rootShapes=e.filter(n=>n.Parents==null||n.Parents.length===0),this.coneAngle=i,this.coneAngle===0&&(this.coneAngle=Math.PI/6)}run(){if(this.edges.length==0||this.geomGraph.isEmpty())return;let e=It.GetShapes(this.geomGraph,this.edges);this.BundlingSettings==null&&this.geomGraph.layoutSettings&&this.geomGraph.layoutSettings.commonSettings.edgeRoutingSettings&&this.geomGraph.layoutSettings.commonSettings.edgeRoutingSettings.bundlingSettings&&(this.BundlingSettings=this.geomGraph.layoutSettings.commonSettings.edgeRoutingSettings.bundlingSettings),this.Initialize(e,this.coneAngle),this.GetOrCreateRoot(),this.RouteOnRoot(),this.RemoveRoot()}rerouteOnSubsetOfNodes(e){this.RouteMultiEdgesAsBundles=!1,this.edges=Array.from(this.geomGraph.deepEdges).filter(n=>ws(n.edge,e));let i=It.GetShapes(this.geomGraph,this.edges);this.rootShapes=i.filter(n=>n.Parents==null||n.Parents.length===0),this.GetOrCreateRoot(),this.CalculateShapeToBoundaries(this.root),this.calcLooseShapesToNodes(),this.CalculatePortsToShapes(),this.rerouteOnActiveNodes(e),this.RemoveRoot()}calcLooseShapesToNodes(){if(this.loosePolylinesToNodes=new Map,!this.OverlapsDetected){for(let[n,o]of this.shapesToTightLooseCouples)this.loosePolylinesToNodes.set(o.LooseShape.BoundaryCurve,new Set([n.node.node]));return}let e=Di(this.geomGraph.nodesBreadthFirst,n=>n.boundingBox),i=this.GetLooseHierarchy();Et(i,e,(n,o)=>{if(E.CurveIsInsideOther(o.boundaryCurve,n)){let s=this.loosePolylinesToNodes.get(n);for(let a of o.getAncestors())if(!(a instanceof ne&&a.parent==null)&&a.boundaryCurve!=null&&E.CurveIsInsideOther(a.boundaryCurve,n))return;s==null&&this.loosePolylinesToNodes.set(n,s=new Set),s.add(o.node)}})}RouteOnRoot(){yn(0),this.CalculatePortsToShapes(),this.CalculatePortsToEnterableShapes(),this.CalculateShapeToBoundaries(this.root),!(this.OverlapsDetected&&!this.ContinueOnOverlaps)&&(this.BindLooseShapes(),this.SetLoosePolylinesForAnywherePorts(),this.CalculateVisibilityGraph(),this.RouteOnVisGraph())}CalculatePortsToEnterableShapes(){this.portsToEnterableShapes=new Map;for(let[e,i]of this.portsToShapes){let n=new Set;fe.EdgesAttachedToPortAvoidTheNode(e)||n.add(i),this.portsToEnterableShapes.set(e,n)}for(let e of this.rootShapes)for(let i of e.Descendants())for(let n of i.Ports){let o=this.portsToEnterableShapes.get(n);sn(o,Array.from(i.Ancestors()).filter(s=>s.BoundaryCurve!=null))}}static EdgesAttachedToPortAvoidTheNode(e){return e instanceof Ct||e instanceof St}SetLoosePolylinesForAnywherePorts(){for(let[e,i]of this.shapesToTightLooseCouples)for(let n of e.Ports){if(n instanceof Ze){let s=n;s.LoosePolyline=i.LooseShape.BoundaryCurve}if(n instanceof St){let s=n;s.LoosePolyline=i.LooseShape.BoundaryCurve}}}BindLooseShapes(){this.looseRoot=new Xr;for(let e of this.root.Children){let i=this.shapesToTightLooseCouples.get(e).LooseShape;this.BindLooseShapesUnderShape(e),this.looseRoot.AddChild(i)}}BindLooseShapesUnderShape(e){let i=this.shapesToTightLooseCouples.get(e).LooseShape;for(let n of e.Children){let o=this.shapesToTightLooseCouples.get(n).LooseShape;i.AddChild(o),this.BindLooseShapesUnderShape(n)}}CalculateShapeToBoundaries(e){if(this.ProgressStep(),e.Children.length!==0){for(let i of e.Children)this.CalculateShapeToBoundaries(i);this.obstacleCalculator=new Xo(e,this.tightPadding,this.AdjustedLoosePadding,this.shapesToTightLooseCouples),this.obstacleCalculator.Calculate(.01),this.OverlapsDetected||(this.OverlapsDetected=this.obstacleCalculator.OverlapsDetected)}}get OverlapsDetected(){return this._overlapsDetected}set OverlapsDetected(e){this._overlapsDetected=e}get AdjustedLoosePadding(){return this.BundlingSettings==null?this.LoosePadding:this.LoosePadding*Zi.SuperLoosePaddingCoefficient}GroupEdgesByPassport(){let e=new Array;for(let i of this.edges){let n=this.EdgePassport(i),o=e.find(s=>$n(s.passport,n));o||(o={passport:n,edges:[]},e.push(o)),o.edges.push(i)}return e}RouteOnVisGraph(){if(this.ancestorSets=fe.GetAncestorSetsMap(Array.from(this.root.Descendants())),this.BundlingSettings==null){let e=this.GroupEdgesByPassport();for(let i=0;i<e.length;i++){let n=e[i],o=n.passport,s=this.GetObstaclesFromPassport(o),a=this.CreateInteractiveEdgeRouter(Array.from(s));this.RouteEdgesWithTheSamePassport(n,a,s)}}else this.RouteBundles()}rerouteOnActiveNodes(e){if(this.ancestorSets=fe.GetAncestorSetsMap(Array.from(this.root.Descendants())),this.BundlingSettings==null)for(let i of this.GroupEdgesByPassport()){let n=i.passport,o=this.GetObstaclesFromPassport(n),s=new Set;for(let u of o){let h=this.LooseShapeOfOriginalShape(u);for(let c of this.loosePolylinesToNodes.get(h.BoundaryCurve))e.has(c)&&s.add(u)}let a=this.CreateInteractiveEdgeRouter(Array.from(s));this.rerouteEdgesWithTheSamePassportActiveNodes(i,a,s,e)}else this.RouteBundles()}getDebugCurvesFromEdgesAndCdt(e){let i=Array.from(this.geomGraph.deepEdges).map(n=>n.curve).filter(n=>n!=null).filter(n=>n.count>5).map(n=>oe.mkDebugCurveTWCI(200,1,"Red",n));for(let n of e.PointsToSites.values())for(let o of n.Edges)i.push(oe.mkDebugCurveTWCI(200,.5,o.constrained?"Blue":"Green",w.mkPP(o.lowerSite.point,o.upperSite.point)));return i}RouteEdgesWithTheSamePassport(e,i,n){let o={regularEdges:[],multiEdges:[]};try{let s=this.getCdtFromPassport(n);i.pathOptimizer.setCdt(s)}catch(s){i.pathOptimizer.setCdt(null)}if(this.RouteMultiEdgesAsBundles){if(this.SplitOnRegularAndMultiedges(e.edges,o),o.regularEdges.length>0)for(let s=0;s<o.regularEdges.length;s++)this.routeEdge(i,o.regularEdges[s]);o.multiEdges!=null&&(this.ScaleDownLooseHierarchy(i,n),this.RouteMultiEdges(o.multiEdges,i,e.passport))}else for(let s=0;s<e.edges.length;s++)this.routeEdge(i,e.edges[s])}rerouteEdgesWithTheSamePassportActiveNodes(e,i,n,o){let s={regularEdges:[],multiEdges:[]};try{let a=this.getCdtFromPassport(n);i.pathOptimizer.setCdt(a)}catch(a){console.log(a),i.pathOptimizer.setCdt(null)}if(this.RouteMultiEdgesAsBundles){if(this.SplitOnRegularAndMultiedges(e.edges,s),s.regularEdges.length>0)for(let a=0;a<s.regularEdges.length;a++){let u=s.regularEdges[a];le.assert(ws(u.edge,o)),this.rerouteEdge(i,u)}s.multiEdges!=null&&(this.ScaleDownLooseHierarchy(i,n),this.RouteMultiEdges(s.multiEdges,i,e.passport))}else for(let a=0;a<e.edges.length;a++){let u=e.edges[a];ws(u.edge,o)&&this.rerouteEdge(i,u)}}rerouteEdge(e,i){try{e.rerouteEdge(i),We.trimSplineAndCalculateArrowheadsII(i,i.sourcePort.Curve,i.targetPort.Curve,i.curve,!1)}catch(n){}}getCdtFromPassport(e){let i=new Set,n=[],o=D.mkEmpty();for(let u of e){let h=this.LoosePolyOfOriginalShape(u);if(h!=null){i.add(h);for(let c of u.Ports)n.push(c.Location);o.addRecSelf(h.boundingBox)}}o.pad(Math.max(o.diagonal/4,100));let s=Array.from(i);s.push(o.perimeter());let a=new Ee(n,s,[]);return a.run(),a}get RouteMultiEdgesAsBundles(){return this.routeMultiEdgesAsBundles}set RouteMultiEdgesAsBundles(e){this.routeMultiEdgesAsBundles=e}routeEdge(e,i){let n=this.makeTransparentShapesOfEdgeAndGetTheShapes(i);this.ProgressStep(),this.RouteEdgeInternal(i,e),fe.SetTransparency(n,!1)}ScaleDownLooseHierarchy(e,i){let n=new Array;for(let o of i){let s=this.shapesToTightLooseCouples.get(o);n.push(lt.LoosePolylineWithFewCorners(s.TightPolyline,s.Distance/1.1,0))}e.LooseHierarchy=fe.CreateLooseObstacleHierarachy(n),e.ClearActivePolygons(),e.AddActivePolygons(n.map(o=>new at(o)))}RouteMultiEdges(e,i,n){let o=[];for(let u of n)for(let h of u.Children)o.push(h.BoundaryCurve);let s=new Dr;s.InkImportance=1e-5,s.EdgeSeparation=this.MultiEdgesSeparation,new Ao(e,i,o,s,u=>this.makeTransparentShapesOfEdgeAndGetTheShapes(u)).run()}SplitOnRegularAndMultiedges(e,i){let n=new Nr;for(let o of e)fe.IsEdgeToParent(o)?i.regularEdges.push(o):fe.RegisterInPortLocationsToEdges(o,n);i.multiEdges=null;for(let o of n.values())o.length===1||this.OverlapsDetected?di(i.regularEdges,o):(i.multiEdges==null&&(i.multiEdges=new Array),i.multiEdges.push(o))}static RegisterInPortLocationsToEdges(e,i){let n,o=new ke(e.sourcePort.Location,e.targetPort.Location);n=i.get(o),n||(n=new Array,i.set(o,n)),n.push(e)}static IsEdgeToParent(e){return e.sourcePort instanceof Ze||e.targetPort instanceof Ze}CreateInteractiveEdgeRouter(e){let i=new Set(e.map(o=>this.shapesToTightLooseCouples.get(o).LooseShape.BoundaryCurve)),n=new Ce(this.cancelToken);return n.pathOptimizer=new Yl,n.ObstacleCalculator=new lt(e.map(o=>o.BoundaryCurve),this.tightPadding,this.loosePadding,!1),n.VisibilityGraph=this.visGraph,n.TightHierarchy=this.CreateTightObstacleHierarachy(e),n.LooseHierarchy=fe.CreateLooseObstacleHierarachy(Array.from(i)),n.UseSpanner=!0,n.LookForRoundedVertices=!0,n.TightPadding=this.tightPadding,n.LoosePadding=this.LoosePadding,n.UseEdgeLengthMultiplier=this.UseEdgeLengthMultiplier,n.UsePolylineEndShortcutting=this.UsePolylineEndShortcutting,n.UseInnerPolylingShortcutting=this.UseInnerPolylingShortcutting,n.AllowedShootingStraightLines=this.AllowedShootingStraightLines,n.AddActivePolygons(Array.from(i).map(o=>new at(o))),n}GetObstaclesFromPassport(e){if(e.size===0)return new Set(this.root.Children);let i=this.GetCommonAncestorsAbovePassport(e),n=this.GetAllAncestors(e),o=new Set;for(let u of e)for(let h of u.Children)n.has(h)||o.add(h);let s=Ur(new Set(e),o),a=new jd.Queue;for(let u of e)i.has(u)||a.enqueue(u);for(;a.length>0;){let u=a.dequeue();for(let h of u.Parents){for(let c of h.Children)n.has(c)||o.add(c);!i.has(h)&&!s.has(h)&&(a.enqueue(h),s.add(h))}}return o}GetAllAncestors(e){if(e.size===0)return new Set;let i=new Set(e);for(let n of e)i=Ur(i,this.ancestorSets.get(n));return i}GetCommonAncestorsAbovePassport(e){if(e.size===0)return new Set;let i=Array.from(e),n=this.ancestorSets.get(i[0]);for(let o=1;o<i.length;o++){let s=i[o];n=jr(n,this.ancestorSets.get(s))}return n}RouteBundles(){this.ScaleLooseShapesDown(),this.CalculateEdgeEnterablePolylines();let e=this.GetLooseHierarchy(),i=Ol(e),n=new Hr(s=>this.makeTransparentShapesOfEdgeAndGetTheShapes(s),i,this.FindCdtGates(i));new Zi(this.edges,n,this.visGraph,this.BundlingSettings,this.LoosePadding,this.GetTightHierarchy(),e,this.enterableLoose,this.enterableTight,s=>this.LoosePolyOfOriginalShape(this.portsToShapes.get(s))).run()}CreateTheMapToParentLooseShapes(e,i){for(let n of e.Children){let s=this.shapesToTightLooseCouples.get(n).LooseShape.BoundaryCurve;i.set(s,e),this.CreateTheMapToParentLooseShapes(n,i)}}FindCdtGates(e){let i=new Map;this.CreateTheMapToParentLooseShapes(this.root,i);let n=new Set;for(let o of e.PointsToSites.values())for(let s of o.Edges){if(s.CwTriangle==null&&s.CcwTriangle==null)continue;let a=o.Owner,u=s.lowerSite.Owner;if(a===u)continue;let h=i.get(a);if(h){let c=i.get(u);h===c&&n.add(s)}}return n}CalculateEdgeEnterablePolylines(){this.enterableLoose=new Map,this.enterableTight=new Map;for(let e of this.edges){let i=new Set,n=new Set;this.GetEdgeEnterablePolylines(e,i,n),this.enterableLoose.set(e,i),this.enterableTight.set(e,n)}}GetEdgeEnterablePolylines(e,i,n){let o=this.portsToShapes.get(e.sourcePort),s=this.portsToShapes.get(e.targetPort);o!==this.root&&this.GetEnterablesForShape(o,i,n),s!==this.root&&this.GetEnterablesForShape(s,i,n)}GetEnterablesForShape(e,i,n){for(let o of this.ancestorSets.get(e)){let s=this.LoosePolyOfOriginalShape(o);s&&i.add(s);let a=this.TightPolyOfOriginalShape(o);a&&n.add(a)}}GetTightHierarchy(){return Oe(Array.from(this.shapesToTightLooseCouples.values()).map(e=>Fe(e.TightPolyline,e.TightPolyline.boundingBox)))}GetLooseHierarchy(){let e=new Set;for(let i of this.shapesToTightLooseCouples.values())e.add(i.LooseShape.BoundaryCurve);return Oe(Array.from(e).map(i=>Fe(i,i.boundingBox)))}ScaleLooseShapesDown(){for(let[,e]of this.shapesToTightLooseCouples)e.LooseShape.BoundaryCurve=lt.LoosePolylineWithFewCorners(e.TightPolyline,e.Distance/Zi.SuperLoosePaddingCoefficient,0)}EdgePassport(e){let i=new Set,n=this.portsToShapes.get(e.sourcePort),o=this.portsToShapes.get(e.targetPort);return this.IsAncestor(n,o)?(sn(i,o.Parents),i.add(n),i):this.IsAncestor(o,n)?(sn(i,n.Parents),i.add(o),i):(n!==this.looseRoot&&sn(i,n.Parents),o!==this.looseRoot&&sn(i,o.Parents),i)}*AllPorts(){for(let e of this.edges)yield e.sourcePort,yield e.targetPort}CalculatePortsToShapes(){this.portsToShapes=new Map;for(let e of this.root.Descendants())for(let i of e.Ports)this.portsToShapes.set(i,e);for(let e of this.AllPorts())this.portsToShapes.has(e)||(this.root.Ports.add(e),this.portsToShapes.set(e,this.root))}RouteEdgeInternal(e,i){let n=new Array;e.sourcePort instanceof Ze||di(n,this.AddVisibilityEdgesFromPort(e.sourcePort)),e.targetPort instanceof Ze||di(n,this.AddVisibilityEdgesFromPort(e.targetPort));let o={smoothedPolyline:null};if(d.closeDistEps(e.sourcePort.Location,e.targetPort.Location)?e.curve=Re.RouteSelfEdge(e.sourcePort.Curve,Math.max(this.LoosePadding*2,e.GetMaxArrowheadLength()),o):e.curve=i.RouteSplineFromPortToPortWhenTheWholeGraphIsReady(e.sourcePort,e.targetPort,!0,o),e.smoothedPolyline=o.smoothedPolyline,e.curve==null)throw new Error;for(let s of n)Ie.RemoveEdge(s);We.trimSplineAndCalculateArrowheadsII(e,e.sourcePort.Curve,e.targetPort.Curve,e.curve,!1)}*AddVisibilityEdgesFromPort(e){let i,n;if(e instanceof Ct||!(i=this.portsToShapes.get(e))||!(n=this.shapesToTightLooseCouples.get(i)))return;let o=n.LooseShape;for(let s of o.BoundaryCurve)this.visGraph.FindEdgePP(e.Location,s)==null&&(yield this.visGraph.AddEdgePP(e.Location,s))}makeTransparentShapesOfEdgeAndGetTheShapes(e){let i=this.portsToShapes.get(e.sourcePort),n=this.portsToShapes.get(e.targetPort),o=new Array;for(let s of this.GetTransparentShapes(e.sourcePort,e.targetPort,i,n))s!=null&&o.push(this.LooseShapeOfOriginalShape(s));for(let s of this.portsToEnterableShapes.get(e.sourcePort))o.push(this.LooseShapeOfOriginalShape(s));for(let s of this.portsToEnterableShapes.get(e.targetPort))o.push(this.LooseShapeOfOriginalShape(s));return fe.SetTransparency(o,!0),o}LooseShapeOfOriginalShape(e){return e===this.root?this.looseRoot:this.shapesToTightLooseCouples.get(e).LooseShape}LoosePolyOfOriginalShape(e){return this.LooseShapeOfOriginalShape(e).BoundaryCurve}TightPolyOfOriginalShape(e){return e===this.root?null:this.shapesToTightLooseCouples.get(e).TightPolyline}*GetTransparentShapes(e,i,n,o){for(let s of this.ancestorSets.get(n))yield s;for(let s of this.ancestorSets.get(o))yield s;fe.EdgesAttachedToPortAvoidTheNode(e)||(yield n),fe.EdgesAttachedToPortAvoidTheNode(i)||(yield o)}static SetTransparency(e,i){for(let n of e)n.IsTransparent=i}IsAncestor(e,i){let n;return i!=null&&(n=this.ancestorSets.get(i))!=null&&n.has(e)}static CreateLooseObstacleHierarachy(e){return Oe(e.map(i=>Fe(i,i.boundingBox)))}CreateTightObstacleHierarachy(e){let i=e.map(n=>this.shapesToTightLooseCouples.get(n).TightPolyline);return Oe(i.map(n=>Fe(n,n.boundingBox)))}CalculateVisibilityGraph(){let e=this.LineSweeperPorts!=null?Se.mk(this.LineSweeperPorts):new Se;this.ProcessHookAnyWherePorts(e),this.portRTree=ki(Array.from(e.values()).map(i=>[D.rectangleOnPoint(i),i])),this.visGraph=new Ie,this.FillVisibilityGraphUnderShape(this.root)}static ShowVisGraph(e,i,n,o=null,s=null){let a=Array.from(i.Edges).map(u=>oe.mkDebugCurveTWCI(100,1,u.IsPassable!=null&&u.IsPassable()?"green":"black",w.mkPP(u.SourcePoint,u.TargetPoint)));if(n!=null)for(let u of n){a.push(oe.mkDebugCurveTWCI(100,.3,"brown",u));for(let h of u)a.push(oe.mkDebugCurveTWCI(100,1,"green",me.mkCircle(1,h)))}if(o!=null)for(let u of o)a.push(oe.mkDebugCurveTWCI(100,10,"navy",u));if(s!=null)for(let u of s)a.push(oe.mkDebugCurveTWCI(100,10,"red",u))}ProcessHookAnyWherePorts(e){for(let i of this.edges)i.sourcePort instanceof Ze||i.sourcePort instanceof St||e.add(i.sourcePort.Location),i.targetPort instanceof Ze||i.targetPort instanceof St||e.add(i.targetPort.Location)}FillVisibilityGraphUnderShape(e){let i=e.Children;for(let f=0;f<i.length;f++){let P=i[f];this.FillVisibilityGraphUnderShape(P)}let n=this.shapesToTightLooseCouples.get(e),o=n?n.LooseShape.BoundaryCurve:null,s=n?n.LooseShape:this.looseRoot,a=new Set(s.Children.map(f=>f.BoundaryCurve)),u=this.RemoveInsidePortsAndSplitBoundaryIfNeeded(o),h=new Ie,c=yi.mk([],h,this.coneAngle,u,o);c.run(),h=new Ie,c=yi.mk(Array.from(a),h,this.coneAngle,u,o),c.run(),this.ProgressStep();for(let f of h.Edges)this.TryToCreateNewEdgeAndSetIsPassable(f,s);this.AddBoundaryEdgesToVisGraph(o)}TryToCreateNewEdgeAndSetIsPassable(e,i){let n=this.visGraph.FindEdgePP(e.SourcePoint,e.TargetPoint);n==null&&(n=this.visGraph.AddEdgePP(e.SourcePoint,e.TargetPoint),i!=null&&(n.IsPassable=()=>i.IsTransparent))}AddBoundaryEdgesToVisGraph(e){if(e==null)return;let i;for(let n=e.startPoint;i=n.nextOnPolyline,this.visGraph.AddEdgePP(n.point,i.point),i!==e.startPoint;n=i);}RemoveInsidePortsAndSplitBoundaryIfNeeded(e){let i=new Se;if(e==null){for(let s of this.portRTree.GetAllLeaves())i.add(s);return this.portRTree.clear(),i}let n=e.boundingBox,o=this.portRTree.GetAllIntersecting(n);for(let s of o)switch(E.PointRelativeToCurveLocation(s,e)){case 2:i.add(s),this.portRTree.Remove(D.rectangleOnPoint(s),s);break;case 1:this.portRTree.Remove(D.rectangleOnPoint(s),s);let a=fe.FindPointOnPolylineToInsertAfter(e,s);if(a!=null)st.InsertPointIntoPolylineAfter(e,a,s);else throw new Error;break}return i}static FindPointOnPolylineToInsertAfter(e,i){for(let n=e.startPoint;;){let o=n.nextOnPolyline;if(d.closeDistEps(i,n.point)||d.closeDistEps(i,o.point))return null;let s=d.distToLineSegment(i,n.point,o.point).dist;if(Q(s,0))return n;if(n=o,n===e.startPoint)throw new Error}}GetOrCreateRoot(){if(this.rootShapes.length===1){let e=this.rootShapes[0];if(e.BoundaryCurve==null){this.root=e;return}}this.rootWasCreated=!0,this.root=new Xr(null);for(let e of this.rootShapes)this.root.AddChild(e)}RemoveRoot(){if(!!this.rootWasCreated){for(let e of this.rootShapes)e.RemoveParent(this.root);this.root=null,this.rootWasCreated=!1}}static GetAncestorSetsMap(e){let i=new Map;for(let n of e.filter(o=>!i.has(o)))i.set(n,fe.GetAncestorSet(n,i));return i}static GetAncestorSet(e,i){let n=new Set(e.Parents);for(let o of e.Parents){let s=i.get(o);s||i.set(o,s=fe.GetAncestorSet(o,i));for(let a of s)n.add(a)}return n}static CreatePortsIfNeeded(e){for(let i of e){if(i.sourcePort==null){let n=i;new Rt(()=>n.source.boundaryCurve,()=>n.source.center,new d(0,0))}if(i.targetPort==null){let n=i;new Rt(()=>n.target.boundaryCurve,()=>n.target.center,new d(0,0))}}}};function Hd(l,t,e){let i=Ah(l);new fe(l,t,i.Padding,i.PolylinePadding,i.coneAngle,i.bundlingSettings,e).run()}var _i=class extends Vi{toString(){return"label of "+(this.parent?this.parent.toString():"null")}constructor(t){super(),this.parent=t}};var Gi=class extends ft{constructor(e,i){super();this.SetEdges(e,i)}};var Zl=class{constructor(t){this.MultipleMiddles=new Set;this.Multiedges=new ar(t)}*RegularMultiedges(){for(let[t,e]of this.Multiedges.keyValues())t.x!==t.y&&(yield e)}*AllIntEdges(){for(let t of this.Multiedges.values())for(let e of t)yield e}addFeedbackSet(t){for(let e of t){let i=new Z(e.source,e.target),n=new Z(e.target,e.source),o=this.Multiedges.get(i.x,i.y);for(let s of o)s.reverse();if(this.Multiedges.has(n.x,n.y)){let s=this.Multiedges.get(n.x,n.y);for(let a of o)s.push(a)}else this.Multiedges.set(n.x,n.y,o);this.Multiedges.delete(i.x,i.y)}}registerOriginalEdgeInMultiedges(t){let e=this.Multiedges.get(t.source,t.target);e==null&&this.Multiedges.set(t.source,t.target,e=[]),e.push(t)}*SkeletonEdges(){for(let[t,e]of this.Multiedges.keyValues())t.x!==t.y&&(yield e[0])}GetMultiedge(t,e){return this.GetMultiedgeI(new Z(t,e))}GetMultiedgeI(t){return this.Multiedges.has(t.x,t.y)?this.Multiedges.get(t.x,t.y):new Array}};function da(l,t){for(let e=0;e<l.length;e++)t[e]=l[e]}var fr=class{constructor(t){this.initialize(t)}initialize(t){this.y=t,this.verticesToX=null,this.layers=null}DropEmptyLayers(){let t=new Array(this.Layers.length),e=0;for(let s=0;s<this.Layers.length;s++)t[s]=e,this.Layers[s].length===0&&e++;if(e===0)return this;let i=new Array(this.y.length);for(let s=0;s<i.length;s++)i[s]=this.y[s]-t[this.y[s]];let n=new Array(this.layers.length-e);for(let s=0;s<this.layers.length;s++)this.layers[s].length>0&&(n[s-t[s]]=Array.from(this.layers[s]));let o=new fr(i);return o.layers=n,o}updateLayers(t){this.layers==null&&this.InitLayers();for(let e=0;e<this.layers.length;e++)da(t[e],this.layers[e]);this.UpdateXFromLayers()}UpdateXFromLayers(){this.layers==null&&this.InitLayers(),this.verticesToX==null&&(this.verticesToX=new Array(this.y.length));for(let t of this.layers){let e=0;for(let i of t)this.verticesToX[i]=e++}}get x(){return this.verticesToX!=null?this.verticesToX:(this.verticesToX=new Array(this.y.length),this.UpdateXFromLayers(),this.verticesToX)}ReversedClone(){let t=new Array(this.y.length),e=this.Layers.length-1;for(let i=0;i<this.y.length;i++)t[i]=e-this.y[i];return new fr(t)}get Layers(){return this.layers!=null?this.layers:(this.InitLayers(),this.layers)}set Layers(t){this.layers=t}InitLayers(){let t=0;for(let i of this.y)i+1>t&&(t=i+1);let e=new Array(t).fill(0);for(let i of this.y)e[i]++;this.layers=new Array(t);for(let i=0;i<t;i++)this.layers[i]=new Array(e[i]),e[i]=0;for(let i=0;i<this.y.length;i++){let n=this.y[i];this.layers[n][e[n]++]=i}}};var ps=class extends _{constructor(e,i,n,o){super(o);this.jumpers=new Set;this.possibleJumperFeasibleIntervals=new Map;this.nodeCount=n,this.dag=e,this.layering=i,this.Init()}static Balance(e,i,n,o){new ps(e,i,n,o).run()}run(){for(;this.jumpers.size>0;)this.Jump(this.ChooseJumper())}Init(){this.CalculateLayerCounts(),this.InitJumpers()}Jump(e){this.jumpers.delete(e);let i=this.possibleJumperFeasibleIntervals.get(e),n=this.CalcJumpInfo(i.x,i.y,e);if(n==null)return;this.layering[e]=n.layerToJumpTo;let o=this.nodeCount[e];this.vertsCounts[n.jumperLayer]-=o,this.vertsCounts[n.layerToJumpTo]+=o,this.UpdateRegionsForPossibleJumpersAndInsertJumpers(n.jumperLayer,e)}IsJumper(e){return this.possibleJumperFeasibleIntervals.has(e)}UpdateRegionsForPossibleJumpersAndInsertJumpers(e,i){let n=new Set;for(let s of this.dag.pred(i))this.IsJumper(s)&&(this.CalculateRegionAndInsertJumper(s),n.add(s));for(let s of this.dag.succ(i))this.IsJumper(s)&&(this.CalculateRegionAndInsertJumper(s),n.add(s));let o=new Array;for(let s of this.possibleJumperFeasibleIntervals)n.has(s[0])||s[1].x>e&&s[1].y<e&&o.push(s[0]);for(let s of o)this.CalculateRegionAndInsertJumper(s)}InitJumpers(){let e=new Array(this.dag.nodeCount).fill(0);for(let i of this.dag.edges)e[i.source]-=i.weight,e[i.target]+=i.weight;this.possibleJumperFeasibleIntervals=new Map;for(let i=0;i<this.dag.nodeCount;i++)e[i]===0&&this.CalculateRegionAndInsertJumper(i)}CalculateRegionAndInsertJumper(e){let i=new Z(this.Up(e),this.Down(e));this.possibleJumperFeasibleIntervals.set(e,i),this.InsertJumper(i.x,i.y,e)}InsertJumper(e,i,n){this.CalcJumpInfo(e,i,n)!=null&&this.jumpers.add(n)}CalcJumpInfo(e,i,n){let o=this.layering[n],s=-1,a=this.vertsCounts[o]-2*this.nodeCount[n];for(let u=e-1;u>o;u--)this.vertsCounts[u]<a&&(a=this.vertsCounts[u],s=u);for(let u=o-1;u>i;u--)this.vertsCounts[u]<a&&(a=this.vertsCounts[u],s=u);if(s!==-1)return{jumperLayer:o,layerToJumpTo:s}}Up(e){let i=Number.MAX_SAFE_INTEGER;for(let n of this.dag.inEdges[e]){let o=this.layering[n.source]-n.separation+1;o<i&&(i=o)}return i===Number.MAX_SAFE_INTEGER&&(i=this.layering[e]+1),i}Down(e){let i=Number.NEGATIVE_INFINITY;for(let n of this.dag.outEdges[e]){let o=this.layering[n.target]+n.separation-1;o>i&&(i=o)}return i===Number.NEGATIVE_INFINITY&&(i=this.layering[e]-1),i}CalculateLayerCounts(){this.vertsCounts=new Array(Math.max(...this.layering)+1).fill(0);for(let e of this.layering)this.vertsCounts[e]+=this.nodeCount[e]}ChooseJumper(){for(let e of this.jumpers)return e;throw new Error("there are no jumpers to choose")}};var zr=class{constructor(t){this.Initialize(t)}Initialize(t){this.BaseGraph=t,this.totalNumberOfNodes=t.nodeCount;for(let e of this.BaseGraph.edges)if(e.LayerEdges!=null)for(let i of e.LayerEdges){let n=Math.max(i.Source,i.Target)+1;n>this.totalNumberOfNodes&&(this.totalNumberOfNodes=n)}this.firstVirtualNode=Number.POSITIVE_INFINITY;for(let e of this.BaseGraph.edges)if(e.LayerEdges!=null)for(let i=1;i<e.LayerEdges.length;i++){let n=e.LayerEdges[i];this.firstVirtualNode=Math.min(this.firstVirtualNode,n.Source)}this.firstVirtualNode===Number.POSITIVE_INFINITY&&(this.firstVirtualNode=this.BaseGraph.nodeCount,this.totalNumberOfNodes=this.BaseGraph.nodeCount),this.virtualNodesToInEdges=new Array(this.totalNumberOfNodes-this.firstVirtualNode),this.virtualNodesToOutEdges=new Array(this.totalNumberOfNodes-this.firstVirtualNode);for(let e of this.BaseGraph.edges)if(e.LayerSpan>0)for(let i of e.LayerEdges)i.Target!==e.target&&(this.virtualNodesToInEdges[i.Target-this.firstVirtualNode]=i),i.Source!==e.source&&(this.virtualNodesToOutEdges[i.Source-this.firstVirtualNode]=i)}*edges_(){for(let t of this.BaseGraph.edges)if(t.LayerSpan>0)for(let e of t.LayerEdges)yield e}get Edges(){return this.edges_()}*InEdges(t){if(t<this.BaseGraph.nodeCount)for(let e of this.BaseGraph.inEdges[t])e.source!==e.target&&e.LayerEdges!=null&&(yield zr.LastEdge(e));else t>=this.firstVirtualNode&&(yield this.InEdgeOfVirtualNode(t))}static LastEdge(t){return t.LayerEdges[t.LayerEdges.length-1]}InEdgeOfVirtualNode(t){return this.virtualNodesToInEdges[t-this.firstVirtualNode]}*OutEdges(t){if(t<this.BaseGraph.nodeCount)for(let e of this.BaseGraph.outEdges[t])e.source!==e.target&&e.LayerEdges!=null&&(yield zr.FirstEdge(e));else t>=this.firstVirtualNode&&(yield this.OutEdgeOfVirtualNode(t))}OutDegreeIsMoreThanOne(t){return t<this.BaseGraph.nodeCount?this.BaseGraph.outEdges[t].length>1:!1}InDegreeIsMoreThanOne(t){return t<this.BaseGraph.nodeCount?this.BaseGraph.inEdges[t].length>1:!1}OutEdgeOfVirtualNode(t){return this.virtualNodesToOutEdges[t-this.firstVirtualNode]}static FirstEdge(t){return t.LayerEdges[0]}InEdgesCount(t){return this.RealInEdgesCount(t)}RealInEdgesCount(t){return t<this.BaseGraph.nodeCount?this.BaseGraph.inEdges[t].filter(e=>e.LayerEdges!=null).length:1}OutEdgesCount(t){return this.RealOutEdgesCount(t)}RealOutEdgesCount(t){return t<this.BaseGraph.nodeCount?this.BaseGraph.outEdges[t].filter(e=>e.LayerEdges!=null).length:1}get NodeCount(){return this.totalNumberOfNodes}IsRealNode(t){return t<this.BaseGraph.nodeCount}IsVirtualNode(t){return!this.IsRealNode(t)}ReversedClone(){let t=this.CreateReversedEdges();return new zr(new Gi(t,this.BaseGraph.nodeCount))}CreateReversedEdges(){let t=new Array;for(let e of this.BaseGraph.edges)e.isSelfEdge()||t.push(e.reversedClone());return t}*Succ(t){for(let e of this.OutEdges(t))yield e.Target}*Pred(t){for(let e of this.InEdges(t))yield e.Source}};var en=class{constructor(t,e,i,n){this.la=e,this.database=i,this.layeredGraph=t,this.intGraph=n}static InsertLayers(t,e,i,n){let o=new en(t,e,i,n);return o.InsertLayers(),{layeredGraph:o.nLayeredGraph,la:o.Nla.DropEmptyLayers()}}get NLayering(){return this.Nla.y}InsertLayers(){this.EditOldLayering(),this.CreateFullLayeredGraph(),this.InitNewLayering(),this.MapVirtualNodesToEdges(),this.FillUnsortedNewOddLayers(),this.WidenOriginalLayers(),this.SortNewOddLayers()}EditOldLayering(){let t=this.intGraph.nodeCount;for(let e of this.database.RegularMultiedges()){let i=0,n=e[0];if(i=n.LayerSpan*2,i>0){for(let o of n.LayerEdges)o.Target!==n.target&&(t++,this.UpdateOldLayer(t++,o.Target));t+=(i-1)*(e.length-1)+1}}}UpdateOldLayer(t,e){let i=this.la.x[e],n=this.la.y[e],o=this.la.Layers[n];o[i]=t}WidenOriginalLayers(){for(let t=0;t<this.la.Layers.length;t++){let e=this.Nla.Layers[t*2],i=0;for(let n of this.la.Layers[t]){let o=this.virtNodesToIntEdges[n];if(o!=null){let s=this.NLayering[o.source]-this.NLayering[n],a=this.database.Multiedges.get(o.source,o.target);for(let u of a)if(u!==o){let h=u.LayerEdges[s].Source;e[i]=h,this.Nla.x[h]=i++}else e[i]=n,this.Nla.x[n]=i++}else e[i]=n,this.Nla.x[n]=i++}}}FillUnsortedNewOddLayers(){let t=new Array(this.Nla.Layers.length).fill(0);for(let e=this.intGraph.nodeCount;e<this.nLayeredGraph.NodeCount;e++){let i=this.NLayering[e];i%2===1&&(this.Nla.Layers[i][t[i]++]=e)}}MapVirtualNodesToEdges(){this.virtNodesToIntEdges=new Array(this.NLayering.length);for(let t of this.database.AllIntEdges())if(t.source!==t.target&&t.LayerEdges!=null)for(let e of t.LayerEdges)e.Target!==t.target&&(this.virtNodesToIntEdges[e.Target]=t)}CreateFullLayeredGraph(){this.totalNodes=this.intGraph.nodeCount;for(let t of this.database.RegularMultiedges()){let e=0,i=!0;for(let n of t)if(i&&(i=!1,e=n.LayerSpan*2),e>0){n.LayerEdges=new Array(e);for(let o=0;o<e;o++){let s={currentVV:this.totalNodes},a=ri.GetSource(s,n,o);this.totalNodes=s.currentVV;let u=ri.GetTarget(this.totalNodes,n,o,e);n.LayerEdges[o]=new gr(a,u,n.CrossingWeight)}en.RegisterDontStepOnVertex(this.database,n)}}this.nLayeredGraph=new zr(this.intGraph)}SortNewOddLayers(){for(let t=1;t<this.Nla.Layers.length;t+=2){let e=new Ei,i=this.Nla.Layers[t];for(let o of i){let s=-1;for(let h of this.nLayeredGraph.InEdges(o))s=h.Source;let a=-1;for(let h of this.nLayeredGraph.OutEdges(o))a=h.Target;let u=this.Nla.x[s]+this.Nla.x[a];if(e.has(u)){let h=e.get(u);if(typeof h=="number"){let c=new Array;c.push(h),c.push(o),e.set(u,c)}else h.push(o)}else e.set(u,o)}let n=0;for(let o of e.values())if(typeof o=="number")i[n++]=o;else for(let s of o)i[n++]=s;for(let o=0;o<i.length;o++)this.Nla.x[i[o]]=o}}InitNewLayering(){this.Nla=new fr(new Array(this.totalNodes));for(let i=0;i<this.layeredGraph.NodeCount;i++)this.NLayering[i]=this.la.y[i]*2;for(let[i,n]of this.database.Multiedges.keyValues())if(i.x!==i.y&&this.la.y[i.x]!==this.la.y[i.y]){let o=this.la.y[i.x]*2;for(let s of n){let a=o-1;for(let u of s.LayerEdges)u.Target!==s.target&&(this.NLayering[u.Target]=a--)}}let t=new Array(2*this.la.Layers.length-1),e=new Array(t.length).fill(0);for(let i of this.NLayering)e[i]++;for(let i=0;i<e.length;i++)t[i]=new Array(e[i]);this.Nla=new fr(this.NLayering),this.Nla.Layers=t}static RegisterDontStepOnVertex(t,e){if(t.Multiedges.get(e.source,e.target).length>1){let i=e.LayerEdges[e.LayerEdges.length/2];t.MultipleMiddles.add(i.Source)}}};var ri=class{constructor(t,e,i,n){this.virtNodesToIntEdges=new Map;this.la=e,this.database=i,this.layeredGraph=t,this.intGraph=n}get NLayering(){return this.Nla.y}static InsertPaths(t,e,i,n){let o=new ri(t,e,i,n);return o.InsertPaths(),{layeredGraph:o.NLayeredGraph,la:o.Nla}}InsertPaths(){this.CreateFullLayeredGraph(),this.InitNewLayering(),this.MapVirtualNodesToEdges(),this.WidenOriginalLayers()}WidenOriginalLayers(){for(let t=0;t<this.la.Layers.length;t++){let e=this.Nla.Layers[t],i=0;for(let n of this.la.Layers[t]){let o=this.virtNodesToIntEdges.get(n);if(o!=null){let s=this.NLayering[o.source]-this.NLayering[n],a=this.database.Multiedges.get(o.source,o.target);for(let u of a)if(!this.EdgeIsFlat(u))if(u!==o){let h=u.LayerEdges[s].Source;e[i]=h,this.Nla.x[h]=i++}else e[i]=n,this.Nla.x[n]=i++}else e[i]=n,this.Nla.x[n]=i++}}}EdgeIsFlat(t){return this.la.y[t.source]===this.la.y[t.target]}MapVirtualNodesToEdges(){for(let t of this.database.RegularMultiedges())for(let e of t)if(!this.EdgeIsFlat(e))for(let i of e.LayerEdges)i.Target!==e.target&&this.virtNodesToIntEdges.set(i.Target,e)}CreateFullLayeredGraph(){let t=this.layeredGraph.NodeCount;for(let[e,i]of this.database.Multiedges.keyValues())if(e.x!==e.y){let n=!0,o=0;for(let s of i){if(n)n=!1,o=s.LayerSpan;else if(s.LayerEdges=new Array(o),o===1)s.LayerEdges[0]=new gr(s.source,s.target,s.CrossingWeight);else for(let a=0;a<o;a++){let u={currentVV:t},h=ri.GetSource(u,s,a);t=u.currentVV;let c=ri.GetTarget(t,s,a,o);s.LayerEdges[a]=new gr(h,c,s.CrossingWeight)}en.RegisterDontStepOnVertex(this.database,s)}}this.NLayeredGraph=new zr(this.intGraph)}static GetTarget(t,e,i,n){return i<n-1?t:e.target}static GetSource(t,e,i){return i===0?e.source:t.currentVV++}InitNewLayering(){this.Nla=new fr(new Array(this.NLayeredGraph.NodeCount));for(let i=0;i<this.layeredGraph.NodeCount;i++)this.NLayering[i]=this.la.y[i];for(let[i,n]of this.database.Multiedges.keyValues())if(i.x!==i.y&&this.la.y[i.x]!==this.la.y[i.y]){let o=0,s=!0;for(let a of n){s&&(s=!1,o=this.la.y[a.source]);let u=o-1;for(let h of a.LayerEdges)this.NLayering[h.Target]=u--}}let t=new Array(this.la.Layers.length),e=new Array(t.length).fill(0);for(let i of this.NLayering)e[i]++;for(let i=0;i<e.length;i++)t[i]=new Array(e[i]);this.Nla=new fr(this.NLayering),this.Nla.Layers=t}};var jn=class{constructor(t,e,i){this.numberOfCrossings=e,this.la=t,this.virtVertexStart=i}LayerGroupDisbalance(t,e,i){return e===1?this.LayerGroupDisbalanceWithOrigSeparators(t,i):this.LayerGroupDisbalanceWithVirtSeparators(t,e)}LayerGroupDisbalanceWithVirtSeparators(t,e){let i=0;for(let n=0;n<t.length;){let o=this.CurrentOrigGroupDelta(n,t,e);n=o.i,i+=o.ret}return i}CurrentOrigGroupDelta(t,e,i){let n=0,o=t;for(;o<e.length&&e[o]<this.virtVertexStart;o++)n++;return t=o+1,{ret:Math.abs(i-n),i:t}}LayerGroupDisbalanceWithOrigSeparators(t,e){let i=0;for(let n=0;n<t.length;){let o=this.CurrentVirtGroupDelta(n,t,e);i+=o.ret,n=o.i}return i}CurrentVirtGroupDelta(t,e,i){let n=0,o=t;for(;o<e.length&&e[o]>=this.virtVertexStart;o++)n++;return t=o+1,{ret:Math.abs(i-n),i:t}}static less(t,e){return t.numberOfCrossings<e.numberOfCrossings}static greater(t,e){return t.numberOfCrossings>e.numberOfCrossings}IsPerfect(){return this.numberOfCrossings===0}};var Xd=he(Gr(),1);var _l=class{constructor(t){this.x=t}Compare(t,e){let i=this.x[t.Source]-this.x[e.Source];return i!==0?i:this.x[t.Target]-this.x[e.Target]}};var eu=class{constructor(t){this.x=t}Compare(t,e){let i=this.x[t.Target]-this.x[e.Target];return i!==0?i:this.x[t.Source]-this.x[e.Source]}};function tu(){return Pn(2)===0}function Up(l,t,e){let i=e.Layers[l+1],n=e.Layers[l];return n.length<=i.length?Qp(n,t,e):jp(i,n,t,e)}function jp(l,t,e,i){let n=Jd(t,e),o=new eu(i.x);n.sort((h,c)=>o.Compare(h,c));let s=1;for(;s<l.length;)s*=2;let a=new Array(2*s-1).fill(0);s--;let u=0;for(let h of n){let c=s+i.x[h.Source],f=h.CrossingWeight;for(a[c]+=f;c>0;)c%2!==0&&(u+=f*a[c+1]),c=Math.floor((c-1)/2),a[c]+=f}return u}function Qp(l,t,e){let i=Jd(l,t),n=new _l(e.x);i.sort((u,h)=>n.Compare(u,h));let o=1;for(;o<l.length;)o*=2;let s=new Array(2*o-1).fill(0);o--;let a=0;for(let u of i){let h=o+e.x[u.Target],c=u.CrossingWeight;for(s[h]+=c;h>0;)h%2!==0&&(a+=c*s[h+1]),h=Math.floor((h-1)/2),s[h]+=c}return a}function Jd(l,t){return gi(l,e=>t.InEdges(e))}function Qd(l,t){let e=0;for(let i=0;i<t.Layers.length-1;i++)e+=Up(i,l,t);return e}var tn=class extends _{constructor(e,i,n,o,s,a,u){super(u);this.tryReverse=!0;this.MaxNumberOfAdjacentExchanges=50;this.cancelToken=u,this.tryReverse=i,this.startOfVirtNodes=o,this.layerArrays=n,this.layering=n.y,this.nOfLayers=n.Layers.length,this.layers=n.Layers,this.properLayeredGraph=e,this.hasCrossWeights=s,this.SugSettings=a}get NoGainStepsBound(){return this.SugSettings.NoGainAdjacentSwapStepsBound*this.SugSettings.NoGainStepsForOrderingMultiplier}get SeedOfRandom(){return Pn(100)}get MaxOfIterations(){return this.SugSettings.MaxNumberOfPassesInOrdering*this.SugSettings.NoGainStepsForOrderingMultiplier}static OrderLayers(e,i,n,o,s){let a=!1;for(let h of e.Edges)if(h.CrossingWeight!==1){a=!0;break}new tn(e,!0,i,n,a,o,s).run()}run(){if(this.Calculate(),this.tryReverse){let e=this.layerArrays.ReversedClone(),i=new tn(this.properLayeredGraph.ReversedClone(),!1,e,this.startOfVirtNodes,this.hasCrossWeights,this.SugSettings,this.cancelToken);if(i.run(),jn.less(i.measure,this.measure)){for(let n=0;n<this.nOfLayers;n++)da(e.Layers[n],this.layerArrays.Layers[this.nOfLayers-1-n]);this.layerArrays.UpdateXFromLayers()}}}Calculate(){this.Init(),this.layerArraysCopy=tn.CloneLayers(this.layers,this.layerArraysCopy);let e=0;this.measure=new jn(this.layerArraysCopy,Qd(this.properLayeredGraph,this.layerArrays),this.startOfVirtNodes);for(let i=0;i<this.MaxOfIterations&&e<this.NoGainStepsBound&&!this.measure.IsPerfect();i++){let n=i%2===0;this.LayerByLayerSweep(n),this.AdjacentExchange();let o=new jn(this.layerArrays.Layers,Qd(this.properLayeredGraph,this.layerArrays),this.startOfVirtNodes);jn.less(this.measure,o)?(this.Restore(),e++):(jn.less(o,this.measure)||tu())&&(e=0,this.layerArraysCopy=tn.CloneLayers(this.layers,this.layerArraysCopy),this.measure=o)}}static CloneLayers(e,i){if(i==null){i=new Array(e.length);for(let n=0;n<e.length;n++)i[n]=e[n].map(o=>o)}else for(let n=0;n<e.length;n++)da(e[n],i[n]);return i}Restore(){this.layerArrays.updateLayers(this.layerArraysCopy)}LayerByLayerSweep(e){if(e)for(let i=1;i<this.nOfLayers;i++)this.SweepLayer(i,!0);else for(let i=this.nOfLayers-2;i>=0;i--)this.SweepLayer(i,!1)}SweepLayer(e,i){let n=this.layers[e],o=new Array(n.length);for(let a=0;a<o.length;a++)o[a]=this.WMedian(n[a],i);this.Sort(e,o);let s=this.layerArrays.Layers[e];for(let a=0;a<s.length;a++)this.layerArrays.x[s[a]]=a}Sort(e,i){let n=new Ei,o=this.layers[e],s=0;for(let u of i){let h=o[s++];if(u!==-1)if(!n.has(u))n.set(u,h);else{let c=n.get(u);if(typeof c!="number"){let f=c;if(tu())f.push(h);else{let P=Pn(f.length),v=f[P];f[P]=h,f.push(v)}}else{let f=c,P=new Array;n.set(u,P),tu()?(P.push(f),P.push(h)):(P.push(h),P.push(f))}}}let a=n.values();for(s=0;s<o.length;)if(i[s]!==-1){let u=a.next().value;if(typeof u=="number")o[s++]=u;else{let h=u;for(let c of h){for(;i[s]===-1;)s++;o[s++]=c}}}else s++}WMedian(e,i){let n,o;if(i?(n=this.properLayeredGraph.OutEdges(e),o=this.properLayeredGraph.OutEdgesCount(e)):(n=this.properLayeredGraph.InEdges(e),o=this.properLayeredGraph.InEdgesCount(e)),o===0)return-1;let s=new Array(o),a=0;if(i)for(let f of n)s[a++]=this.X[f.Target];else for(let f of n)s[a++]=this.X[f.Source];s.sort((f,P)=>f-P);let u=Math.floor(o/2);if(o%2===1)return s[u];if(o===2)return .5*(s[0]+s[1]);let h=s[u-1]-s[0],c=s[o-1]-s[u];return Math.floor((s[u-1]*h+s[u]*c)/(h+c))}Init(){let e=new Array(this.nOfLayers).fill(0),i=new Xd.Stack;for(let o=0;o<this.properLayeredGraph.NodeCount;o++)this.properLayeredGraph.InEdgesCount(o)===0&&i.push(o);let n=new Array(this.properLayeredGraph.NodeCount).fill(!1);for(;i.size>0;){let o=i.pop(),s=this.layerArrays.y[o];this.layerArrays.Layers[s][e[s]]=o,this.layerArrays.x[o]=e[s],e[s]++;for(let a of this.properLayeredGraph.Succ(o))n[a]||(n[a]=!0,i.push(a))}this.X=this.layerArrays.x}AdjacentExchange(){this.InitArrays();let e=0,i=!0;for(;i&&e++<this.MaxNumberOfAdjacentExchanges;){i=!1;for(let n=0;n<this.layers.length;n++)i=this.AdjExchangeLayer(n)||i;for(let n=this.layers.length-2;n>=0;n--)i=this.AdjExchangeLayer(n)||i}}AllocArrays(){let e=this.properLayeredGraph.NodeCount;this.predecessors=new Array(e),this.successors=new Array(e),this.pOrder=new Array(e),this.sOrder=new Array(e),this.hasCrossWeights&&(this.outCrossingCount=new Array(e),this.inCrossingCount=new Array(e));for(let i=0;i<e;i++){let n=this.properLayeredGraph.InEdgesCount(i);if(this.predecessors[i]=new Array(n),this.hasCrossWeights){let o=this.inCrossingCount[i]=new Map;for(let s of this.properLayeredGraph.InEdges(i))o.set(s.Source,s.CrossingWeight)}if(this.pOrder[i]=new Map,n=this.properLayeredGraph.OutEdgesCount(i),this.successors[i]=new Array(n),this.sOrder[i]=new Map,this.hasCrossWeights){let o=this.outCrossingCount[i]=new Map;for(let s of this.properLayeredGraph.OutEdges(i))o.set(s.Target,s.CrossingWeight)}}}InitArrays(){this.successors==null&&this.AllocArrays();for(let e=0;e<this.properLayeredGraph.NodeCount;e++)this.pOrder[e]=new Map,this.sOrder[e]=new Map;for(let e of this.layers)this.InitPsArraysForLayer(e)}CalcPair(e,i){let n=this.successors[e],o=this.successors[i],s=this.predecessors[e],a=this.predecessors[i];if(this.hasCrossWeights){let u=this.outCrossingCount[e],h=this.outCrossingCount[i],c=this.inCrossingCount[e],f=this.inCrossingCount[i];return{cuv:this.CountOnArraysUV(n,o,u,h)+this.CountOnArraysUV(s,a,c,f),cvu:this.CountOnArraysUV(o,n,h,u)+this.CountOnArraysUV(a,s,f,c)}}else return{cuv:this.CountOnArrays(n,o)+this.CountOnArrays(s,a),cvu:this.CountOnArrays(o,n)+this.CountOnArrays(a,s)}}InitPsArraysForLayer(e){for(let i of e){for(let n of this.properLayeredGraph.Pred(i)){let o=this.sOrder[n],s=o.size;this.successors[n][s]=i,o.set(i,s)}for(let n of this.properLayeredGraph.Succ(i)){let o=this.pOrder[n],s=o.size;this.predecessors[n][s]=i,o.set(i,s)}}}CountOnArrays(e,i){let n=0,o=i.length-1,s=-1,a=0;for(let u of e){let h=this.X[u];for(;s<o&&this.X[i[s+1]]<h;s++)a++;n+=a}return n}CountOnArraysUV(e,i,n,o){let s=0,a=i.length-1,u=-1,h=0;for(let c of e){let f=this.X[c],P;for(;u<a&&this.X[P=i[u+1]]<f;u++)h+=o.get(P);s+=h*n.get(c)}return s}AdjExchangeLayer(e){let i=this.layers[e];return this.ExchangeWithGainWithNoDisturbance(i)?!0:(this.DisturbLayer(i),this.ExchangeWithGainWithNoDisturbance(i))}Swap(e,i){let n=this.X[e],o=this.X[i],s=this.layering[e],a=this.layers[s];a[n]=i,a[o]=e,this.X[e]=o,this.X[i]=n,this.UpdateSsContainingUv(e,i),this.UpdatePsContainingUv(e,i)}UpdatePsContainingUv(e,i){if(this.successors[e].length<=this.successors[i].length)for(let n of this.successors[e]){let o=this.pOrder[n];if(o.has(i)){let s=o.get(i),a=this.predecessors[n];a[s-1]=i,a[s]=e,o.set(i,s-1),o.set(e,s)}}else for(let n of this.successors[i]){let o=this.pOrder[n];if(o.has(e)){let s=o.get(i),a=this.predecessors[n];a[s-1]=i,a[s]=e,o.set(i,s-1),o.set(e,s)}}}UpdateSsContainingUv(e,i){if(this.predecessors[e].length<=this.predecessors[i].length)for(let n of this.predecessors[e]){let o=this.sOrder[n];if(o.has(i)){let s=o.get(i),a=this.successors[n];a[s-1]=i,a[s]=e,o.set(i,s-1),o.set(e,s)}}else for(let n of this.predecessors[i]){let o=this.sOrder[n];if(o.has(e)){let s=o.get(i),a=this.successors[n];a[s-1]=i,a[s]=e,o.set(i,s-1),o.set(e,s)}}}DisturbLayer(e){for(let i=0;i<e.length-1;i++)this.AdjacentSwapToTheRight(e,i)}ExchangeWithGainWithNoDisturbance(e){let i=!1,n;do n=this.ExchangeWithGain(e),i=i||n;while(n);return i}ExchangeWithGain(e){for(let i=0;i<e.length-1;i++)if(this.SwapWithGain(e[i],e[i+1]))return this.SwapToTheLeft(e,i),this.SwapToTheRight(e,i+1),!0;return!1}SwapToTheLeft(e,i){for(let n=i-1;n>=0;n--)this.AdjacentSwapToTheRight(e,n)}SwapToTheRight(e,i){for(let n=i;n<e.length-1;n++)this.AdjacentSwapToTheRight(e,n)}AdjacentSwapToTheRight(e,i){let n=e[i],o=e[i+1],s=this.SwapGain(n,o);(s>0||s===0&&tu())&&this.Swap(n,o)}SwapGain(e,i){let n=this.CalcPair(e,i);return n.cuv-n.cvu}UvAreOfSameKind(e,i){return e<this.startOfVirtNodes&&i<this.startOfVirtNodes||e>=this.startOfVirtNodes&&i>=this.startOfVirtNodes}NeighborsForbidTheSwap(e,i){return this.UpperNeighborsForbidTheSwap(e,i)||this.LowerNeighborsForbidTheSwap(e,i)}LowerNeighborsForbidTheSwap(e,i){let n,o;return(n=this.properLayeredGraph.OutEdgesCount(e))===0||(o=this.properLayeredGraph.OutEdgesCount(i))===0?!1:this.X[this.successors[e][n>>1]]<this.X[this.successors[i][o>>1]]}UpperNeighborsForbidTheSwap(e,i){let n=this.properLayeredGraph.InEdgesCount(e),o=this.properLayeredGraph.InEdgesCount(i);return n===0||o===0?!1:this.X[this.predecessors[e][n>>1]]<this.X[this.predecessors[i][o>>1]]}CalcDeltaBetweenGroupsToTheLeftAndToTheRightOfTheSeparator(e,i,n){let o=this.GetKindDelegate(n),s=0;for(let u=i-1;u>=0&&!o(e[u]);u--)s++;let a=0;for(let u=i+1;u<e.length&&!o(e[u]);u++)a++;return s-a}IsOriginal(e){return e<this.startOfVirtNodes}IsVirtual(e){return e>=this.startOfVirtNodes}GetKindDelegate(e){return this.IsVirtual(e)?this.IsVirtual:this.IsOriginal}SwapWithGain(e,i){return this.SwapGain(e,i)>0?(this.Swap(e,i),!0):!1}};var Io=class{constructor(t,e,i){this.properLayeredGraph=t,this.layerArrays=e,this.nodePositions=i}static UpdateLayerArrays0(t,e,i){new Io(t,e,i).UpdateLayerArrays()}static UpdateLayerArrays1(t,e){let i=Io.BuildInitialNodePositions(t,e);this.UpdateLayerArrays0(t,e,i)}static BuildInitialNodePositions(t,e){let i=new Map;for(let n=0;n<e.Layers.length;n++){let o=0,s=0;for(;o<e.Layers[n].length;){for(;o<e.Layers[n].length&&t.IsVirtualNode(e.Layers[n][o]);)o++;for(let a=s;a<o;a++)i.set(e.Layers[n][a],new d(n,s));o<e.Layers[n].length&&i.set(e.Layers[n][o],new d(n,o)),o++,s=o}}return i}UpdateLayerArrays(){let t=this.CreateInitialOrdering();t=this.BuildOrdering(t),this.RestoreLayerArrays(t)}CreateInitialOrdering(){let t=new qe;for(let e of this.layerArrays.Layers)for(let i of e){let n=this.nodePositions.get(i);t.hasxy(n.x,n.y)||t.setxy(n.x,n.y,[]),t.getxy(n.x,n.y).push(i)}return t}BuildOrdering(t){let e=new qe,i=new Map;for(let n of this.layerArrays.Layers)for(let o of n){let s=this.nodePositions.get(o);e.hasxy(s.x,s.y)||(this.BuildNodeOrdering(t.get(s),i),e.set(s,t.get(s)))}return e}BuildNodeOrdering(t,e){t.sort(this.Comparison(e));for(let i=0;i<t.length;i++)e.set(t[i],i)}firstSucc(t){for(let e of this.properLayeredGraph.Succ(t))return e}firstPred(t){for(let e of this.properLayeredGraph.Pred(t))return e}Comparison(t){return(e,i)=>{let n=this.firstSucc(e),o=this.firstSucc(i),s=this.firstPred(e),a=this.firstPred(i),u=this.nodePositions.get(n),h=this.nodePositions.get(o),c=this.nodePositions.get(s),f=this.nodePositions.get(a);if(!u.equal(h))return c.equal(f)?u.compareTo(h):c.compareTo(f);if(this.properLayeredGraph.IsVirtualNode(n)){if(!c.equal(f))return c.compareTo(f);let P=t.get(n),v=t.get(o);return ce(P,v)}for(;this.nodePositions.get(s).equal(this.nodePositions.get(a))&&this.properLayeredGraph.IsVirtualNode(s);)s=this.firstPred(s),a=this.firstPred(a);return this.nodePositions.get(s).equal(this.nodePositions.get(a))?ce(e,i):this.nodePositions.get(s).compareTo(this.nodePositions.get(a))}}RestoreLayerArrays(t){for(let e of this.layerArrays.Layers){let i=0,n=0;for(;i<e.length;){for(;i<e.length&&this.nodePositions.get(e[n]).equal(this.nodePositions.get(e[i]));)i++;let o=t.get(this.nodePositions.get(e[n]));for(let s=n;s<i;s++)e[s]=o[s-n];n=i}}this.layerArrays.UpdateXFromLayers()}};var Kd=he(gt(),1);var $d=he(Gr(),1);var Qn=class{static getOrder(t,e){let i=vt(e.map(([n,o])=>new Z(n,o)),t);return Qn.getOrderOnGraph(i)}static getOrderOnGraph(t){let e=new Array(t.nodeCount).fill(!1),i=new $d.Stack,n=[],o;for(let s=0;s<t.nodeCount;s++){if(e[s])continue;let a=s;e[a]=!0;let u=0;o=t.outEdges[s];do{for(;u<o.length;u++){let h=o[u].target;e[h]||(e[h]=!0,i.push({edges:o,index:u+1,current_u:a}),a=h,o=t.outEdges[a],u=-1)}if(n.push(a),i.length>0){let h=i.pop();o=h.edges,u=h.index,a=h.current_u}else break}while(!0)}return n.reverse()}};var ru=class{GetLayers(){let t=Qn.getOrderOnGraph(this.graph),e=new Array(this.graph.nodeCount).fill(0),i=this.graph.nodeCount;for(;i-- >0;){let n=t[i];for(let o of this.graph.inEdges[n]){let s=o.source,a=e[n]+o.separation;e[s]<a&&(e[s]=a)}}return e}checkTopoOrder(t){for(let e of this.graph.edges)if(Xp(e,t))return!1;return!0}constructor(t){this.graph=t}};function Xp(l,t){let e=t.findIndex(n=>n===l.source),i=t.findIndex(n=>n===l.target);return e===-1||i===-1||e>=i}var Ih=class{constructor(t){this.inTree=!1;this.cut=Ih.infinity;this.iedge=t}get source(){return this.iedge.source}get target(){return this.iedge.target}get separation(){return this.iedge.separation}get crossingWeight(){return this.iedge.CrossingWeight}get weight(){return this.iedge.weight}},or=Ih;or.infinity=Number.MAX_SAFE_INTEGER;var Xn=he(Gr(),1);function Jp(l){let t=new Array;for(let e of l.edges)t.push(new or(e));return vt(t,l.nodeCount)}var ga=class{constructor(t,e,i,n,o){this.v=t,this.outEnum=e,this.i=i,this.inEnum=n,this.j=o}},bs=class{constructor(t,e){this.layers=null;this.treeVertices=[];this.vertices=[];this.leaves=[];this.graph=Jp(t),this.networkCancelToken=e;for(let i=0;i<this.graph.nodeCount;i++)this.vertices.push({inTree:!1,lim:-1,low:-1,parent:null})}get weight(){return this.graph.edges.map(t=>t.weight*(this.layers[t.source]-this.layers[t.target])).reduce((t,e)=>t+e,0)}get nodeCount(){return this.vertices.length}setLow(t,e){this.vertices[t].low=e}setLim(t,e){this.vertices[t].lim=e}setParent(t,e){this.vertices[t].parent=e}GetLayers(){return this.layers==null&&this.run(),this.layers}shiftLayerToZero(){let t=Math.min(...this.layers);for(let e=0;e<this.layers.length;e++)this.layers[e]-=t}addVertexToTree(t){this.vertices[t].inTree=!0}vertexInTree(t){return this.vertices[t].inTree}lim(t){return this.vertices[t].lim}low(t){return this.vertices[t].low}parent(t){return this.vertices[t].parent}feasibleTree(){for(this.initLayers();this.tightTree()<this.nodeCount;){let t=this.getNonTreeEdgeIncidentToTheTreeWithMinimalAmountOfSlack();if(t==null)break;let e=this.slack(t);this.vertexInTree(t.source)&&(e=-e);for(let i of this.treeVertices)this.layers[i]+=e}this.initCutValues()}vertexSourceTargetVal(t,e){let i=e.source,n=e.target;return this.lim(i)>this.lim(n)?this.lim(t)<=this.lim(n)&&this.low(n)<=this.lim(t)?0:1:this.lim(t)<=this.lim(i)&&this.low(i)<=this.lim(t)?1:0}incidentEdges(t){return this.graph.incidentEdges(t)}allLowCutsHaveBeenDone(t){for(let e of this.incidentEdges(t))if(e.inTree&&e.cut===or.infinity&&e!==this.parent(t))return!1;return!0}edgeSourceTargetVal(t,e){return this.vertexSourceTargetVal(t.source,e)-this.vertexSourceTargetVal(t.target,e)}initCutValues(){this.initLimLowAndParent();let t=new Xn.Stack;for(let i of this.leaves)t.push(i);let e=new Xn.Stack;for(;t.length>0;){for(;t.length>0;){let n=t.pop(),o=this.parent(n);if(o==null)continue;let s=0;for(let u of this.incidentEdges(n))if(u.inTree===!1){let h=this.edgeSourceTargetVal(u,o);h!==0&&(s+=h*u.weight)}else if(u===o)s+=u.weight;else{let h=o.source===u.target||o.target===u.source?1:-1;s+=this.edgeContribution(u,n)*h}o.cut=s;let a=o.source===n?o.target:o.source;this.allLowCutsHaveBeenDone(a)&&e.push(a)}let i=t;t=e,e=i}}edgeContribution(t,e){let i=t.cut-t.weight;for(let n of this.incidentEdges(e))if(n.inTree===!1){let o=this.edgeSourceTargetVal(n,t);o===-1?i+=n.weight:o===1&&(i-=n.weight)}return i}initLimLowAndParent(){this.initLowLimParentAndLeavesOnSubtree(1,0)}initLowLimParentAndLeavesOnSubtree(t,e){let i=new Xn.Stack,n=this.graph.outEdges[e],o=-1,s=this.graph.inEdges[e],a=-1;for(i.push(new ga(e,n,o,s,a)),this.vertices[e].low=t;i.length>0;){let u=i.pop();e=u.v,n=u.outEnum,o=u.i,s=u.inEnum,a=u.j;let h;do{for(h=!0;++o<n.length;){let c=n[o];!c.inTree||this.vertices[c.target].low>0||(i.push(new ga(e,n,o,s,a)),e=c.target,this.setParent(e,c),this.setLow(e,t),n=this.graph.outEdges[e],o=-1,s=this.graph.inEdges[e],a=-1)}for(;++a<s.length;){let c=s[a];if(!(!c.inTree||this.vertices[c.source].low>0)){i.push(new ga(e,n,o,s,a)),e=c.source,this.setLow(e,t),this.setParent(e,c),n=this.graph.outEdges[e],o=-1,s=this.graph.inEdges[e],a=-1,h=!1;break}}}while(!h);this.setLim(e,t++),this.lim(e)===this.low(e)&&this.leaves.push(e)}}updateLimLowLeavesAndParentsUnderNode(t){let e=this.vertices[t].low,i=this.vertices[t].lim;this.leaves=[];for(let n=0;n<this.nodeCount;n++)e<=this.vertices[n].lim&&this.vertices[n].lim<=i?this.setLow(n,0):this.low(n)===this.lim(n)&&this.leaves.push(n);this.initLowLimParentAndLeavesOnSubtree(e,t)}slack(t){return this.layers[t.source]-this.layers[t.target]-t.separation}getNonTreeEdgeIncidentToTheTreeWithMinimalAmountOfSlack(){let t=null,e=or.infinity;for(let i of this.treeVertices){for(let n of this.graph.outEdges[i]){if(this.vertexInTree(n.source)&&this.vertexInTree(n.target))continue;let o=this.slack(n);if(o<e&&(t=n,e=o,o===1))return n}for(let n of this.graph.inEdges[i]){if(this.vertexInTree(n.source)&&this.vertexInTree(n.target))continue;let o=this.slack(n);if(o<e&&(t=n,e=o,o===1))return n}}return t}tightTree(){this.treeVertices=[];for(let e of this.graph.edges)e.inTree=!1;for(let e=1;e<this.nodeCount;e++)this.vertices[e].inTree=!1;this.vertices[0].inTree=!0,this.treeVertices.push(0);let t=new Xn.Stack;for(t.push(0);t.length>0;){let e=t.pop();for(let i of this.graph.outEdges[e])this.vertexInTree(i.target)||this.layers[i.source]-this.layers[i.target]===i.separation&&(t.push(i.target),this.addVertexToTree(i.target),this.treeVertices.push(i.target),i.inTree=!0);for(let i of this.graph.inEdges[e])this.vertexInTree(i.source)||this.layers[i.source]-this.layers[i.target]===i.separation&&(t.push(i.source),this.addVertexToTree(i.source),this.treeVertices.push(i.source),i.inTree=!0)}return this.treeVertices.length}leaveEnterEdge(){let t,e,i=0;for(let s of this.graph.edges)s.inTree&&s.cut<i&&(i=s.cut,t=s);if(t==null)return null;let n=!1,o=or.infinity;for(let s of this.graph.edges){let a=this.slack(s);if(s.inTree===!1&&this.edgeSourceTargetVal(s,t)===-1&&(a<o||a===o&&(n=Pn(2)===1))){if(o=a,e=s,o===0&&!n)break;n=!1}}if(e==null)throw new Error;return{leaving:t,entering:e}}exchange(t,e){let i=this.commonPredecessorOfSourceAndTargetOfF(e);this.createPathForCutUpdates(t,e,i),this.updateLimLowLeavesAndParentsUnderNode(i),this.updateCuts(t),this.updateLayersUnderNode(i)}updateLayersUnderNode(t){let e=new Xn.Stack;e.push(t);for(let i=0;i<this.nodeCount;i++)this.low(t)<=this.lim(i)&&this.lim(i)<=this.lim(t)&&i!==t&&(this.layers[i]=or.infinity);for(;e.length>0;){let i=e.pop();for(let n of this.graph.outEdges[i])n.inTree&&this.layers[n.target]===or.infinity&&(this.layers[n.target]=this.layers[i]-n.separation,e.push(n.target));for(let n of this.graph.inEdges[i])n.inTree&&this.layers[n.source]===or.infinity&&(this.layers[n.source]=this.layers[i]+n.separation,e.push(n.source))}}updateCuts(t){let e=new Xn.Stack,i=new Xn.Stack;for(e.push(t.source),e.push(t.target);e.length>0;){for(;e.length>0;){let o=e.pop(),s=this.parent(o);if(s==null||s.cut!==or.infinity)continue;let a=0;for(let h of this.incidentEdges(o))if(h.inTree===!1)a+=this.edgeSourceTargetVal(h,s)*h.weight;else if(h===s)a+=h.weight;else{let c=s.source===h.target||s.target===h.source?1:-1;a+=this.edgeContribution(h,o)*c}s.cut=a;let u=s.source===o?s.target:s.source;this.allLowCutsHaveBeenDone(u)&&i.push(u)}let n=e;e=i,i=n}}createPathForCutUpdates(t,e,i){let n=e.target;for(;n!==i;){let o=this.parent(n);o.cut=or.infinity,n=o.source===n?o.target:o.source}e.cut=or.infinity,t.inTree=!1,e.inTree=!0}commonPredecessorOfSourceAndTargetOfF(t){let e,i;this.lim(t.source)<this.lim(t.target)?(e=this.lim(t.source),i=this.lim(t.target)):(e=this.lim(t.target),i=this.lim(t.source));let n=t.source;for(;!(this.low(n)<=e&&i<=this.lim(n));){let o=this.parent(n);o.cut=or.infinity,n=o.source===n?o.target:o.source}return n}checkCutValues(){for(let t of this.graph.edges)if(t.inTree){let e=0;for(let i of this.graph.edges)e+=this.edgeSourceTargetVal(i,t)*i.weight;t.cut!==e&&console.log(Kd.String.Format("cuts are wrong for {0}; should be {1} but is {2}",t,e,t.cut))}}initLayers(){let t=new ru(this.graph);return this.layers=t.GetLayers()}run(){if(this.graph.edges.length===0&&this.graph.nodeCount===0)this.layers=[];else{this.feasibleTree();let t;for(;(t=this.leaveEnterEdge())!=null;)this.exchange(t.leaving,t.entering);this.shiftLayerToZero()}}};var iu=class{GetLayers(){return new bs(this.graph,this.Cancel).GetLayers()}ShrunkComponent(t){let e=[];for(let i of t){let n=i[0],o=i[1];for(let s of this.graph.outEdges[n]){let a=new Vt(o,t.get(s.target),s.edge);a.separation=s.separation,a.weight=s.weight,e.push(a)}}return new Gi(e,t.size)}constructor(t,e){this.graph=t,this.Cancel=e}};var Kt=class{constructor(t){this.padding=0;this.alreadySitsOnASpline=!1;this.labelIsToTheLeftOfTheSpline=!1;this.labelIsToTheRightOfTheSpline=!1;this.labelCornersPreserveCoefficient=t}toString(){return"la:ra "+this.la+" "+this.ra+" ta:ba "+this.ta+" "+this.ba+" x:y "+this.x_+" "+this.y_}get leftAnchor(){return this.la}set leftAnchor(t){this.la=Math.max(t,0)}get rightAnchor(){return this.ra}set rightAnchor(t){this.ra=Math.max(t,0)}get topAnchor(){return this.ta}set topAnchor(t){this.ta=Math.max(t,0)}get bottomAnchor(){return this.ba}set bottomAnchor(t){this.ba=Math.max(t,0)}get left(){return this.x_-this.la}get right(){return this.x_+this.ra}get top(){return this.y_+this.ta}set top(t){this.y_+=t-this.ta}get bottom(){return this.y_-this.ba}set bottom(t){this.y_+=t-this.ba}get leftTop(){return new d(this.left,this.top)}get leftBottom(){return new d(this.left,this.bottom)}get rightBottom(){return new d(this.right,this.bottom)}get node(){return this.node_}set node(t){this.node_=t,this.polygonalBoundary_=null}get rightTop(){return new d(this.right,this.top)}static mkAnchor(t,e,i,n,o,s){let a=new Kt(s);return a.la=t,a.ra=e,a.ta=i,a.ba=n,a.node=o,a}get x(){return this.x_}set x(t){this.polygonalBoundary_=null,this.x_=t}get y(){return this.y_}set y(t){this.polygonalBoundary_=null,this.y_=t}get origin(){return new d(this.x,this.y)}get width(){return this.la+this.ra}get height(){return this.ta+this.ba}get hasLabel(){return this.labelIsToTheLeftOfTheSpline||this.labelIsToTheLeftOfTheSpline}get LabelWidth(){if(this.labelIsToTheLeftOfTheSpline)return this.leftAnchor;if(this.labelIsToTheRightOfTheSpline)return this.rightAnchor;throw new Error}get polygonalBoundary(){return this.polygonalBoundary_!=null?this.polygonalBoundary_:this.polygonalBoundary_=Kt.pad(this.creatPolygonalBoundaryWithoutPadding(),this.padding)}static pad(t,e){return e===0?t:Kt.curveIsConvex(t)?Kt.padConvexCurve(t,e):Kt.padConvexCurve(t.boundingBox.perimeter(),e)}static padCorner(t,e,i,n,o){let s=Kt.getPaddedCorner(e,i,n,o);t.addPoint(s.a),s.numberOfPoints===2&&t.addPoint(s.b)}static padConvexCurve(t,e){let i=new j;Kt.padCorner(i,t.endPoint.prev,t.endPoint,t.startPoint,e),Kt.padCorner(i,t.endPoint,t.startPoint,t.startPoint.next,e);for(let n=t.startPoint;n.next.next!=null;n=n.next)Kt.padCorner(i,n,n.next,n.next.next,e);return i.closed=!0,i}static getPaddedCorner(t,e,i,n){let o=t.point,s=e.point,a=i.point,u=d.getTriangleOrientation(o,s,a)===1,h=s.sub(o),c=h.rotate((u?-Math.PI:Math.PI)/2).normalize(),f=h.normalize().add(s.sub(a).normalize());if(f.length<C.intersectionEpsilon)return{a:s.add(c.mul(n)),b:null,numberOfPoints:1};let P=f.normalize().mul(n),v=P.rotate(Math.PI/2),A=(n-P.dot(c))/v.dot(c);return{a:P.add(v.mul(A)).add(s),b:P.sub(v.mul(A)).add(s),numberOfPoints:2}}static*orientations(t){yield d.getTriangleOrientation(t.endPoint.point,t.startPoint.point,t.startPoint.next.point),yield d.getTriangleOrientation(t.endPoint.prev.point,t.endPoint.point,t.startPoint.point);let e=t.startPoint;for(;e.next.next!=null;)yield d.getTriangleOrientation(e.point,e.next.point,e.next.next.point),e=e.next}static curveIsConvex(t){let e=2;for(let i of Kt.orientations(t))if(i!==2){if(e===2)e=i;else if(i!==e)return!1}return!0}creatPolygonalBoundaryWithoutPadding(){return this.hasLabel?this.labelIsToTheLeftOfTheSpline?this.polygonOnLeftLabel():this.polygonOnRightLabel():this.nodeBoundary==null?this.standardRectBoundary():E.polylineAroundClosedCurve(this.nodeBoundary)}get nodeBoundary(){return this.node==null?null:this.node.boundaryCurve}standardRectBoundary(){let t=new j;return t.addPoint(this.leftTop),t.addPoint(this.rightTop),t.addPoint(this.rightBottom),t.addPoint(this.leftBottom),t.closed=!0,t}polygonOnLeftLabel(){let t=this.left+(1-this.labelCornersPreserveCoefficient)*this.LabelWidth;return j.mkClosedFromPoints([new d(t,this.top),this.rightTop,this.rightBottom,new d(t,this.bottom),new d(this.left,this.y)])}polygonOnRightLabel(){let t=this.right-(1-this.labelCornersPreserveCoefficient)*this.LabelWidth;return j.mkClosedFromPoints([new d(t,this.top),new d(this.right,this.y),new d(t,this.bottom),this.leftBottom,this.leftTop])}move(t){this.x+=t.x,this.y+=t.y}};var Ps=class{constructor(t,e,i,n,o){this.xCoords=new Array(4);this.la=t,this.graph=e,this.nOfOriginalVertices=i,this.nOfVertices=this.graph.NodeCount,this.markedEdges=new wt,this.h=this.la.Layers.length,this.root=new Array(this.nOfVertices),this.align=new Array(this.nOfVertices),this.anchors=n,this.nodeSep=o}get CurrentEnumRightUp(){return(this.LR?0:1)+2*(this.BT?0:1)}IsVirtual(t){return t>=this.nOfOriginalVertices}Source(t){return this.BT?t.Source:t.Target}Target(t){return this.BT?t.Target:t.Source}static CalculateXCoordinates(t,e,i,n,o){new Ps(t,e,i,n,o).Calculate()}Calculate(){this.SortInAndOutEdges(),this.RightUpSetup(),this.CalcBiasedAlignment(),this.LeftUpSetup(),this.CalcBiasedAlignment(),this.RightDownSetup(),this.CalcBiasedAlignment(),this.LeftDownSetup(),this.CalcBiasedAlignment(),this.HorizontalBalancing()}SortInAndOutEdges(){this.FillLowMedians(),this.FillUpperMedins()}FillUpperMedins(){this.upperMedians=new Array(this.graph.NodeCount);for(let t=0;t<this.graph.NodeCount;t++)this.FillUpperMediansForNode(t)}CompareByX(t,e){return this.la.x[t]-this.la.x[e]}FillUpperMediansForNode(t){let e=this.graph.InEdgesCount(t);if(e>0){let i=new Array(e);e=0;for(let o of this.graph.InEdges(t))i[e++]=o.Source;i.sort((o,s)=>this.CompareByX(o,s));let n=Math.floor(e/2);n*2===e?this.upperMedians[t]=new Z(i[n-1],i[n]):this.upperMedians[t]=i[n]}else this.upperMedians[t]=-1}FillLowMedians(){this.lowMedians=new Array(this.graph.NodeCount);for(let t=0;t<this.graph.NodeCount;t++)this.FillLowMediansForNode(t)}FillLowMediansForNode(t){let e=this.graph.OutEdgesCount(t);if(e>0){let i=new Array(e);e=0;for(let o of this.graph.OutEdges(t))i[e++]=o.Target;i.sort((o,s)=>this.CompareByX(o,s));let n=Math.floor(e/2);n*2===e?this.lowMedians[t]=new Z(i[n-1],i[n]):this.lowMedians[t]=i[n]}else this.lowMedians[t]=-1}HorizontalBalancing(){let t=-1,e=new Array(4),i=new Array(4),n=Number.MAX_VALUE;for(let s=0;s<4;s++){let a={a:0,b:0};this.AssignmentBounds(s,a),e[s]=a.a,i[s]=a.b;let u=i[s]-e[s];u<n&&(t=s,n=u)}for(let s=0;s<4;s++){let a;if(Ps.IsLeftMostAssignment(s)?a=e[t]-e[s]:a=i[t]-i[s],this.x=this.xCoords[s],a!==0)for(let u=0;u<this.nOfVertices;u++)this.x[u]=this.x[u]+a}let o=new Array(4);for(let s=0;s<this.nOfVertices;s++)o[0]=this.xCoords[0][s],o[1]=this.xCoords[1][s],o[2]=this.xCoords[2][s],o[3]=this.xCoords[3][s],o.sort((a,u)=>a-u),this.anchors[s].x=(o[1]+o[2])/2}static IsLeftMostAssignment(t){return t===0||t===2}AssignmentBounds(t,e){if(this.nOfVertices===0)e.a=0,e.b=0;else{this.x=this.xCoords[t],e.a=e.b=this.x[0];for(let i=1;i<this.nOfVertices;i++){let n=this.x[i];n<e.a?e.a=n:n>e.b&&(e.b=n)}}}CalcBiasedAlignment(){this.ConflictElimination(),this.Align()}LeftUpSetup(){this.LR=!1,this.BT=!0}LeftDownSetup(){this.LR=!1,this.BT=!1}RightDownSetup(){this.LR=!0,this.BT=!1}RightUpSetup(){this.LR=!0,this.BT=!0}ConflictElimination(){this.RemoveMarksFromEdges(),this.MarkConflictingEdges()}*UpperEdgeMedians(t){let e=this.BT?this.upperMedians[t]:this.lowMedians[t];if(typeof e!="number"){let n=e;this.LR?(yield n.x,yield n.y):(yield n.y,yield n.x)}else{let n=e;n>=0&&(yield n)}}MarkConflictingEdges(){let t=this.LowerOf(0,this.h-1),e=t,i=this.UpperOf(0,this.h-1),n=this.NextLower(i);for(;this.IsBelow(t,i);t=this.NextUpper(t))this.IsBelow(e,t)&&this.IsBelow(t,n)&&this.ConflictsWithAtLeastOneInnerEdgeForALayer(t)}NextUpper(t){return this.BT?t+1:t-1}NextLower(t){return this.BT?t-1:t+1}UpperOf(t,e){return this.BT?Math.max(t,e):Math.min(t,e)}LowerOf(t,e){return this.BT?Math.min(t,e):Math.max(t,e)}IsBelow(t,e){return this.BT?t<e:e<t}LeftMost(t,e){return this.LR?Math.min(t,e):Math.max(t,e)}RightMost(t,e){return this.LR?Math.max(t,e):Math.min(t,e)}IsNotRightFrom(t,e){return this.LR?t<=e:e<=t}IsLeftFrom(t,e){return this.LR?t<e:e<t}NextRight(t){return this.LR?t+1:t-1}NextLeft(t){return this.LR?t-1:t+1}ConflictsWithAtLeastOneInnerEdgeForALayer(t){if(t>=0&&t<this.la.Layers.length){let e=this.la.Layers[t],i=null,n=this.LeftMost(0,e.length-1),o=this.RightMost(0,e.length-1);for(;this.IsNotRightFrom(n,o)&&i==null;n=this.NextRight(n))i=this.InnerEdgeByTarget(e[n]);if(i!=null){let s=this.Pos(this.Source(i));for(let u=this.LeftMost(0,e.length-1);this.IsLeftFrom(u,n);u=this.NextRight(u))for(let h of this.InEdges(e[u]))this.IsLeftFrom(s,this.Pos(this.Source(h)))&&this.MarkEdge(h);let a=this.Pos(this.Source(i));for(;this.IsNotRightFrom(n,o);){let u=this.AlignmentToTheRightOfInner(e,n,s);if(n=this.NextRight(n),u!=null){let h=this.Pos(this.Source(u));this.MarkEdgesBetweenInnerAndNewInnerEdges(e,i,u,a,h),i=u,a=h}}for(let u=this.NextRight(this.Pos(this.Target(i)));this.IsNotRightFrom(u,o);u=this.NextRight(u))for(let h of this.InEdges(e[u]))this.IsLeftFrom(this.Pos(this.Source(h)),this.Pos(this.Source(i)))&&this.MarkEdge(h)}}}InEdgeOfVirtualNode(t){return this.BT?this.graph.InEdgeOfVirtualNode(t):this.graph.OutEdgeOfVirtualNode(t)}InEdges(t){return this.BT?this.graph.InEdges(t):this.graph.OutEdges(t)}MarkEdgesBetweenInnerAndNewInnerEdges(t,e,i,n,o){let s=this.NextRight(this.Pos(this.Target(e)));for(;this.IsLeftFrom(s,this.Pos(this.Target(i)));s=this.NextRight(s))for(let a of this.InEdges(t[s])){let u=this.Pos(this.Source(a));this.IsLeftFrom(u,n)?this.MarkEdge(a):this.IsLeftFrom(o,u)&&this.MarkEdge(a)}}AlignmentToTheRightOfInner(t,e,i){if(this.NumberOfInEdges(t[e])===1){let o=null;for(let s of this.InEdges(t[e]))o=s;return this.IsInnerEdge(o)&&this.IsLeftFrom(i,this.Pos(o.Source))?o:null}return null}NumberOfInEdges(t){return this.BT?this.graph.InEdgesCount(t):this.graph.OutEdgesCount(t)}Pos(t){return this.la.x[t]}InnerEdgeByTarget(t){if(this.IsVirtual(t)){let e=this.InEdgeOfVirtualNode(t);if(this.IsVirtual(this.Source(e)))return e}return null}IsInnerEdge(t){return this.IsVirtual(t.Source)&&this.IsVirtual(t.Target)}RemoveMarksFromEdges(){this.markedEdges.clear()}Align(){this.CreateBlocks(),this.AssignCoordinatesByLongestPath()}AssignCoordinatesByLongestPath(){this.x=this.xCoords[this.CurrentEnumRightUp]=new Array(this.nOfVertices);let t=new Array;for(let n=0;n<this.nOfVertices;n++)if(n===this.root[n]){let o=n;do{let s={neighbor:0};this.TryToGetRightNeighbor(o,s)&&t.push(new Vt(n,this.root[s.neighbor],null)),o=this.align[o]}while(o!==n)}let e=vt(t,this.nOfVertices),i=Qn.getOrderOnGraph(e);for(let n of i)if(n===this.root[n]){let o=0,s=!0,a=n;do{let u={neighbor:0};this.TryToGetLeftNeighbor(a,u)&&(s?(o=this.x[this.root[u.neighbor]]+this.DeltaBetweenVertices(u.neighbor,a),s=!1):o=this.RightMost(o,this.x[this.root[u.neighbor]]+this.DeltaBetweenVertices(u.neighbor,a))),a=this.align[a]}while(a!==n);this.x[n]=o}for(let n of i)if(n===this.root[n]&&e.inEdges[n].length===0){let o=n,s=this.RightMost(-Ps.infinity,Ps.infinity),a=s;do{let u={neighbor:0};this.TryToGetRightNeighbor(o,u)&&(s=this.LeftMost(s,this.x[this.root[u.neighbor]]-this.DeltaBetweenVertices(o,u.neighbor))),o=this.align[o]}while(o!==n);a!==s&&(this.x[n]=s)}for(let n=0;n<this.nOfVertices;n++)n!==this.root[n]&&(this.x[n]=this.x[this.root[n]])}TryToGetRightNeighbor(t,e){let i=this.NextRight(this.Pos(t)),n=this.la.Layers[this.la.y[t]];return i>=0&&i<n.length?(e.neighbor=n[i],!0):!1}TryToGetLeftNeighbor(t,e){let i=this.NextLeft(this.Pos(t)),n=this.la.Layers[this.la.y[t]];return i>=0&&i<n.length?(e.neighbor=n[i],!0):!1}CreateBlocks(){for(let e=0;e<this.nOfVertices;e++)this.root[e]=this.align[e]=e;let t=this.LowerOf(0,this.h-1);for(let e=this.NextLower(this.UpperOf(0,this.h-1));!this.IsBelow(e,t);e=this.NextLower(e)){let i=this.la.Layers[e],n=this.LeftMost(-1,this.la.Layers[this.NextUpper(e)].length),o=this.RightMost(0,i.length-1);for(let s=this.LeftMost(0,i.length-1);this.IsNotRightFrom(s,o);s=this.NextRight(s)){let a=i[s];for(let u of this.UpperEdgeMedians(a))if(!this.IsMarked(a,u)&&this.IsLeftFrom(n,this.Pos(u))){this.align[u]=a,this.root[a]=this.root[u],this.align[a]=this.root[u],n=this.Pos(u);break}}}}IsMarked(t,e){return this.BT?this.markedEdges.hasxy(e,t):this.markedEdges.hasxy(t,e)}MarkEdge(t){this.markedEdges.addNN(t.Source,t.Target)}DeltaBetweenVertices(t,e){let i;if(this.Pos(t)>this.Pos(e)){let n=t;t=e,e=n,i=-1}else i=1;return(this.anchors[t].rightAnchor+this.anchors[e].leftAnchor+this.nodeSep)*i}},ma=Ps;ma.infinity=1e7;var nu=class extends ft{constructor(e,i,n,o,s){super();this.weightMultiplierOfOriginalOriginal=1;this.weightMultOfOneVirtual=3;this.weightMultiplierOfTwoVirtual=8;this.SetEdges(o,s),this.virtualVerticesStart=e.nodeCount,this.virtualVerticesEnd=i.NodeCount-1,this.layeredGraph=i,this.layerArrays=n}EdgeWeightMultiplier(e){let i=e.source,n=e.target;if(i<this.layeredGraph.NodeCount&&this.layerArrays.y[i]===this.layerArrays.y[n]&&this.layerArrays.x[i]===this.layerArrays.x[n]+1)return 0;let o=0,s=-1,a=-1;for(let h of this.outEdges[i])a===-1?a=h.target:s=h.target;return a>=this.virtualVerticesStart&&a<=this.virtualVerticesEnd&&o++,s>=this.virtualVerticesStart&&s<=this.virtualVerticesEnd&&o++,o===0?this.weightMultiplierOfOriginalOriginal:o===1?this.weightMultOfOneVirtual:this.weightMultiplierOfTwoVirtual}SetEdgeWeights(){for(let e of this.edges)e.weight=e.weight*this.EdgeWeightMultiplier(e)}};var rn=class{constructor(t,e){this.groupSplitThreshold=2;this.initialNodes=t,this.groupSplitThreshold=e}static Calculate(t,e=0){return new rn(t,e).Calculate()}Calculate(){return this.Calc(this.initialNodes)}Calc(t){if(t.length===0)return null;if(t.length===1)return t[0];let e=t[0].parallelogram,i=1,n=ae.parallelogramOfTwo(e,t[i].parallelogram).area;for(let c=2;c<t.length;c++){let f=ae.parallelogramOfTwo(e,t[c].parallelogram).area;f>n&&(i=c,n=f)}let o;for(let c=0;c<t.length;c++)if(c!==i){o=c;break}n=ae.parallelogramOfTwo(t[i].parallelogram,t[o].parallelogram).area;for(let c=0;c<t.length;c++){if(c===i)continue;let f=ae.parallelogramOfTwo(t[i].parallelogram,t[c].parallelogram).area;f>n&&(o=c,n=f)}let s=new Array,a=new Array;s.push(t[i]),a.push(t[o]);let u=t[i].parallelogram,h=t[o].parallelogram;for(let c=0;c<t.length;c++){if(c===i||c===o)continue;let f=ae.parallelogramOfTwo(u,t[c].parallelogram),P=f.area-u.area,v=ae.parallelogramOfTwo(h,t[c].parallelogram),A=v.area-h.area;s.length*this.groupSplitThreshold<a.length?(s.push(t[c]),u=f):a.length*this.groupSplitThreshold<s.length?(a.push(t[c]),h=v):P<A?(s.push(t[c]),u=f):(a.push(t[c]),h=v)}return{parallelogram:ae.parallelogramOfTwo(u,h),node:{children:[this.Calc(s),this.Calc(a)]},seg:void 0,leafBoxesOffset:void 0}}};var Yt=class{constructor(t,e,i,n,o,s,a,u){this.topNode=t,this.bottomNode=e,this.topSite=i,this.bottomSite=i.next,this.currentTopSite=i,this.currentBottomSite=i.next,this.layerArrays=n,this.layeredGraph=o,this.originalGraph=s,this.anchors=a,this.layerSeparation=u}static Refine(t,e,i,n,o,s,a,u){new Yt(t,e,i,o,s,a,n,u).Refine()}Refine(){for(this.Init();this.InsertSites(););}FixCorner(t,e,i){if(t.equal(e))return e;let n=d.ClosestPointAtLineSegment(e,t,i),o=e.sub(n),s=Math.abs(o.y),a=this.layerSeparation/2;return s>a&&(o=o.mul(a/(s*2))),o.add(e)}InsertSites(){return Pn(2)===0?this.CalculateNewTopSite()||this.CalculateNewBottomSite():this.CalculateNewBottomSite()||this.CalculateNewTopSite()}CalculateNewBottomSite(){let t=this.currentBottomSite.point.sub(this.currentTopSite.point),e=Yt.absCotan(t),i,n=!1;for(let o of this.bottomCorners()){let s=Yt.absCotan(o.sub(this.currentBottomSite.point));s<e&&(e=s,i=o,n=!0)}return n?Q(e,Yt.absCotan(t))?!1:(this.currentBottomSite=ye.mkSiteSPS(this.currentTopSite,this.FixCorner(this.currentTopSite.point,i,this.currentBottomSite.point),this.currentBottomSite),!0):!1}static absCotan(t){return Math.abs(t.x/t.y)}CalculateNewTopSite(){let t=this.currentBottomSite.point.sub(this.currentTopSite.point),e=Yt.absCotan(t),i,n=!1;for(let o of this.topCorners()){let s=Yt.absCotan(o.sub(this.currentTopSite.point));s<e&&(e=s,i=o,n=!0)}return n?Q(e,Yt.absCotan(t))?!1:(this.currentTopSite=ye.mkSiteSPS(this.currentTopSite,this.FixCorner(this.currentTopSite.point,i,this.currentBottomSite.point),this.currentBottomSite),!0):!1}Init(){this.IsTopToTheLeftOfBottom()?(this.topCorners=()=>this.CornersToTheRightOfTop(),this.bottomCorners=()=>this.CornersToTheLeftOfBottom()):(this.topCorners=()=>this.CornersToTheLeftOfTop(),this.bottomCorners=()=>this.CornersToTheRightOfBottom())}IsTopToTheLeftOfBottom(){return this.topSite.point.x<this.topSite.next.point.x}*NodeCorners(t){for(let e of this.anchors[t].polygonalBoundary.polylinePoints())yield e.point}*CornersToTheLeftOfBottom(){let t=this.layerArrays.x[this.bottomNode],e=this.currentTopSite.point.x,i=this.currentBottomSite.point.x;for(let n of this.LeftFromTheNode(this.NodeLayer(this.bottomNode),t,2,e,i))for(let o of this.NodeCorners(n))o.y>this.currentBottomSite.point.y&&Yt.PossibleCorner(e,i,o)&&(yield o)}*CornersToTheLeftOfTop(){let t=this.layerArrays.x[this.topNode],e=this.currentBottomSite.point.x,i=this.currentTopSite.point.x;for(let n of this.LeftFromTheNode(this.NodeLayer(this.topNode),t,0,e,i))for(let o of this.NodeCorners(n))o.y<this.currentTopSite.point.y&&Yt.PossibleCorner(e,i,o)&&(yield o)}*CornersToTheRightOfBottom(){let t=this.layerArrays.x[this.bottomNode],e=this.currentBottomSite.point.x,i=this.currentTopSite.point.x;for(let n of this.RightFromTheNode(this.NodeLayer(this.bottomNode),t,2,e,i))for(let o of this.NodeCorners(n))o.y>this.currentBottomSite.point.y&&Yt.PossibleCorner(e,i,o)&&(yield o)}*CornersToTheRightOfTop(){let t=this.layerArrays.x[this.topNode],e=this.currentTopSite.point.x,i=this.currentBottomSite.point.x;for(let n of this.RightFromTheNode(this.NodeLayer(this.topNode),t,0,e,i))for(let o of this.NodeCorners(n))o.y<this.currentTopSite.point.y&&Yt.PossibleCorner(e,i,o)&&(yield o)}static PossibleCorner(t,e,i){return i.x>t&&i.x<e}NodeLayer(t){return this.layerArrays.Layers[this.layerArrays.y[t]]}IsLabel(t){return this.anchors[t].hasLabel}NodeUCanBeCrossedByNodeV(t,e){return this.IsLabel(t)||this.IsLabel(e)?!1:!!(this.IsVirtualVertex(t)&&this.IsVirtualVertex(e)&&this.AdjacentEdgesIntersect(t,e))}AdjacentEdgesIntersect(t,e){return this.Intersect(this.IncomingEdge(t),this.IncomingEdge(e))||this.Intersect(this.OutcomingEdge(t),this.OutcomingEdge(e))}Intersect(t,e){return(this.layerArrays.x[t.Source]-this.layerArrays.x[e.Source])*(this.layerArrays.x[t.Target]-this.layerArrays.x[e.Target])<0}IncomingEdge(t){for(let e of this.layeredGraph.InEdges(t))return e;throw new Error}OutcomingEdge(t){for(let e of this.layeredGraph.OutEdges(t))return e;throw new Error}IsVirtualVertex(t){return t>=this.originalGraph.shallowNodeCount}*RightFromTheNode(t,e,i,n,o){let s=0,a=0;i===2&&(s=Number.MAX_VALUE),i===0&&(a=Number.MAX_VALUE);let u=t[e];for(let h=e+1;h<t.length;h++){let c=t[h];if(this.NodeUCanBeCrossedByNodeV(c,u))continue;let f=this.anchors[c];if(f.left>=o)break;f.right>n&&(f.topAnchor>a+C.distanceEpsilon?(a=f.topAnchor,yield c):f.bottomAnchor>s+C.distanceEpsilon&&(s=f.bottomAnchor,yield c))}}*LeftFromTheNode(t,e,i,n,o){let s=0,a=0;i===2&&(s=Number.MAX_VALUE),i===0&&(a=Number.MAX_VALUE);let u=t[e];for(let h=e-1;h>-1;h--){let c=t[h];if(this.NodeUCanBeCrossedByNodeV(c,u))continue;let f=this.anchors[c];if(f.right<=n)break;f.left<o&&(f.topAnchor>a+C.distanceEpsilon?(a=f.topAnchor,yield c):f.bottomAnchor>s+C.distanceEpsilon&&(s=f.bottomAnchor,yield c))}}};var Pt=class{constructor(t,e,i,n,o,s,a){this.thinRightNodes=new Array;this.thinWestNodes=new Array;this.database=a,this.edgePath=t,this.anchors=e,this.layerArrays=o,this.originalGraph=i,this.settings=n,this.layeredGraph=s,this.eastHierarchy=this.BuildEastHierarchy(),this.westHierarchy=this.BuildWestHierarchy()}BuildEastHierarchy(){let t=this.FindEastBoundaryAnchorCurves(),e=new Array;for(let i of t)e.push(i.pNodeOverICurve());return this.thinEastHierarchy=rn.Calculate(this.thinRightNodes),rn.Calculate(e)}BuildWestHierarchy(){let t=this.FindWestBoundaryAnchorCurves(),e=new Array;for(let i of t)e.push(i.pNodeOverICurve());return this.thinWestHierarchy=rn.Calculate(this.thinWestNodes),rn.Calculate(e)}FindEastBoundaryAnchorCurves(){let t=new Array,e=0;for(let i of this.edgePath){let n=null;for(let o of this.EastBoundaryNodesOfANode(i,qr.GetNodeKind(e,this.edgePath))){let s=this.anchors[o];(n==null||n.origin.x>s.origin.x)&&(n=s),t.push(s.polygonalBoundary)}n!=null&&this.thinRightNodes.push(w.mkLinePXY(n.origin,this.originalGraph.right,n.y).pNodeOverICurve()),e++}return t}FindWestBoundaryAnchorCurves(){let t=[],e=0;for(let i of this.edgePath.nodes()){let n=-1;for(let o of this.LeftBoundaryNodesOfANode(i,qr.GetNodeKind(e,this.edgePath)))(n===-1||this.layerArrays.x[o]>this.layerArrays.x[n])&&(n=o),t.push(this.anchors[o].polygonalBoundary);if(n!==-1){let o=this.anchors[n];this.thinWestNodes.push(w.mkLinePXY(o.origin,this.originalGraph.left,o.origin.y).pNodeOverICurve())}e++}return t}*FillRightTopAndBottomVerts(t,e,i){let n=0,o=0;i===2?n=Number.MAX_VALUE:i===0&&(o=Number.MAX_VALUE);let s=t[e];for(let a=e+1;a<t.length;a++){let u=t[a],h=this.anchors[u];h.topAnchor>o?this.NodeUCanBeCrossedByNodeV(u,s)||(o=h.topAnchor,h.bottomAnchor>n&&(n=h.bottomAnchor),yield u):h.bottomAnchor>n&&(this.NodeUCanBeCrossedByNodeV(u,s)||(n=h.bottomAnchor,h.topAnchor>o&&(o=h.topAnchor),yield u))}}*FillLeftTopAndBottomVerts(t,e,i){let n=0,o=0;i===0?o=Number.MAX_VALUE:i===2&&(n=Number.MAX_VALUE);let s=t[e];for(let a=e-1;a>=0;a--){let u=t[a],h=this.anchors[u];h.topAnchor>o+C.distanceEpsilon?this.NodeUCanBeCrossedByNodeV(u,s)||(o=h.topAnchor,n=Math.max(n,h.bottomAnchor),yield u):h.bottomAnchor>n+C.distanceEpsilon&&(this.NodeUCanBeCrossedByNodeV(u,s)||(o=Math.max(o,h.topAnchor),n=h.bottomAnchor,yield u))}}IsVirtualVertex(t){return t>=this.originalGraph.shallowNodeCount}IsLabel(t){return this.anchors[t].hasLabel}NodeUCanBeCrossedByNodeV(t,e){return this.IsLabel(t)||this.IsLabel(e)?!1:!!(this.IsVirtualVertex(t)&&this.IsVirtualVertex(e)&&this.EdgesIntersectSomewhere(t,e))}EdgesIntersectSomewhere(t,e){return this.UVAreMiddlesOfTheSameMultiEdge(t,e)?!1:this.IntersectAbove(t,e)||this.IntersectBelow(t,e)}UVAreMiddlesOfTheSameMultiEdge(t,e){return!!(this.database.MultipleMiddles.has(t)&&this.database.MultipleMiddles.has(e)&&this.SourceOfTheOriginalEdgeContainingAVirtualNode(t)===this.SourceOfTheOriginalEdgeContainingAVirtualNode(e))}SourceOfTheOriginalEdgeContainingAVirtualNode(t){for(;this.IsVirtualVertex(t);)t=this.IncomingEdge(t).Source;return t}IntersectBelow(t,e){do{let i=this.OutcomingEdge(t),n=this.OutcomingEdge(e);if(this.Intersect(i,n))return!0;t=i.Target,e=n.Target}while(this.IsVirtualVertex(t)&&this.IsVirtualVertex(e));return t===e}IntersectAbove(t,e){do{let i=this.IncomingEdge(t),n=this.IncomingEdge(e);if(this.Intersect(i,n))return!0;t=i.Source,e=n.Source}while(this.IsVirtualVertex(t)&&this.IsVirtualVertex(e));return t===e}Intersect(t,e){let i=this.layerArrays.x[t.Source]-this.layerArrays.x[e.Source],n=this.layerArrays.x[t.Target]-this.layerArrays.x[e.Target];return i>0&&n<0||i<0&&n>0}IncomingEdge(t){return this.layeredGraph.InEdgeOfVirtualNode(t)}OutcomingEdge(t){return this.layeredGraph.OutEdgeOfVirtualNode(t)}EastBoundaryNodesOfANode(t,e){return this.FillRightTopAndBottomVerts(this.NodeLayer(t),this.layerArrays.x[t],e)}NodeLayer(t){return this.layerArrays.Layers[this.layerArrays.y[t]]}LeftBoundaryNodesOfANode(t,e){return this.FillLeftTopAndBottomVerts(this.NodeLayer(t),this.layerArrays.x[t],e)}getSpline(t){return this.createRefinedPolyline(t),this.createSmoothedPolyline()}get GetPolyline(){return new Ge(this.headSite)}LineSegIntersectBound(t,e){let i=w.mkPP(t,e);return Pt.CurveIntersectsHierarchy(i,this.westHierarchy)||Pt.CurveIntersectsHierarchy(i,this.thinWestHierarchy)||Pt.CurveIntersectsHierarchy(i,this.eastHierarchy)||Pt.CurveIntersectsHierarchy(i,this.thinEastHierarchy)}SegIntersectWestBound(t,e){return Pt.SegIntersectsBound(t,e,this.westHierarchy)||Pt.SegIntersectsBound(t,e,this.thinWestHierarchy)}SegIntersectEastBound(t,e){return Pt.SegIntersectsBound(t,e,this.eastHierarchy)||Pt.SegIntersectsBound(t,e,this.thinEastHierarchy)}TryToRemoveInflectionCorner(t){if(!t.s.next||!t.s.prev||t.s.turn===1&&this.SegIntersectEastBound(t.s.prev,t.s.next)||t.s.turn===0&&this.SegIntersectWestBound(t.s.prev,t.s.next)){t.cut=!1,t.s=t.s.next;return}let e=t.s.next;t.s.prev.next=e,e.prev=t.s.prev,t.s=e,t.cut=!0}static SegIntersectsBound(t,e,i){return Pt.CurveIntersectsHierarchy(w.mkPP(t.point,e.point),i)}static CurveIntersectsHierarchy(t,e){if(e==null||!ae.intersect(t.pNodeOverICurve().parallelogram,e.parallelogram))return!1;if(e.node.hasOwnProperty("children")){let i=e.node;return Pt.CurveIntersectsHierarchy(t,i.children[0])||Pt.CurveIntersectsHierarchy(t,i.children[1])}return E.intersectionOne(t,e.seg,!1)!=null}static Flat(t){return d.getTriangleOrientation(t.prev.point,t.point,t.next.point)===2}Reverse(){let t=new Pt(this.edgePath,this.anchors,this.originalGraph,this.settings,this.layerArrays,this.layeredGraph,this.database),e=this.headSite,i=null;for(;e!=null;)t.headSite=e.clone(),t.headSite.next=i,i!=null&&(i.prev=t.headSite),i=t.headSite,e=e.next;return t}createRefinedPolyline(t){this.CreateInitialListOfSites();let e=this.headSite,i;for(let n=0;n<this.edgePath.count;n++)i=e.next,this.RefineBeetweenNeighborLayers(e,this.EdgePathNode(n),this.EdgePathNode(n+1)),e=i;this.TryToRemoveInflections(),t&&this.OptimizeShortPath()}RefineBeetweenNeighborLayers(t,e,i){Yt.Refine(e,i,t,this.anchors,this.layerArrays,this.layeredGraph,this.originalGraph,this.settings.LayerSeparation)}CreateInitialListOfSites(){let t=this.headSite=ye.mkSiteP(this.EdgePathPoint(0));for(let e=1;e<=this.edgePath.count;e++)t=ye.mkSiteSP(t,this.EdgePathPoint(e))}get TailSite(){let t=this.headSite;for(;t.next!=null;)t=t.next;return t}OptimizeForThreeSites(){let t=this.EdgePathNode(0),e=this.EdgePathNode(2),i=this.anchors[t],n=this.anchors[e];if(Q(i.x,n.x))return;let o={ax:i.x,bx:n.x,sign:0};if(!this.FindLegalPositions(i,n,o))return;let s=(i.y-n.y)/(i.bottom-n.top),a=.5*(o.ax+o.bx),u=o.sign*((o.ax-o.bx)*.5);o.ax=a+s*(u*o.sign),o.bx=a-s*(u*o.sign),this.headSite.point=new d(o.ax,i.y);let h=this.headSite.next,c=h.point.y;h.point=new d(this.MiddlePos(o.ax,o.bx,i,n,c),c),h.next.point=new d(o.bx,n.y);let f=this.anchors[this.EdgePathNode(1)];f.x=h.point.x}OptimizeForTwoSites(){let t=this.EdgePathNode(0),e=this.EdgePathNode(1),i=this.anchors[t],n=this.anchors[e];if(Q(i.x,n.x))return;let o={ax:i.x,bx:n.x,sign:0};if(!this.FindPositions(i,n,o))return;let s=(i.y-n.y)/(i.bottom-n.top),a=.5*(o.ax+o.bx),u=o.sign*((o.ax-o.bx)*.5);o.ax=a+s*(u*o.sign),o.bx=a-s*(u*o.sign),this.headSite.point=new d(o.ax,i.y),this.headSite.next.point=new d(o.bx,n.y)}FindLegalPositions(t,e,i){return this.FindPositions(t,e,i)?this.PositionsAreLegal(i.ax,i.bx,i.sign,t,e,this.EdgePathNode(1)):!1}FindPositions(t,e,i){let n,o;if(i.ax<i.bx?(i.sign=1,o=Math.max(i.ax,e.left),n=Math.min(t.right,i.bx)):(i.sign=-1,o=Math.max(t.left,i.bx),n=Math.min(e.right,i.ax)),o<=n)i.bx=.5*(o+n),i.ax=.5*(o+n);else{if(this.OriginToOriginSegCrossesAnchorSide(t,e))return!1;i.sign===1?(i.ax=t.right-.1*t.rightAnchor,i.bx=e.left):(i.ax=t.left+.1*t.leftAnchor,i.bx=e.right)}return!0}OriginToOriginSegCrossesAnchorSide(t,e){let i=w.mkPP(t.origin,e.origin);return t.x<e.x&&E.CurvesIntersect(i,w.mkPP(t.rightBottom,t.rightTop))||E.CurvesIntersect(i,w.mkPP(e.leftBottom,t.leftTop))||t.x>e.x&&E.CurvesIntersect(i,w.mkPP(t.leftBottom,t.leftTop))||E.CurvesIntersect(i,w.mkPP(e.rightBottom,t.rightTop))}OptimizeShortPath(){this.edgePath.count>2||(this.edgePath.count===2&&this.headSite.next.next!=null&&this.headSite.next.next.next==null&&this.anchors[this.EdgePathNode(1)].node==null?this.OptimizeForThreeSites():this.edgePath.count===1&&this.OptimizeForTwoSites())}PositionsAreLegal(t,e,i,n,o,s){if(!Q(t,e)&&(t-e)*i>0)return!1;let a=this.anchors[s],u=this.MiddlePos(t,e,n,o,a.y);return this.MiddleAnchorLegal(u,s,a)?!this.LineSegIntersectBound(new d(t,n.bottom),new d(e,o.top)):!1}MiddleAnchorLegal(t,e,i){let n=this.NodeLayer(e),o=this.layerArrays.x[e],s=t-i.x;return!(o>0&&this.anchors[n[o-1]].right>s+i.left||o<n.length-1&&this.anchors[n[o+1]].left<s+i.right)}MiddlePos(t,e,i,n,o){let s=i.y-o,a=o-n.y;return(t*s+e*a)/(s+a)}TryToRemoveInflections(){if(this.TurningAlwaySameDirection())return;let t=!0;for(;t;){t=!1;for(let e={s:this.headSite,cut:!1};e.s;)this.TryToRemoveInflectionCorner(e),t=e.cut||t}}TurningAlwaySameDirection(){let t=0;for(let e=this.headSite.next;e!=null&&e.next!=null;e=e.next){let i=e.turn;if(t===0)i>0?t=1:i<0&&(t=-1);else if(t*i<0)return!1}return!0}EdgePathPoint(t){return this.anchors[this.EdgePathNode(t)].origin}EdgePathNode(t){return t===this.edgePath.count?this.edgePath.LayerEdges[this.edgePath.count-1].Target:this.edgePath.LayerEdges[t].Source}createSmoothedPolyline(){this.RemoveVerticesWithNoTurns();let t=new E,e=this.headSite,i=E.findCorner(e);return i!==void 0?(this.createFilletCurve(t,{a:e,b:i.b,c:i.c}),t=this.ExtendCurveToEndpoints(t)):t.addSegment(w.mkPP(this.headSite.point,this.TailSite.point)),t}curveIsLegal(t){return!0}RemoveVerticesWithNoTurns(){for(;this.RemoveVerticesWithNoTurnsOnePass(););}RemoveVerticesWithNoTurnsOnePass(){let t=!1;for(let e=this.headSite;e.next!=null&&e.next.next!=null;e=e.next)Pt.Flat(e.next)&&(t=!0,e.next=e.next.next,e.next.prev=e);return t}ExtendCurveToEndpoints(t){let e=this.headSite.point;if(!d.closeDistEps(e,t.start)){let i=new E;i.addSegs([w.mkPP(e,t.start),t]),t=i}return e=this.TailSite.point,d.closeDistEps(e,t.end)||t.addSegment(w.mkPP(t.end,e)),t}createFilletCurve(t,e){for(;this.AddSmoothedCorner(e.a,e.b,e.c,t),e.a=e.b,e.b=e.c,e.b.next!=null;)e.c=e.b.next}AddSmoothedCorner(t,e,i,n){let o=.5,s;do s=E.createBezierSeg(o,o,t,e,i),e.previouisBezierCoefficient=o,o/=2;while(this.BezierSegIntersectsBoundary(s));if(o*=2,o<.5){o=.5*(o+o*2);let a=E.createBezierSeg(o,o,t,e,i);this.BezierSegIntersectsBoundary(a)||(e.nextBezierCoefficient=o,e.previouisBezierCoefficient=o,s=a)}n.segs.length>0&&!d.closeDistEps(n.end,s.start)&&n.addSegment(w.mkPP(n.end,s.start)),n.addSegment(s)}BezierSegIntersectsBoundary(t){return d.signedDoubledTriangleArea(t.B(0),t.B(1),t.B(2))<0?this.BezierSegIntersectsTree(t,this.thinWestHierarchy)||this.BezierSegIntersectsTree(t,this.westHierarchy):this.BezierSegIntersectsTree(t,this.thinEastHierarchy)||this.BezierSegIntersectsTree(t,this.eastHierarchy)}BezierSegIntersectsTree(t,e){if(e==null)return!1;if(ae.intersect(t.pNodeOverICurve().parallelogram,e.parallelogram))if(e.node.hasOwnProperty("children")){let i=e.node;return this.BezierSegIntersectsTree(t,i.children[0])||this.BezierSegIntersectsTree(t,i.children[1])}else return Pt.BezierSegIntersectsBoundary(t,e.seg);else return!1}static BezierSegIntersectsBoundary(t,e){for(let i of E.getAllIntersections(t,e,!1))if(e instanceof E){let n=e;if(E.realCutWithClosedCurve(i,n,!1))return!0}else return!0;return!1}};var qr=class extends _{constructor(e,i,n,o,s,a){super(null);this.settings=e,this.OriginalGraph=i,this.Database=n,this.ProperLayeredGraph=s,this.LayerArrays=o,this.IntGraph=a}run(){this.createSplines()}createSplines(){this.createRegularSplines(),this.createSelfSplines(),this.IntGraph!=null&&this.RouteFlatEdges(),this.OriginalGraph.graph.parent==null&&this.RouteUnroutedEdges()}RouteUnroutedEdges(){let e=[];for(let a of this.OriginalGraph.deepEdges)a.curve||e.push(a);if(e.length==0)return;let n=(this.OriginalGraph.layoutSettings?this.OriginalGraph.layoutSettings:new _e).commonSettings.edgeRoutingSettings;new fe(this.OriginalGraph,e,n.padding,n.polylinePadding,n.coneAngle,n.bundlingSettings,this.cancelToken).run(),xr.constructorGA(this.OriginalGraph,e).run()}RouteFlatEdges(){}createRegularSplines(){for(let e of this.Database.RegularMultiedges()){if($p(e))continue;let i=e.length,n=i===1&&this.MayOptimizeEdge(e[0]);for(let o=Math.floor(i/2);o<i;o++)this.createSplineForNonSelfEdge(e[o],n);for(let o=Math.floor(i/2)-1;o>=0;o--)this.createSplineForNonSelfEdge(e[o],n)}}MayOptimizeEdge(e){return!(this.ProperLayeredGraph.OutDegreeIsMoreThanOne(e.source)||this.ProperLayeredGraph.InDegreeIsMoreThanOne(e.target)||Zd(e.edge.source)||Zd(e.edge.target))}createSelfSplines(){for(let[e,i]of this.Database.Multiedges.keyValues()){let n=e;if(n.x===n.y){let o=this.Database.Anchors[n.x],s=o.leftAnchor;for(let a of i){let u=this.settings.NodeSeparation+(this.settings.MinNodeWidth+s),h=o.bottomAnchor/2,c=o.origin,f=c.add(new d(0,h)),P=c.add(new d(u,h)),v=c.add(new d(u,-h)),A=c.add(new d(0,-h)),O=ye.mkSiteP(c),M=new Ge(O);O=ye.mkSiteSP(O,f),O=ye.mkSiteSP(O,P),O=ye.mkSiteSP(O,v),O=ye.mkSiteSP(O,A),ye.mkSiteSP(O,c);let z=M.createCurve();if(a.curve=z,a.edge.smoothedPolyline=M,s=u,a.edge.label!=null){s+=a.edge.label.width;let $=z.value((z.parStart+z.parEnd)/2),N=new d($.x+a.labelWidth/2,o.y),q=new d(a.edge.label.width/2,a.edge.label.height/2),Te=D.mkPP(N.add(q),N.sub(q));a.edge.label.width=Te.width,a.edge.label.height=Te.height,a.edge.label.positionCenter(N)}We.trimSplineAndCalculateArrowheadsII(a.edge,a.edge.source.boundaryCurve,a.edge.target.boundaryCurve,z,!1)}}}}createSplineForNonSelfEdge(e,i){e.LayerEdges!=null&&(this.drawSplineBySmothingThePolyline(e,i),e.IsVirtualEdge||(e.updateEdgeLabelPosition(this.Database.Anchors),We.trimSplineAndCalculateArrowheadsII(e.edge,e.edge.source.boundaryCurve,e.edge.target.boundaryCurve,e.curve,!0)))}drawSplineBySmothingThePolyline(e,i){let n=new Pt(e,this.Database.Anchors,this.OriginalGraph,this.settings,this.LayerArrays,this.ProperLayeredGraph,this.Database),o=n.getSpline(i);e.reversed?(e.curve=o.reverse(),e.underlyingPolyline=n.Reverse().GetPolyline):(e.curve=o,e.underlyingPolyline=n.GetPolyline)}static UpdateLabel(e,i){let n=null;i.labelIsToTheRightOfTheSpline?(e.label.positionCenter(new d(i.x+i.rightAnchor/2,i.y)),n=w.mkPP(e.label.boundingBox.leftTop,e.label.boundingBox.leftBottom)):i.labelIsToTheLeftOfTheSpline&&(e.label.positionCenter(new d(i.x-i.leftAnchor/2,i.y)),n=w.mkPP(e.label.boundingBox.rightTop,e.label.boundingBox.rightBottom));let o=qr.GetSegmentInFrontOfLabel(e.curve,e.label.center.y);if(o!=null&&E.getAllIntersections(e.curve,E.polyFromBox(e.label.boundingBox),!1).length===0){let s={curveClosestPoint:void 0,labelSideClosest:void 0};if(qr.FindClosestPoints(s,o,n))qr.ShiftLabel(e,s);else{let a=o.closestParameter(n.start),u=o.closestParameter(n.end);o.value(a).sub(n.start).length<o.value(u).sub(n.end).length?(s.curveClosestPoint=o.value(a),s.labelSideClosest=n.start):(s.curveClosestPoint=o.value(u),s.labelSideClosest=n.end),qr.ShiftLabel(e,s)}}}static ShiftLabel(e,i){let n=e.lineWidth/2,o=i.curveClosestPoint.sub(i.labelSideClosest),s=o.length;s>n&&e.label.positionCenter(e.label.center.add(o.div(s*(s-n))))}static FindClosestPoints(e,i,n){let o=E.minDistWithinIntervals(i,n,i.parStart,i.parEnd,n.parStart,n.parEnd,(i.parStart+i.parEnd)/2,(n.parStart+n.parEnd)/2);return o?(e.curveClosestPoint=o.aX,e.labelSideClosest=o.bX,!0):!1}static GetSegmentInFrontOfLabel(e,i){if(e instanceof E){let n=e;for(let o of n.segs)if((o.start.y-i)*(o.end.y-i)<=0)return o}return null}static GetNodeKind(e,i){return e===0?0:e<i.count?1:2}};function $p(l){if(l.length<4)return!1;for(let t of l)if(t.edge.label)return!1;return!0}function Zd(l){return l.node.selfEdges.size>0}var cs=class extends _{constructor(e,i,n){super(n);this.LayersAreDoubled=!1;if(e==null)return;this.originalGraph=e,this.sugiyamaSettings=i;let o=Array.from(e.shallowNodes);this.nodeIdToIndex=new Map;let s=0;for(let u of o)this.nodeIdToIndex.set(u.id,s++);let a=[];for(let u of this.originalGraph.shallowEdges){let h=this.nodeIdToIndex.get(u.source.id);if(h==null)continue;let c=this.nodeIdToIndex.get(u.target.id);if(c==null)continue;let f=new Vt(h,c,u);a.push(f)}this.IntGraph=new Gi(a,e.shallowNodeCount),this.IntGraph.nodes=o,this.database=new Zl(o.length);for(let u of this.IntGraph.edges)this.database.registerOriginalEdgeInMultiedges(u);this.cycleRemoval()}get extremeAspectRatio(){let e=this.originalGraph.boundingBox,i=e.width/e.height;return i<1/50||i>50}get verticalConstraints(){return this.sugiyamaSettings.verticalConstraints}get HorizontalConstraints(){return this.sugiyamaSettings.horizontalConstraints}run(){if(this.originalGraph.shallowNodeCount===0){this.originalGraph.boundingBox=D.mkEmpty();return}hb(this.originalGraph,this.sugiyamaSettings.transform),this.engineLayerArrays=this.calculateLayers(),this.sugiyamaSettings.edgeRoutingSettings.EdgeRoutingMode===3&&this.runPostLayering(),cb(this.originalGraph,this.sugiyamaSettings.transform)}runPostLayering(){let e=this.sugiyamaSettings.commonSettings.edgeRoutingSettings,i=this.constrainedOrdering!=null?0:e.EdgeRoutingMode;this.extremeAspectRatio?Ll(this.originalGraph,Array.from(this.originalGraph.deepEdges),this.cancelToken):i===3?this.calculateEdgeSplines():bo(this.originalGraph,Array.from(this.originalGraph.deepEdges),this.cancelToken)}SetLabels(){throw new Error("not implementedt")}cycleRemoval(){let e=this.sugiyamaSettings.verticalConstraints,i=e.isEmpty?cr.getFeedbackSet(this.IntGraph):e.getFeedbackSetExternal(this.IntGraph,this.nodeIdToIndex);this.database.addFeedbackSet(i)}calculateLayers(){this.CreateGluedDagSkeletonForLayering();let e=this.CalculateLayerArrays();return this.UpdateNodePositionData(),e}UpdateNodePositionData(){for(let e=0;e<this.IntGraph.nodeCount&&e<this.database.Anchors.length;e++)this.IntGraph.nodes[e].center=this.database.Anchors[e].origin;if(this.sugiyamaSettings.GridSizeByX>0)for(let e=0;e<this.originalGraph.shallowNodeCount;e++)this.SnapLeftSidesOfTheNodeToGrid(e,this.sugiyamaSettings.GridSizeByX)}SnapLeftSidesOfTheNodeToGrid(e,i){let n=this.IntGraph.nodes[e],o=this.database.Anchors[e];o.leftAnchor-=i/2,o.rightAnchor-=i/2;let s=n.boundingBox.left,a=Math.floor(s/i),u=s-a*i;Math.abs(u)<.001||(Math.abs(u)<=i/2?n.center=n.center.add(new d(-u,0)):n.center=n.center.add(new d(i-u,0)),o.x=n.center.x)}GetCurrentHeight(){let e=new Cr;for(let i of this.NodeAnchors())e.AddValue(i.top),e.AddValue(i.bottom);return e.length}*NodeAnchors(){let e=Math.min(this.IntGraph.nodeCount,this.anchors.length);for(let i=0;i<e;i++)yield this.anchors[i]}GetCurrentWidth(){let e=new Cr;for(let i of this.NodeAnchors())e.AddValue(i.left),e.AddValue(i.right);return e.length}ExtendLayeringToUngluedSameLayerVertices(e){let i=this.verticalConstraints;for(let n=0;n<e.length;n++)e[n]=e[i.nodeToRepr(n)];return e}calculateEdgeSplines(){new qr(this.sugiyamaSettings,this.originalGraph,this.database,this.engineLayerArrays,this.properLayeredGraph,this.IntGraph).run()}YLayeringAndOrdering(e){let i=e.GetLayers();ps.Balance(this.gluedDagSkeletonForLayering,i,this.GetNodeCountsOfGluedDag(),null),i=this.ExtendLayeringToUngluedSameLayerVertices(i);let n=new fr(i);if(this.HorizontalConstraints==null||this.HorizontalConstraints.IsEmpty)return n=this.YLayeringAndOrderingWithoutHorizontalConstraints(n),n;throw new Error("not implemented")}CreateProperLayeredGraph(e){let i=e.length,n=0;for(let s of this.database.SkeletonEdges()){let a=eb(e,s);a>0&&(s.LayerEdges=new Array(a));let u=0;if(a>1){let h=i+n++,c=new gr(s.source,h,s.CrossingWeight,s.weight);s.LayerEdges[u++]=c;for(let f=0;f<a-2;f++)h++,n++,c=new gr(h-1,h,s.CrossingWeight,s.weight),s.LayerEdges[u++]=c;c=new gr(h,s.target,s.CrossingWeight,s.weight),s.LayerEdges[u]=c}else if(a===1){let h=new gr(s.source,s.target,s.CrossingWeight,s.weight);s.LayerEdges[u]=h}}let o=new Array(this.originalGraph.shallowNodeCount+n).fill(0);for(let s of this.database.SkeletonEdges())if(s.LayerEdges!=null){let a=e[s.source];o[s.source]=a--;for(let u of s.LayerEdges)o[u.Target]=a--}else o[s.source]=e[s.source],o[s.target]=e[s.target];return this.properLayeredGraph=new zr(new Gi(Array.from(this.database.SkeletonEdges()),e.length)),this.properLayeredGraph.BaseGraph.nodes=this.IntGraph.nodes,new fr(o)}YLayeringAndOrderingWithoutHorizontalConstraints(e){let i=this.CreateProperLayeredGraph(e.y);return tn.OrderLayers(this.properLayeredGraph,i,this.originalGraph.shallowNodeCount,this.sugiyamaSettings,this.cancelToken),Io.UpdateLayerArrays1(this.properLayeredGraph,i),i}CalculateYLayers(){let e=this.YLayeringAndOrdering(new iu(this.gluedDagSkeletonForLayering,this.cancelToken));return this.constrainedOrdering!=null?e:this.InsertLayersIfNeeded(e)}InsertLayersIfNeeded(e){this.InsertVirtualEdgesIfNeeded(e);let i=this.AnalyzeNeedToInsertLayersAndHasMultiedges(e);if(i.needToInsertLayers){let n=en.InsertLayers(this.properLayeredGraph,e,this.database,this.IntGraph);this.properLayeredGraph=n.layeredGraph,e=n.la,this.LayersAreDoubled=!0}else if(i.multipleEdges){let n=ri.InsertPaths(this.properLayeredGraph,e,this.database,this.IntGraph);this.properLayeredGraph=n.layeredGraph,e=n.la}return this.RecreateIntGraphFromDataBase(),e}RecreateIntGraphFromDataBase(){let e=new Array;for(let i of this.database.Multiedges.values())e=e.concat(i);this.IntGraph.SetEdges(e,this.IntGraph.nodeCount)}InsertVirtualEdgesIfNeeded(e){if(this.constrainedOrdering==null){for(let[i,n]of this.database.Multiedges.keyValues())if(n.length%2===0&&e.y[i.x]-1===e.y[i.y]){let o=new Re(null),s=new Vt(i.x,i.y,o);s.IsVirtualEdge=!0,n.splice(n.length/2,0,s),this.IntGraph.addEdge(s)}}}AnalyzeNeedToInsertLayersAndHasMultiedges(e){let i=!1,n=!1;for(let o of this.IntGraph.edges)if(o.hasLabel&&e.y[o.source]!==e.y[o.target]){i=!0;break}if(i===!1&&this.constrainedOrdering==null){for(let[o,s]of this.database.Multiedges.keyValues())if(s.length>1&&(n=!0,e.y[o.x]-e.y[o.y]===1)){i=!0;break}}return{needToInsertLayers:i,multipleEdges:n}}UseBrandesXCalculations(e){return e.x.length>=this.sugiyamaSettings.BrandesThreshold}CalculateAnchorsAndYPositions(e){this.anchors=Yp(this.database,this.properLayeredGraph,this.originalGraph,this.IntGraph,this.sugiyamaSettings),Zp(e,500,this.originalGraph,this.database,this.IntGraph,this.sugiyamaSettings,this.LayersAreDoubled)}OptimizeEdgeLabelsLocations(){for(let e=0;e<this.anchors.length;e++){let i=this.anchors[e];if(i.labelIsToTheRightOfTheSpline){let n=this.GetSuccessorAndPredecessor(e);if(!nb(i,n.predecessor,n.successor)){let o=n.predecessor.origin.sub(i.origin).length+n.successor.origin.sub(i.origin).length,s=i.right-i.leftAnchor,a=new d(s,i.y);n.predecessor.origin.sub(a).length+n.successor.origin.sub(a).length<o&&rg(i)}}}}GetSuccessorAndPredecessor(e){let i;for(let o of this.properLayeredGraph.InEdges(e))i=o.Source;let n;for(let o of this.properLayeredGraph.OutEdges(e))n=o.Target;return{predecessor:this.anchors[i],successor:this.anchors[n]}}CalculateLayerArrays(){let e=this.CalculateYLayers();return this.constrainedOrdering==null?(this.CalculateAnchorsAndYPositions(e),this.UseBrandesXCalculations(e)?this.CalculateXPositionsByBrandes(e):this.CalculateXLayersByGansnerNorth(e)):this.anchors=this.database.Anchors,this.OptimizeEdgeLabelsLocations(),this.engineLayerArrays=e,this.StraightensShortEdges(),this.CalculateOriginalGraphBox(),e}StretchToDesiredAspectRatio(e,i){e>i?this.StretchInYDirection(e/i):e<i&&this.StretchInXDirection(i/e)}StretchInYDirection(e){let i=(this.originalGraph.boundingBox.top+this.originalGraph.boundingBox.bottom)/2;for(let o of this.database.Anchors)o.bottomAnchor=o.bottomAnchor*e,o.topAnchor=o.topAnchor*e,o.y=i+e*(o.y-i);let n=this.originalGraph.height*e;this.originalGraph.boundingBox=new D({left:this.originalGraph.boundingBox.left,top:i+n/2,right:this.originalGraph.boundingBox.right,bottom:i-n/2})}StretchInXDirection(e){let i=(this.originalGraph.boundingBox.left+this.originalGraph.boundingBox.right)/2;for(let o of this.database.Anchors)o.leftAnchor=o.leftAnchor*e,o.rightAnchor=o.rightAnchor*e,o.x=i+e*(o.x-i);let n=this.originalGraph.width*e;this.originalGraph.boundingBox=new D({left:i-n/2,top:this.originalGraph.boundingBox.top,right:i+n/2,bottom:this.originalGraph.boundingBox.bottom})}CalculateOriginalGraphBox(){if(this.anchors.length===0)return;let e=new D({left:this.anchors[0].left,top:this.anchors[0].top,right:this.anchors[0].right,bottom:this.anchors[0].bottom});for(let i=1;i<this.anchors.length;i++){let n=this.anchors[i];e.add(n.leftTop),e.add(n.rightBottom)}this.originalGraph.labelSize&&this.originalGraph.addLabelToGraphBB(e),e.padEverywhere(this.originalGraph.margins),this.originalGraph.boundingBox=e}StraightensShortEdges(){for(;this.StraightenEdgePaths(););}StraightenEdgePaths(){let e=!1;for(let i of this.database.AllIntEdges())i.LayerSpan===2&&(e=this.ShiftVertexWithNeighbors(i.LayerEdges[0].Source,i.LayerEdges[0].Target,i.LayerEdges[1].Target)||e);return e}ShiftVertexWithNeighbors(e,i,n){let o=this.database.Anchors[e],s=this.database.Anchors[n],a=this.database.Anchors[i],u=(a.y-o.y)*((s.x-o.x)/(s.y-o.y))+o.x,h=1e-4;return u>a.x+h?this.TryShiftToTheRight(u,i):u<a.x-h?this.TryShiftToTheLeft(u,i):!1}TryShiftToTheLeft(e,i){let n=this.engineLayerArrays.Layers[this.engineLayerArrays.y[i]],o=this.engineLayerArrays.x[i];if(o>0){let s=this.database.Anchors[n[o-1]],a=Math.max(s.right+(this.sugiyamaSettings.NodeSeparation+this.database.Anchors[i].leftAnchor),e);return a<this.database.Anchors[i].x-1?(this.database.Anchors[i].x=a,!0):!1}return this.database.Anchors[i].x=e,!0}TryShiftToTheRight(e,i){let n=this.engineLayerArrays.Layers[this.engineLayerArrays.y[i]],o=this.engineLayerArrays.x[i];if(o<n.length-1){let s=this.database.Anchors[n[o+1]],a=Math.min(s.left-(this.sugiyamaSettings.NodeSeparation-this.database.Anchors[i].rightAnchor),e);return a>this.database.Anchors[i].x+1?(this.database.Anchors[i].x=a,!0):!1}return this.database.Anchors[i].x=e,!0}CalculateXLayersByGansnerNorth(e){this.xLayoutGraph=this.CreateXLayoutGraph(e),this.CalculateXLayersByGansnerNorthOnProperLayeredGraph()}CalculateXLayersByGansnerNorthOnProperLayeredGraph(){let e=new bs(this.xLayoutGraph,null).GetLayers();for(let i=0;i<this.database.Anchors.length;i++)this.anchors[i].x=e[i]}CreateXLayoutGraph(e){let i=this.properLayeredGraph.NodeCount,n=new Array;for(let s of this.properLayeredGraph.Edges){let a=new Vt(i,s.Source,null),u=new Vt(i,s.Target,null);u.weight=s.Weight,a.weight=s.Weight,a.separation=0,u.separation=0,i++,n.push(a),n.push(u)}for(let s of e.Layers)for(let a=s.length-1;a>0;a--){let u=s[a],h=s[a-1],c=new Vt(u,h,null),f=this.database.Anchors[u],P=this.database.Anchors[h],v=f.leftAnchor+(P.rightAnchor+this.sugiyamaSettings.NodeSeparation);c.separation=Math.ceil(v+.5),n.push(c)}let o=new nu(this.IntGraph,this.properLayeredGraph,e,n,i);return o.SetEdgeWeights(),o}CalculateXPositionsByBrandes(e){ma.CalculateXCoordinates(e,this.properLayeredGraph,this.originalGraph.shallowNodeCount,this.database.Anchors,this.sugiyamaSettings.NodeSeparation)}GluedDagSkeletonEdges(){let e=new ar(this.IntGraph.nodeCount);for(let[n,o]of this.database.Multiedges.keyValues()){if(n.isDiagonal())continue;let s=this.verticalConstraints.gluedIntEdge(o[0]);s.source!==s.target&&e.set(s.source,s.target,s)}let i=Array.from(this.verticalConstraints.gluedUpDownIntConstraints.values()).map(n=>_p(n,null));for(let n of i)e.set(n.source,n.target,n);return Array.from(e.values())}static CalcAnchorsForOriginalNode(e,i,n,o,s){let a={leftAnchor:0,rightAnchor:0,topAnchor:0,bottomAnchor:0};if(i.nodes!=null){let c=i.nodes[e];ab(a,c,s)}lb(e,a,o,s);let u=s.MinNodeWidth/2;a.leftAnchor<u&&(a.leftAnchor=u),a.rightAnchor<u&&(a.rightAnchor=u);let h=s.MinNodeHeight/2;a.topAnchor<h&&(a.topAnchor=h),a.bottomAnchor<h&&(a.bottomAnchor=h),n[e]=Kt.mkAnchor(a.leftAnchor,a.rightAnchor,a.topAnchor,a.bottomAnchor,i.nodes[e],s.LabelCornersPreserveCoefficient),n[e].padding=i.nodes[e].padding}CreateGluedDagSkeletonForLayering(){this.gluedDagSkeletonForLayering=new Gi(this.GluedDagSkeletonEdges(),this.originalGraph.shallowNodeCount),this.SetGluedEdgesWeights()}SetGluedEdgesWeights(){let e=new ar(this.IntGraph.nodeCount);for(let i of this.gluedDagSkeletonForLayering.edges)e.set(i.source,i.target,i);for(let[i,n]of this.database.Multiedges.keyValues())if(i.x!==i.y){let o=this.verticalConstraints.gluedIntPair(i);if(o.x===o.y)continue;let s=e.get(o.x,o.y);for(let a of n)s.weight+=a.weight}}GetNodeCountsOfGluedDag(){return this.verticalConstraints.isEmpty?new Array(this.IntGraph.nodeCount).fill(1):this.verticalConstraints.getGluedNodeCounts()}};function _d(l,t){if(t===0)return 0;let e=Math.floor(l/t),i=l-e*t;return Math.abs(i)<1e-4?0:t-i}function Kp(l,t){for(let e of l)if(e<t)return!0;return!1}function Yp(l,t,e,i,n){let o=l.Anchors=new Array(t.NodeCount);for(let s=0;s<o.length;s++)o[s]=new Kt(n.LabelCornersPreserveCoefficient);for(let s=0;s<e.shallowNodeCount;s++)cs.CalcAnchorsForOriginalNode(s,i,o,l,n);for(let s of l.AllIntEdges())if(s.LayerEdges!=null){for(let a of s.LayerEdges){let u=a.Target;if(u!==s.target){let h=o[u];l.MultipleMiddles.has(u)?(h.leftAnchor=h.rightAnchor=xh()*4,h.topAnchor=h.bottomAnchor=eg(n)/2):(h.leftAnchor=h.rightAnchor=xh()/2,h.topAnchor=h.bottomAnchor=eg(n)/2)}}if(s.hasLabel){let a=s.LayerEdges[s.LayerEdges.length/2].Source,u=o[a],h=s.labelWidth,c=s.labelHeight;u.rightAnchor=h,u.leftAnchor=xh()*8,u.topAnchor<c/2&&(u.topAnchor=u.bottomAnchor=c/2),u.labelIsToTheRightOfTheSpline=!0}}return o}function xh(){return 1}function eg(l){return l.MinNodeHeight*1.5/8}function tg(l,t,e,i,n,o){let s=0;if(e>0){let a=ob(t.Layers[e-1],t.y,i);if(a.length){let u=n.LayerSeparation/3,h=o;s=Math.max(...a.map(c=>sb(c,h,u,l)))}}return s}function Zp(l,t,e,i,n,o,s){let a=i.Anchors,u=e.margins.top+t,h=0;for(let c of l.Layers){let f=0,P=0;for(let z of c){let $=a[z];$.bottomAnchor>f&&(f=$.bottomAnchor),$.topAnchor>P&&(P=$.topAnchor)}tb(c,f,P,e.shallowNodeCount,i.Anchors);let v=tg(i,l,h,n,o,u),A=u+f+v,O=A+P;if(rb(o)){O+=_d(O,o.GridSizeByY);for(let z of c)a[z].top=O}else if(ib(o)){let z=A-f;z+=_d(z,z);for(let $ of c)a[$].bottom=z,O=Math.max(a[$].top,O)}else for(let z of c)a[z].y=A;let M=o.ActualLayerSeparation(s);u=O+M,h++}tg(i,l,h,n,o,u)}function _p(l,t){let e=new Vt(l.x,l.y,t);return e.weight=0,e.separation=1,e}function eb(l,t){return l[t.source]-l[t.target]}function tb(l,t,e,i,n){if(Kp(l,i)){for(let o of l)if(o>=i){let s=n[o];s.bottomAnchor=t,s.topAnchor=e}}}function rb(l){return l.SnapToGridByY===1}function ib(l){return l.SnapToGridByY===2}function nb(l,t,e){if(l.labelIsToTheRightOfTheSpline){if(d.getTriangleOrientation(t.origin,l.origin,e.origin)===0)return!0;let i=l.leftAnchor,n=l.rightAnchor,o=l.x;return rg(l),d.getTriangleOrientation(t.origin,l.origin,e.origin)===1?!0:(l.x=o,l.leftAnchor=i,l.rightAnchor=n,l.labelIsToTheRightOfTheSpline=!0,l.labelIsToTheLeftOfTheSpline=!1,!1)}return!1}function rg(l){let t=l.right,e=l.leftAnchor;l.leftAnchor=l.rightAnchor,l.rightAnchor=e,l.x=t-l.rightAnchor,l.labelIsToTheLeftOfTheSpline=!0,l.labelIsToTheRightOfTheSpline=!1}function ob(l,t,e){let i=new wt;for(let n of l)if(!(n>=e.nodeCount))for(let o of e.outEdges[n])t[o.source]===t[o.target]&&i.addNN(o.source,o.target);return Array.from(i.values())}function sb(l,t,e,i){let n=0,o=i.GetMultiedgeI(l);for(let s of o){n+=e;let a=s.edge.label;a!=null&&(a.positionCenter(new d(a.center.x,t+n+a.height/2)),n+=a.height)}return n}function ab(l,t,e){l.rightAnchor=l.leftAnchor=(t.width+e.GridSizeByX)/2,l.topAnchor=l.bottomAnchor=t.height/2}function lb(l,t,e,i){let n=ub(e,l,t,i);t.rightAnchor+=n}function ub(l,t,e,i){let n=0,o=l.GetMultiedge(t,t);if(o.length>0){for(let s of o)s.edge.label!=null&&(e.rightAnchor+=s.edge.label.width,e.topAnchor<s.edge.label.height/2&&(e.topAnchor=e.bottomAnchor=s.edge.label.height/2));n+=(i.NodeSeparation+i.MinNodeWidth)*o.length}return n}function hb(l,t){if(t.isIdentity())return;let e=t.inverse();for(let i of l.shallowNodes)i.transform(e);for(let i of l.shallowEdges)if(i.label!=null){let n=D.mkPP(e.multiplyPoint(new d(0,0)),e.multiplyPoint(new d(i.label.width,i.label.height)));i.label.width=n.width,i.label.height=n.height}}function cb(l,t){if(!t.isIdentity()){for(let e of l.shallowNodes)e.transform(t);for(let e of l.shallowEdges)if(e.label!=null){let i=D.mkPP(t.multiplyPoint(new d(0,0)),t.multiplyPoint(new d(e.label.width,e.label.height)));e.label.width=i.width,e.label.height=i.height}db(l,t),l.graph.parent==null&&(l.boundingBox=null)}}function db(l,t){for(let e of l.shallowEdges)e.label&&e.label.transform(t),gb(t,e)}function gb(l,t){if(t.curve!=null){t.curve=t.curve.transform(l);let e=t;e.sourceArrowhead!=null&&(e.sourceArrowhead.tipPosition=l.multiplyPoint(e.sourceArrowhead.tipPosition)),e.targetArrowhead!=null&&(e.targetArrowhead.tipPosition=l.multiplyPoint(e.targetArrowhead.tipPosition)),mb(t,l)}}function mb(l,t){if(l.smoothedPolyline!=null)for(let e=l.smoothedPolyline.headSite;e!=null;e=e.next)e.point=t.multiplyPoint(e.point)}var Jb=he(ag(),1);var ii=(N=>(N[N.normal=0]="normal",N[N.inv=1]="inv",N[N.dot=2]="dot",N[N.invdot=3]="invdot",N[N.odot=4]="odot",N[N.invodot=5]="invodot",N[N.none=6]="none",N[N.tee=7]="tee",N[N.empty=8]="empty",N[N.invempty=9]="invempty",N[N.diamond=10]="diamond",N[N.odiamond=11]="odiamond",N[N.ediamond=12]="ediamond",N[N.crow=13]="crow",N[N.box=14]="box",N[N.obox=15]="obox",N[N.open=16]="open",N[N.halfopen=17]="halfopen",N[N.vee=18]="vee",N))(ii||{});var wo=(q=>(q[q.diamond=0]="diamond",q[q.ellipse=1]="ellipse",q[q.box=2]="box",q[q.circle=3]="circle",q[q.record=4]="record",q[q.plaintext=5]="plaintext",q[q.point=6]="point",q[q.mdiamond=7]="mdiamond",q[q.msquare=8]="msquare",q[q.polygon=9]="polygon",q[q.doublecircle=10]="doublecircle",q[q.house=11]="house",q[q.invhouse=12]="invhouse",q[q.parallelogram=13]="parallelogram",q[q.octagon=14]="octagon",q[q.tripleoctagon=15]="tripleoctagon",q[q.triangle=16]="triangle",q[q.trapezium=17]="trapezium",q[q.drawFromGeometry=18]="drawFromGeometry",q[q.hexagon=19]="hexagon",q))(wo||{});var ou=(o=>(o[o.same=0]="same",o[o.min=1]="min",o[o.source=2]="source",o[o.max=3]="max",o[o.sink=4]="sink",o))(ou||{});var fa=(h=>(h[h.none=0]="none",h[h.dashed=1]="dashed",h[h.solid=2]="solid",h[h.invis=3]="invis",h[h.bold=4]="bold",h[h.filled=5]="filled",h[h.diagonals=6]="diagonals",h[h.dotted=7]="dotted",h[h.rounded=8]="rounded",h))(fa||{});var su=(n=>(n[n.forward=0]="forward",n[n.back=1]="back",n[n.both=2]="both",n[n.none=3]="none",n))(su||{});var au=(e=>(e[e.in=0]="in",e[e.out=1]="out",e))(au||{});var S=class{static mkWithKeyword(t,e,i,n,o){let s=new S(t,e,i,n);return s.keyword=o,s}static parse(t){switch(t.toLowerCase()){case"aliceblue":return S.AliceBlue;case"antiquewhite":return S.AntiqueWhite;case"aqua":return S.Aqua;case"aquamarine":return S.Aquamarine;case"azure":return S.Azure;case"beige":return S.Beige;case"bisque":return S.Bisque;case"black":return S.Black;case"blanchedalmond":return S.BlanchedAlmond;case"blue":return S.Blue;case"blueviolet":return S.BlueViolet;case"brown":return S.Brown;case"burlywood":return S.BurlyWood;case"cadetblue":return S.CadetBlue;case"chartreuse":return S.Chartreuse;case"chocolate":return S.Chocolate;case"coral":return S.Coral;case"cornflowerblue":return S.CornflowerBlue;case"cornsilk":return S.Cornsilk;case"crimson":return S.Crimson;case"cyan":return S.Cyan;case"darkblue":return S.DarkBlue;case"darkcyan":return S.DarkCyan;case"darkgoldenrod":return S.DarkGoldenrod;case"darkgray":return S.DarkGray;case"darkgreen":return S.DarkGreen;case"darkkhaki":return S.DarkKhaki;case"darkmagenta":return S.DarkMagenta;case"darkolivegreen":return S.DarkOliveGreen;case"darkorange":return S.DarkOrange;case"darkorchid":return S.DarkOrchid;case"darkred":return S.DarkRed;case"darksalmon":return S.DarkSalmon;case"darkseagreen":return S.DarkSeaGreen;case"darkslateblue":return S.DarkSlateBlue;case"darkslategray":return S.DarkSlateGray;case"darkturquoise":return S.DarkTurquoise;case"darkviolet":return S.DarkViolet;case"deeppink":return S.DeepPink;case"deepskyblue":return S.DeepSkyBlue;case"dimgray":return S.DimGray;case"dodgerblue":return S.DodgerBlue;case"firebrick":return S.Firebrick;case"floralwhite":return S.FloralWhite;case"forestgreen":return S.ForestGreen;case"fuchsia":return S.Fuchsia;case"gainsboro":return S.Gainsboro;case"ghostwhite":return S.GhostWhite;case"gold":return S.Gold;case"goldenrod":return S.Goldenrod;case"gray":return S.Gray;case"green":return S.Green;case"greenyellow":return S.GreenYellow;case"honeydew":return S.Honeydew;case"hotpink":return S.HotPink;case"indianred":return S.IndianRed;case"indigo":return S.Indigo;case"ivory":return S.Ivory;case"khaki":return S.Khaki;case"lavender":return S.Lavender;case"lavenderblush":return S.LavenderBlush;case"lawngreen":return S.LawnGreen;case"lemonchiffon":return S.LemonChiffon;case"lightblue":return S.LightBlue;case"lightcoral":return S.LightCoral;case"lightcyan":return S.LightCyan;case"lightgoldenrodyellow":return S.LightGoldenrodYellow;case"lightgray":case"lightgrey":return S.LightGray;case"lightgreen":return S.LightGreen;case"lightpink":return S.LightPink;case"lightsalmon":return S.LightSalmon;case"lightseagreen":return S.LightSeaGreen;case"lightskyblue":return S.LightSkyBlue;case"lightslategray":return S.LightSlateGray;case"lightsteelblue":return S.LightSteelBlue;case"lightyellow":return S.LightYellow;case"lime":return S.Lime;case"limegreen":return S.LimeGreen;case"linen":return S.Linen;case"magenta":return S.Magenta;case"maroon":return S.Maroon;case"mediumaquamarine":return S.MediumAquamarine;case"mediumblue":return S.MediumBlue;case"mediumorchid":return S.MediumOrchid;case"mediumpurple":return S.MediumPurple;case"mediumseagreen":return S.MediumSeaGreen;case"mediumslateblue":return S.MediumSlateBlue;case"mediumspringgreen":return S.MediumSpringGreen;case"mediumturquoise":return S.MediumTurquoise;case"mediumvioletred":return S.MediumVioletRed;case"midnightblue":return S.MidnightBlue;case"mintcream":return S.MintCream;case"mistyrose":return S.MistyRose;case"moccasin":return S.Moccasin;case"navajowhite":return S.NavajoWhite;case"navy":return S.Navy;case"oldlace":return S.OldLace;case"olive":return S.Olive;case"olivedrab":return S.OliveDrab;case"orange":return S.Orange;case"orangered":return S.OrangeRed;case"orchid":return S.Orchid;case"palegoldenrod":return S.PaleGoldenrod;case"palegreen":return S.PaleGreen;case"paleturquoise":return S.PaleTurquoise;case"palevioletred":return S.PaleVioletRed;case"papayawhip":return S.PapayaWhip;case"peachpuff":return S.PeachPuff;case"peru":return S.Peru;case"pink":return S.Pink;case"plum":return S.Plum;case"powderblue":return S.PowderBlue;case"purple":return S.Purple;case"red":return S.Red;case"rosybrown":return S.RosyBrown;case"royalblue":return S.RoyalBlue;case"saddlebrown":return S.SaddleBrown;case"salmon":return S.Salmon;case"sandybrown":return S.SandyBrown;case"seagreen":return S.SeaGreen;case"seashell":return S.SeaShell;case"sienna":return S.Sienna;case"silver":return S.Silver;case"skyblue":return S.SkyBlue;case"slateblue":return S.SlateBlue;case"slategray":return S.SlateGray;case"snow":return S.Snow;case"springgreen":return S.SpringGreen;case"steelblue":return S.SteelBlue;case"tan":return S.Tan;case"teal":return S.Teal;case"thistle":return S.Thistle;case"tomato":return S.Tomato;case"transparent":return S.Transparent;case"turquoise":return S.Turquoise;case"violet":return S.Violet;case"wheat":return S.Wheat;case"white":return S.White;case"whitesmoke":return S.WhiteSmoke;case"yellow":return S.Yellow;case"yellowgreen":return S.YellowGreen;default:return}}get keyword(){return this.keyword_}set keyword(t){this.keyword_=t}constructor(t,e,i,n){this.a=t,this.r=e,this.g=i,this.b=n}static mkRGB(t,e,i){return new S(255,t,e,i)}get A(){return this.a}set A(t){this.a=t}get R(){return this.r}set R(t){this.r=t}get G(){return this.g}set G(t){this.g=t}get B(){return this.b}set B(t){this.b=t}static Xex(t){let e=t.toString(16);return e.length===1?"0"+e:e.substring(e.length-2,2)}static equal(t,e){return t.a===e.a&&t.r===e.r&&t.b===e.b&&t.g===e.g}toString(){return this.keyword?this.keyword:'"#'+S.Xex(this.R)+S.Xex(this.G)+S.Xex(this.B)+(this.A===255?"":S.Xex(this.A))+'"'}static get AliceBlue(){return S.mkWithKeyword(255,240,248,255,"aliceblue")}static get AntiqueWhite(){return S.mkWithKeyword(255,250,235,215,"antiquewhite")}static get Aqua(){return S.mkWithKeyword(255,0,255,255,"aqua")}static get Aquamarine(){return S.mkWithKeyword(255,127,255,212,"aquamarine")}static get Azure(){return S.mkWithKeyword(255,240,255,255,"azure")}static get Beige(){return S.mkWithKeyword(255,245,245,220,"beige")}static get Bisque(){return S.mkWithKeyword(255,255,228,196,"bisque")}static get Black(){return S.mkWithKeyword(255,0,0,0,"black")}static get BlanchedAlmond(){return S.mkWithKeyword(255,255,235,205,"blanchedalmond")}static get Blue(){return S.mkWithKeyword(255,0,0,255,"blue")}static get BlueViolet(){return S.mkWithKeyword(255,138,43,226,"blueviolet")}static get Brown(){return S.mkWithKeyword(255,165,42,42,"brown")}static get BurlyWood(){return S.mkWithKeyword(255,222,184,135,"burlywood")}static get CadetBlue(){return S.mkWithKeyword(255,95,158,160,"cadetblue")}static get Chartreuse(){return S.mkWithKeyword(255,127,255,0,"chartreuse")}static get Chocolate(){return S.mkWithKeyword(255,210,105,30,"chocolate")}static get Coral(){return S.mkWithKeyword(255,255,127,80,"coral")}static get CornflowerBlue(){return S.mkWithKeyword(255,100,149,237,"cornflowerblue")}static get Cornsilk(){return S.mkWithKeyword(255,255,248,220,"cornsilk")}static get Crimson(){return S.mkWithKeyword(255,220,20,60,"crimson")}static get Cyan(){return S.mkWithKeyword(255,0,255,255,"cyan")}static get DarkBlue(){return S.mkWithKeyword(255,0,0,139,"darkblue")}static get DarkCyan(){return S.mkWithKeyword(255,0,139,139,"darkcyan")}static get DarkGoldenrod(){return S.mkWithKeyword(255,184,134,11,"darkgoldenrod")}static get DarkGray(){return S.mkWithKeyword(255,169,169,169,"darkgray")}static get DarkGreen(){return S.mkWithKeyword(255,0,100,0,"darkgreen")}static get DarkKhaki(){return S.mkWithKeyword(255,189,183,107,"darkkhaki")}static get DarkMagenta(){return S.mkWithKeyword(255,139,0,139,"darkmagenta")}static get DarkOliveGreen(){return S.mkWithKeyword(255,85,107,47,"darkolivegreen")}static get DarkOrange(){return S.mkWithKeyword(255,255,140,0,"darkorange")}static get DarkOrchid(){return S.mkWithKeyword(255,153,50,204,"darkorchid")}static get DarkRed(){return S.mkWithKeyword(255,139,0,0,"darkred")}static get DarkSalmon(){return S.mkWithKeyword(255,233,150,122,"darksalmon")}static get DarkSeaGreen(){return S.mkWithKeyword(255,143,188,139,"darkseagreen")}static get DarkSlateBlue(){return S.mkWithKeyword(255,72,61,139,"darkslateblue")}static get DarkSlateGray(){return S.mkWithKeyword(255,47,79,79,"darkslategray")}static get DarkTurquoise(){return S.mkWithKeyword(255,0,206,209,"darkturquoise")}static get DarkViolet(){return S.mkWithKeyword(255,148,0,211,"darkviolet")}static get DeepPink(){return S.mkWithKeyword(255,255,20,147,"deeppink")}static get DeepSkyBlue(){return S.mkWithKeyword(255,0,191,255,"deepskyblue")}static get DimGray(){return S.mkWithKeyword(255,105,105,105,"dimgray")}static get DodgerBlue(){return S.mkWithKeyword(255,30,144,255,"dodgerblue")}static get Firebrick(){return S.mkWithKeyword(255,178,34,34,"firebrick")}static get FloralWhite(){return S.mkWithKeyword(255,255,250,240,"floralwhite")}static get ForestGreen(){return S.mkWithKeyword(255,34,139,34,"forestgreen")}static get Fuchsia(){return S.mkWithKeyword(255,255,0,255,"fuchsia")}static get Gainsboro(){return S.mkWithKeyword(255,220,220,220,"gainsboro")}static get GhostWhite(){return S.mkWithKeyword(255,248,248,255,"ghostwhite")}static get Gold(){return S.mkWithKeyword(255,255,215,0,"gold")}static get Goldenrod(){return S.mkWithKeyword(255,218,165,32,"goldenrod")}static get Gray(){return S.mkWithKeyword(255,128,128,128,"gray")}static get Green(){return S.mkWithKeyword(255,0,128,0,"green")}static get GreenYellow(){return S.mkWithKeyword(255,173,255,47,"greenyellow")}static get Honeydew(){return S.mkWithKeyword(255,240,255,240,"honeydew")}static get HotPink(){return S.mkWithKeyword(255,255,105,180,"hotpink")}static get IndianRed(){return S.mkWithKeyword(255,205,92,92,"indianred")}static get Indigo(){return S.mkWithKeyword(255,75,0,130,"indigo")}static get Ivory(){return S.mkWithKeyword(255,255,255,240,"ivory")}static get Khaki(){return S.mkWithKeyword(255,240,230,140,"khaki")}static get Lavender(){return S.mkWithKeyword(255,230,230,250,"lavender")}static get LavenderBlush(){return S.mkWithKeyword(255,255,240,245,"lavenderblush")}static get LawnGreen(){return S.mkWithKeyword(255,124,252,0,"lawngreen")}static get LemonChiffon(){return S.mkWithKeyword(255,255,250,205,"lemonchiffon")}static get LightBlue(){return S.mkWithKeyword(255,173,216,230,"lightblue")}static get LightCoral(){return S.mkWithKeyword(255,240,128,128,"lightcoral")}static get LightCyan(){return S.mkWithKeyword(255,224,255,255,"lightcyan")}static get LightGoldenrodYellow(){return S.mkWithKeyword(255,250,250,210,"lightgoldenrodyellow")}static get LightGray(){return S.mkWithKeyword(255,211,211,211,"lightgray")}static get LightGreen(){return S.mkWithKeyword(255,144,238,144,"lightgreen")}static get LightPink(){return S.mkWithKeyword(255,255,182,193,"lightpink")}static get LightSalmon(){return S.mkWithKeyword(255,255,160,122,"lightsalmon")}static get LightSeaGreen(){return S.mkWithKeyword(255,32,178,170,"lightseagreen")}static get LightSkyBlue(){return S.mkWithKeyword(255,135,206,250,"lightskyblue")}static get LightSlateGray(){return S.mkWithKeyword(255,119,136,153,"lightslategray")}static get LightSteelBlue(){return S.mkWithKeyword(255,176,196,222,"lightsteelblue")}static get LightYellow(){return S.mkWithKeyword(255,255,255,224,"lightyellow")}static get Lime(){return S.mkWithKeyword(255,0,255,0,"lime")}static get LimeGreen(){return S.mkWithKeyword(255,50,205,50,"limegreen")}static get Linen(){return S.mkWithKeyword(255,250,240,230,"linen")}static get Magenta(){return S.mkWithKeyword(255,255,0,255,"magenta")}static get Maroon(){return S.mkWithKeyword(255,128,0,0,"maroon")}static get MediumAquamarine(){return S.mkWithKeyword(255,102,205,170,"mediumaquamarine")}static get MediumBlue(){return S.mkWithKeyword(255,0,0,205,"mediumblue")}static get MediumOrchid(){return S.mkWithKeyword(255,186,85,211,"mediumorchid")}static get MediumPurple(){return S.mkWithKeyword(255,147,112,219,"mediumpurple")}static get MediumSeaGreen(){return S.mkWithKeyword(255,60,179,113,"mediumseagreen")}static get MediumSlateBlue(){return S.mkWithKeyword(255,123,104,238,"mediumslateblue")}static get MediumSpringGreen(){return S.mkWithKeyword(255,0,250,154,"mediumspringgreen")}static get MediumTurquoise(){return S.mkWithKeyword(255,72,209,204,"mediumturquoise")}static get MediumVioletRed(){return S.mkWithKeyword(255,199,21,133,"mediumvioletred")}static get MidnightBlue(){return S.mkWithKeyword(255,25,25,112,"midnightblue")}static get MintCream(){return S.mkWithKeyword(255,245,255,250,"mintcream")}static get MistyRose(){return S.mkWithKeyword(255,255,228,225,"mistyrose")}static get Moccasin(){return S.mkWithKeyword(255,255,228,181,"moccasin")}static get NavajoWhite(){return S.mkWithKeyword(255,255,222,173,"navajowhite")}static get Navy(){return S.mkWithKeyword(255,0,0,128,"navy")}static get OldLace(){return S.mkWithKeyword(255,253,245,230,"oldlace")}static get Olive(){return S.mkWithKeyword(255,128,128,0,"olive")}static get OliveDrab(){return S.mkWithKeyword(255,107,142,35,"olivedrab")}static get Orange(){return S.mkWithKeyword(255,255,165,0,"orange")}static get OrangeRed(){return S.mkWithKeyword(255,255,69,0,"orangered")}static get Orchid(){return S.mkWithKeyword(255,218,112,214,"orchid")}static get PaleGoldenrod(){return S.mkWithKeyword(255,238,232,170,"palegoldenrod")}static get PaleGreen(){return S.mkWithKeyword(255,152,251,152,"palegreen")}static get PaleTurquoise(){return S.mkWithKeyword(255,175,238,238,"paleturquoise")}static get PaleVioletRed(){return S.mkWithKeyword(255,219,112,147,"palevioletred")}static get PapayaWhip(){return S.mkWithKeyword(255,255,239,213,"papayawhip")}static get PeachPuff(){return S.mkWithKeyword(255,255,218,185,"peachpuff")}static get Peru(){return S.mkWithKeyword(255,205,133,63,"peru")}static get Pink(){return S.mkWithKeyword(255,255,192,203,"pink")}static get Plum(){return S.mkWithKeyword(255,221,160,221,"plum")}static get PowderBlue(){return S.mkWithKeyword(255,176,224,230,"powderblue")}static get Purple(){return S.mkWithKeyword(255,128,0,128,"purple")}static get Red(){return S.mkWithKeyword(255,255,0,0,"red")}static get RosyBrown(){return S.mkWithKeyword(255,188,143,143,"rosybrown")}static get RoyalBlue(){return S.mkWithKeyword(255,65,105,225,"royalblue")}static get SaddleBrown(){return S.mkWithKeyword(255,139,69,19,"saddlebrown")}static get Salmon(){return S.mkWithKeyword(255,250,128,114,"salmon")}static get SandyBrown(){return S.mkWithKeyword(255,244,164,96,"sandybrown")}static get SeaGreen(){return S.mkWithKeyword(255,46,139,87,"seagreen")}static get SeaShell(){return S.mkWithKeyword(255,255,245,238,"seashell")}static get Sienna(){return S.mkWithKeyword(255,160,82,45,"sienna")}static get Silver(){return S.mkWithKeyword(255,192,192,192,"silver")}static get SkyBlue(){return S.mkWithKeyword(255,135,206,235,"skyblue")}static get SlateBlue(){return S.mkWithKeyword(255,106,90,205,"slateblue")}static get SlateGray(){return S.mkWithKeyword(255,112,128,144,"slategray")}static get Snow(){return S.mkWithKeyword(255,255,250,250,"snow")}static get SpringGreen(){return S.mkWithKeyword(255,0,255,127,"springgreen")}static get SteelBlue(){return S.mkWithKeyword(255,70,130,180,"steelblue")}static get Tan(){return S.mkWithKeyword(255,210,180,140,"tan")}static get Teal(){return S.mkWithKeyword(255,0,128,128,"teal")}static get Thistle(){return S.mkWithKeyword(255,216,191,216,"thistle")}static get Tomato(){return S.mkWithKeyword(255,255,99,71,"tomato")}static get Transparent(){return S.mkWithKeyword(0,255,255,255,"transparent")}static get Turquoise(){return S.mkWithKeyword(255,64,224,208,"turquoise")}static get Violet(){return S.mkWithKeyword(255,238,130,238,"violet")}static get Wheat(){return S.mkWithKeyword(255,245,222,179,"wheat")}static get White(){return S.mkWithKeyword(255,255,255,255,"white")}static get WhiteSmoke(){return S.mkWithKeyword(255,245,245,245,"whitesmoke")}static get Yellow(){return S.mkWithKeyword(255,255,255,0,"yellow")}static get YellowGreen(){return S.mkWithKeyword(255,154,205,50,"yellowgreen")}};var ys=class extends Ni{constructor(e){super(e,Ae.DrawingObjectIndex);this.labelfontcolor=S.Black;this.styles=[];this.penwidth=1;this.fontname=ys.defaultLabelFontName,this.fontsize=ys.defaultLabelFontSize}rebind(e){this.entity=e,this.bind(Ae.DrawingObjectIndex)}static copyValidFields(e,i){e==null||i==null||(e.color&&e.color.keyword&&e.color.keyword.toLowerCase()!=="black"&&(i.color=e.color),e.fillColor&&(i.fillColor=e.fillColor),e.labelfontcolor&&e.labelfontcolor.keyword.toLowerCase()!=="black"&&(i.labelfontcolor=e.labelfontcolor),e.labelText!=null&&e.labelText!==""&&e.labelText!==e.id&&(i.labelText=e.labelText),e.fontColor&&e.fontColor.keyword&&e.fontColor.keyword.toLowerCase()!=="black"&&(i.fontColor=e.fontColor),e.styles&&e.styles.length&&(i.styles=e.styles.map(n=>n)),e.pencolor&&e.pencolor.keyword!=="black"&&(i.pencolor=e.pencolor),e.penwidth&&e.penwidth!==1&&(i.penwidth=e.penwidth),e.rankdir&&(i.rankdir=e.rankdir),e.fontname&&e.fontname!==ys.defaultLabelFontName&&(i.fontname=e.fontname),e.margin&&(i.margin=e.margin),e.fontsize&&e.fontsize!==ys.defaultLabelFontSize&&(i.fontsize=e.fontsize),e.orientation&&(i.orientation=e.orientation),e.ranksep&&(i.ranksep=e.ranksep),e.arrowtail&&(i.arrowtail=e.arrowtail),e.arrowhead&&(i.arrowhead=e.arrowhead),e.ordering&&(i.ordering=e.ordering),e.bgcolor&&(i.bgcolor=e.bgcolor),e.pos&&(i.pos=e.pos),e.nodesep&&(i.nodesep=e.nodesep),e.arrowsize&&(i.arrowsize=e.arrowsize),e.samehead&&(i.samehead=e.samehead),e.layersep&&(i.layersep=e.layersep),e.clusterRank&&(i.clusterRank=e.clusterRank))}get labelText(){return this._labelText}set labelText(e){this._labelText=e}get arrowhead(){return this._arrowhead}set arrowhead(e){this._arrowhead=e}get id(){return this._id}set id(e){this._id=e}static getDrawingObj(e){return e==null?null:e.getAttr(Ae.DrawingObjectIndex)}},ze=ys;ze.defaultLabelFontName="Times-Roman",ze.defaultLabelFontSize=12;var lu=class extends ze{constructor(e){super(e);this.shape=2;this.padding=2;this.xRad=3;this.yRad=3;this.labelMargin=1;this.labelWidthToHeightRatio=1;e!=null&&(this.labelText=e.id)}clone(){throw new Error("Method not implemented.")}get Padding(){return this.padding}set Padding(e){this.padding=Math.max(0,e)}get XRadius(){return this.xRad}set XRadius(e){this.xRad=e}get YRadius(){return this.yRad}set YRadius(e){this.yRad=e}static get DefaultFillColor(){return lu.defaultFillColor}static set DefaultFillColor(e){lu.defaultFillColor=e}get ShapeEnum(){return this.shape}set ShapeEnum(e){this.shape=e}get LabelMargin(){return this.labelMargin}set LabelMargin(e){this.labelMargin=e}get LabelWidthToHeightRatio(){return this.labelWidthToHeightRatio}set LabelWidthToHeightRatio(e){this.labelWidthToHeightRatio=e}get node(){return this.entity}get id(){return this.node?this.node.id:""}},Mt=lu;Mt.defaultFillColor=S.LightGray;var ni=class extends ze{constructor(e,i){super(e);this.directed=!0;this.directed=i,i?this.arrowhead=0:this.arrowhead=6,this.arrowtail=6}clone(){let e=new ni(null,this.directed);return ze.copyValidFields(this,e),e.directed=this.directed,e.arrowtail=this.arrowtail,e.arrowhead=this.arrowhead,e}};var yt=class extends Mt{constructor(){super(...arguments);this.graphVisData={sameRanks:new Array,minRanks:new Array,maxRanks:new Array,sourceRanks:new Array,sinkRanks:new Array}}get defaultNodeObject(){return this._defaultNodeObject}set defaultNodeObject(e){this._defaultNodeObject=e}static getDrawingGraph(e){return ze.getDrawingObj(e)}get graph(){return this.entity}findNode(e){let n=this.graph.findNode(e);return n==null?null:ze.getDrawingObj(n)}hasDirectedEdge(){for(let e of this.graph.deepEdges)if(ze.getDrawingObj(e).directed)return!0;return!1}createGeometry(e=i=>i?new nt(i.length*8+8,20):null){let i=new ne(this.graph);this.textMeasure=e;let n={fontFamily:this.fontname,fontSize:this.fontsize,fontStyle:"normal"};i.labelSize=e(this.labelText,n);for(let o of this.graph.nodesBreadthFirst)this.createNodeGeometry(o);for(let o of this.graph.deepEdges)this.createEdgeGeometry(o);if(this.rankdir){let o=i.layoutSettings=new _e;o.layerDirection=this.rankdir}return i}createEdgeGeometry(e){let i=ni.getDrawingObj(e),n=new Re(e);if(i.arrowhead!=6&&(n.targetArrowhead=new We),i.arrowtail!=6&&(n.sourceArrowhead=new We),i.labelText){let o=this.textMeasure(i.labelText,{fontSize:i.fontsize,fontFamily:i.fontname,fontStyle:"normal"}),s=e.label=new _i(e);new Lr(s,D.mkPP(new d(0,0),new d(o.width,o.height))),i.measuredTextSize=o}i.penwidth&&(n.lineWidth=i.penwidth)}curveByShape(e,i,n,o){let s;switch(o.shape){case 0:s=me.mkDiamond(e,i,n);break;case 1:s=me.mkEllipse(e/1.6,i/1.6,n);break;case 4:case 2:s=me.mkRectangleWithRoundedCorners(e,i,o.XRadius,o.YRadius,n);break;case 3:s=me.mkCircle(Math.sqrt(e*e+i*i),n);break;case 5:break;case 6:break;case 7:break;case 8:break;case 9:break;case 10:s=me.mkCircle(Math.sqrt(e*e+i*i)+2*o.penwidth,n);break;case 11:s=me.createHouse(e,i,n);break;case 12:s=me.createInvertedHouse(e,i,n);break;case 13:s=me.createParallelogram(e,i,n);break;case 14:s=me.createOctagon(e,i,n);break;case 15:break;case 16:break;case 17:break;case 18:break;case 19:s=me.createHexagon(e,i,n);break}return s!=null?s:me.mkRectangleWithRoundedCorners(e,i,o.XRadius,o.YRadius,n)}createNodeGeometry(e,i=new d(0,0)){if(e instanceof de){let n=ze.getDrawingObj(e),o=new ne(e);n.labelText&&(o.labelSize=n.measuredTextSize=wh(n,this.textMeasure))}else{let n=Mt.getDrawingObj(e),o=new nt(1,1);n.labelText&&(o=wh(n,this.textMeasure)),n.measuredTextSize=o;let s=new Ke(e),a=o.width+n.LabelMargin*2,u=o.height+n.LabelMargin*2;s.boundaryCurve=this.curveByShape(a,u,i,n)}}measureLabelSizes(e){var i;for(let n of this.graph.nodesBreadthFirst){let o=Mt.getDrawingObj(n);o.measuredTextSize=(i=wh(o,e))!=null?i:new nt(1,1)}}};function wh(l,t){return l.labelText?t(l.labelText,{fontSize:l.fontsize,fontFamily:l.fontname,fontStyle:"normal"}):null}var Pb=he(Qr(),1);var yg=he(Pg(),1);function nn(l){let t=(0,yg.default)(l);if(t.keyword!=null)return S.parse(t.keyword.toString());if(t!=null){if(t.rgba!=null)return new S(t.rgba[3],t.rgba[0],t.rgba[1],t.rgba[2]);if(t.rgb!=null)return S.mkRGB(t.rgb[0],t.rgb[1],t.rgb[2])}return S.Black}function Mh(l,t,e){for(let n of e.attr_list)if(n.type==="attr"){let o=n.eq;switch(n.id){case"edgeCurve":{let s=va(l),a=JSON.parse(o);s.curve=Ra(a)}break;case"graphBoundingBox":{let s=va(l),a=JSON.parse(o);s.boundingBox=new D(a)}break;case"boundaryCurve":{let s=va(l),a=JSON.parse(o),u=Ra(a);s instanceof ne?s.boundingBox=u.boundingBox:s.boundaryCurve=u}break;case"sourceArrowhead":{let s=va(l);s.sourceArrowhead==null&&(s.sourceArrowhead=new We),s.sourceArrowhead.tipPosition=d.fromJSON(JSON.parse(o));break}case"targetArrowhead":{let s=va(l);s.targetArrowhead==null&&(s.targetArrowhead=new We),s.targetArrowhead.tipPosition=d.fromJSON(JSON.parse(o));break}case"geomEdgeLabel":{let s=JSON.parse(o),a=l;i(a),new Lr(a.label,new D(s)).setBoundingBox(new D(s));break}case"color":t.color=nn(o);break;case"pencolor":t.pencolor=nn(o);break;case"labelfontcolor":t.labelfontcolor=nn(o);break;case"fontcolor":t.fontColor=nn(o);break;case"fillcolor":t.fillColor=nn(o);break;case"style":for(let s of Kb(o))t.styles.push(s);break;case"shape":{let s=t;s.shape=Yb(o);break}case"peripheries":t.peripheries=parseInt(o);break;case"headlabel":t.headlabel=o;break;case"label":if(typeof o=="string"){let s="\\n",a=0;t.labelText="";do{let u=o.indexOf(s,a);if(u>=0)t.labelText+=o.substring(a,u)+`
`,a=u+2;else{t.labelText+=o.substring(a);break}}while(!0)}else typeof o=="number"&&(t.labelText=o.toString());l instanceof sr&&i(l);break;case"size":t.size=kh(o);break;case"pos":t.pos=kh(o);break;case"rankdir":t.rankdir=Zb(o);break;case"fontname":t.fontname=o;break;case"fontsize":t.fontsize=parseFloat(o);break;case"width":t.width=parseFloat(o);break;case"penwidth":t.penwidth=parseFloat(o);break;case"height":t.height=parseFloat(o);break;case"margin":t.margin=parseFloat(o);break;case"len":t.len=parseFloat(o);break;case"minlen":t.minlen=parseFloat(o);break;case"rank":t.rank=_b(o);break;case"charset":t.charset=o;break;case"orientation":t.orientation=o;break;case"ratio":t.ratio=o;break;case"weight":t.weight=parseFloat(o);break;case"nodesep":t.nodesep=parseFloat(o);break;case"layersep":t.layersep=parseFloat(o);break;case"arrowsize":t.arrowsize=parseFloat(o);break;case"rotate":t.rotate=parseFloat(o);break;case"ranksep":t.ranksep=parseFloat(o);break;case"splines":t.splines=o==="true";break;case"overlap":t.overlap=o==="true";break;case"arrowtail":t.arrowtail=Sg(o);break;case"taillabel":t.taillabel=o;break;case"arrowhead":t.arrowhead=Sg(o);break;case"ordering":t.ordering=eP(o);break;case"URL":t.URL=o;break;case"dir":t.dir=tP(o);break;case"concentrate":t.concentrate=o==="true";break;case"compound":t.compound=o==="true";break;case"lhead":t.lhead=o;break;case"ltail":t.ltail=o;break;case"bgcolor":t.bgcolor=nn(o);break;case"center":t.center=o===!0||parseInt(o)===1;break;case"colorscheme":t.colorscheme=o;break;case"sides":t.sides=parseInt(o);break;case"distortion":t.distortion=parseFloat(o);break;case"skew":t.skew=parseFloat(o);break;case"bb":t.bb=rP(o);break;case"labelloc":t.labelloc=o;break;case"decorate":t.decorate=o==="true";break;case"tailclip":t.tailclip=o==="true";break;case"headclip":t.headclip=o==="true";break;case"constraint":t.constraint=o==="true";break;case"gradientangle":t.gradientangle=parseFloat(o);break;case"samehead":t.samehead=o;break;case"href":t.href=o;break;case"imagepath":t.imagepath=o;break;case"image":t.image=o;break;case"labeljust":t.labejust=o;break;case"layers":t.layers=o.split(",");break;case"layer":t.layer=o;break;case"f":t.f=parseFloat(o);break;case"nojustify":t.nojustify=o==="true";break;case"root":t.root=o==="true";break;case"page":t.page=kh(o);break;case"pname":t.pname=o;break;case"kind":t.kind=o;break;case"fname":t.fname=o;break;case"subkind":t.subkind=o;break;case"area":t.area=parseFloat(o);break;case"tailport":t.tailport=o;break;case"headport":t.headport=o;break;case"wt":t.wt=o;break;case"id":t instanceof Mt||(t.id=o);break;case"edgetooltip":t.edgetooltip=o;break;case"headtooltip":t.headtooltip=o;break;case"tailtooltip":t.tailtooltip=o;break;case"headURL":t.headURL=o;break;case"tailURL":t.tailURL=o;break;case"labelURL":t.labelURL=o;break;case"edgeurl":t.edgeurl=o;break;case"shapefile":t.shapefile=o;break;case"xlabel":t.xlabel=o;break;case"sametail":t.sametail=o;break;case"clusterrank":t.clusterRank=o;break;case"measuredTextSize":t.measuredTextSize=JSON.parse(o);break;default:break}}else throw new Error("unexpected type "+n.type);function i(n){n.label==null&&(n.label=new _i(n))}}function Cs(l,t){let e=ze.getDrawingObj(t);l.attr_list!=null&&Mh(t,e,l)}var Wh=class{constructor(t){this.nodeMap=new Map;this.ast=t}parseEdge(t,e,i,n,o){let s,a;if(t.type==="node_id"){let h=t.id.toString();s=this.nodeMap.get(h),s==null?s=this.newNode(h,i,!1):this.tryToMoveToADeeperGraph(s,i)}else{let h=[];for(let c of t.children)if(c.type==="node_stmt")for(let f of this.parseEdge(c.node_id,e,i,n,o))h.push(f);else if(c.type!=="attr_stmt")throw new Error("not implemented");for(let c of t.children)if(c.type==="attr_stmt")for(let f of h)Cs(c,f);return h}if(e.type==="node_id"){let h=e.id.toString();a=this.nodeMap.get(h),a==null?a=this.newNode(h,i,!1):this.tryToMoveToADeeperGraph(a,i)}else if(e.type==="subgraph"){let h=new Array;for(let c of e.children)if(c.type==="node_stmt")for(let f of this.parseEdge(t,c.node_id,i,n,o))h.push(f);else if(c.type!=="attr_stmt")throw new Error("not implemented");for(let c of e.children)if(c.type==="attr_stmt")for(let f of h)Cs(c,f);return h}let u=new sr(s,a);return new ni(u,n),Cs(o,u),[u]}tryToMoveToADeeperGraph(t,e){le.assert(t.parent!=null);let i=t.parent;i!=e&&n(i)<n(e)&&(i.remove(t),e.addNode(t));function n(o){let s=0,a=o.parent;for(;a;)s++,a=a.parent;return s}}newNode(t,e,i){let n=this.nodeMap.get(t);if(n==null){n=new Rr(t),this.nodeMap.set(t,n),e.addNode(n);let o=new Mt(n);o.labelText=t;let s=yt.getDrawingObj(e);ze.copyValidFields(s.defaultNodeObject,o)}else i&&qu(e,n);return n}parseNode(t,e,i){let n=t.node_id.id.toString(),o=this.newNode(n,e,i);return ze.getDrawingObj(o)==null&&new Mt(o),Cs(t,o),o}parse(){return this.ast==null?null:(this.graph=new de(this.ast[0].id?this.ast[0].id.toString():"__graph__"),this.drawingGraph=new yt(this.graph),this.parseUnderGraph(this.ast[0].children,this.graph,this.ast[0].type==="digraph",!1),nP(this.graph),oP(this.graph),this.graph)}parseGraphAttr(t,e){if(t.target==="node"){let i=yt.getDrawingObj(e);i.defaultNodeObject==null&&(i.defaultNodeObject=new Mt(null)),Mh(null,i.defaultNodeObject,t)}else t.target==="graph"&&Cs(t,e)}getEntitiesSubg(t,e,i){let n=[];for(let o of t.children)if(o.type==="edge_stmt")for(let s=0;s<o.edge_list.length-1;s++)for(let a of this.parseEdge(o.edge_list[s],o.edge_list[s+1],e,i,o))n.push(a);else if(o.type!=="attr_stmt")if(o.type==="node_stmt")n.push(this.parseNode(o,e,!0));else if(o.type==="subgraph")if(o.id!=null){let s=new de(o.id.toString());e.addNode(s),this.nodeMap.set(s.id,s);let a=new yt(s);this.parseUnderGraph(o.children,s,i,!0),n.push(a.graph),s.isEmpty&&(e.removeNode(s),this.nodeMap.delete(s.id))}else n=n.concat(this.getEntitiesSubg(o,e,i));else throw new Error("Function not implemented.");return n}parseUnderGraph(t,e,i,n){for(let o of t)switch(o.type){case"node_stmt":this.parseNode(o,e,n);break;case"edge_stmt":{let s=o.edge_list;for(let a=0;a<s.length-1;a++)this.parseEdge(s[a],s[a+1],e,i,o)}break;case"subgraph":if(!this.process_same_rank(o,yt.getDrawingGraph(e)))if(o.id==null){let s=this.getEntitiesSubg(o,e,i);iP(o,yt.getDrawingGraph(e),s)}else{let s=new de(o.id.toString());this.nodeMap.set(o.id.toString(),s),e.addNode(s),new yt(s),this.parseUnderGraph(o.children,s,i,!0),s.isEmpty()&&(e.remove(s),this.nodeMap.delete(s.id))}break;case"attr_stmt":this.parseGraphAttr(o,e);break;default:throw new Error("not implemented")}}process_same_rank(t,e){let i=t.children[0];if(i==null||i.type!=="attr_stmt")return!1;let n=i.attr_list;if(n==null||n.length===0)return!1;let o=n[0];if(o.type!=="attr"||o.id!=="rank")return!1;switch(o.eq){case"min":for(let s=1;s<t.children.length;s++){let a=t.children[s];if(a.type==="node_stmt")e.graphVisData.minRanks.push(a.node_id.id.toString());else throw new Error}return!0;case"max":for(let s=1;s<t.children.length;s++){let a=t.children[s];if(a.type==="node_stmt")e.graphVisData.minRanks.push(a.node_id.id.toString());else throw new Error}return!0;case"same":{let s=[];for(let a=1;a<t.children.length;a++){let u=t.children[a];u.type==="node_stmt"?(this.newNode(u.node_id.id.toString(),e.graph,!1),s.push(u.node_id.id.toString())):u.type==="attr_stmt"&&u.target==="node"&&(e.defaultNodeObject==null&&(e.defaultNodeObject=new Mt(null)),Mh(null,e.defaultNodeObject,u))}return e.graphVisData.sameRanks.push(s),!0}case"source":{for(let s=1;s<t.children.length;s++){let a=t.children[s];if(a.type==="node_stmt")e.graphVisData.sourceRanks.push(a.node_id.id.toString());else throw new Error}return!0}case"sink":for(let s=1;s<t.children.length;s++){let a=t.children[s];if(a.type==="node_stmt")e.graphVisData.sinkRanks.push(a.node_id.id.toString());else throw new Error}return!0;default:throw new Error("incorrect rank")}}};function $b(l){try{return new Wh([l]).parse()}catch(t){return console.log(t.message),null}}function*Kb(l){let t=l.split(",");for(let e of t){let n=fa[e];n&&(yield n)}}function Yb(l){let t=l.toLowerCase();return wo[t]}function kh(l){let t=l.split(",");return[parseFloat(t[0]),parseFloat(t[1])]}function Zb(l){return ns[l]}function _b(l){return ou[l]}function Sg(l){return ii[l]}function eP(l){return au[l]}function tP(l){return su[l]}function rP(l){let t=l.split(",");return[parseFloat(t[0]),parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3])]}function iP(l,t,e){for(let i of l.children)if(i.type==="attr_stmt")for(let n of e)Cs(i,n)}function nP(l){let t=[];for(let e of l.subgraphsBreadthFirst())e.isEmpty()&&t.push(e);for(let e of t){let i=e.parent;i&&i.removeNode(e)}}function oP(l){for(let t of l.subgraphsBreadthFirst())ne.getGeom(t)==null&&t.hasSomeAttrOnIndex(Ae.GeomObjectIndex)&&new ne(t);ne.getGeom(l)==null&&l.hasSomeAttrOnIndex(Ae.GeomObjectIndex)&&new ne(l)}function gu(l){let t=mP(l);return{type:dP(l),id:l.id,children:aP(l,t)}}function sP(l){return{type:"edge_stmt",edge_list:[{type:"node_id",id:l.source.id},{type:"node_id",id:l.target.id}],attr_list:Array.from(lP(l))}}function aP(l,t){let e=new Map,i=[],n=ne.getGeom(l);if(n){let o=Array.from(Eg(n));i.push({type:"attr_stmt",target:"graph",attr_list:o})}pP(i,l);for(let o of l.nodesBreadthFirst)e.set(o.id,uP(o));for(let o of l.nodesBreadthFirst){if(o.parent===l)continue;e.get(o.parent.id).children.push(e.get(o.id))}for(let o of l.deepEdges){let s=sP(o),a=gP(o,t);a===l?i.push(s):e.get(a.id).children.push(s)}for(let o of l.shallowNodes)i.push(e.get(o.id));return i}function*lP(l){let t=ie.getGeom(l);if(t&&t.curve&&(yield{type:"attr",id:"edgeCurve",eq:JSON.stringify(Na(t.curve))},t.sourceArrowhead&&(yield{type:"attr",id:"sourceArrowhead",eq:JSON.stringify(t.sourceArrowhead.tipPosition.toJSON())}),t.targetArrowhead&&(yield{type:"attr",id:"targetArrowhead",eq:JSON.stringify(t.targetArrowhead.tipPosition.toJSON())}),l.label)){let e=l.label.getAttr(Ae.GeomObjectIndex).boundingBox,i={left:e.left,right:e.right,top:e.top,bottom:e.bottom};yield{type:"attr",id:"geomEdgeLabel",eq:JSON.stringify(i)}}yield*Hh(ze.getDrawingObj(l))}function uP(l){if(l instanceof de){let e=Array.from(Eg(ne.getGeom(l))),i=[],n={type:"attr_stmt",target:"graph",attr_list:e};return i.push(n),{type:"subgraph",children:i,id:l.id}}else return{type:"node_stmt",node_id:{type:"node_id",id:l.id},attr_list:Array.from(cP(l))}}function hP(l){let t=Ke.getGeom(l).boundaryCurve;return{type:"attr",id:"boundaryCurve",eq:JSON.stringify(Na(t))}}function*cP(l){ie.getGeom(l)&&(yield hP(l)),yield*Hh(ze.getDrawingObj(l))}function*Hh(l){if(l.color&&l.color.keyword.toLowerCase()!=="black"&&(yield{type:"attr",id:"color",eq:l.color.toString()}),l.fillColor&&(yield{type:"attr",id:"fillColor",eq:l.fillColor.toString()}),l.labelfontcolor&&l.labelfontcolor.keyword.toLowerCase()!=="black"&&(yield{type:"attr",id:"labelfontcolor",eq:l.labelfontcolor.toString()}),!(l.labelText==null||l.labelText==="")&&l.entity&&l.labelText!==l.id&&(yield{type:"attr",id:"label",eq:l.labelText}),l.fontColor&&l.fontColor.keyword.toLowerCase()!=="black"&&(yield{type:"attr",id:"fontColor",eq:l.fontColor.toString()}),l.styles&&l.styles.length){let t=l.styles.map(e=>fa[e]).reduce((e,i)=>e.concat(","+i));yield{type:"attr",id:"style",eq:t}}l.pencolor&&l.pencolor.keyword!=="black"&&(yield{type:"attr",id:"pencolor",eq:l.pencolor.toString()}),l.penwidth&&l.penwidth!==1&&(yield{type:"attr",id:"penwidth",eq:l.penwidth.toString()}),l.rankdir&&(yield{type:"attr",id:"rankdir",eq:l.rankdir.toString()}),l.fontname&&l.fontname!==ze.defaultLabelFontName&&(yield{type:"attr",id:"fontname",eq:l.fontname}),l.margin&&(yield{type:"attr",id:"margin",eq:l.margin.toString()}),l.fontsize&&l.fontsize!==ze.defaultLabelFontSize&&(yield{type:"attr",id:"fontsize",eq:l.fontsize.toString()}),l.orientation&&(yield{type:"attr",id:"orientation",eq:l.orientation.toString()}),l.ranksep&&(yield{type:"attr",id:"ranksep",eq:l.ranksep.toString()}),l.arrowtail&&(yield{type:"attr",id:"arrowtail",eq:ii[l.arrowtail]}),l.arrowhead&&(yield{type:"attr",id:"arrowhead",eq:ii[l.arrowhead]}),l.ordering&&(yield{type:"attr",id:"ordering",eq:l.ordering.toString()}),l.bgcolor&&(yield{type:"attr",id:"bgcolor",eq:l.bgcolor.toString()}),l.pos&&(yield{type:"attr",id:"pos",eq:l.pos.toString()}),l.nodesep&&(yield{type:"attr",id:"nodesep",eq:l.nodesep.toString()}),l.arrowsize&&(yield{type:"attr",id:"arrowsize",eq:l.arrowsize.toString()}),l.samehead&&(yield{type:"attr",id:"samehead",eq:l.samehead.toString()}),l.layersep&&(yield{type:"attr",id:"layersep",eq:l.layersep.toString()}),l.clusterRank&&(yield{type:"attr",id:"clusterrank",eq:l.clusterRank.toString()}),l.measuredTextSize&&(yield{type:"attr",id:"measuredTextSize",eq:JSON.stringify(l.measuredTextSize)}),l instanceof Mt&&(l.shape&&l.shape!==2&&(yield{type:"attr",id:"shape",eq:l.shape.toString()}),l.xRad&&l.xRad!==3&&(yield{type:"attr",id:"xRad",eq:l.xRad.toString()}),l.yRad&&l.yRad!==3&&(yield{type:"attr",id:"yRad",eq:l.yRad.toString()}),l.padding&&l.padding!==2&&(yield{type:"attr",id:"padding",eq:l.padding.toString()}))}function dP(l){return yt.getDrawingGraph(l).hasDirectedEdge()?"digraph":"graph"}function gP(l,t){let e=l.source,i=l.target,n=t.get(e.id),o=t.get(i.id);for(;n>o;)e=e.parent,n--;for(;n<o;)i=i.parent,o--;for(;e.parent!==i.parent;)e=e.parent,i=i.parent;return e.parent}function mP(l){let t=new Map;return t.set(l.id,0),Cg(l,t),t}function Cg(l,t){let e=t.get(l.id)+1;for(let i of l.shallowNodes)t.set(i.id,e),i instanceof de&&Cg(i,t)}function va(l){var t;return(t=ie.getGeom(l))!=null?t:fP(l)}function fP(l){if(l instanceof de)return new ne(l);if(l instanceof Rr)return new Ke(l);if(l instanceof sr)return new Re(l);throw new Error("unsupported type "+l)}function pP(l,t){let e=yt.getDrawingObj(t);if(e==null)return;let i=e.defaultNodeObject;i&&l.push({type:"attr_stmt",target:"node",attr_list:Array.from(Hh(i))})}function*Eg(l){if(l==null)return;let t=l.boundingBox;if(t&&t.isEmpty()===!1){let e={left:t.left,right:t.right,top:t.top,bottom:t.bottom};yield{type:"attr",id:"graphBoundingBox",eq:JSON.stringify(e)}}l.radX!==10&&(yield{type:"attr",id:"radX",eq:l.radX.toString()}),l.radY!==10&&(yield{type:"attr",id:"radY",eq:l.radY.toString()})}function mu(l){return"nodes"in l?bP(l):$b(l)}function bP(l){let t=new de;for(let e of l.nodes){let i=String(e.id),n=t.addNode(new Rr(i)),o=new Mt(n),{label:s=i,shape:a="box"}=e;o.labelText=s,o.ShapeEnum=wo[a],"weight"in e&&(o.weight=e.weight),"color"in e&&(o.color=nn(e.color))}for(let e of l.edges){let i=t.setEdge(String(e.source),String(e.target)),n=new ni(i,!1),{arrowhead:o="none",arrowtail:s="none",directed:a=!0}=e;n.arrowhead=ii[o],n.arrowtail=ii[s],n.directed=a,"weight"in e&&(n.weight=e.weight),"color"in e&&(n.color=nn(e.color))}return new yt(t),t}function zh(l,t,e=!1){let i=!1,n=e,o=yt.getDrawingObj(l),s=ne.getGeom(l);function a(u){if(!u)return;for(let f of u.subgraphs())a(f);let h=PP(o,u,t),c=yP(u.layoutSettings,h);n=n||c.layoutChanged,i=i||c.routingChanged,u.layoutSettings=h}if(a(s),n||i)for(let u of s.deepEdges)u.requireRouting();return n?Hl(s,null):i&&bo(s,Array.from(s.deepEdges),null),l}function PP(l,t,e){let i=!1;for(let o of t.deepEdges)if(o.sourceArrowhead!=null||o.targetArrowhead!=null){i=!0;break}let n;switch(e.layoutType){case"Sugiyama LR":{let o=n=new _e;o.layerDirection=1;break}case"Sugiyama RL":{let o=n=new _e;o.layerDirection=3;break}case"Sugiyama TB":{let o=n=new _e;o.layerDirection=0;break}case"Sugiyama BT":{let o=n=new _e;o.layerDirection=2;break}case"MDS":n=new Ir;break;case"IPsepCola":n=new kt;break;default:{let o=t.graph.shallowNodeCount>2001||t.graph.deepEdgesCount>4e3;if(i&&!o){let s=n=new _e;l&&l.rankdir&&(s.layerDirection=l.rankdir)}else n=new kt}}return e.edgeRoutingMode==null?n instanceof _e?n.edgeRoutingSettings.EdgeRoutingMode=3:n.edgeRoutingSettings.EdgeRoutingMode=0:n.edgeRoutingSettings.EdgeRoutingMode=e.edgeRoutingMode,n}function yP(l,t){if(!l)return{layoutChanged:!0,routingChanged:!0};let e=l.commonSettings.edgeRoutingSettings.EdgeRoutingMode!==t.commonSettings.edgeRoutingSettings.EdgeRoutingMode,i=e&&t.commonSettings.edgeRoutingSettings.EdgeRoutingMode===3,n=l instanceof _e&&t instanceof _e&&l.layerDirection!=t.layerDirection;return{layoutChanged:l.constructor!==t.constructor||i||n,routingChanged:e}}function fu(){globalThis.onmessage=({data:l})=>{switch(l.type){case"layout":{let t=mu(l.graph);console.debug("graph transfer to worker",Date.now()-l.timestamp+" ms"),(yt.getDrawingObj(t)||new yt(t)).createGeometry(),zh(t,l.options,l.forceUpdate),postMessage({type:"layout-done",timestamp:Date.now(),graph:gu(t)})}}},globalThis.onerror=l=>{postMessage({type:"Error",message:l.toString()})}}fu();})();
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   THIRD PARTY LICENSE NOTICE:

   HashMap is derived from the implementation of Dictionary<T> in .NET Core.
   HashSet is derived from the implementation of HashSet<T> in .NET Core.
   "getPrime", "expandPrime", and "isPrime" are derived from the implementation
   of "HashHelpers" in .NET Core.

   .NET Core is licensed under the MIT License:

   The MIT License (MIT)

   Copyright (c) .NET Foundation and Contributors

   All rights reserved.

   Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included in all
   copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.
*/
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   THIRD PARTY LICENSE NOTICE:

   HashSet is derived from the implementation of HashSet<T> in .NET Core.

   .NET Core is licensed under the MIT License:

   The MIT License (MIT)

   Copyright (c) .NET Foundation and Contributors

   All rights reserved.

   Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included in all
   copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.
*/
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   THIRD PARTY LICENSE NOTICE:

   LinkedList is derived from the implementation of LinkedList in
   Promise Extensions for Javascript: https://github.com/rbuckton/prex

   Promise Extensions is licensed under the Apache 2.0 License:

   Promise Extensions for JavaScript
   Copyright (c) Microsoft Corporation

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

*/
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/*!
   Copyright 2021 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/*!
   Copyright 2022 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   THIRD PARTY LICENSE NOTICE:

   xxHash Library
   Copyright (c) 2012-2021 Yann Collet
   All rights reserved.

   BSD 2-Clause License (https://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without modification,
   are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.

   * Redistributions in binary form must reproduce the above copyright notice, this
     list of conditions and the following disclaimer in the documentation and/or
     other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*!
   Copyright 2022 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/*! The following comments were added due to code inlined from "@esfx/internal-binarysearch": */
/*! The following comments were added due to code inlined from "@esfx/internal-collections-hash": */
